#include "_Seg_Analysis.h"
#include <math.h>
#include <map>
using namespace std;
static int MaxRadius=30;
static int MiniSize=3;
static float ValueMaxVoltage=10000;
static float ConvThresh=10E-5;
static float MaxDistanceValue=1E18;
static int MaxNumberLaminae=15;
int tmp[] = { 10, 20, 30 };

static int RS[] = { 24,32,    37,    39,    41,    43,    48,    50,    52,54,    56,    58,    60,    62,    64,    66,    77,    81,82,    83,    84,    85,    86,    96,    101,    103,    105,107,    109,    113,    115,117,    119,    121,    123,    125,129,133 ,   135,    137,    139,    141,    143,    145,    147,149,    151,    153,    155,    157,    161,    163,169,    171,    173,    175,    177,    179,    181,    183,    185,    187,191,    193,    195,    197,199,    201,    203,    205, 207};
static vector<int> RightSide( RS, RS+74 );
static int LS[] = {31,33,    38,40,42,    44,    49,    51,    53,    55,57,59,    61,    63,    65,    67,    76,    89,    90,91,    92,    93,    94,    97,    102,    104,    106,    108,110,    114,    116,   118,    120,   122,    124,    126,    130,  134,    136,    138,    140,    142,    144,    146,    148,    150,152,    154,    156,    158,    162,    164,    166,    168,    170,172,    174,    176,    178,    180,    182,    184,    186,    188,    192,194,    196,    198,    200,    202,    204,    206,208};
static vector<int> LeftSide( LS, LS+74 );
static int Ventricles[] = {5, 16, 12, 53, 52, 50, 51};
static vector<int> VentriclesVector(Ventricles, Ventricles+7);



log_level_t GetLevelMap(int level_int)
{
   std::map<int,log_level_t> int2log;
   int2log.insert ( std::pair<int,log_level_t>(0,LOG_NOTHING) );

      int2log[1] = LOG_CRITICAL;
      int2log[2] = LOG_ERROR;
      int2log[3] = LOG_WARNING;
      int2log[4] = LOG_INFO;
      int2log[5] = LOG_DEBUG;

  // Shall I check the iterator here?
  return int2log.find(level_int)->second;
}

float * CreateVentriclesFromParc(float * ParcData, int numel){
    float * VentricleResult = new float[numel];
    for (int i = 0; i < numel ; i++){
        VentricleResult[i]=0;
        for (int l = 0 ; l<VentriclesVector.size();l++ ){

            if (ParcData[i] == VentriclesVector[l]){
                VentricleResult[i] = 1;
            }
        }
    }
    return VentricleResult;
}

float * CreateHemisphereFromParc(float * ParcData, int Side, int numel){
    float * HemisphereResult = new float[numel];
    vector<int>  SideLabel;
    if (Side == 0){
        SideLabel = LeftSide;
    }
    else {
        SideLabel = RightSide;
    }
    for (int i = 0; i < numel ; i++){
        HemisphereResult[i]=0;
        for (int l = 0 ; l<SideLabel.size();l++ ){
            if (ParcData[i] == SideLabel[l]){
                HemisphereResult[i] = 1;
            }
        }
    }
    return HemisphereResult;
}

// Provides the combination (union) of a vector of nifti_images given a threshold
nifti_image * CombineVectorNifti(vector<nifti_image *> VectorSegCombine, float threshold){
    //    First check for the compatibility of the images
    if (VectorSegCombine.size()==0) {
        return NULL;
    }
    bool flag_Compatibility=1;
    int numbCombine=VectorSegCombine.size();
    for (int c=0; c<numbCombine-1; c++) {
        flag_Compatibility*=CheckCompatibleDimensions(VectorSegCombine[c], VectorSegCombine[c+1]);
        if (!flag_Compatibility) {
            return NULL;
        }
    }
    //  Initialise data pointer to look at images
    vector<float *> VectorDataCombine;
    for (int c=0; c<numbCombine; c++) {
        VectorDataCombine.push_back(static_cast<float *>(VectorSegCombine[c]->data));
    }
    //    Initialise data result
    nifti_image * ResultCombine=nifti_copy_nim_info(VectorSegCombine[0]);
    ResultCombine->data=(void*) calloc(ResultCombine->nvox, sizeof(float));
    float * ResultData=static_cast<float *>(ResultCombine->data);
    int numel=ResultCombine->nvox;
    for (int i=0; i<numel; i++) {
        for (int c=0; c<numbCombine; c++) {
            if (VectorDataCombine[c][i]>threshold) {
                ResultData[i]=1;
                break;
            }
        }
    }
    return ResultCombine;
}

//Provides the hard segmentation of the WMI given the summarised segmentation and the lesion segmentation
nifti_image * WMIHardSegmentation(nifti_image * SummarisedSeg1, nifti_image * SegLesBasis,SEG_ANALYSIS * segment_analysis,int * L2SToUse){
    if (SummarisedSeg1==NULL) {
        return NULL;
    }
    if (SegLesBasis==NULL) {
        return HardSegmentationIndex(SummarisedSeg1, segment_analysis->IndexWM, L2SToUse);
    }
    int numel=SegLesBasis->nvox;
    nifti_image * WMIHardSeg=nifti_copy_nim_info(SegLesBasis);
    WMIHardSeg->data=(void *) calloc(numel, sizeof(float));
    float *WMIHardSegData=static_cast<float *>(WMIHardSeg->data);
    
    nifti_image * HardWM=HardSegmentationIndex(SummarisedSeg1, segment_analysis->IndexWM, L2SToUse);
    
    float * HardWMData=static_cast<float*>(HardWM->data);
    float * SummarisedData=static_cast<float *>(SummarisedSeg1->data);
    float * SummarisedWMData=&SummarisedData[numel*segment_analysis->IndexWM];
    float * LesionData=static_cast<float *>(SegLesBasis->data);
    for (int i=0; i<numel; i++) {
        if (L2SToUse[i]>0 && HardWMData[i]>0) {
            if (LesionData[i]>(SummarisedWMData[i]-LesionData[i])) {
                WMIHardSegData[i]=0;
            }
            else{
                WMIHardSegData[i]=1;
            }
        }
        else {
            WMIHardSegData[i]=0;
        }
    }
    return WMIHardSeg;
}


//Provides the hard segmentation for the index chosen
nifti_image * HardSegmentationIndex(nifti_image * SoftSegmentation, int IndexHard, int * L2S){
    if (SoftSegmentation==NULL) {
        return NULL;
    }
    //    First must check that the index and the images are ok
    int numel = SoftSegmentation->nx*SoftSegmentation->ny*SoftSegmentation->nz;
    int numgen=SoftSegmentation->nu*SoftSegmentation->nt;
    if (IndexHard>=numgen) { // Impossible index
        return NULL;
    }
    //    Then prepare the result and initialise to 0
    nifti_image * HardResult=nifti_copy_nim_info(SoftSegmentation);
    HardResult->dim[0]=3;
    HardResult->dim[4]=1;
    HardResult->dim[5]=1;
    nifti_update_dims_from_array(HardResult);
    HardResult->data=(void *)calloc(HardResult->nvox, sizeof(float));
    float * SoftSegData=static_cast<float *>(SoftSegmentation->data);
    float *HardResData=static_cast<float *>(HardResult->data);
    for (int i=0; i<numel; i++) {
        HardResData[i]=0;
    }
    
    //    Performs the hard segmentation
    for (int i=0; i<numel; i++) {
        if (L2S[i]>=0) {
            bool flag_Max=1;
            float ValueComp=SoftSegData[numel*IndexHard+i];
            for (int g=0; g<numgen; g++) {
                if (g!=IndexHard) {
                    if (ValueComp<SoftSegData[g*numel+i]) {
                        flag_Max=0;
                        break;
                    }
                }
            }
            HardResData[i]=flag_Max;
        }
    }
    //    Return the result
    return HardResult;
}

// Return the segmentation of the inliers (option 0) or of the outliers (option 1) according to the different Leaves used
nifti_image * HardSegmentationTemp(TreeEM * TreeToAnalyse, bool * BoolOppSeg, int Option, SEG_ANALYSIS * segment_analysis){
    
    
    float * GMNormResp;
    float * WMNormResp;
    float * CSFNormResp;
    float * OutNormResp;
    float * OppNormResp;
    
    if (Option==1) {
        GMNormResp=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
        WMNormResp=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
        CSFNormResp=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF)->GetNormResp();
        OutNormResp=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexOut)->GetNormResp();
         OppNormResp=TreeToAnalyse->GetNodeInlier()->GetNormResp();
    }

    else{
        GMNormResp=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
        WMNormResp=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
        CSFNormResp=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexCSF)->GetNormResp();
        OutNormResp=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexOut)->GetNormResp();
        OppNormResp=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    }
    
    vector<float*> CompVec;
    CompVec.push_back(GMNormResp);
    CompVec.push_back(WMNormResp);
    CompVec.push_back(CSFNormResp);
    CompVec.push_back(OutNormResp);
    CompVec.push_back(OppNormResp);
    
    nifti_image * ResultsSeg=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    ResultsSeg->dim[0]=4;
    ResultsSeg->dim[4]=5;
    nifti_update_dims_from_array(ResultsSeg);
    ResultsSeg->data=(void *) calloc(ResultsSeg->nvox, sizeof(float));
    int * L2S=TreeToAnalyse->GetL2S();
//    int * S2L=TreeToAnalyse->GetS2L();
    int numel=TreeToAnalyse->GetNumberElements();
    
    float * ResultsData=static_cast<float*>(ResultsSeg->data);
    for (int i=0; i<numel; i++) {
        int Index=-1;
        float Max=0;
        int TrueIndex=L2S[i];
        if (TrueIndex>=0&& BoolOppSeg[i]) {
            Index=4;
            Max=1;
        }
        else{
            for (int c=0; c<5; c++) {
                ResultsData[c*numel+i]=0;
                if (TrueIndex>=0) {
                    if (Max<CompVec[c][TrueIndex]) {
                        Index=c;
                        Max=CompVec[c][TrueIndex];
                    }
                }
            }
        }
        if (Index>-1) {
            ResultsData[Index*numel+i]=Max;
        }

    }
    return ResultsSeg;
    
}

nifti_image * HardSegmentationLesionReconstruct_ter(nifti_image * SegToAnalyse, nifti_image * SummarisedSeg, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    
    
    if (SegToAnalyse==NULL) {
        return NULL;
    }
    int numel=TreeToAnalyse->GetNumberElements();
    int numbvox=SegToAnalyse->nvox;
    if (numbvox != numel) {
        return NULL;
    }
    int * L2S=TreeToAnalyse->GetL2S();
    
    nifti_image * WMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexWM, L2S);
    float * SegToAnalyseData=static_cast<float *>(SegToAnalyse->data);
    float * WMSeg=static_cast<float *>(WMHard->data);
    float * WMData=&static_cast<float *>(SummarisedSeg->data)[numel*segment_analysis->IndexWM];
    // First correct SummarisedSeg so that lesion are retrieved from WM seg
    int indexToCorrect=segment_analysis->IndexWM;
    float * SummarisedSegData=static_cast<float *>(SummarisedSeg->data);
    float * SegToAnalyseData_PTR=static_cast<float *>(SegToAnalyse->data);
    float * SummarisedSegDataCorrect_PTR=&SummarisedSegData[numel*indexToCorrect];
    
    for (int i=0; i<numel; i++) {
        SummarisedSegDataCorrect_PTR[i]-=SegToAnalyseData_PTR[i];
    }
    
    //    Then compare for each resultant probability to the lesion seg probability
    
    nifti_image * HardSegLesion=nifti_copy_nim_info(SegToAnalyse);
    HardSegLesion->data=(void *)calloc(HardSegLesion->nvox, sizeof(float));
    float * HardSegData=static_cast<float *>(HardSegLesion->data);
    for (int i=0; i<numel; i++) {
        if (L2S[i]) {
            HardSegData[i]=SegToAnalyseData[i]>WMSeg[i]*WMData[i]?1:0;
        }
        else{
            HardSegData[i]=0;
        }
    }
    
    return HardSegLesion;
}

// Return the image of the hard lesion segmentation when comparing to WM GM CSF and Out separately. The binary answer is stored in a float image.
nifti_image * HardSegmentationLesionReconstruct_bis(nifti_image * SegToAnalyse, nifti_image * SummarisedSeg, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    if (SegToAnalyse==NULL) {
        return NULL;
    }
    int numel=TreeToAnalyse->GetNumberElements();
    int numbvox=SegToAnalyse->nvox;
    if (numbvox != numel) {
        return NULL;
    }
    
    //    int numelmasked = TreeToAnalyse->GetNumberMaskedElements();
    // First copy SummarisedSeg and correct it so that correct SummarisedSeg so that lesion are retrieved from WM seg
    nifti_image * SummarisedSegCorrect=CopyFloatNii(SummarisedSeg);
    int indexToCorrect=segment_analysis->IndexWM;
    float * SummarisedSegData=static_cast<float *>(SummarisedSegCorrect->data);
    float * SegToAnalyseData_PTR=static_cast<float *>(SegToAnalyse->data);
    float * SummarisedSegDataCorrect_PTR=&SummarisedSegData[numel*indexToCorrect];
    
    for (int i=0; i<numel; i++) {
        SummarisedSegDataCorrect_PTR[i]-=SegToAnalyseData_PTR[i];
    }
    
    //    Then compare for each resultant probability to the lesion seg probability
    
    nifti_image * HardSegLesion=nifti_copy_nim_info(SegToAnalyse);
    HardSegLesion->data=(void *)calloc(HardSegLesion->nvox, sizeof(float));
    int numbgen=SummarisedSeg->nu*SummarisedSeg->nt;
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    float * SegData_PTR=static_cast<float *>(SegToAnalyse->data);
    float * HardData_PTR=static_cast<float *>(HardSegLesion->data);
    for (int i=0; i<numel; i++,L2S_PTR++) {
        bool flagMax=1;
        HardData_PTR[i]=0;
        if (*L2S_PTR>=0) {
            float SumTmp=0;
            for (int g=0; g<numbgen; g++) {
                SumTmp+=SummarisedSegData[numel*g+i];
                if(SummarisedSegData[numel*g+i]>SegData_PTR[i]){
                    flagMax=0;
                    break;
                }
            }
            HardData_PTR[i]=flagMax;
        }
    }
    nifti_image_free(SummarisedSegCorrect);
    SummarisedSegCorrect=NULL;
    return HardSegLesion;
}

nifti_image * HardSegmentationThresholdFromNormResp(float * NormResp, TreeEM* TreeToAnalyse, float Threshold){
    nifti_image * HardSegResult=NULL;
    if (NormResp==NULL) {
        return HardSegResult;
    }
    HardSegResult=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    HardSegResult->dim[0]=3;
    HardSegResult->dim[4]=1;
    HardSegResult->dim[5]=1;
    nifti_update_dims_from_array(HardSegResult);
    int numel=HardSegResult->nvox;
    HardSegResult->data=(void*) calloc(numel, sizeof(float));
    
    float * NormRespLong=CreateLong(NormResp, TreeToAnalyse->GetL2S(), numel);
    float * HardSegData=static_cast<float *>(HardSegResult->data);
    for (int i=0; i<numel; i++) {
        HardSegData[i]=NormRespLong[i]>=Threshold?1:0;
    }
    delete [] NormRespLong;
    NormRespLong=NULL;
    return HardSegResult;
}

//Return the soft segmentation corresponding to the threshold define = Threshold the image. We also assume that SegToAnalyse in float format.
nifti_image * HardSegmentationThreshold(nifti_image * SegToAnalyse,float Threshold,int Option){
    //    Preparation and allocation of memory for the resultant image
    nifti_image * SoftHardResult=nifti_copy_nim_info(SegToAnalyse);
    SoftHardResult->data=(void *)calloc(SoftHardResult->nvox, sizeof(float));
    float * SegToAnalyseData=static_cast<float *>(SegToAnalyse->data);
    float * SoftHardResultData=static_cast<float *>(SoftHardResult->data);
    int numel=SoftHardResult->nvox;
    switch (Option) {
            case 1:{
                for (int i=0; i<numel; i++) {
                    SoftHardResultData[i]=SegToAnalyseData[i]>=Threshold?SegToAnalyseData[i]:0;
                }
            }
            break;
            case 2:{
                for (int i=0; i<numel; i++) {
                    SoftHardResultData[i]=SegToAnalyseData[i]>=Threshold?1:0;
                }
            }
            break;
        default:
            break;
    }
    
    return SoftHardResult;
}

// Return the soft segmentation corresponding to the hard comparison of SegToAnalyse with all the subdimensions of SummarisedSeg according to Mask. We assume that SegToAnalyse is of 3dimensions only but could be easily modified into 4D segmentation
nifti_image * HardSegmentationCompare(nifti_image * SegToAnalyse, nifti_image * SummarisedSeg, int TypeHard, nifti_image * Mask){
    Binarisation(Mask);
    bool * MaskData=NULL;
    if(Mask!=NULL){
        MaskData=static_cast<bool*>(Mask->data);
    }
    nifti_image * SoftHardResult=nifti_copy_nim_info(SegToAnalyse);
    int numel=SegToAnalyse->nvox;
    SoftHardResult->data=(void *)calloc(numel, sizeof(float));
    float * SoftHardResultData=static_cast<float *>(SoftHardResult->data);
    for(int i=0;i<numel;i++){
        SoftHardResultData[i]=0;
    }
    float * SegToAnalyseData=static_cast<float *>(SegToAnalyse->data);
    float * SummarisedSegData=static_cast<float *>(SummarisedSeg->data);
    
    int numbCompare=SummarisedSeg->nu*SummarisedSeg->nt;
    int Dim[3];
    Dim[0]=SegToAnalyse->nx;
    Dim[1]=SegToAnalyse->ny;
    Dim[2]=SegToAnalyse->nz;
    int * L2S=MakeL2S(MaskData, Dim);
    for(int i=0;i<numel;i++){
        if(L2S[i]>=0){
            bool flag_max=1;
            for(int c=0;c<numbCompare;c++){
                if(SummarisedSegData[numel*c+i]>SegToAnalyseData[i]){
                    flag_max=0;
                    break;
                }
            }
            if(flag_max){
                if(TypeHard==1){ // Case we want the probabilities in the hard segmented result
                    SoftHardResultData[i]=SegToAnalyseData[i];
                }
                else{
                    SoftHardResultData[i]=1;
                }
            }
        }
    }
    return SoftHardResult;
}

// From the tree and the reconstructed image of the lesion provides the hard segmentation of the lesion (putting to 1 the voxel when the lesion is the maximum)
nifti_image * HardSegmentationLesionReconstruct(nifti_image * SegToAnalyse, TreeEM * TreeToAnalyse){
    if (SegToAnalyse==NULL) {
        return NULL;
    }
    int numel=TreeToAnalyse->GetNumberElements();
    int numbvox=SegToAnalyse->nvox;
    if (numbvox != numel) {
        return NULL;
    }
    
    nifti_image * HardSegLesion=nifti_copy_nim_info(SegToAnalyse);
    HardSegLesion->data=(void *)calloc(HardSegLesion->nvox, sizeof(float));
    vector<TreeEM *> GeneralInlierClasses=TreeToAnalyse->GetGeneralClassesVector();
    vector<float * > NormRespInliers;
    int numbgen=GeneralInlierClasses.size();
    for (int g=0; g<numbgen; g++) {
        NormRespInliers.push_back(GeneralInlierClasses[g]->GetNormResp());
    }
    int j=0;
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    float * SegData_PTR=static_cast<float *>(SegToAnalyse->data);
    float * HardData_PTR=static_cast<float *>(HardSegLesion->data);
    for (int i=0; i<numel; i++,L2S_PTR++) {
        bool flagMax=1;
        if (*L2S_PTR>=0) {
            float SumTmp=0;
            for (int g=0; g<numbgen; g++) {
                SumTmp+=NormRespInliers[g][j];
                if(NormRespInliers[g][j]>SegData_PTR[i]){
                    flagMax=0;
                    break;
                }
            }
            if (SegData_PTR[i]<1-SegData_PTR[i]-SumTmp) {
                flagMax=0;
            }
            j++;
            HardData_PTR[i]=flagMax;
        }
    }
    return HardSegLesion;
}


// From the tree and the reconstructed image of the lesion provides the hard segmentation of the lesion (putting to 1 the voxel when the lesion is the maximum)
nifti_image * SoftSegmentationLesionReconstruct(nifti_image * SegToAnalyse, TreeEM * TreeToAnalyse){
    if (SegToAnalyse==NULL) {
        return NULL;
    }
    int numel=TreeToAnalyse->GetNumberElements();
    int numbvox=SegToAnalyse->nvox;
    if (numbvox != numel) {
        return NULL;
    }
    
    nifti_image * SoftSegLesion=nifti_copy_nim_info(SegToAnalyse);
    SoftSegLesion->data=(void *)calloc(SoftSegLesion->nvox, sizeof(float));
    vector<TreeEM *> GeneralInlierClasses=TreeToAnalyse->GetGeneralClassesVector();
    vector<float * > NormRespInliers;
    int numbgen=GeneralInlierClasses.size();
    for (int g=0; g<numbgen; g++) {
        NormRespInliers.push_back(GeneralInlierClasses[g]->GetNormResp());
    }
    int j=0;
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    float * SegData_PTR=static_cast<float *>(SegToAnalyse->data);
    float * SoftData_PTR=static_cast<float *>(SoftSegLesion->data);
    for (int i=0; i<numel; i++,L2S_PTR++) {
        bool flagMax=1;
        if (L2S_PTR[0]>=0) {
            float SumTmp=0;
            for (int g=0; g<numbgen; g++) {
                SumTmp+=NormRespInliers[g][j];
                if(NormRespInliers[g][j]>SegData_PTR[i]){
                    flagMax=0;
                    break;
                }
            }
            if (SegData_PTR[i]<1-SegData_PTR[i]-SumTmp) {
                flagMax=0;
            }
            j++;
            if (flagMax) {
                SoftData_PTR[i]=SegData_PTR[i];
            }
            else{
                SoftData_PTR[i]=0;
            }
            
        }
    }
    return SoftSegLesion;
}


// Returns the hard segmentation as boolean nifti image with as many classes as before with each class being binarised.
nifti_image * HardSegmentation_bis(nifti_image * SoftSegmentation, nifti_image * Mask){
    bool * Mask_PTR=NULL;
    if(Mask!=NULL){
        Binarisation(Mask);
    }
    nifti_image * HardSeg=nifti_copy_nim_info(SoftSegmentation);
    HardSeg->datatype=DT_BINARY;
    HardSeg->nbyper = sizeof(bool);
    HardSeg->data = (void *)calloc(HardSeg->nvox,sizeof(bool));
    int numel=HardSeg->nx*HardSeg->ny*HardSeg->nz;
    int numbclasses =HardSeg->nt*HardSeg->nu;
    float * SoftSeg_PTR=static_cast<float *>(SoftSegmentation->data);
    if (Mask!=NULL) {
        Mask_PTR=static_cast<bool *>(Mask->data);
    }
    bool * HardSeg_PTR=static_cast<bool *>(HardSeg->data);
    
    // Performs the binary segmentation depends if more than one subclass in SoftSeg
    // If more than one class, take the maximum from all classes. If only one class, classified if above 0.5
    if (numbclasses>1) { // case with more than 1 class to consider for the segmentation
        if (Mask_PTR!=NULL) {
            for (int i=0; i<numel ; i++) {
                float MaxValue=0;
                int MaxIndex=-1;
                if (Mask_PTR[i]) {
                    for (int c=0; c<numbclasses; c++) {
                        if(SoftSeg_PTR[i+c*numel]>MaxValue){
                            MaxValue=SoftSeg_PTR[i+c*numel];
                            MaxIndex=c;
                        }
                    }
                }
                if (MaxIndex>-1) {
                    for (int c=0; c<numbclasses; c++) {
                        if (c==MaxIndex) {
                            HardSeg_PTR[i+MaxIndex*numel]=1;
                        }
                        else{
                            HardSeg_PTR[i+c*numel]=0;
                        }
                    }
                }
                else{
                    for (int c=0; c<numbclasses; c++) {
                        HardSeg_PTR[i+c*numel]=0;
                    }
                }
            }
        }
        else { // case when there is no mask
            for (int i=0; i<numel; i++) {
                float MaxValue=0;
                int MaxIndex=-1;
                for (int c=0; c<numbclasses; c++) {
                    if(SoftSeg_PTR[i+c*numel]>MaxValue){
                        MaxValue=SoftSeg_PTR[i+c*numel];
                        MaxIndex=c;
                    }
                }
                if (MaxIndex>-1) {
                    for (int c=0; c<numbclasses; c++) {
                        if (c==MaxIndex) {
                            HardSeg_PTR[i+MaxIndex*numel]=1;
                        }
                        else{
                            HardSeg_PTR[i+c*numel]=0;
                        }
                    }
                }
                else{
                    for (int c=0; c<numbclasses; c++) {
                        HardSeg_PTR[i+c*numel]=0;
                    }
                }
            }
        }
    }
    else{ // Case there is only one class considered
        if (Mask_PTR!=NULL) {
            for (int i=0; i<numel; i++) {
                if (Mask_PTR[i]) {
                    for (int c=0; c<numbclasses; c++) {
                        if(SoftSeg_PTR[i]>=0.5){
                            HardSeg_PTR[i]=1;
                        }
                        else{
                            HardSeg_PTR[i]=0;
                        }
                    }
                }
                else{
                    HardSeg_PTR[i]=0;
                }
            }
        }
        else{
            for (int i=0; i<numel; i++) {
                for (int c=0; c<numbclasses; c++) {
                    if(SoftSeg_PTR[i]>=0.5){
                        HardSeg_PTR[i]=1;
                    }
                    else{
                        HardSeg_PTR[i]=0;
                    }
                }
            }
        }
    }
    return HardSeg;
}

// Returns a pointer to a boolean array of size numelmasked * numbclass where numbclass is the 4D dimension of BoolSeg that contains the boolean segmentation for each label in a separate dimension.
bool * SegBoolArray(nifti_image * BoolSeg, nifti_image * Mask){
    bool * SegBoolResult=NULL;
    bool * Mask_PTR=NULL;
    if (BoolSeg==NULL) {
        return SegBoolResult;
    }
    if (BoolSeg->datatype!=DT_BINARY) {
        cout<<"the bool seg considered is not binary"<<endl;
        return NULL;
    }
    if (Mask!=NULL) {
        Mask=Binarisation(Mask);
        Mask_PTR=static_cast<bool*>(Mask->data);
    }
    // Check if Mask and BoolSeg have compatible dimension
    int numel=BoolSeg->nx*BoolSeg->ny*BoolSeg->nz;
    if (!CheckCompatibleDimensions(BoolSeg, Mask) && Mask!=NULL) {
        cout<<"Incompatibility in dimensions"<<endl;
        return NULL;
    }
    // Determination of the size of the array and therefore of numelmasked;
    int numelmasked=CalculateNumberMaskedElements(Mask);
    if (numelmasked==0) {
        numelmasked=numel;
    }
    int numbclasses = BoolSeg->nt*BoolSeg->nu;
    bool * BoolSeg_PTR=static_cast<bool *>(BoolSeg->data);
    SegBoolResult=new bool[numelmasked*numbclasses];
    
    // Filling of SegBoolResult according to Mask
    int i2=0;
    for (int i=0; i<numel; i++) {
        if (numelmasked<numel) { // Meaning that Mask is not Null
            if (Mask_PTR[i]) {
                for (int c=0; c<numbclasses; c++) {
                    SegBoolResult[i2+c*numelmasked]=BoolSeg_PTR[i+numelmasked*c];
                }
                i2++;
            }
        }
        else{
            for (int c=0; c<numbclasses; c++) {
                SegBoolResult[i2+c*numelmasked]=BoolSeg_PTR[i+numelmasked*c];
            }
        }
    }
    return SegBoolResult;
}

// Idem as before but with float segmentation instead of binary one
float * SegFloatArray(nifti_image * FloatSeg, nifti_image * Mask){
    float * SegFloatResult=NULL;
    bool * Mask_PTR=NULL;
    if (FloatSeg==NULL) {
        return SegFloatResult;
    }
    if (FloatSeg->datatype!=DT_FLOAT) {
        cout<<"the float seg considered is not float"<<endl;
        return NULL;
    }
    if (Mask!=NULL) {
        Mask=Binarisation(Mask);
        Mask_PTR=static_cast<bool*>(Mask->data);
    }
    // Check if Mask and BoolSeg have compatible dimension
    int numel=FloatSeg->nx*FloatSeg->ny*FloatSeg->nz;
    if (!CheckCompatibleDimensions(FloatSeg, Mask) && Mask!=NULL) {
        cout<<"Incompatibility in dimensions"<<endl;
        return NULL;
    }
    // Determination of the size of the array and therefore of numelmasked;
    int numelmasked=CalculateNumberMaskedElements(Mask);
    if (numelmasked==0) {
        numelmasked=numel;
    }
    int numbclasses = FloatSeg->nt*FloatSeg->nu;
    float * FloatSeg_PTR=static_cast<float *>(FloatSeg->data);
    SegFloatResult=new float[numelmasked*numbclasses];
    
    // Filling of SegFloatResult according to Mask
    int i2=0;
    for (int i=0; i<numel; i++) {
        if (numelmasked<numel) { // Meaning that Mask is not Null
            if (Mask_PTR[i]) {
                for (int c=0; c<numbclasses; c++) {
                    SegFloatResult[i2+c*numelmasked]=FloatSeg_PTR[i+numel*c];
                }
                i2++;
            }
        }
        else{// only possible case is numelmasked==numel
            for (int c=0; c<numbclasses; c++) {
                SegFloatResult[i+c*numelmasked]=FloatSeg_PTR[i+numel*c];
            }
        }
    }
    return SegFloatResult;
}

// Return the number of active voxels given the mask
int CalculateNumberMaskedElements(nifti_image * Mask){
    Mask=Binarisation(Mask);
    int numelmasked=0;
    if (Mask==NULL) {
        return numelmasked;
    }
    if (Mask!=NULL) {
        int numel=Mask->nx*Mask->ny*Mask->nz;
        bool * Mask_PTR=static_cast<bool*>(Mask->data);
        numelmasked=0;
        for (int i=0; i<numel; i++) {
            if (Mask_PTR[i]) {
                numelmasked++;
            }
        }
    }
    return numelmasked;
}

// Returns the answer to a check on dimension compatibility
bool CheckCompatibleDimensions(nifti_image * Image1, nifti_image * Image2){
    if (Image1 ==NULL || Image2==NULL) {
        return 0;
    }
    else{
        return (Image1->nx==Image2->nx) * (Image1->ny==Image2->ny) * (Image1->nz==Image2->nz);
    }
}

//Returns the bool checking on dimension compatibility in a vector of nii images
bool CheckCompatibilityVectorNii(vector<nifti_image*> VectorNii){
    int SizeVector=VectorNii.size();
    if(SizeVector==0){
        return 0;
    }
    int fnn=FirstNotNULL(VectorNii);
    int lnn=LastNotNULL(VectorNii);
    if(lnn-fnn<0){
        cout<<"all NULL in mean"<<endl;
        return 0;
    }
    if(VectorNii.size()==1){
        return 1;
    }
    
    bool Check=1;
    for(int i=1;i<SizeVector;i++){
        for(int m=0;m<5;m++){
            Check*=(VectorNii[i]->dim[m]==VectorNii[0]->dim[m]);
            if(Check==0){
                return 0;
            }
        }
        Check*=(VectorNii[i]->nbyper==VectorNii[0]->nbyper);
    }
    return Check;
}

// From Binary segmentation image, returns the pointer to the corresponding boolean array restricted to the active voxels
bool * SegBoolArrayClass(nifti_image * BoolSeg, int c, nifti_image * Mask){
    bool * SegBoolResult=NULL;
    bool * Mask_PTR=NULL;
    if (BoolSeg==NULL) {
        return SegBoolResult;
    }
    if (BoolSeg->datatype!=DT_BINARY) {
        cout<<"the bool seg considered is not binary"<<endl;
        return NULL;
    }
    int numbclasses = BoolSeg->nt*BoolSeg->nu;
    if (c>=numbclasses || c<0) { // check that asked class is available in terms of dimension;
        return SegBoolResult;
    }
    if (Mask!=NULL) {
        Mask=Binarisation(Mask);
        Mask_PTR=static_cast<bool*>(Mask->data);
    }
    // Check if Mask and BoolSeg have compatible dimension
    int numel=BoolSeg->nx*BoolSeg->ny*BoolSeg->nz;
    if (!CheckCompatibleDimensions(BoolSeg, Mask) && Mask!=NULL) {
        cout<<"Incompatibility in dimensions"<<endl;
        return NULL;
    }
    // Determination of the size of the array and therefore of numelmasked;
    int numelmasked=CalculateNumberMaskedElements(Mask);
    if (numelmasked==0) {
        numelmasked=numel;
    }
    
    bool * BoolSeg_PTR=static_cast<bool *>(BoolSeg->data);
    SegBoolResult=new bool[numelmasked];
    
    // Filling of SegBoolResult according to Mask
    int i2=0;
    for (int i=0; i<numel; i++) {
        if (numelmasked<numel) { // Meaning that Mask is not Null
            if (Mask_PTR[i]) {
                SegBoolResult[i2]=BoolSeg_PTR[i+numelmasked*c];
                i2++;
            }
        }
        else{
            for (int c=0; c<numbclasses; c++) {
                SegBoolResult[i]=BoolSeg_PTR[i+numelmasked*c];
            }
        }
    }
    return SegBoolResult;
}

// Same as before but with float image
float * SegFloatArrayClass(nifti_image * FloatSeg, int c, nifti_image * Mask){
    float * SegFloatResult=NULL;
    bool * Mask_PTR=NULL;
    if (FloatSeg==NULL) {
        return SegFloatResult;
    }
    if (FloatSeg->datatype!=DT_FLOAT) {
        cout<<"the bool seg considered is not binary"<<endl;
        return NULL;
    }
    int numbclasses = FloatSeg->nt*FloatSeg->nu;
    if (c>=numbclasses || c<0) { // check that asked class is available in terms of dimension;
        return SegFloatResult;
    }
    if (Mask!=NULL) {
        Mask=Binarisation(Mask);
        Mask_PTR=static_cast<bool*>(Mask->data);
    }
    // Check if Mask and BoolSeg have compatible dimension
    int numel=FloatSeg->nx*FloatSeg->ny*FloatSeg->nz;
    if (!CheckCompatibleDimensions(FloatSeg, Mask) && Mask!=NULL) {
        cout<<"Incompatibility in dimensions"<<endl;
        return NULL;
    }
    // Determination of the size of the array and therefore of numelmasked;
    int numelmasked=CalculateNumberMaskedElements(Mask);
    if (numelmasked==0) {
        numelmasked=numel;
    }
    
    float * FloatSeg_PTR=static_cast<float *>(FloatSeg->data);
    SegFloatResult=new float[numelmasked];
    
    // Filling of SegBoolResult according to Mask
    int i2=0;
    for (int i=0; i<numel; i++) {
        if (numelmasked<numel) { // Meaning that Mask is not Null
            if (Mask_PTR[i]) {
                SegFloatResult[i2]=FloatSeg_PTR[i+numelmasked*c];
                i2++;
            }
        }
        else{
            for (int c=0; c<numbclasses; c++) {
                SegFloatResult[i]=FloatSeg_PTR[i+numelmasked*c];
            }
        }
    }
    return SegFloatResult;
}


nifti_image* HardSegmentation(nifti_image* SoftSegmentation){
    int numel=SoftSegmentation->nx*SoftSegmentation->ny*SoftSegmentation->nz;
    int numbclasses=SoftSegmentation->nu*SoftSegmentation->nt;
    bool testSeg=IsResultSegmentation(SoftSegmentation);
    if (!testSeg){
        cout <<"Not a segmentation result"<<endl;
        //        return NULL;
        MakeSoftSegmentation(SoftSegmentation);
    }
    
    nifti_image * ResultHardSeg=nifti_copy_nim_info(SoftSegmentation);
    ResultHardSeg->dim[0]=3;
    ResultHardSeg->dim[4]=1;
    ResultHardSeg->dim[5]=1;
    nifti_update_dims_from_array(ResultHardSeg);
    ResultHardSeg->data = (void *) calloc(ResultHardSeg->nvox, sizeof(float));
    float * SoftData=static_cast<float *>(SoftSegmentation->data);
    float * ResultData=static_cast<float *>(ResultHardSeg->data);
    for(int i=0;i<numel;i++){
        int maxClass=-1;
        float maxValue=-1;
        for(int c=0;c<numbclasses;c++){
            if(SoftData[c*numel+i]>maxValue){
                maxValue=SoftData[c*numel+i];
                maxClass=c;
            }
        }
        if(maxValue<=1E-6){
            maxClass=-1;
        }
        ResultData[i]=maxClass;
    }
    return ResultHardSeg;
    
}

// Returns as an image for a class the sum of probabilities in the neighborhood according to the radius that has been defined
nifti_image* NeighbourhingWeight(nifti_image * SoftSeg,int ExploRadius){
    int numbClasses=SoftSeg->nu*SoftSeg->nt;
    nifti_image * ResultNW=nifti_copy_nim_info(SoftSeg);
    ResultNW->data = (void *) calloc(ResultNW->nvox, sizeof(float));
    float * ResultNWData=static_cast<float *>(ResultNW->data);
    int numel=SoftSeg->nx*SoftSeg->ny*SoftSeg->nz;
    float * SoftSegData=static_cast<float *>(SoftSeg->data);
    for(int i=0;i<numel;i++){
        float sumSeg=0;
        
        for(int c=0;c<numbClasses;c++){
            sumSeg+=SoftSegData[i+c*numel];
        }
        if(sumSeg>1E-6){
            vector<int> ExploredNeighborhood=IndicesToExplore(SoftSeg,i,ExploRadius);
            int lenExplored=ExploredNeighborhood.size();
            for (int c=0;c<numbClasses;c++){
                float sumNW=0;
                for(int l=0;l<lenExplored;l++){
                    sumNW+=SoftSegData[ExploredNeighborhood[l]+c*numel];
                }
                ResultNWData[i+c*numel]=sumNW-SoftSegData[i+c*numel];
            }
            ExploredNeighborhood.clear();
            
        }
        else{
            for(int c=0;c<numbClasses;c++){
                ResultNWData[i+c*numel]=0;
            }
        }
    }
    return ResultNW;
}

vector<nifti_image*> DistanceFromClassesHS(nifti_image * SoftSeg1, nifti_image * SoftSeg2,int ExploRadius){
    int numbClasses=SoftSeg1->nu*SoftSeg1->nt;
    int numbClasses2=SoftSeg2->nu*SoftSeg2->nt;
    nifti_image * HS1=HardSegmentation(SoftSeg1);
    int numel=HS1->nx*HS1->ny*HS1->nz;
    float * HS1Data=static_cast<float*>(HS1->data);
    float * SoftSeg2Data=static_cast<float*>(SoftSeg2->data);
    vector<nifti_image*> DistanceVector;
    nifti_image * ResultDistances=nifti_copy_nim_info(SoftSeg1);
    ResultDistances->data = (void *) calloc(ResultDistances->nvox, sizeof(float));
    float * ResultDistancesData=static_cast<float *>(ResultDistances->data);
    for(int i=0;i<numel;i++){
        if(HS1Data[i]>-1){
            vector<int> ExploredIndices=IndicesToExplore(HS1,i,ExploRadius);
            for(int c1=0;c1<numbClasses;c1++){
                vector<int> ValidExploredInd=ValidIndicesFromExplo( HS1, c1,ExploredIndices);
                if(ValidExploredInd.size()==0){
                    ResultDistancesData[i+numel*c1]=-1;
                }
                else{
                    ResultDistancesData[i+numel*c1]=MinimumDistance(HS1,i,ValidExploredInd);
                }
                
                ValidExploredInd.clear();
            }
            ExploredIndices.clear();
        }
        else{
            for(int c1=0;c1<numbClasses;c1++){
                ResultDistancesData[i+numel*c1]=-1;
            }
            
        }
    }
    for(int c2=0;c2<numbClasses2;c2++){
        
        nifti_image * WeightedResultDistances=nifti_copy_nim_info(SoftSeg1);
        WeightedResultDistances->data = (void *) calloc(WeightedResultDistances->nvox, sizeof(float));
        float * WeightedResultDistancesData=static_cast<float *>(WeightedResultDistances->data);
        for(int i=0;i<numel;i++){
            for(int c1=0;c1<numbClasses;c1++){
                if(ResultDistancesData[i+c1*numel]>-1){
                    WeightedResultDistancesData[i+c1*numel]=SoftSeg2Data[i+c2*numel]/(1+ResultDistancesData[i+c1*numel]);
                }
                else{
                    WeightedResultDistancesData[i+c1*numel]=0;
                }
            }
            
        }
        DistanceVector.push_back(WeightedResultDistances);
        
    }
    return DistanceVector;
}



// Gives in a vector all Indices around a certain index CentralIndex, within a certain ExploRadius
vector<int> IndicesToExplore(nifti_image * HS1, int CentralIndex, int ExploRadius){
    int PlaneSize=HS1->nx*HS1->ny;
    int ColumnSize=HS1->nx;
    int MaxY=HS1->ny;
    int MaxX=HS1->nx;
    int MaxZ=HS1->nz;
    int CIz=CentralIndex/PlaneSize;
    int CIy=(CentralIndex-CIz*PlaneSize)/ColumnSize;
    int CIx=CentralIndex-CIz*PlaneSize-CIy*ColumnSize;
    vector<int> VectorIndices;
    for(int i=0;i<ExploRadius;i++){
        for(int j=0;j<ExploRadius;j++){
            for(int k=0;k<ExploRadius;k++){
                int im=CIx-i;
                bool Tim=(im>=0);
                int iM=CIx+i;
                bool TiM=(iM<MaxX);
                int jm=CIy-j;
                bool Tjm=(jm>=0);
                int jM=CIy+j;
                bool TjM=(jM<MaxY);
                int km=CIz-k;
                bool Tkm=(km>=0);
                int kM=CIz+k;
                bool TkM=(kM<MaxZ);
                VectorIndices.push_back(CentralIndex);
                if(Tim){
                    VectorIndices.push_back(im+CIy*ColumnSize+CIz*PlaneSize);
                    if(Tjm){
                        VectorIndices.push_back(im+jm*ColumnSize+CIz*PlaneSize);
                        if(Tkm){
                            VectorIndices.push_back(im+jm*ColumnSize+km*PlaneSize);
                        }
                        if(TkM && km!=kM){
                            VectorIndices.push_back(im+jm*ColumnSize+kM*PlaneSize);
                        }
                    }
                    if(TjM && jm!=jM){
                        VectorIndices.push_back(im+jM*ColumnSize+CIz*PlaneSize);
                        if(Tkm){
                            VectorIndices.push_back(im+jM*ColumnSize+km*PlaneSize);
                        }
                        if(TkM && jm!=jM){
                            VectorIndices.push_back(im+jM*ColumnSize+kM*PlaneSize);
                        }
                    }
                }
                if(TiM && im!=iM){
                    VectorIndices.push_back(iM+CIy*ColumnSize+CIz*PlaneSize);
                    if(Tjm){
                        VectorIndices.push_back(iM+jm*ColumnSize+CIz*PlaneSize);
                        if(Tkm){
                            VectorIndices.push_back(iM+jm*ColumnSize+km*PlaneSize);
                        }
                        if(TkM && km!=kM){
                            VectorIndices.push_back(iM+jm*ColumnSize+kM*PlaneSize);
                        }
                    }
                    if(TjM && jm!=jM){
                        VectorIndices.push_back(iM+jM*ColumnSize+CIz*PlaneSize);
                        if(Tkm){
                            VectorIndices.push_back(iM+jM*ColumnSize+km*PlaneSize);
                        }
                        if(TkM && km!=kM){
                            VectorIndices.push_back(iM+jM*ColumnSize+kM*PlaneSize);
                        }
                    }
                }
            }
        }
    }
    int sizeVI=VectorIndices.size();
    if(sizeVI>(ExploRadius*2+1)*(ExploRadius*2+1)*(ExploRadius*2+1)){
        cout<<"Already pb with number of indices to explore with size ";
    }
    //    cout<<VectorIndices.size()<<endl;
    return VectorIndices;
}


// Returns from the vector of indices to explore the ones that are classified under ClassToCheck according to the label given by HS1
vector<int> ValidIndicesFromExplo(nifti_image * HS1, int ClassToCheck, vector<int> IndicesToExplore){
    //    int PlaneSize=HS1->nx*HS1->ny;
    //    int ColumnSize=HS1->nx;
    vector<int> ValidIndices;
    // Check if Class to look at is valid;
    if(ClassToCheck <0 ){
        return ValidIndices;
    }
    int LenToCheck=IndicesToExplore.size();
    //    int numel=HS1->nz*PlaneSize;
    float * DataHS=static_cast<float*>(HS1->data);
    for(int i=0;i<LenToCheck;i++){
        if((int)DataHS[IndicesToExplore[i]]==ClassToCheck){
            ValidIndices.push_back(IndicesToExplore[i]);
        }
    }
    return ValidIndices;
}

// From the list of valid indices, returns the minimal distance to the central index considered
float MinimumDistance(nifti_image * HS1,int CentralIndex,vector<int>ValidIndices){
    int LenValid=ValidIndices.size();
    int PlaneSize=HS1->nx*HS1->ny;
    int ColumnSize=HS1->nx;
    int CIz=CentralIndex/PlaneSize;
    int CIy=(CentralIndex-CIz*PlaneSize)/ColumnSize;
    int CIx=CentralIndex-CIz*PlaneSize-CIy*ColumnSize;
    float minDist=1E18;
    if(LenValid==0){
        return -1;
    }
    else{
        //        float * SquarePixDim=new float[3];
        float SquarePixDim[3];
        for (int d=0; d<3; d++) {
            SquarePixDim[d]=pow_int(HS1->pixdim[d+1],2);
        }
        for(int i=0;i<LenValid;i++){
            int IndexUnderStudy=ValidIndices[i];
            int zI=IndexUnderStudy/PlaneSize;
            int yI=(IndexUnderStudy-PlaneSize*zI)/ColumnSize;
            int xI=IndexUnderStudy-zI*PlaneSize-yI*ColumnSize;
            int DiffZ=zI-CIz;
            int DiffY=yI-CIy;
            int DiffX=xI-CIx;
            float Dist=sqrt(DiffZ*DiffZ*SquarePixDim[2]+DiffY*DiffY*SquarePixDim[1]+DiffX*DiffX*SquarePixDim[0]);
            if(Dist<minDist){
                minDist=Dist;
            }
            //            if(Dist>4){
            //                cout<<"Pb with Dist calculation "<<Dist<<endl;
            //            }
        }
        //        delete [] SquarePixDim;
        //        SquarePixDim=NULL;
        return minDist;
    }
    
}

// Return the value for the probability similarity index given the float segmentation to assess in an array of size numelmasked, and the reference binary segmentation BinSegRef
float ProbabilitySimilarityIndex(float * SoftSeg, bool * BinSegRef, int numelmasked){
    float * SoftSeg_PTR=SoftSeg;
    bool * BinSegRef_PTR=BinSegRef;
    float Numerator=0;
    float DenBin=0;
    float DenSoft=0;
    for (int i=0; i<numelmasked; i++,BinSegRef_PTR++,SoftSeg_PTR++) {
        if (*BinSegRef_PTR) {
            Numerator+=*SoftSeg_PTR;
        }
        DenBin+=*BinSegRef_PTR;
        DenSoft+=*SoftSeg_PTR;
    }
    return 2*Numerator/(DenBin+DenSoft);
}

// Returns the value for the sensitivity given two boolean classification, HardClass2 being used as reference and stored in boolean arrays of size numelmasked
float Sensitivity(bool * HardClass1, bool * HardClass2, int numelmasked){
    if (HardClass1==NULL || HardClass2==NULL) {
        return 0;
    }
    int TP=TruePositives_bis(HardClass1, HardClass2, numelmasked);
    int FN=FalseNegatives_bis(HardClass1, HardClass2, numelmasked);
    return (float)(TP)/(TP+FN);
}

// Returns the value for the specificity given two boolean classification, HardClass2 being used as reference and stored in boolean arrays of size numelmasked
float Specificity(bool * HardClass1, bool * HardClass2, int numelmasked){
    if (HardClass1==NULL || HardClass2==NULL) {
        return 0;
    }
    int TN=TrueNegatives_bis(HardClass1, HardClass2, numelmasked);
    int FP=FalsePositives_bis(HardClass1, HardClass2, numelmasked);
    return (float)(TN)/(FP+TN);
}

// Returns the value for the accuracy given two boolean classification, HardClass2 being used as reference and stored in boolean arrays of size numelmasked
float Accuracy(bool * HardClass1, bool * HardClass2, int numelmasked){
    if (HardClass1==NULL || HardClass2==NULL) {
        return 0;
    }
    int TP=TruePositives_bis(HardClass1, HardClass2, numelmasked);
    int FP=FalsePositives_bis(HardClass1, HardClass2, numelmasked);
    int TN=TrueNegatives_bis(HardClass1, HardClass2, numelmasked);
    int FN=FalseNegatives_bis(HardClass1, HardClass2, numelmasked);
    return (float)(TP+TN)/(float)(TP+FP+FN+TN);
}

//Returns the TPR for the two given boolean classification with HardClass2 as reference, stored in boolean arrays of size numelmasked
float TPR(bool * HardClass1, bool * HardClass2, int numelmasked){
    if (HardClass1==NULL || HardClass2==NULL) {
        return 0;
    }
    int TP=TruePositives_bis(HardClass1, HardClass2, numelmasked);
    int CountRef=CountNonZero(HardClass2,numelmasked);
    
    
    return (float)(TP)/(float)(CountRef);
}

//Returns the volume difference between two boolean segmentation stored in arrays of size numelmasked considering HardClass2 as the reference
float VD(bool * HardClass1, bool * HardClass2, int numelmasked){
    if (HardClass1==NULL || HardClass2==NULL) {
        return 0;
    }
    int CountSeg=CountNonZero(HardClass1, numelmasked);
    int CountRef=CountNonZero(HardClass2,numelmasked);
    
    
    return fabsf(1-(float)(CountSeg)/(float)(CountRef));
}

// Returns the minimum average distance between two borders. cf introMS MICCAI Challenge for description of the metric. Should be as low as possible
float AverageDistanceMetric(bool * BoolSeg, bool * BoolRef, nifti_image * ImageRef){
    //    First Build Shift, Dim and PixDim that will be needed to get the Distance
    int Dim[3];
    int Shift[3];
    float Pixdim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=ImageRef->dim[d+1];
        Pixdim[d]=ImageRef->pixdim[d+1];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
    }
    int numel=Dim[0]*Dim[1]*Dim[2];
    //    BorderExtraction for the two binary segmentations
    bool * BorderSeg=CreateBorderFromBool(BoolSeg, Dim, Shift);
    bool * BorderRef=CreateBorderFromBool(BoolRef, Dim, Shift);
    
    //    Transform the border into arrays of the corresponding indices;
    //    Count the number of elements in BorderSeg and BorderRef
    int CountBorderSeg=0;
    int CountBorderRef=0;
    for (int i=0; i<numel ; i++) {
        if (BorderSeg[i]==1) {
            CountBorderSeg++;
        }
        if (BorderRef[i]==1) {
            CountBorderRef++;
        }
    }
    //    Create the ArrayIndices
    int * IndicesBorderSeg=new int[CountBorderSeg];
    int * IndicesBorderRef=new int[CountBorderRef];
    int js=0;
    int jr=0;
    for (int i=0; i<numel; i++) {
        if (BorderSeg[i]==1) {
            IndicesBorderSeg[js]=i;
            js++;
        }
        if (BorderRef[i]==1) {
            IndicesBorderRef[jr]=i;
            jr++;
        }
    }
    //    For each point of border seg, calculate distance to all points in BorderRef and keep only the smallest in a float array of size numel
    //    Create the array of minimal distances
    float * MinDistSeg=new float[CountBorderSeg];
    float * MinDistRef=new float[CountBorderRef];
    //    Initialised at numel
    for (int js=0; js<CountBorderSeg; js++) {
        MinDistSeg[js]=numel;
    }
    for (int jr=0; jr<CountBorderRef; jr++) {
        MinDistRef[jr]=numel;
    }
    //    Get minimum distance from seg to ref
    for (int js=0; js<CountBorderSeg; js++) {
        for (int jr=0; jr<CountBorderRef; jr++) {
            float DistanceTmp=GetDistanceBetweenPoints(IndicesBorderSeg[js], IndicesBorderRef[jr], Dim, Pixdim);
            if (DistanceTmp<MinDistSeg[js]) {
                MinDistSeg[js]=DistanceTmp;
            }
            if (DistanceTmp==0) {
                MinDistSeg[js]=0;
                break;
            }
        }
    }
    
    //    Get minimum distance from ref to seg
    for (int jr=0; jr<CountBorderRef; jr++) {
        for (int js=0; js<CountBorderSeg; js++) {
            float DistanceTmp=GetDistanceBetweenPoints(IndicesBorderSeg[js], IndicesBorderRef[jr], Dim, Pixdim);
            if (DistanceTmp<MinDistRef[jr]) {
                MinDistRef[jr]=DistanceTmp;
            }
            if (DistanceTmp==0) {
                MinDistRef[jr]=0;
                break;
            }
        }
    }
    
    //    Calculate the average for the two parts
    float sumRef=0;
    float sumSeg=0;
    for (int jr=0; jr<CountBorderRef; jr++) {
        sumRef+=MinDistRef[jr];
    }
    for (int js=0; js<CountBorderSeg; js++) {
        sumSeg+=MinDistSeg[js];
    }
    //    float ResultingAvDistMin=0.5*(sumSeg/CountBorderSeg + sumRef/CountBorderRef);
    float ResultingAvDistMin=(sumSeg+sumRef)/(CountBorderRef+CountBorderSeg);
    
    //    Return result after clearing memory
    delete [] MinDistSeg;
    delete [] MinDistRef;
    delete [] BorderRef;
    delete [] BorderSeg;
    delete [] IndicesBorderRef;
    delete [] IndicesBorderSeg;
    MinDistRef=NULL;
    MinDistSeg=NULL;
    BorderSeg=NULL;
    BorderRef=NULL;
    IndicesBorderSeg=NULL;
    IndicesBorderRef=NULL;
    
    return ResultingAvDistMin;
}


float GetDistanceBetweenPoints(int Point1 , int Point2, int * Dim, float * PixDim) {
    int numel=Dim[0]*Dim[1]*Dim[2];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    if (Point1>=numel || Point1<0) {
        return -1;
    }
    if (Point2>=numel || Point2<0) {
        return -1;
    }
    
    //    Obtain corresponding coordinates
    int Coord1[3];
    int Coord2[3];
    int tmp1=Point1;
    int tmp2=Point2;
    for (int d=2; d>=0; d--) {
        Coord2[d]=tmp2/Shift[d];
        tmp2-=Coord2[d]*Shift[d];
        Coord1[d]=tmp1/Shift[d];
        tmp1-=Coord1[d]*Shift[d];
    }
    
    float Dist=0;
    for (int d=0; d<3; d++) {
        Dist+=(Coord1[d]-Coord2[d])*(Coord1[d]-Coord2[d])*PixDim[d]*PixDim[d];
    }
    Dist=sqrtf(Dist);
    return Dist;
}


//Returns the false positive ratio between two boolean segmentation stored in arrays of size numelmasked considering HardClass2 as the reference
float FPR(bool * HardClass1, bool * HardClass2, int numelmasked){
    if (HardClass1==NULL || HardClass2==NULL) {
        return 0;
    }
    int TP=TruePositives_bis(HardClass1, HardClass2, numelmasked);
    int CountSeg=CountNonZero(HardClass1, numelmasked);
    int CountRef=CountNonZero(HardClass2,numelmasked);
    return (float)(CountSeg-TP)/(float)CountRef;
}

// Returns the total lesion load as sum of the probabilities stored in the float array of size numelmasked SoftLes
float TLL(float * SoftLes, int numelmasked){
    float TLL=0;
    for (int i=0; i<numelmasked; i++) {
        TLL+=SoftLes[i];
    }
    return TLL;
}

// Returns the total lesion load as sum of the True binary voxels stored in the binary array of size numelmasked HardLes
float TLL(bool * HardLes, int numelmasked){
    float TLL=0;
    for (int i=0; i<numelmasked; i++) {
        TLL+=HardLes[i];
    }
    return TLL;
}

// Returns the number of true positives, given two binary segmentation stored in binary arrays of size numelmasked with HardClass2 as the reference
int TruePositives_bis(bool * HardClass1, bool * HardClass2, int numelmasked ){
    if (HardClass2==NULL || HardClass1==NULL) {
        return 0;
    }
    bool * HardClass1_PTR=HardClass1;
    bool * HardClass2_PTR=HardClass2;
    int TP=0;
    for (int i=0; i<numelmasked; i++, HardClass1_PTR++, HardClass2_PTR++) {
        if (*HardClass1_PTR && *HardClass2_PTR) {
            TP++;
        }
    }
    return TP;
}

float * TruePositives(nifti_image * SoftSegmentation1, nifti_image * SoftSegmentation2){
    nifti_image * HardSegmentation1=HardSegmentation(SoftSegmentation1);
    int numbclasses1=SoftSegmentation1->nt*SoftSegmentation2->nu;
    nifti_image * HardSegmentation2=HardSegmentation(SoftSegmentation2);
    int numbclasses2=SoftSegmentation2->nt*SoftSegmentation2->nu;
    bool CompDim=(SoftSegmentation1->nx==SoftSegmentation2->nx)*(SoftSegmentation1->ny==SoftSegmentation2->ny)*(SoftSegmentation1->nz==SoftSegmentation2->nz);
    if(numbclasses1!=numbclasses2 || !CompDim){
        cout<<"Incompatible comparisons"<<endl;
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        return NULL;
    }
    else{
        float * TP=new float[numbclasses1+1];
        //      float CountNorm[numbclasses1+1];
        float * CountNorm=new float[numbclasses1+1];
        for(int c=0;c<=numbclasses1;c++){
            TP[c]=0;
            CountNorm[c]=0;
        }
        int numel=HardSegmentation1->nvox;
        float * HardSeg1_PTR=static_cast<float*>(HardSegmentation1->data);
        float * HardSeg2_PTR=static_cast<float*>(HardSegmentation2->data);
        for(int i=0;i<numel;i++,HardSeg1_PTR++,HardSeg2_PTR++){
            if((int)*HardSeg1_PTR==(int)*HardSeg2_PTR && *HardSeg1_PTR>=0){
                TP[(int)*HardSeg1_PTR]++;
            }
            if((int)*HardSeg2_PTR>=0){
                CountNorm[(int)*HardSeg2_PTR]++;
            }
        }
        for(int c=0;c<numbclasses1;c++){
            TP[numbclasses1]+=TP[c];
            CountNorm[numbclasses1]+=CountNorm[c];
        }
        for(int c=0;c<=numbclasses1;c++){
            TP[c]/=(float)CountNorm[c];
        }
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        
        if(CountNorm!=NULL){
            delete [] CountNorm;
            CountNorm=NULL;
        }
        return TP;
    }
}

// Return the correlation value between two images. Can be used to measure the relation between the outlier class found and the lesion mask
float Correlation(nifti_image * ImageCorrelate1, nifti_image * ImageCorrelate2, nifti_image * Mask){
    // first check that the dimensions are compatible
    if (ImageCorrelate1->nx != ImageCorrelate2->nx || ImageCorrelate1->ny != ImageCorrelate2->ny || ImageCorrelate1->nz != ImageCorrelate2->nz || ImageCorrelate1->nt != ImageCorrelate2->nt || ImageCorrelate1->nu != ImageCorrelate2->nu ) {
        cout<< "Incompatibility in dimensions between images to correlate "<<endl;
        return -2;
    }
    else if (ImageCorrelate1->nx != Mask->nx || ImageCorrelate1->ny != Mask->ny || ImageCorrelate1->nz != Mask->nz){
        cout<< "Incompatibility in dimensions between the mask and the images to correlate"<<endl;
    }
    Mask=Binarisation(Mask);
    ImageCorrelate1=Floatisation(ImageCorrelate1);
    ImageCorrelate2=Floatisation(ImageCorrelate2);
    int numel=Mask->nvox;
    //    int numbclasses=ImageCorrelate1->nt*ImageCorrelate1->nu;
    // Determination of mean for ImageCorrelate1 and ImageCorrelate2
    bool * Mask_PTR=NULL;
    if (Mask!=NULL) {
        Mask_PTR=static_cast<bool *>(Mask->data);
    }
    float * Image1_PTR=static_cast<float *>(ImageCorrelate1->data);
    float * Image2_PTR=static_cast<float *>(ImageCorrelate2->data);
    float Mean1=0;
    float Mean2=0;
    float numelmasked=0;
    for (int i=0; i<numel; i++,Image1_PTR++,Image2_PTR++,Mask_PTR++) {
        if (*Mask_PTR>0) {
            Mean1+=*Image1_PTR;
            Mean2+=*Image2_PTR;
            numelmasked++;
        }
    }
    if (numelmasked!=0) {
        Mean1/=numelmasked;
        Mean2/=numelmasked;
    }
    else{
        cout <<"Pb with numelmasked in correlation "<<endl;
        return -2;
    }
    
    
    // Determination of standard deviation for ImageCorrelate1 and ImageCorrelate2
    if (Mask!=NULL) {
        Mask_PTR=static_cast<bool *>(Mask->data);
    }
    Image1_PTR=static_cast<float *>(ImageCorrelate1->data);
    Image2_PTR=static_cast<float *>(ImageCorrelate2->data);
    float Variance1=0;
    float Variance2=0;
    for (int i=0; i<numel; i++,Image1_PTR++,Image2_PTR++,Mask_PTR++) {
        if (*Mask_PTR>0) {
            Variance1+=(*Image1_PTR-Mean1)*(*Image1_PTR-Mean1);
            Variance2+=(*Image2_PTR-Mean2)*(*Image2_PTR-Mean2);
        }
    }
    if (numelmasked!=0) {
        Variance1/=numelmasked;
        Variance2/=numelmasked;
    }
    
    
    // Determination of correlation value between ImageCorrelate1 and ImageCorrelate2
    float Correlation=0;
    if (Mask!=NULL) {
        Mask_PTR=static_cast<bool *>(Mask->data);
    }
    Image1_PTR=static_cast<float *>(ImageCorrelate1->data);
    Image2_PTR=static_cast<float *>(ImageCorrelate2->data);
    for (int i=0; i<numel; i++,Mask_PTR++,Image1_PTR++,Image2_PTR++) {
        Correlation+=(*Image1_PTR-Mean1)*(*Image2_PTR-Mean2);
    }
    if (Variance1>0 && Variance2>0) {
        return Correlation/=sqrtf(Variance1)*sqrtf(Variance2);
    }
    else{
        cout <<"Pb with the calculation of the variance for the correlation"<<endl;
        return -2;
    }
    
}

// Returns the number of true negatives, given two binary segmentation stored in binary arrays of size numelmasked with HardClass2 as the reference
int TrueNegatives_bis(bool * HardClass1, bool * HardClass2, int numelmasked ){
    bool * HardClass1_PTR=HardClass1;
    bool * HardClass2_PTR=HardClass2;
    int TN=0;
    for (int i=0; i<numelmasked; i++, HardClass1_PTR++, HardClass2_PTR++) {
        if (!*HardClass1_PTR && !*HardClass2_PTR) {
            TN++;
        }
    }
    return TN;
}

float * TrueNegatives(nifti_image * SoftSegmentation1, nifti_image * SoftSegmentation2){
    nifti_image * HardSegmentation1=HardSegmentation(SoftSegmentation1);
    int numbclasses1=SoftSegmentation1->nt*SoftSegmentation2->nu;
    nifti_image * HardSegmentation2=HardSegmentation(SoftSegmentation2);
    int numbclasses2=SoftSegmentation2->nt*SoftSegmentation2->nu;
    bool CompDim=(SoftSegmentation1->nx==SoftSegmentation2->nx)*(SoftSegmentation1->ny==SoftSegmentation2->ny)*(SoftSegmentation1->nz==SoftSegmentation2->nz);
    if(numbclasses1!=numbclasses2 || !CompDim){
        cout<<"Incompatible comparisons"<<endl;
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        return NULL;
    }
    else{
        float * TN = new float[numbclasses1+1];
        //        float CountNorm[numbclasses1+1];
        float * CountNorm=new float[numbclasses1+1];
        for(int c=0;c<=numbclasses1;c++){
            TN[c]=0;
            CountNorm[c]=0;
        }
        int numel=HardSegmentation1->nvox;
        float * HardSeg1_PTR=static_cast<float*>(HardSegmentation1->data);
        float * HardSeg2_PTR=static_cast<float*>(HardSegmentation2->data);
        for(int i=0;i<numel;i++,HardSeg1_PTR++,HardSeg2_PTR++){
            for(int c=0;c<numbclasses1;c++){
                if((int)*HardSeg1_PTR!= c && (int)*HardSeg2_PTR != c && *HardSeg1_PTR>=0){
                    TN[c]++;
                }
                if((int)*HardSeg2_PTR!=c && *HardSeg2_PTR>=0){
                    CountNorm[c]++;
                }
            }
            
        }
        for(int c=0;c<numbclasses1;c++){
            TN[numbclasses1]+=TN[c];
            CountNorm[numbclasses1]+=CountNorm[c];
        }
        for(int c=0;c<=numbclasses1;c++){
            TN[c]/=CountNorm[c];
        }
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        if(CountNorm!=NULL){
            delete [] CountNorm;
            CountNorm=NULL;
        }
        return TN;
    }
}

// Returns the number of false negatives given the binary classification the second bool array being taken as reference for the classification
int FalseNegatives_bis(bool * HardClass1, bool * HardClass2, int numelmasked ){
    bool * HardClass1_PTR=HardClass1;
    bool * HardClass2_PTR=HardClass2;
    int FN=0;
    for (int i=0; i<numelmasked; i++, HardClass1_PTR++, HardClass2_PTR++) {
        if (!*HardClass1_PTR && *HardClass2_PTR) {
            FN++;
        }
    }
    return FN;
}

float * FalseNegatives(nifti_image * SoftSegmentation1, nifti_image * SoftSegmentation2){
    nifti_image * HardSegmentation1=HardSegmentation(SoftSegmentation1);
    int numbclasses1=SoftSegmentation1->nt*SoftSegmentation2->nu;
    nifti_image * HardSegmentation2=HardSegmentation(SoftSegmentation2);
    int numbclasses2=SoftSegmentation2->nt*SoftSegmentation2->nu;
    bool CompDim=(SoftSegmentation1->nx==SoftSegmentation2->nx)*(SoftSegmentation1->ny==SoftSegmentation2->ny)*(SoftSegmentation1->nz==SoftSegmentation2->nz);
    if(numbclasses1!=numbclasses2 || !CompDim){
        cout<<"Incompatible comparisons"<<endl;
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        return NULL;
    }
    else{
        float * FN=new float[numbclasses1+1];
        //        float CountNorm[numbclasses1+1];
        float * CountNorm=new float[numbclasses1+1];
        for(int c=0;c<=numbclasses1;c++){
            FN[c]=0;
            CountNorm[c]=0;
        }
        int numel=HardSegmentation1->nvox;
        float * HardSeg1_PTR=static_cast<float*>(HardSegmentation1->data);
        float * HardSeg2_PTR=static_cast<float*>(HardSegmentation2->data);
        for(int i=0;i<numel;i++,HardSeg1_PTR++,HardSeg2_PTR++){
            for(int c=0;c<numbclasses1;c++){
                if((int)*HardSeg1_PTR!= c && (int)*HardSeg2_PTR == c && *HardSeg1_PTR>=0){
                    FN[c]++;
                }
                if((int)*HardSeg2_PTR!=c && *HardSeg2_PTR>=0){
                    CountNorm[c]++;
                }
            }
            
        }
        for(int c=0;c<numbclasses1;c++){
            FN[numbclasses1]+=FN[c];
            CountNorm[numbclasses1]+=CountNorm[c];
        }
        for(int c=0;c<=numbclasses1;c++){
            FN[c]/=CountNorm[c];
        }
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        if(CountNorm!=NULL){
            delete [] CountNorm;
            CountNorm=NULL;
        }
        return FN;
    }
}

// Returns in an array the size of number of labels in LabelSeg the categorisation of the label ie FP, TP or FN
ResultType * ClassifLabel(int * LabelSeg, int * LabelRef, int numel){
    int maxLabelSeg=GetMaxLabel(LabelSeg, numel);
    ResultType * ResultTypeLabel=new ResultType[maxLabelSeg];
    for (int l=0; l<maxLabelSeg; l++) {
        ResultTypeLabel[l]=FP;
        for (int i=0;i<numel; i++) {
            if (LabelSeg[i]==l+1) {
                if (LabelRef[i]>0) {
                    ResultTypeLabel[l]=TP;
                    break;
                }
            }
        }
    }
    return ResultTypeLabel;
}

// Returns in a float array for each lesion in the connected reference (or its merge version if need be given the segmented couterpart) the volume of the lesion, the volume of the segmented counter part, for each modality given in DataCompImage the corresponding mean, ratio vs the inlier mean of WMSeg, as well as the Mahal Distance both per modality and globally.
vector<LesionRefIntensity * > AnalysisPerRefConnectedIntensity(int * LabelSeg, int * LabelRef, nifti_image * MahalDistMaps, SEG_ANALYSIS * segment_analysis){
    vector<LesionRefIntensity *> VectorLesionIntensity;
    if (LabelRef==NULL || LabelSeg ==NULL || MahalDistMaps==NULL ) {
        return VectorLesionIntensity;
    }
    int numel=MahalDistMaps->nx*MahalDistMaps->ny*MahalDistMaps->nz;
    //    int numbmodal=MahalDistMaps->nu*MahalDistMaps->nt-1;
    vector<int> RuleCheck=segment_analysis->vecRuleMahal;
    int maxLabelRef=GetMaxLabel(LabelRef, numel);
    int maxLabelSeg=GetMaxLabel(LabelSeg, numel);
    bool * CheckedLabelSeg=new bool[maxLabelSeg];
    for (int l=0; l<maxLabelSeg; l++) {
        CheckedLabelSeg[l]=0;
    }
    
    LesionRefIntensity * GlobalLesionRefIntensity=new LesionRefIntensity();
    float * MahalData=static_cast<float *>(MahalDistMaps->data);
    // For each label gives the list of labels in ref that are merged in Seg
    vector< vector<int> > MergedLabels;
    for (int ls=0; ls<maxLabelSeg; ls++) {
        MergedLabels.push_back(GetListCorrespondingLabels(ls+1, LabelRef, LabelSeg, numel));
    }
    int * WorkingCopyLabelRef=CopyArray(LabelRef, numel);
    for (int ls=0; ls<maxLabelSeg; ls++) {
        if (MergedLabels[ls].size()>1) {
            cout<<"Have to merge labels "<<MergedLabels[ls][0]<<" and ";
            int numbMerged=MergedLabels[ls].size();
            for (int lm=1; lm<numbMerged; lm++) {
                cout<<MergedLabels[ls][lm]<<" ";
                for (int i=0; i<numel; i++) {
                    if (WorkingCopyLabelRef[i]==MergedLabels[ls][lm]) {
                        WorkingCopyLabelRef[i]=MergedLabels[ls][0];
                    }
                }
            }
            cout<<endl;
        }
    }
    int VolumeSegGlobal=0;
    int TPGlobal=0;
    int FPGlobal=0;
    int FNGlobal=0;
    int FPGlobalNonValid=0;
    float * TPMahalGlobal=GlobalLesionRefIntensity->TPMahal;
    float * FPMahalGlobal=GlobalLesionRefIntensity->FPMahal;
    float * FNMahalGlobal=GlobalLesionRefIntensity->FNMahal;
    //    Analysis for each lesion
    for (int lr=0; lr<maxLabelRef; lr++) {
        
        int LabelSize=GetLabelSize(lr+1, LabelRef, numel);
        
        int LabelSizeWorking=GetLabelSize(lr+1, WorkingCopyLabelRef, numel);
        
        VolumeSegGlobal+=LabelSizeWorking;
        //        cout<<"LabelSize "<<LabelSize<<" and LabelWorking "<<LabelSizeWorking<<endl;
        vector<int> CorrespondingLabels=GetListCorrespondingLabels(lr+1,LabelSeg,LabelRef,numel);
        
        
        if (LabelSizeWorking>0) {
            LesionRefIntensity * LesionToPush=new LesionRefIntensity();
            LesionToPush->Volume=LabelSize;
            LesionToPush->TrueWorkingVolume=LabelSizeWorking;
            int numbCorrespondingLabels=CorrespondingLabels.size();
            int VolumeSeg=0;
            int TPl=0;
            int FPl=0;
            int FNl=0;
            int FPNonValid=0;
            float * TPMahal=LesionToPush->TPMahal;
            float * FPMahal=LesionToPush->FPMahal;
            float * FNMahal=LesionToPush->FNMahal;
            for (int i=0; i<3; i++) {
                FPMahal[i]=pow_int(-1, i+1)*1000*i;
                FNMahal[i]=pow_int(-1, i+1)*1000*i;
                TPMahal[i]=pow_int(-1, i+1)*1000*i;
            }
            
            
            for (int ls=0; ls<numbCorrespondingLabels; ls++) {
                CheckedLabelSeg[CorrespondingLabels[ls]-1]=1; // Checking the label that is worked
                LesionToPush->AssociatedLabel.push_back(CorrespondingLabels[ls]);
            }
            for (int i=0; i<numel; i++) {
                bool flag_FN=1;
                if (numbCorrespondingLabels>0) {
                    LesionToPush->FlagTypeConnectedComponent=TP;
                }
                if (numbCorrespondingLabels==0) {
                    LesionToPush->FlagTypeConnectedComponent=FN;
                }
                for (int ls=0; ls<numbCorrespondingLabels; ls++) {
                    if (LabelSeg[i]==CorrespondingLabels[ls]) {
                        VolumeSeg++;
                        if (WorkingCopyLabelRef[i]==lr+1) {
                            TPl++;
                            TPGlobal++;
                            TPMahal[0]+=MahalData[i];
                            TPMahalGlobal[0]+=MahalData[i];
                            if (TPMahal[0]<0) {
                                cout<<"Pb in negative Mahal..."<<endl;
                            }
                            if (MahalData[i]<TPMahal[1]) {
                                TPMahal[1]=MahalData[i];
                                if (MahalData[i]<TPMahalGlobal[1]) {
                                    TPMahalGlobal[1]=MahalData[i];
                                }
                            }
                            if (MahalData[i]>TPMahal[2]) {
                                TPMahal[2]=MahalData[i];
                                if (MahalData[i]>TPMahalGlobal[2]) {
                                    TPMahalGlobal[2]=MahalData[i];
                                }
                            }
                            flag_FN=0;
                        }
                        else if(WorkingCopyLabelRef[i]==0){ // So that we do not have problems when separated ref connected regions are merged in the segmentation analysed
                            FPl++;
                            FPGlobal++;
                            int sizeRuleCheck=RuleCheck.size();
                            bool flag_check=1;
                            for (int m=0; m<sizeRuleCheck; m++) {
                                int ModalityToCheck=RuleCheck[m]/10;
                                int Sign=RuleCheck[m]>0?1:-1;
                                Sign=RuleCheck[m]==0?0:Sign;
                                flag_check*=(MahalData[numel*(ModalityToCheck+1)+i]*Sign>=0);
                            }
                            if (!flag_check) {
                                FPNonValid++;
                                FPGlobalNonValid++;
                            }
                            else{
                                FPMahal[0]+=MahalData[i];
                                FPMahalGlobal[0]+=MahalData[i];
                                if (FPMahal[0]<0) {
                                    cout<<"Pb in negative Mahal..."<<endl;
                                }
                                if (MahalData[i]<FPMahal[1]) {
                                    FPMahal[1]=MahalData[i];
                                    if (MahalData[i]<FPMahalGlobal[1]) {
                                        FPMahalGlobal[1]=MahalData[i];
                                    }
                                }
                                if (MahalData[i]>FPMahal[2]) {
                                    FPMahal[2]=MahalData[i];
                                    if (MahalData[i]>FPMahalGlobal[2]) {
                                        FPMahalGlobal[2]=MahalData[i];
                                    }
                                }
                            }
                            
                            flag_FN=0;
                        }
                    }
                }
                if (flag_FN && WorkingCopyLabelRef[i]==lr+1) {
                    FNl++;
                    FNGlobal++;
                    FNMahal[0]+=MahalData[i];
                    FNMahalGlobal[0]+=MahalData[i];
                    if (MahalData[i]<FNMahal[1]) {
                        FNMahal[1]=MahalData[i];
                        if (MahalData[i]<FNMahalGlobal[1]) {
                            FNMahalGlobal[1]=MahalData[i];
                        }
                    }
                    if (MahalData[i]>FNMahal[2]) {
                        FNMahal[2]=MahalData[i];
                        if (MahalData[i]>FNMahalGlobal[2]) {
                            FNMahalGlobal[2]=MahalData[i];
                        }
                    }
                }
            }
            TPMahal[0]/=TPl;
            FNMahal[0]/=FNl;
            FPMahal[0]/=(FPl-FPNonValid);
            LesionToPush->DSC=(2.0*TPl)/(2.0*TPl+FNl+FPl);
            LesionToPush->TPl=TPl;
            LesionToPush->FNl=FNl;
            LesionToPush->FPl=FPl;
            LesionToPush->FPNotAgree=FPNonValid;
            //            LesionToPush->Volume=LabelSizeWorking;
            VectorLesionIntensity.push_back(LesionToPush);
        }
        
        
    }
    int sizeRuleCheck=RuleCheck.size();
    //    Taking care then of all the FP connected components (remaining from the CheckedArray)
    for (int ls=0; ls<maxLabelSeg; ls++) {
        if (!CheckedLabelSeg[ls]) {
            LesionRefIntensity * LesionFPToPush=new LesionRefIntensity();
            int FPNonValid=0;
            LesionFPToPush->FlagTypeConnectedComponent=FP;
            int VolumeLesionFP=GetLabelSize(ls+1, LabelSeg, numel);
            LesionFPToPush->Volume=VolumeLesionFP;
            LesionFPToPush->FPl=VolumeLesionFP;
            float * FPMahalLes=LesionFPToPush->FPMahal;
            FPGlobal+=VolumeLesionFP;
            
            for (int i=0; i<numel; i++) {
                if (LabelSeg[i]==ls+1) {
                    bool flag_check=1;
                    for (int m=0; m<sizeRuleCheck; m++) {
                        int ModalityToCheck=RuleCheck[m]/10;
                        int Sign=RuleCheck[m]>0?1:-1;
                        Sign=RuleCheck[m]==0?0:Sign;
                        flag_check*=(MahalData[numel*(ModalityToCheck+1)+i]*Sign>=0);
                    }
                    if (!flag_check) {
                        FPNonValid++;
                        FPGlobalNonValid++;
                    }
                    else{
                        FPMahalLes[0]+=MahalData[i];
                        FPMahalGlobal[0]+=MahalData[i];
                        if (MahalData[i]<FPMahalLes[1]) {
                            FPMahalLes[1]=MahalData[i];
                            if (MahalData[i]<FPMahalGlobal[1]) {
                                FPMahalGlobal[1]=MahalData[i];
                            }
                        }
                        if (MahalData[i]>FPMahalLes[2]) {
                            FPMahalLes[2]=MahalData[i];
                            if (MahalData[i]>FPMahalGlobal[2]) {
                                FPMahalGlobal[2]=MahalData[i];
                            }
                        }
                    }
                    
                }
            }
            FPMahalLes[0]/=(VolumeLesionFP-FPNonValid);
            VectorLesionIntensity.push_back(LesionFPToPush);
        }
    }
    
    
    //    Create the global summaries corresponding to either ee global with OE or DEFP or DEFN
    LesionRefIntensity * OEGlobalLesion=new LesionRefIntensity();
    LesionRefIntensity * DEFPGlobalLesion=new LesionRefIntensity();
    LesionRefIntensity * DEFNGlobalLesion=new LesionRefIntensity();
    OEGlobalLesion->FlagTypeConnectedComponent=OE;
    DEFPGlobalLesion->FlagTypeConnectedComponent=DEFP;
    DEFNGlobalLesion->FlagTypeConnectedComponent=DEFN;
    float * OETP=OEGlobalLesion->TPMahal;
    float * OEFP=OEGlobalLesion->FPMahal;
    float * OEFN=OEGlobalLesion->FNMahal;
    float * DEFP=DEFPGlobalLesion->FPMahal;
    float * DEFN=DEFNGlobalLesion->FNMahal;
    
    int numbLesions=VectorLesionIntensity.size();
    for (int l=0; l<numbLesions; l++) {
        switch (VectorLesionIntensity[l]->FlagTypeConnectedComponent) {
                case TP:{ // case where it belongs to the GlobalOE
                    OEGlobalLesion->TPl+=VectorLesionIntensity[l]->TPl;
                    OEGlobalLesion->FPl+=VectorLesionIntensity[l]->FPl;
                    OEGlobalLesion->FNl+=VectorLesionIntensity[l]->FNl;
                    
                    OETP[0]+=VectorLesionIntensity[l]->TPMahal[0]*VectorLesionIntensity[l]->TPl;
                    if (VectorLesionIntensity[l]->FPMahal[0]==VectorLesionIntensity[l]->FPMahal[0]) {
                        OEFP[0]+=VectorLesionIntensity[l]->FPMahal[0]*VectorLesionIntensity[l]->FPl;
                    }
                    
                    if (OEFP[0]!=OEFP[0]) {
                        cout<<"Pb nan in OEFP";
                    }
                    if (VectorLesionIntensity[l]->FNMahal[0]==VectorLesionIntensity[l]->FNMahal[0]) {
                        OEFN[0]+=VectorLesionIntensity[l]->FNMahal[0]*VectorLesionIntensity[l]->FNl;
                    }
                    
                    
                    if (VectorLesionIntensity[l]->TPMahal[1]<OETP[1]) {
                        OETP[1]=VectorLesionIntensity[l]->TPMahal[1];
                    }
                    if (VectorLesionIntensity[l]->FPMahal[1]<OEFP[1]) {
                        OEFP[1]=VectorLesionIntensity[l]->FPMahal[1];
                    }
                    if (VectorLesionIntensity[l]->FNMahal[1]<OEFN[1]) {
                        OEFN[1]=VectorLesionIntensity[l]->FNMahal[1];
                    }
                    
                    if (VectorLesionIntensity[l]->TPMahal[2]>OETP[2]) {
                        OETP[2]=VectorLesionIntensity[l]->TPMahal[2];
                    }
                    if (VectorLesionIntensity[l]->FPMahal[2]>OEFP[2]) {
                        OEFP[2]=VectorLesionIntensity[l]->FPMahal[2];
                    }
                    if (VectorLesionIntensity[l]->FNMahal[2]>OEFN[2]) {
                        OEFN[2]=VectorLesionIntensity[l]->FNMahal[2];
                    }
                    OEGlobalLesion->FPNotAgree+=VectorLesionIntensity[l]->FPNotAgree;
                }
                break;
                case FP:{
                    DEFPGlobalLesion->FPl+=VectorLesionIntensity[l]->FPl;
                    DEFP[0]+=(VectorLesionIntensity[l]->FPl-VectorLesionIntensity[l]->FPNotAgree)*VectorLesionIntensity[l]->FPMahal[0];
                    if (VectorLesionIntensity[l]->FPMahal[1]<DEFP[1]) {
                        DEFP[1]=VectorLesionIntensity[l]->FPMahal[1];
                    }
                    
                    if (VectorLesionIntensity[l]->FPMahal[2]>DEFP[2]) {
                        DEFP[2]=VectorLesionIntensity[l]->FPMahal[2];
                    }
                    DEFPGlobalLesion->FPNotAgree+=VectorLesionIntensity[l]->FPNotAgree;
                }
                break;
                case FN:{
                    DEFNGlobalLesion->FNl+=VectorLesionIntensity[l]->FNl;
                    DEFN[0]+=(VectorLesionIntensity[l]->FNl)*VectorLesionIntensity[l]->FNMahal[0];
                    if (VectorLesionIntensity[l]->FNMahal[1]<DEFN[1]) {
                        DEFN[1]=VectorLesionIntensity[l]->FNMahal[1];
                    }
                    
                    if (VectorLesionIntensity[l]->FNMahal[2]>DEFN[2]) {
                        DEFN[2]=VectorLesionIntensity[l]->FNMahal[2];
                    }
                }
                break;
            default:
                break;
        }
    }
    
    OETP[0]/=OEGlobalLesion->TPl;
    OEFP[0]/=(OEGlobalLesion->FPl-OEGlobalLesion->FPNotAgree);
    OEFN[0]/=(OEGlobalLesion->FNl);
    OEGlobalLesion->DSC=2*OEGlobalLesion->TPl/(2.0*OEGlobalLesion->TPl+OEGlobalLesion->FNl+OEGlobalLesion->FPl);
    DEFP[0]/=(DEFPGlobalLesion->FPl-DEFPGlobalLesion->FPNotAgree);
    DEFN[0]/=DEFNGlobalLesion->FNl;
    
    VectorLesionIntensity.push_back(OEGlobalLesion);
    VectorLesionIntensity.push_back(DEFPGlobalLesion);
    VectorLesionIntensity.push_back(DEFNGlobalLesion);
    
    //    Final Global Lesion that will give the mahal value for the outline error
    TPMahalGlobal[0]/=TPGlobal;
    FNMahalGlobal[0]/=FNGlobal;
    FPMahalGlobal[0]/=(FPGlobal-FPGlobalNonValid);
    GlobalLesionRefIntensity->FPNotAgree=FPGlobalNonValid;
    GlobalLesionRefIntensity->Volume=TPGlobal+FNGlobal;
    GlobalLesionRefIntensity->DSC=(2.0*TPGlobal)/(2.0*TPGlobal+FPGlobal+FNGlobal);
    GlobalLesionRefIntensity->FNl=FNGlobal;
    GlobalLesionRefIntensity->TPl=TPGlobal;
    GlobalLesionRefIntensity->FPl=FPGlobal;
    VectorLesionIntensity.push_back(GlobalLesionRefIntensity);
    
    //    Clearing before returning
    if (WorkingCopyLabelRef!=NULL) {
        delete [] WorkingCopyLabelRef;
        WorkingCopyLabelRef=NULL;
    }
    if (CheckedLabelSeg!=NULL) {
        delete [] CheckedLabelSeg;
        CheckedLabelSeg=NULL;
    }
    
    return VectorLesionIntensity;
}





// Returns in a float array for each lesion in the connected reference (or its merge version if need be given the segmented couterpart) the volume of the lesion, the volume of the segmented counter part, for each modality given in DataCompImage the corresponding mean, ratio vs the inlier mean of WMSeg, as well as the Mahal Distance both per modality and globally.
vector<LesionRefIntensity * > AnalysisPerRefConnectedIntensity_bis(int * LabelSeg, int * LabelRef, nifti_image * MahalDistMaps, SEG_ANALYSIS * segment_analysis, nifti_image * DistanceToVent){
    vector<LesionRefIntensity *> VectorLesionIntensity;
    if (LabelRef==NULL || LabelSeg ==NULL || MahalDistMaps==NULL ) {
        return VectorLesionIntensity;
    }
    //    float ThresholdCheck=segment_analysis->MahalThresholdCheck;
    int numel=MahalDistMaps->nx*MahalDistMaps->ny*MahalDistMaps->nz;
    
    float * DistanceToVentData=static_cast<float *>(DistanceToVent->data);
    
    float * MahalData=static_cast<float *>(MahalDistMaps->data);
    cout<<"Mahal reaching"<<MahalData[MahalDistMaps->nvox-1]<<endl;
    //    int numbmodal=MahalDistMaps->nu*MahalDistMaps->nt-1;
    vector<int> RuleCheck=segment_analysis->vecRuleMahal;
    //    Creating a bool mask for all voxel of MahalDistMaps that do not satisfy the LesionRule
    
    bool * NonValidMask=new bool[numel];
    int sizeRuleCheck=RuleCheck.size();
    for (int i=0; i<numel; i++) {
        NonValidMask[i]=0;
        if (MahalData[i]!=0) {
            bool flag_check=1;
            for (int m=0; m<sizeRuleCheck; m++) {
                int ModalityToCheck=RuleCheck[m]/10;
                int Sign=RuleCheck[m]>0?1:-1;
                Sign=RuleCheck[m]==0?0:Sign;
                flag_check*=(MahalData[numel*(ModalityToCheck+1)+i]*Sign>=0);
            }
            if (!flag_check) {
                NonValidMask[i]=1;
            }
        }
    }
    
    
    int maxLabelRef=GetMaxLabel(LabelRef, numel);
    int maxLabelSeg=GetMaxLabel(LabelSeg, numel);
    bool * CheckedLabelSeg=new bool[maxLabelSeg];
    for (int l=0; l<maxLabelSeg; l++) {
        CheckedLabelSeg[l]=0;
    }
    
    
    //    LesionRefIntensity * GlobalLesionRefIntensity=new LesionRefIntensity();
    
    // For each label gives the list of labels in ref that are merged in Seg
    vector< vector<int> > MergedLabels;
    for (int ls=0; ls<maxLabelSeg; ls++) {
        MergedLabels.push_back(GetListCorrespondingLabels(ls+1, LabelRef, LabelSeg, numel));
    }
    int * WorkingCopyLabelRef=CopyArray(LabelRef, numel);
    for (int ls=0; ls<maxLabelSeg; ls++) {
        if (MergedLabels[ls].size()>1) {
            cout<<"Have to merge labels "<<MergedLabels[ls][0]<<" and ";
            int numbMerged=MergedLabels[ls].size();
            for (int lm=1; lm<numbMerged; lm++) {
                cout<<MergedLabels[ls][lm]<<" ";
                for (int i=0; i<numel; i++) {
                    if (WorkingCopyLabelRef[i]==MergedLabels[ls][lm]) {
                        WorkingCopyLabelRef[i]=MergedLabels[ls][0];
                    }
                }
            }
            cout<<endl;
        }
    }
    int VolumeSegGlobal=0;
    
    
    bool * TPSegGlobal=new bool[numel];
    bool * FPSegGlobal=new bool[numel];
    bool * FNSegGlobal=new bool[numel];
    bool * SegGlobal=new bool[numel];
    bool * RefGlobal=new bool[numel];
    bool * OESegGlobal=new bool[numel];
    bool * OERefGlobal=new bool[numel];
    bool * DEFPSegGlobal=new bool[numel];
    bool * DEFNSegGlobal=new bool[numel];
    bool * OEFPSegGlobal=new bool[numel];
    bool * OEFNSegGlobal=new bool[numel];
    bool * DEFPSegValid=new bool[numel];
    bool * DEFNSegValid=new bool[numel];
    bool * OEFPSegValid=new bool[numel];
    bool * OEFNSegValid=new bool[numel];
    bool * FNSegValid=new bool[numel];
    bool * FPSegValid=new bool[numel];
    bool * TPSegValid=new bool[numel];
    bool * SegValid=new bool[numel];
    bool * RefValid=new bool[numel];
    
    for (int i=0; i<numel; i++) {
        TPSegGlobal[i]=0;
        FPSegGlobal[i]=0;
        FNSegGlobal[i]=0;
        SegGlobal[i]=0;
        RefGlobal[i]=0;
        SegValid[i]=0;
        RefValid[i]=0;
        FNSegValid[i]=0;
        FPSegValid[i]=0;
        TPSegValid[i]=0;
        DEFNSegValid[i]=0;
        DEFPSegValid[i]=0;
        OEFNSegValid[i]=0;
        OEFPSegValid[i]=0;
        DEFPSegGlobal[i]=0;
        DEFNSegGlobal[i]=0;
        OEFNSegGlobal[i]=0;
        OEFPSegGlobal[i]=0;
        OERefGlobal[i]=0;
        OESegGlobal[i]=0;
    }
    
    cout<<"Non 0 working ref is "<<CountNonZero(WorkingCopyLabelRef, numel)<<endl;
    cout<<"Non 0 Label Seg is "<<CountNonZero(LabelSeg, numel)<<endl;
    
    //    Analysis for each lesion
    for (int lr=0; lr<maxLabelRef; lr++) {
        
        int LabelSize=GetLabelSize(lr+1, LabelRef, numel);
        
        int LabelSizeWorking=GetLabelSize(lr+1, WorkingCopyLabelRef, numel);
        
        VolumeSegGlobal+=LabelSizeWorking;
        //        cout<<"LabelSize "<<LabelSize<<" and LabelWorking "<<LabelSizeWorking<<endl;
        vector<int> CorrespondingLabels=GetListCorrespondingLabels(lr+1,LabelSeg,WorkingCopyLabelRef,numel);
        
        
        if (LabelSizeWorking>0) { // meaning that all FN and FP will contribute to OE and that there are some TP in the lesion bool segmentation.
            
            bool * LesionRefBool=CreateLesionBool(WorkingCopyLabelRef, lr+1, numel);
            LesionRefIntensity * LesionToPush=new LesionRefIntensity();
            LesionToPush->Volume=LabelSize;
            LesionToPush->TrueWorkingVolume=LabelSizeWorking;
            int numbCorrespondingLabels=CorrespondingLabels.size();
            float * TPMahal=LesionToPush->TPMahal;
            float * FPMahal=LesionToPush->FPMahal;
            float * FNMahal=LesionToPush->FNMahal;
            float * RefMahal=LesionToPush->RefMahal;
            float * SegMahal=LesionToPush->SegMahal;
            float * ProportionCloseVent=LesionToPush->ProportionCloseVentricle;
            
            bool * LesionBoolSeg=new bool[numel];
            bool * TPLesionTmp=new bool[numel];
            bool * FPLesionTmp=new bool[numel];
            bool * FNLesionTmp=new bool[numel];
            bool * SegLesionTmp=new bool[numel];
            bool * RefLesionTmp=new bool[numel];
            bool * FNLesionValid=new bool[numel];
            bool * FPLesionValid=new bool[numel];
            bool * TPLesionValid=new bool[numel];
            bool * SegLesionValid=new bool[numel];
            bool * RefLesionValid=new bool[numel];
            for (int i=0; i<numel; i++) {
                LesionBoolSeg[i]=0;
                TPLesionTmp[i]=0;
                FPLesionTmp[i]=0;
                FNLesionTmp[i]=0;
                SegLesionTmp[i]=0;
                RefLesionTmp[i]=0;
                FNLesionValid[i]=0;
                TPLesionValid[i]=0;
                FPLesionValid[i]=0;
                SegLesionValid[i]=0;
                RefLesionValid[i]=0;
            }
            
            if (numbCorrespondingLabels==0) { // case when it is a total FN undetected
                LesionToPush->FlagTypeConnectedComponent=FN;
                OROperationBool(LesionRefBool,FNLesionTmp,FNLesionTmp,numel);
                OROperationBool(FNLesionTmp,DEFNSegGlobal,DEFNSegGlobal,numel);
                OROperationBool(FNLesionTmp, FNSegGlobal, FNSegGlobal, numel);
                LesionToPush->FNl=CountNonZero(FNLesionTmp, numel);
                LesionToPush->Refl=LesionToPush->FNl;
                XOROperationBool(FNLesionTmp, NonValidMask, FNLesionValid, numel);
                LesionToPush->FNNotAgree=LesionToPush->FNl-CountNonZero(FNLesionValid, numel);
                LesionToPush->RefNotAgree=LesionToPush->FNNotAgree;
                for (int i=1; i<11; i++) {
                    LesionToPush->PropMahalRef[i-1]=GetProportionUnder<float, bool>(MahalData, FNLesionTmp, 0.5*i, numel);
                    LesionToPush->PropMahalFN[i-1]=LesionToPush->PropMahalRef[i-1];
                }
                
                float * FNQuantMahal=QuantiliseMask(FNLesionValid, MahalDistMaps);
                FNMahal[1]=GetMin(MahalData, FNLesionValid, numel);
                FNMahal[2]=GetMax(MahalData, FNLesionValid, numel);
                FNMahal[0]=GetMeanData(MahalData, FNLesionValid, numel);
                RefMahal[0]=FNMahal[0];
                RefMahal[1]=FNMahal[1];
                RefMahal[2]=FNMahal[2];
                ProportionCloseVent[2]=GetProportionUnder<float , bool>(DistanceToVentData, FNLesionTmp, 5, numel);
                ProportionCloseVent[3]=ProportionCloseVent[2];
                if (FNQuantMahal!=NULL) {
                    for (int i=0; i<3; i++) {
                        FNMahal[3+i]=FNQuantMahal[i];
                        RefMahal[3+i]=FNQuantMahal[i];
                    }
                    delete [] FNQuantMahal;
                    FNQuantMahal=NULL;
                }
            }
            else{ // Meaning that there is some TP somewhere
                
                
                LesionToPush->FlagTypeConnectedComponent=TP;
                for (int ls=0; ls<numbCorrespondingLabels; ls++) {
                    CheckedLabelSeg[CorrespondingLabels[ls]-1]=1; // Checking the label that is worked
                    LesionToPush->AssociatedLabel.push_back(CorrespondingLabels[ls]);
                    bool * LesionTmpBool=CreateLesionBool(LabelSeg, CorrespondingLabels[ls], numel);
                    OROperationBool(LesionTmpBool,LesionBoolSeg,LesionBoolSeg,numel);
                    delete [] LesionTmpBool;
                    LesionTmpBool=NULL;
                }
                //                Obtention of the TP segmentation
                ANDOperationBool(LesionRefBool,LesionBoolSeg,TPLesionTmp,numel);
                //                Obtention of the FN segmentation
                XOROperationBool(LesionRefBool, LesionBoolSeg, FNLesionTmp, numel);
                //                Obtention of the FP segmentation
                XOROperationBool(LesionBoolSeg, LesionRefBool, FPLesionTmp, numel);
                //             Contribution to global TP
                OROperationBool(TPSegGlobal, TPLesionTmp, TPSegGlobal, numel);
                //                Contribution to global FN
                OROperationBool(FNSegGlobal, FNLesionTmp, FNSegGlobal, numel);
                //                Contribution to global OEFN
                OROperationBool(OEFNSegGlobal, FNLesionTmp, OEFNSegGlobal, numel);
                //                Contribution to global FP
                OROperationBool(FPSegGlobal, FPLesionTmp, FPSegGlobal, numel);
                //                Contribution to global OEFP
                OROperationBool(OEFPSegGlobal, FPLesionTmp, OEFPSegGlobal, numel);
                
                XOROperationBool(TPLesionTmp, NonValidMask, TPLesionValid, numel);
                XOROperationBool(FPLesionTmp, NonValidMask, FPLesionValid, numel);
                XOROperationBool(FNLesionTmp, NonValidMask, FNLesionValid, numel);
                
                //                Contribution to LesionRef and LesionSeg
                OROperationBool(TPLesionTmp, FPLesionTmp, SegLesionTmp, numel);
                OROperationBool(TPLesionTmp, FNLesionTmp, RefLesionTmp, numel);
                XOROperationBool(SegLesionTmp, NonValidMask, SegLesionValid, numel);
                XOROperationBool(RefLesionTmp, NonValidMask, RefLesionValid, numel);
                
                //                Min, Max, Mean, And Quantilisation for TP FN and FP
                LesionToPush->TPl=CountNonZero(TPLesionTmp, numel);
                LesionToPush->FPl=CountNonZero(FPLesionTmp, numel);
                LesionToPush->FNl=CountNonZero(FNLesionTmp, numel);
                LesionToPush->Refl=LesionToPush->TPl+LesionToPush->FNl;
                LesionToPush->Segl=LesionToPush->TPl+LesionToPush->FPl;
                
                //                Proportion of voxels in lesion close to ventricle
                LesionToPush->ProportionCloseVentricle[0]=GetProportionUnder<float, bool>(DistanceToVentData, TPLesionTmp, 5, numel);
                LesionToPush->ProportionCloseVentricle[1]=GetProportionUnder<float, bool>(DistanceToVentData, FPLesionTmp, 5, numel);
                LesionToPush->ProportionCloseVentricle[2]=GetProportionUnder<float, bool>(DistanceToVentData, FNLesionTmp, 5, numel);
                LesionToPush->ProportionCloseVentricle[3]=GetProportionUnder<float, bool>(DistanceToVentData, RefLesionTmp, 5, numel);
                LesionToPush->ProportionCloseVentricle[4]=GetProportionUnder<float, bool>(DistanceToVentData, SegLesionTmp, 5, numel);
                
                LesionToPush->TPNotAgree=LesionToPush->TPl-CountNonZero(TPLesionValid, numel);
                LesionToPush->FPNotAgree=LesionToPush->FPl-CountNonZero(FPLesionValid, numel);
                LesionToPush->FNNotAgree=LesionToPush->FNl-CountNonZero(FNLesionValid, numel);
                LesionToPush->RefNotAgree=LesionToPush->FNNotAgree+LesionToPush->TPNotAgree;
                LesionToPush->SegNotAgree=LesionToPush->FPNotAgree+LesionToPush->TPNotAgree;
                
                //                Proportion mahal array
                for (int i=1; i<11; i++) {
                    LesionToPush->PropMahalRef[i-1]=GetProportionUnder<float, bool>(MahalData, RefLesionTmp, 0.5*i, numel);
                    LesionToPush->PropMahalSeg[i-1]=GetProportionUnder<float, bool>(MahalData, SegLesionTmp, 0.5*i, numel);
                    LesionToPush->PropMahalFN[i-1]=GetProportionUnder<float, bool>(MahalData, FNLesionTmp, 0.5*i, numel);
                    LesionToPush->PropMahalTP[i-1]=GetProportionUnder<float, bool>(MahalData, TPLesionTmp, 0.5*i, numel);
                    LesionToPush->PropMahalFP[i-1]=GetProportionUnder<float, bool>(MahalData, FPLesionTmp, 0.5*i, numel);
                }
                
                
                LesionToPush->DSC=2.0*LesionToPush->TPl/(2.0*LesionToPush->TPl+LesionToPush->FPl+LesionToPush->FNl);
                
                TPMahal[1]=GetMin(MahalData, TPLesionTmp, numel);
                FPMahal[1]=GetMin(MahalData, FPLesionTmp,numel);
                FNMahal[1]=GetMin(MahalData, FNLesionTmp, numel);
                SegMahal[1]=GetMin(MahalData, SegLesionTmp, numel);
                RefMahal[1]=GetMin(MahalData, RefLesionTmp, numel);
                
                TPMahal[2]=GetMax(MahalData, TPLesionTmp, numel);
                FPMahal[2]=GetMax(MahalData, FPLesionTmp,numel);
                FNMahal[2]=GetMax(MahalData, FNLesionTmp, numel);
                SegMahal[2]=GetMax(MahalData, SegLesionTmp, numel);
                RefMahal[2]=GetMax(MahalData, RefLesionTmp, numel);
                
                TPMahal[0]=GetMeanData(MahalData, TPLesionTmp, numel);
                FPMahal[0]=GetMeanData(MahalData, FPLesionTmp,numel);
                FNMahal[0]=GetMeanData(MahalData, FNLesionTmp, numel);
                SegMahal[0]=GetMeanData(MahalData, SegLesionTmp, numel);
                RefMahal[0]=GetMeanData(MahalData, RefLesionTmp, numel);
                
                float * TPMahalQuant=QuantiliseMask(TPLesionTmp, MahalDistMaps);
                float * FNMahalQuant=QuantiliseMask(FNLesionTmp, MahalDistMaps);
                float * FPMahalQuant=QuantiliseMask(FPLesionTmp, MahalDistMaps);
                float * SegMahalQuant=QuantiliseMask(SegLesionTmp, MahalDistMaps);
                float * RefMahalQuant=QuantiliseMask(RefLesionTmp, MahalDistMaps);
                if (TPMahalQuant!=NULL) {
                    for (int i=0; i<3; i++) {
                        TPMahal[3+i]=TPMahalQuant[i];
                    }
                    delete [] TPMahalQuant;
                    TPMahalQuant=NULL;
                }
                if (FPMahalQuant!=NULL) {
                    for (int i=0; i<3; i++) {
                        FPMahal[3+i]=FPMahalQuant[i];
                    }
                    delete [] FPMahalQuant;
                    FPMahalQuant=NULL;
                }
                if (FNMahalQuant!=NULL) {
                    for (int i=0; i<3; i++) {
                        FNMahal[3+i]=FNMahalQuant[i];
                    }
                    delete [] FNMahalQuant;
                    FNMahalQuant=NULL;
                }
                if (SegMahalQuant!=NULL) {
                    for (int i=0; i<3; i++) {
                        SegMahal[3+i]=SegMahalQuant[i];
                    }
                    delete [] SegMahalQuant;
                    SegMahalQuant=NULL;
                }
                if (RefMahalQuant!=NULL) {
                    for (int i=0; i<3; i++) {
                        RefMahal[3+i]=RefMahalQuant[i];
                    }
                    delete [] RefMahalQuant;
                    RefMahalQuant=NULL;
                }
            }
            if (TPLesionTmp!=NULL) {
                delete [] TPLesionTmp;
                TPLesionTmp=NULL;
            }
            if (FNLesionTmp!=NULL) {
                delete [] FNLesionTmp;
                FNLesionTmp=NULL;
            }
            if(FPLesionTmp!=NULL){
                delete [] FPLesionTmp;
                FPLesionTmp=NULL;
            }
            if (FPLesionValid!=NULL) {
                delete [] FPLesionValid;
                FPLesionValid=NULL;
            }
            if (FNLesionValid!=NULL) {
                delete [] FNLesionValid;
                FNLesionValid=NULL;
            }
            if (TPLesionValid!=NULL) {
                delete [] TPLesionValid;
                TPLesionValid=NULL;
            }
            if (RefLesionTmp!=NULL) {
                delete [] RefLesionTmp;
                RefLesionTmp=NULL;
            }
            if (SegLesionTmp!=NULL) {
                delete [] SegLesionTmp;
                SegLesionTmp=NULL;
            }
            if (SegLesionValid!=NULL) {
                delete [] SegLesionValid;
                SegLesionValid=NULL;
            }
            if (RefLesionValid!=NULL) {
                delete [] RefLesionValid;
                RefLesionValid=NULL;
            }
            if (LesionBoolSeg!=NULL) {
                delete [] LesionBoolSeg;
                LesionBoolSeg=NULL;
            }
            VectorLesionIntensity.push_back(LesionToPush);
        }
        
        
        
    }
    
    //    Taking care then of all the FP connected components (remaining from the CheckedArray)
    for (int ls=0; ls<maxLabelSeg; ls++) {
        if (!CheckedLabelSeg[ls]) {
            LesionRefIntensity * LesionFPToPush=new LesionRefIntensity();
            //            int FPNonValid=0;
            float * FPMahal=LesionFPToPush->FPMahal;
            float * SegMahal=LesionFPToPush->SegMahal;
            LesionFPToPush->FlagTypeConnectedComponent=FP;
            bool * LesionBool=CreateLesionBool(LabelSeg, ls+1, numel);
            bool * LesionValid=CopyArray(LesionBool, numel);
            OROperationBool(LesionBool,FPSegGlobal,FPSegGlobal,numel);
            OROperationBool(LesionBool,DEFPSegGlobal,DEFPSegGlobal,numel);
            
            XOROperationBool(LesionBool, NonValidMask, LesionValid, numel);
            
            LesionFPToPush->FPl=CountNonZero(LesionBool, numel);
            LesionFPToPush->FPNotAgree=LesionFPToPush->FPl-CountNonZero(LesionValid, numel);
            LesionFPToPush->SegNotAgree=LesionFPToPush->FPNotAgree;
            LesionFPToPush->Segl=LesionFPToPush->FPl;
            LesionFPToPush->ProportionCloseVentricle[1]=GetProportionUnder<float,bool>(DistanceToVentData, LesionBool, 5, numel);
            LesionFPToPush->ProportionCloseVentricle[4]=LesionFPToPush->ProportionCloseVentricle[1];
            float * FPQuantMahal=QuantiliseMask(LesionBool, MahalDistMaps);
            FPMahal[1]=GetMin(MahalData, LesionBool, numel);
            FPMahal[2]=GetMax(MahalData, LesionBool, numel);
            FPMahal[0]=GetMeanData(MahalData, LesionBool, numel);
            SegMahal[0]=FPMahal[0];
            SegMahal[1]=FPMahal[1];
            SegMahal[2]=FPMahal[2];
            
            //                Proportion mahal array
            for (int i=1; i<11; i++) {
                LesionFPToPush->PropMahalSeg[i-1]=GetProportionUnder<float, bool>(MahalData, LesionBool, 0.5*i, numel);
                LesionFPToPush->PropMahalFP[i-1]=LesionFPToPush->PropMahalSeg[i-1];
            }
            
            
            if (FPQuantMahal!=NULL) {
                for (int i=0; i<3; i++) {
                    FPMahal[3+i]=FPQuantMahal[i];
                }
                delete [] FPQuantMahal;
                FPQuantMahal=NULL;
            }
            LesionFPToPush->Volume=LesionFPToPush->FPl;
            VectorLesionIntensity.push_back(LesionFPToPush);
            if (LesionBool!=NULL) {
                delete [] LesionBool;
                LesionBool=NULL;
            }
            if (LesionValid!=NULL) {
                delete [] LesionValid;
                LesionValid=NULL;
            }
        }
    }
    
    
    //    Create the global summaries corresponding to either ee global with OE or DEFP or DEFN
    LesionRefIntensity * OEGlobalLesion=new LesionRefIntensity();
    LesionRefIntensity * DEFPGlobalLesion=new LesionRefIntensity();
    LesionRefIntensity * DEFNGlobalLesion=new LesionRefIntensity();
    LesionRefIntensity * GlobalComplete=new LesionRefIntensity();
    
    
    //    Get the Ref and the Seg bool results for OE and Global
    OROperationBool(FPSegGlobal, TPSegGlobal, SegGlobal, numel);
    OROperationBool(FNSegGlobal, TPSegGlobal, RefGlobal, numel);
    cout<<"Non 0 in ref is "<<CountNonZero(RefGlobal, numel)<<endl;
    OROperationBool(OEFNSegGlobal, TPSegGlobal, OERefGlobal, numel);
    OROperationBool(OEFPSegGlobal, TPSegGlobal, OESegGlobal, numel);
    
    
    OEGlobalLesion->FlagTypeConnectedComponent=OE;
    DEFPGlobalLesion->FlagTypeConnectedComponent=DEFP;
    DEFNGlobalLesion->FlagTypeConnectedComponent=DEFN;
    float * OETP=OEGlobalLesion->TPMahal;
    float * OEFP=OEGlobalLesion->FPMahal;
    float * OEFN=OEGlobalLesion->FNMahal;
    float * OERef=OEGlobalLesion->RefMahal;
    float * OESeg=OEGlobalLesion->SegMahal;
    float * OEPropMahalRef=OEGlobalLesion->PropMahalRef;
    float * OEPropMahalSeg=OEGlobalLesion->PropMahalSeg;
    float * OEPropMahalTP=OEGlobalLesion->PropMahalTP;
    float * OEPropMahalFN=OEGlobalLesion->PropMahalFN;
    float * OEPropMahalFP=OEGlobalLesion->PropMahalFP;
    float * DEFP=DEFPGlobalLesion->FPMahal;
    float * DEFPPropMahal=DEFPGlobalLesion->PropMahalFP;
    float * DEFPPropMahalSeg=DEFPGlobalLesion->PropMahalSeg;
    float * DEFN=DEFNGlobalLesion->FNMahal;
    float * DEFNPropMahal=DEFNGlobalLesion->PropMahalFN;
    float * DEFNPropMahalRef=DEFNGlobalLesion->PropMahalRef;
    float * GlobalTP=GlobalComplete->TPMahal;
    float * GlobalFN=GlobalComplete->FNMahal;
    float * GlobalFP=GlobalComplete->FPMahal;
    float * GlobalRef=GlobalComplete->RefMahal;
    float * GlobalSeg=GlobalComplete->SegMahal;
    float * GlobalPropMahalRef=GlobalComplete->PropMahalRef;
    float * GlobalPropMahalSeg=GlobalComplete->PropMahalSeg;
    float * GlobalPropMahalTP=GlobalComplete->PropMahalTP;
    float * GlobalPropMahalFN=GlobalComplete->PropMahalFN;
    float * GlobalPropMahalFP=GlobalComplete->PropMahalFP;
    float * GlobalPropVent=GlobalComplete->ProportionCloseVentricle;
    float * DEFPPropVent=DEFPGlobalLesion->ProportionCloseVentricle;
    float * DEFNPropVent=DEFNGlobalLesion->ProportionCloseVentricle;
    float * OEPropVent=OEGlobalLesion->ProportionCloseVentricle;
    
    
    //    Fill proportion when need be
    //                Proportion mahal array
    for (int i=1; i<11; i++) {
        GlobalPropMahalRef[i-1]=GetProportionUnder<float, bool>(MahalData, RefGlobal, 0.5*i, numel);
        GlobalPropMahalSeg[i-1]=GetProportionUnder<float, bool>(MahalData, SegGlobal, 0.5*i, numel);
        GlobalPropMahalFN[i-1]=GetProportionUnder<float, bool>(MahalData, FNSegGlobal, 0.5*i, numel);
        GlobalPropMahalTP[i-1]=GetProportionUnder<float, bool>(MahalData, TPSegGlobal, 0.5*i, numel);
        GlobalPropMahalFP[i-1]=GetProportionUnder<float, bool>(MahalData, FPSegGlobal, 0.5*i, numel);
        OEPropMahalRef[i-1]=GetProportionUnder<float, bool>(MahalData, OERefGlobal, 0.5*i, numel);
        OEPropMahalSeg[i-1]=GetProportionUnder<float, bool>(MahalData, OESegGlobal, 0.5*i, numel);
        OEPropMahalFN[i-1]=GetProportionUnder<float, bool>(MahalData, OEFNSegGlobal, 0.5*i, numel);
        OEPropMahalTP[i-1]=GetProportionUnder<float, bool>(MahalData, TPSegGlobal, 0.5*i, numel);
        OEPropMahalFP[i-1]=GetProportionUnder<float, bool>(MahalData, OEFPSegGlobal, 0.5*i, numel);
        DEFNPropMahal[i-1]=GetProportionUnder<float, bool>(MahalData, DEFNSegGlobal, 0.5*i, numel);
        DEFNPropMahalRef[i-1]=DEFNPropMahal[i-1];
        DEFPPropMahal[i-1]=GetProportionUnder<float, bool>(MahalData, DEFPSegGlobal, 0.5*i, numel);
        DEFPPropMahalSeg[i-1]=DEFPPropMahal[i-1];
        
    }
    
    //    Get the non valid vs valid distinction
    XOROperationBool(TPSegGlobal, NonValidMask, TPSegValid, numel);
    XOROperationBool(FPSegGlobal, NonValidMask, FPSegValid, numel);
    XOROperationBool(FNSegGlobal, NonValidMask, FNSegValid, numel);
    XOROperationBool(OEFNSegGlobal, NonValidMask, OEFNSegValid, numel);
    XOROperationBool(OEFPSegGlobal, NonValidMask, OEFPSegValid, numel);
    XOROperationBool(DEFNSegGlobal, NonValidMask, DEFNSegValid, numel);
    XOROperationBool(DEFPSegGlobal, NonValidMask, DEFPSegValid, numel);
    
    
    float * OETPQuant=QuantiliseMask(TPSegGlobal, MahalDistMaps);
    float * OEFPQuant=QuantiliseMask(OEFPSegGlobal, MahalDistMaps);
    float * OEFNQuant=QuantiliseMask(OEFNSegGlobal, MahalDistMaps);
    float * DEFNQuant=QuantiliseMask(DEFNSegGlobal, MahalDistMaps);
    float * DEFPQuant=QuantiliseMask(DEFPSegGlobal, MahalDistMaps);
    float * FNQuant=QuantiliseMask(FNSegGlobal, MahalDistMaps);
    float * FPQuant=QuantiliseMask(FPSegGlobal, MahalDistMaps);
    float * RefQuant=QuantiliseMask(RefGlobal, MahalDistMaps);
    float * SegQuant=QuantiliseMask(SegGlobal, MahalDistMaps);
    float * OERefQuant=QuantiliseMask(OERefGlobal, MahalDistMaps);
    float * OESegQuant=QuantiliseMask(OESegGlobal, MahalDistMaps);
    
    //    Get min for all types of generic lesions
    OETP[1]=GetMin(MahalData, TPSegGlobal, numel);
    OEFP[1]=GetMin(MahalData, OEFPSegGlobal,numel);
    OEFN[1]=GetMin(MahalData, OEFNSegGlobal,numel);
    OERef[1]=GetMin(MahalData, OERefGlobal,numel);
    OESeg[1]=GetMin(MahalData, OESegGlobal,numel);
    DEFP[1]=GetMin(MahalData, DEFPSegGlobal, numel);
    DEFN[1]=GetMin(MahalData, DEFNSegGlobal,numel);
    GlobalTP[1]=GetMin(MahalData, TPSegGlobal ,numel);
    GlobalFN[1]=GetMin(MahalData, FNSegGlobal,numel);
    GlobalFP[1]=GetMin(MahalData, FPSegGlobal,numel);
    GlobalRef[1]=GetMin(MahalData, RefGlobal,numel);
    GlobalSeg[1]=GetMin(MahalData, SegGlobal,numel);
    
    //    Get max for all types of generic lesions
    OETP[2]=GetMax(MahalData, TPSegGlobal, numel);
    OEFP[2]=GetMax(MahalData, OEFPSegGlobal,numel);
    OEFN[2]=GetMax(MahalData, OEFNSegGlobal,numel);
    OERef[2]=GetMax(MahalData, OERefGlobal,numel);
    OESeg[2]=GetMax(MahalData, OESegGlobal,numel);
    DEFP[2]=GetMax(MahalData, DEFPSegGlobal, numel);
    DEFN[2]=GetMax(MahalData, DEFNSegGlobal,numel);
    GlobalTP[2]=GetMax(MahalData, TPSegGlobal ,numel);
    GlobalFN[2]=GetMax(MahalData, FNSegGlobal,numel);
    GlobalFP[2]=GetMax(MahalData, FPSegGlobal,numel);
    GlobalRef[2]=GetMax(MahalData, RefGlobal,numel);
    GlobalSeg[2]=GetMax(MahalData, SegGlobal,numel);
    
    //    Get mean for all types of generic lesions
    OETP[0]=GetMeanData(MahalData, TPSegGlobal, numel);
    OEFP[0]=GetMeanData(MahalData, OEFPSegGlobal,numel);
    OEFN[0]=GetMeanData(MahalData, OEFNSegGlobal,numel);
    OERef[0]=GetMeanData(MahalData, OERefGlobal,numel);
    OESeg[0]=GetMeanData(MahalData, OESegGlobal,numel);
    DEFP[0]=GetMeanData(MahalData, DEFPSegGlobal, numel);
    DEFN[0]=GetMeanData(MahalData, DEFNSegGlobal,numel);
    GlobalTP[0]=GetMeanData(MahalData, TPSegGlobal ,numel);
    GlobalFN[0]=GetMeanData(MahalData, FNSegGlobal,numel);
    GlobalFP[0]=GetMeanData(MahalData, FPSegGlobal,numel);
    GlobalRef[0]=GetMeanData(MahalData, RefGlobal,numel);
    GlobalSeg[0]=GetMeanData(MahalData, SegGlobal,numel);
    
    //    Get proportion close to ventricle
    DEFNPropVent[2]=GetProportionUnder<float, bool>(DistanceToVentData, DEFNSegGlobal, 5, numel);
    DEFNPropVent[3]=DEFNPropVent[2];
    DEFPPropVent[1]=GetProportionUnder<float, bool>(DistanceToVentData, DEFPSegGlobal, 5, numel);
    DEFPPropVent[4]=DEFPPropVent[1];
    OEPropVent[2]=GetProportionUnder<float, bool>(DistanceToVentData, OEFPSegGlobal, 5, numel);
    OEPropVent[1]=GetProportionUnder<float, bool>(DistanceToVentData, OEFNSegGlobal, 5, numel);
    OEPropVent[0]=GetProportionUnder<float, bool>(DistanceToVentData, TPSegGlobal, 5, numel);
    OEPropVent[3]=GetProportionUnder<float, bool>(DistanceToVentData, OERefGlobal, 5, numel);
    OEPropVent[4]=GetProportionUnder<float, bool>(DistanceToVentData, OESegGlobal, 5, numel);
    GlobalPropVent[2]=GetProportionUnder<float, bool>(DistanceToVentData, FNSegGlobal, 5, numel);
    GlobalPropVent[1]=GetProportionUnder<float, bool>(DistanceToVentData, FPSegGlobal, 5, numel);
    GlobalPropVent[0]=GetProportionUnder<float, bool>(DistanceToVentData, TPSegGlobal, 5, numel);
    GlobalPropVent[3]=GetProportionUnder<float, bool>(DistanceToVentData, RefGlobal, 5, numel);
    GlobalPropVent[4]=GetProportionUnder<float, bool>(DistanceToVentData, SegGlobal, 5, numel);
    
    
    //    Fill quantilisation for all types of generic lesions
    if (OETPQuant!=NULL) {
        for (int d=0; d<3; d++) {
            OETP[3+d]=OETPQuant[d];
        }
    }
    if (OEFNQuant!=NULL) {
        for (int d=0; d<3; d++) {
            OEFN[3+d]=OEFNQuant[d];
        }
        delete [] OEFNQuant;
        OEFNQuant=NULL;
    }
    if (OEFPQuant!=NULL) {
        for (int d=0; d<3; d++) {
            OEFP[3+d]=OEFPQuant[d];
        }
        delete [] OEFPQuant;
        OEFPQuant=NULL;
    }
    if (DEFNQuant!=NULL) {
        for (int d=0; d<3; d++) {
            DEFN[3+d]=DEFNQuant[d];
        }
        delete [] DEFNQuant;
        DEFNQuant=NULL;
    }
    if (DEFPQuant!=NULL) {
        for (int d=0; d<3; d++) {
            DEFP[3+d]=DEFPQuant[d];
        }
        delete [] DEFPQuant;
        DEFPQuant=NULL;
    }
    if (FPQuant!=NULL) {
        for (int d=0; d<3; d++) {
            GlobalFP[3+d]=FPQuant[d];
        }
        delete [] FPQuant;
        FPQuant=NULL;
    }
    if (FNQuant!=NULL) {
        for (int d=0; d<3; d++) {
            GlobalFN[3+d]=FNQuant[d];
        }
        delete [] FNQuant;
        FNQuant=NULL;
    }
    if (OETPQuant!=NULL) {
        for (int d=0; d<3; d++) {
            GlobalTP[3+d]=OETPQuant[d];
        }
        delete [] OETPQuant;
        OETPQuant=NULL;
    }
    if (OERefQuant!=NULL) {
        for (int d=0; d<3; d++) {
            OERef[3+d]=OERefQuant[d];
        }
        delete [] OERefQuant;
        OERefQuant=NULL;
    }
    if (OESegQuant!=NULL) {
        for (int d=0; d<3; d++) {
            OESeg[3+d]=OESegQuant[d];
        }
        delete [] OESegQuant;
        OESegQuant=NULL;
    }
    if (SegQuant!=NULL) {
        for (int d=0; d<3; d++) {
            GlobalSeg[3+d]=SegQuant[d];
        }
        delete [] SegQuant;
        SegQuant=NULL;
    }
    if (RefQuant!=NULL) {
        for (int d=0; d<3; d++) {
            GlobalRef[3+d]=RefQuant[d];
        }
        delete [] RefQuant;
        RefQuant=NULL;
    }
    
    
    
    //    Fill volumes for all types of generic lesions
    OEGlobalLesion->TPl=CountNonZero(TPSegGlobal, numel);
    OEGlobalLesion->FPl=CountNonZero(OEFPSegGlobal, numel);
    OEGlobalLesion->FNl=CountNonZero(OEFNSegGlobal, numel);
    OEGlobalLesion->Refl=OEGlobalLesion->TPl+OEGlobalLesion->FNl;
    OEGlobalLesion->Segl=OEGlobalLesion->TPl+OEGlobalLesion->FPl;
    DEFNGlobalLesion->FNl=CountNonZero(DEFNSegGlobal, numel);
    DEFPGlobalLesion->FPl=CountNonZero(DEFPSegGlobal, numel);
    GlobalComplete->TPl=CountNonZero(TPSegGlobal, numel);
    GlobalComplete->FPl=CountNonZero(FPSegGlobal, numel);
    GlobalComplete->FNl=CountNonZero(FNSegGlobal, numel);
    GlobalComplete->Refl=GlobalComplete->TPl+GlobalComplete->FNl;
    GlobalComplete->Segl=GlobalComplete->TPl+GlobalComplete->FPl;
    
    //    Fill volumes of non agreement for all types of generic lesions
    OEGlobalLesion->TPNotAgree=OEGlobalLesion->TPl-CountNonZero(TPSegValid, numel);
    OEGlobalLesion->FPNotAgree=OEGlobalLesion->FPl-CountNonZero(OEFPSegValid, numel);
    OEGlobalLesion->FNNotAgree=OEGlobalLesion->FNl-CountNonZero(OEFNSegValid, numel);
    OEGlobalLesion->RefNotAgree=OEGlobalLesion->FNNotAgree+OEGlobalLesion->TPNotAgree;
    OEGlobalLesion->SegNotAgree=OEGlobalLesion->FPNotAgree+OEGlobalLesion->TPNotAgree;
    DEFNGlobalLesion->FNNotAgree=DEFNGlobalLesion->FNl-CountNonZero(DEFNSegValid, numel);
    DEFPGlobalLesion->FPNotAgree=DEFPGlobalLesion->FPl-CountNonZero(DEFPSegValid, numel);
    GlobalComplete->TPNotAgree=OEGlobalLesion->TPNotAgree;
    GlobalComplete->FPNotAgree=GlobalComplete->FPl-CountNonZero(FPSegValid, numel);
    GlobalComplete->FNNotAgree=GlobalComplete->FNl-CountNonZero(FNSegValid, numel);
    GlobalComplete->SegNotAgree=GlobalComplete->TPNotAgree+GlobalComplete->FPNotAgree;
    GlobalComplete->RefNotAgree=GlobalComplete->TPNotAgree+GlobalComplete->FNNotAgree;
    GlobalComplete->DSC=2.0*GlobalComplete->TPl/(2.0*GlobalComplete->TPl+GlobalComplete->FNl + GlobalComplete->FPl);
    
    delete [] FNSegGlobal;
    FNSegGlobal=NULL;
    delete [] FPSegGlobal;
    FPSegGlobal=NULL;
    delete [] TPSegGlobal;
    TPSegGlobal=NULL;
    delete [] DEFPSegGlobal;
    DEFPSegGlobal=NULL;
    delete [] DEFNSegGlobal;
    DEFNSegGlobal=NULL;
    delete [] OEFNSegGlobal;
    OEFNSegGlobal=NULL;
    delete [] OEFPSegGlobal;
    OEFPSegGlobal=NULL;
    delete [] FNSegValid;
    FNSegValid=NULL;
    delete [] FPSegValid;
    FPSegValid=NULL;
    delete [] TPSegValid;
    TPSegValid=NULL;
    delete [] DEFPSegValid;
    DEFPSegValid=NULL;
    delete [] DEFNSegValid;
    DEFNSegValid=NULL;
    delete [] OEFPSegValid;
    OEFPSegValid=NULL;
    delete [] OEFNSegValid;
    OEFNSegValid=NULL;
    delete [] OERefGlobal;
    OERefGlobal=NULL;
    delete [] OESegGlobal;
    OESegGlobal=NULL;
    delete [] RefGlobal;
    RefGlobal=NULL;
    delete [] SegGlobal;
    SegGlobal=NULL;
    
    
    
    VectorLesionIntensity.push_back(DEFPGlobalLesion);
    VectorLesionIntensity.push_back(DEFNGlobalLesion);
    VectorLesionIntensity.push_back(OEGlobalLesion);
    VectorLesionIntensity.push_back(GlobalComplete);
    
    //    Clearing before returning
    if (WorkingCopyLabelRef!=NULL) {
        delete [] WorkingCopyLabelRef;
        WorkingCopyLabelRef=NULL;
    }
    if (CheckedLabelSeg!=NULL) {
        delete [] CheckedLabelSeg;
        CheckedLabelSeg=NULL;
    }
    
    return VectorLesionIntensity;
}







// Returns in an int array for each lesion in the connected reference, the volume of the lesion, the volume of the segmented counterpart, the amount of TP, the amount of FN, the number of associated FP, the number of associated lesions.
int * AnalysisPerRefConnected(int * LabelSeg, int * LabelRef, int numel){
    //    Initialisation of the results of comparison analysis per ref lesion label
    int maxLabelRef=GetMaxLabel(LabelRef, numel);
    int maxLabelSeg=GetMaxLabel(LabelSeg, numel);
    int * ResultAnalysis=new int[6*maxLabelRef];
    int SizeResult=6*maxLabelRef;
    for (int i=0; i<SizeResult; i++) {
        ResultAnalysis[i]=0;
    }
    // For each label gives the list of labels in ref that are merged in Seg
    vector< vector<int> > MergedLabels;
    for (int ls=0; ls<maxLabelSeg; ls++) {
        MergedLabels.push_back(GetListCorrespondingLabels(ls+1, LabelRef, LabelSeg, numel));
    }
    int * WorkingCopyLabelRef=CopyArray(LabelRef, numel);
    for (int ls=0; ls<maxLabelSeg; ls++) {
        if (MergedLabels[ls].size()>1) {
            cout<<"Have to merge labels "<<MergedLabels[ls][0]<<" and ";
            int numbMerged=MergedLabels[ls].size();
            for (int lm=1; lm<numbMerged; lm++) {
                cout<<MergedLabels[ls][lm]<<" ";
                for (int i=0; i<numel; i++) {
                    if (WorkingCopyLabelRef[i]==MergedLabels[ls][lm]) {
                        WorkingCopyLabelRef[i]=MergedLabels[ls][0];
                    }
                }
            }
            cout<<endl;
        }
    }
    //    Analysis for each lesion
    for (int lr=0; lr<maxLabelRef; lr++) {
        int LabelSize=GetLabelSize(lr+1, LabelRef, numel);
        int LabelSizeWorking=GetLabelSize(lr+1, WorkingCopyLabelRef, numel);
        //        cout<<"LabelSize "<<LabelSize<<" and LabelWorking "<<LabelSizeWorking<<endl;
        vector<int> CorrespondingLabels=GetListCorrespondingLabels(lr+1,LabelSeg,LabelRef,numel);
        int numbCorrespondingLabels=CorrespondingLabels.size();
        int VolumeSeg=0;
        int TP=0;
        int FP=0;
        int FN=0;
        if (LabelSizeWorking>0) {
            for (int ls=0; ls<numbCorrespondingLabels; ls++) {
                for (int i=0; i<numel; i++) {
                    if (LabelSeg[i]==CorrespondingLabels[ls]) {
                        VolumeSeg++;
                        if (WorkingCopyLabelRef[i]==lr+1) {
                            TP++;
                        }
                        else if(WorkingCopyLabelRef[i]==0){ // So that we do not have problems when separated ref connected regions are merged in the segmentation analysed
                            FP++;
                        }
                    }
                }
            }
        }
        
        FN=LabelSizeWorking-TP;
        //        Filling result final with obtained results:
        //        Volume of reference lesion
        ResultAnalysis[6*lr]=LabelSize;
        //        Volume of segmented counterpart
        ResultAnalysis[6*lr+1]=VolumeSeg;
        //        Number of TP
        ResultAnalysis[6*lr+2]=TP;
        //        Number of FP
        ResultAnalysis[6*lr+3]=FP;
        //        Number of FN
        ResultAnalysis[6*lr+4]=FN;
        //        Number of counterparts lesions
        ResultAnalysis[6*lr+5]=LabelSizeWorking;
    }
    return ResultAnalysis;
}



vector<int>GetListCorrespondingLabels(int Label,int * LabelSeg,int * LabelRef,int numel){
    set<int> SetLabels;
    std::set<int>::iterator FL;
    for (int i=0; i<numel; i++) {
        if (LabelRef[i]==Label) {
            if (LabelSeg[i]>0) {
                SetLabels.insert(LabelSeg[i]);
            }
        }
    }
    vector<int> VectorLabels;
    int numbLabels=SetLabels.size();
    //    cout<<"Corresponding to label "<<Label<<" are ";
    for (int n=0; n<numbLabels; n++) {
        FL=SetLabels.begin();
        //        cout<<*FL<<" ";
        VectorLabels.push_back(*FL);
        SetLabels.erase(FL);
    }
    //    cout<<endl;
    return VectorLabels;
}


//Returns the detection error as defined in Wack 2012
int DetectionError(int * LabelSeg, int * LabelRef, int numel){
    int ResultDE=0;
    //    Find the preliminary results : classification of label and volume for each label
    ResultType * ResultTypeSeg=ClassifLabel(LabelSeg, LabelRef, numel);
    ResultType * ResultTypeRef=ClassifLabel(LabelRef, LabelSeg, numel);
    int maxLabelSeg=GetMaxLabel(LabelSeg, numel);
    int maxLabelRef=GetMaxLabel(LabelRef, numel);
    int * VolumeSeg=GetVolumeLabels(LabelSeg, numel);
    int * VolumeRef=GetVolumeLabels(LabelRef, numel);
    //    Separately add the volume corresponding to each erroneous label
    for (int ls=0 ; ls<maxLabelSeg; ls++) {
        if (ResultTypeSeg[ls]==FP) {
            ResultDE+=VolumeSeg[ls];
        }
    }
    for (int lr=0; lr<maxLabelRef; lr++) {
        if (ResultTypeRef[lr]==FP) {
            ResultDE+=VolumeRef[lr];
        }
    }
    //    Clearing memory before returning the result
    delete [] VolumeRef;
    delete [] VolumeSeg;
    delete [] ResultTypeRef;
    delete [] ResultTypeSeg;
    VolumeSeg=NULL;
    VolumeRef=NULL;
    ResultTypeSeg=NULL;
    ResultTypeRef=NULL;
    
    return ResultDE;
}

//Returns the detection error as defined in Wack 2012 but restricted to FP
int DetectionErrorFP(int * LabelSeg, int * LabelRef, int numel){
    int ResultDE=0;
    //    Find the preliminary results : classification of label and volume for each label
    ResultType * ResultTypeSeg=ClassifLabel(LabelSeg, LabelRef, numel);
    int maxLabelSeg=GetMaxLabel(LabelSeg, numel);
    int * VolumeSeg=GetVolumeLabels(LabelSeg, numel);

    for (int ls=0 ; ls<maxLabelSeg; ls++) {
        if (ResultTypeSeg[ls]==FP) {
            ResultDE+=VolumeSeg[ls];
        }
    }

    //    Clearing memory before returning the result
    delete [] VolumeSeg;
    delete [] ResultTypeSeg;
    VolumeSeg=NULL;
    ResultTypeSeg=NULL;
    
    return ResultDE;
}

//Returns the detection error as defined in Wack 2012 but restricted to FN
int DetectionErrorFN(int * LabelSeg, int * LabelRef, int numel){
    int ResultDE=0;
    //    Find the preliminary results : classification of label and volume for each label

    ResultType * ResultTypeRef=ClassifLabel(LabelRef, LabelSeg, numel);

    int maxLabelRef=GetMaxLabel(LabelRef, numel);

    int * VolumeRef=GetVolumeLabels(LabelRef, numel);
    //    Separately add the volume corresponding to each erroneous label
    for (int lr=0; lr<maxLabelRef; lr++) {
        if (ResultTypeRef[lr]==FP) {
            ResultDE+=VolumeRef[lr];
        }
    }
    //    Clearing memory before returning the result
    delete [] VolumeRef;

    delete [] ResultTypeRef;
    VolumeRef=NULL;
    ResultTypeRef=NULL;
    
    return ResultDE;
}


// Return the float value for the probabilities in order to get the exact volume of lesion needed
float GetThresholdForVolume(float * BlurredLesion, bool* MaskData, int  NumberNeeded,int numel){
    float * CopyArray=MultiplyElementwiseChoose<float, bool, float>(BlurredLesion, MaskData, numel);
    HeapSort(CopyArray, numel-1);

    float ThresholdVolume=CopyArray[numel-NumberNeeded-1];
    delete [] CopyArray;
    CopyArray=NULL;
    return ThresholdVolume;
}

nifti_image * ReductionLesion(nifti_image * LesNii, nifti_image * MaskNii, float Threshold, int NumberOut){
    float * LesData=static_cast<float*>(LesNii->data);
    bool * MaskData=static_cast<bool*>(MaskNii->data);
    int numel=LesNii->nvox;
    int numelAbove=GetCountAbove(LesData, MaskData, Threshold, numel);
    float * ArrayForHist=new float[numelAbove];
    int j=0;
    for (int i=0; i<numel; i++) {
        if (LesData[i]>Threshold && MaskData[i]>0) {
            ArrayForHist[j]=LesData[i];
            j++;
        }
    }
    cout <<"NumberOut is "<<NumberOut<< " j is "<<j <<" and numelAbove is "<<numelAbove<<endl;
    float ValueX;
    HeapSort(ArrayForHist, numelAbove-1);
    if (NumberOut>numelAbove-1) {
        ValueX=1;
    }
    else{
        ValueX=ArrayForHist[NumberOut];
    }

    float ValueP=2*ValueX-1;
    //            Now creating new Les Data
    float * NewLesData=new float[numel];
    for(int i=0;i<numel;i++){
        NewLesData[i]=LesData[i]>ValueP?(LesData[i]-ValueP)/(1.0-ValueP):0;
    }
    nifti_image * ResultImage=CreateNiiFromArray(NewLesData, LesNii, numel);
    delete [] NewLesData;
    delete [] ArrayForHist;
    NewLesData=NULL;
    ArrayForHist=NULL;
    return ResultImage;
}

nifti_image * ReductionLesionVector(nifti_image * LesNii, nifti_image * MaskNii, vector<float> vecLesionReduction){
    float * LesData=static_cast<float*>(LesNii->data);
    bool * MaskData=static_cast<bool*>(MaskNii->data);
    int numel=LesNii->nvox;
    float threshold=vecLesionReduction[0];
    int numelAbove=GetCountAbove(LesData, MaskData, threshold, numel);
    float * ArrayForHist=new float[numelAbove];
    int j=0;
    for (int i=0; i<numel; i++) {
        if (LesData[i]>threshold && MaskData[i]>0) {
            ArrayForHist[j]=LesData[i];
            j++;
        }
    }
    HeapSort(ArrayForHist, numelAbove-1);
    int numbStep=(int)numelAbove/(int)vecLesionReduction[1];
    int sizeStep=vecLesionReduction[1];
    float * ResultThreshold=new float[numbStep+1];
    for (int i=0; i<=numbStep; i++) {
        ResultThreshold[i]=ArrayForHist[i*sizeStep];
    }
    float ValueX;
    int numbChange=vecLesionReduction[2];
    if (numbStep>numbChange) {
        ValueX=ResultThreshold[numbChange];
    }
    else {
        ValueX=ResultThreshold[numbStep/2];
    }
    float ValueP=2*ValueX-1;
    //            Now creating new Les Data
    float * NewLesData=new float[numel];
    for(int i=0;i<numel;i++){
        NewLesData[i]=LesData[i]>ValueP?(LesData[i]-ValueP)/(1.0-ValueP):0;
    }
    nifti_image * ResultImage=CreateNiiFromArray(NewLesData, LesNii, numel);
    delete [] NewLesData;
    delete [] ResultThreshold;
    delete [] ArrayForHist;
    NewLesData=NULL;
    ArrayForHist=NULL;
    ResultThreshold=NULL;
    return ResultImage;
}


float * VolumeRange(nifti_image * RefNii,vector<float> ThreshVec,nifti_image *MaskNii){
    if (ThreshVec.size()<3 || RefNii==NULL || MaskNii==NULL) {
        return NULL;
    }
    bool * MaskData=static_cast<bool*>(MaskNii->data);
    float * RefData=static_cast<float*>(RefNii->data);
    int numel=RefNii->nx*RefNii->ny*RefNii->nz;
    float step=fabs(ThreshVec[1]-ThreshVec[0])/ThreshVec[2];
    int sizeResults=(int)ThreshVec[2]+1;
    float * Result=new float[(int)ThreshVec[2]+1];
    for (int s=0; s<sizeResults; s++) {
        Result[s]=GetCountAbove(RefData, MaskData, ThreshVec[0]+s*step, numel);
    }
    return Result;
}


// Create the evaluation report based on the raw nifti images and the mask
EvaluationReport * CreateEvaluationReport(nifti_image * LesNii, nifti_image * RefNii, nifti_image * MaskNii){
    EvaluationReport * Result=new EvaluationReport();
    int numel=LesNii->nx*LesNii->ny*LesNii->nz;
//    We assume without checking that the images have compatible dimensions.
    bool * MaskData=static_cast<bool*>(MaskNii->data);
    int numelm=0;
    int Dim[3];
    Dim[0]=LesNii->nx;
    Dim[1]=LesNii->ny;
    Dim[2]=LesNii->nz;
    int * L2S=MakeL2S(MaskData, Dim);
    int * S2L=MakeS2L(MaskData, Dim, numelm);
    int numelmasked=CountNonZero(MaskData, numel);
    float * LesData=static_cast<float *>(LesNii->data);
    float * RefData=static_cast<float*>(RefNii->data);
    bool * RefBool=ThresholdArray<float, bool>(RefData, 0.5, numel);
    bool * LesBool=ThresholdArray<float, bool>(LesData, 0.5, numel);
    bool * RefBoolShort=CreateShort(RefBool, S2L, numelmasked);
    bool * LesBoolShort=CreateShort(LesBool, S2L, numelmasked);
    int * RefLabel=ComponentLabeling(RefNii, 6);
    int * LesLabel=ComponentLabeling(LesNii, 6);
//    Creation of the relevant metrics
    Result->TP=TruePositives_bis(LesBoolShort, RefBoolShort, numelmasked);
    Result->FN=FalseNegatives_bis(LesBoolShort, RefBoolShort, numelmasked);
    Result->FP=FalsePositives_bis(LesBoolShort, RefBoolShort, numelmasked);
    Result->TPR=TPR(LesBoolShort, RefBoolShort, numelmasked);
    Result->FPR=FPR(LesBoolShort, RefBoolShort, numelmasked);
//    Result->FNR=FNR(LesBool, RefBool, numelmasked);
    Result->AvDist=AverageDistanceMetric(LesBool, RefBool, LesNii);
    Result->DSC=DSC(LesBoolShort, RefBoolShort, numelmasked);
    Result->DE=DetectionError(LesLabel, RefLabel, numel);
    Result->DEFP=DetectionErrorFP(LesLabel, RefLabel, numel);
    Result->DEFN=DetectionErrorFN(LesLabel, RefLabel, numel);
    int OETot=OutlineError(LesLabel, RefLabel, numel);
    Result->OER=1.0*OETot/CountNonZero(RefBool, numel);
    Result->OEFP=Result->FP-Result->DEFP;
    Result->OEFN=Result->FN-Result->DEFN;
    Result->VD=VD(LesBoolShort, RefBoolShort, numelmasked);
    cout <<"Number labels is for les and ref "<<GetMaxLabel(LesLabel, numel)<<" "<<GetMaxLabel(RefLabel, numel)<<endl;
    vector<float > ResultRate=RateVector_card(LesLabel, RefLabel, numel);
    Result->TPR_card=ResultRate[0];
    Result->FPR_card=ResultRate[1];
    Result->FNR_card=ResultRate[2];
    Result->VolumeRef=CountNonZero(RefBoolShort, numelmasked);
    Result->VolumeSeg=CountNonZero(LesBoolShort, numelmasked);
    Result->LabelRef=GetMaxLabel(RefLabel, numel);
    Result->LabelSeg=GetMaxLabel(LesLabel, numel);
    delete [] L2S;
    delete [] S2L;
    delete [] LesLabel;
    delete [] RefLabel;
    delete [] LesBoolShort;
    delete [] RefBoolShort;
    delete [] LesBool;
    delete [] RefBool;
    
    return Result;
}

float DSC(bool * BoolSeg, bool * BoolRef, int numelmasked){
    float TP=TruePositives_bis(BoolSeg, BoolRef, numelmasked);
    float FN=FalseNegatives_bis(BoolSeg, BoolRef, numelmasked);
    float FP=FalsePositives_bis(BoolSeg, BoolRef, numelmasked);
    float DSC=2.0*TP/(FP+FN+2.0*TP);
    return DSC;
}

// Returns the outline error as a number of voxels as defined in Wack 2012
int OutlineError(int * LabelSeg, int * LabelRef, int numel){
    int Union=0;
    int Intersection=0;
    //    int maxLabelSeg=GetMaxLabel(LabelSeg, numel);
    //    int maxLabelRef=GetMaxLabel(LabelRef, numel);
    ResultType * ResultTypeSeg=ClassifLabel(LabelSeg, LabelRef, numel);
    ResultType * ResultTypeRef=ClassifLabel(LabelRef, LabelSeg, numel);
    for (int i=0; i<numel; i++) {
        if(LabelSeg[i]>0||LabelRef[i]>0){
            int ls=LabelSeg[i];
            int lr=LabelRef[i];
            ResultType TypeSeg=ls>0?ResultTypeSeg[ls-1]:TN;
            ResultType TypeRef=lr>0?ResultTypeRef[lr-1]:TN;
            if (TypeRef==TP||TypeSeg==TP) {
                if (TypeSeg!=TN || TypeRef !=TN) {
                    Union++;
                }
                if (TypeSeg ==TP && TypeRef==TP) {
                    Intersection++;
                }
            }
        }
    }
    
    //    Clearing before returning
    delete [] ResultTypeRef;
    delete [] ResultTypeSeg;
    ResultTypeSeg=NULL;
    ResultTypeRef=NULL;
    return Union-Intersection;
}

//Returns the number of lesions that do not overlap with any of the lesions defined in the reference - Using connected component and cardinality (cf definition in paper)
int FalsePositives_card(int * LabelsSeg, int * LabelsRef, int numel){
    int CountFP=0;
    int maxLabelSeg=GetMaxLabel(LabelsSeg, numel);
    //    int maxLabelRef=GetMaxLabel(LabelsRef, numel);
    for (int l=1; l<=maxLabelSeg; l++) {
        bool flag_fp=1;
        for (int i=0; i<numel; i++) {
            if (LabelsSeg[i]==l) {
                if (LabelsRef[i]>0) {
                    flag_fp=0;
                    break;
                }
            }
        }
        CountFP+=(int)flag_fp;
    }
    return CountFP;
}

//Returns the number of lesions that do not overlap with any of the lesions defined in the reference - Using connected component and cardinality (cf definition in paper)
int TruePositives_card(int * LabelsSeg, int * LabelsRef, int numel){
    int CountTP=0;
    //    int maxLabelSeg=GetMaxLabel(LabelsSeg, numel);
    int maxLabelRef=GetMaxLabel(LabelsRef, numel);
    for (int l=1; l<=maxLabelRef; l++) {
        bool flag_tp=0;
        for (int i=0; i<numel; i++) {
            if (LabelsRef[i]==l) {
                if (LabelsSeg[i]>0) {
                    flag_tp=1;
                    break;
                }
            }
        }
        CountTP+=(int)flag_tp;
    }
    return CountTP;
}

//Returns the true positive rate in cardinality by dividing the number of lesions in the segmentation that have a correspondance in the reference by the number of lesions in the segmentation as well as the false positive rate and the false negative rate
vector<float> RateVector_card(int * LabelsSeg, int * LabelsRef, int numel){
    vector<float> ResultsRate;
    int numbSegLabel=GetMaxLabel(LabelsSeg, numel);
    int numbRefLabel=GetMaxLabel(LabelsRef, numel);
    int * CountOverlapSeg=new int[numbSegLabel];
    int * CountOverlapRef=new int[numbRefLabel];
    for(int l=0;l<numbSegLabel;l++){
        CountOverlapSeg[l]=0;
    }
    for(int l=0;l<numbRefLabel;l++){
        CountOverlapRef[l]=0;
    }
    for(int i=0;i<numel;i++){
        if(LabelsSeg[i]>0&&LabelsRef[i]>0){
            CountOverlapSeg[LabelsSeg[i]-1]++;
            CountOverlapRef[LabelsRef[i]-1]++;
        }
    }
    float TPR=numbSegLabel>0?float(CountNonZero(CountOverlapSeg, numbSegLabel))/numbSegLabel:0;
    float FPR=numbSegLabel>0?1.0*(numbSegLabel-CountNonZero(CountOverlapSeg, numbSegLabel))/numbSegLabel:0;
    float FNR=numbRefLabel>0?1.0*(numbRefLabel-CountNonZero(CountOverlapRef, numbRefLabel))/numbRefLabel:0;
    ResultsRate.push_back(TPR);
    ResultsRate.push_back(FPR);
    ResultsRate.push_back(FNR);
    return ResultsRate;
}

//Returns the false positive rate in cardinality by dividing the number of lesions that do not overlap with lesions in the reference by the number of lesions in the reference
float FPR_card(int * LabelsSeg, int * LabelsRef, int numel){
    //    NOT DONE FOR THE MOMENT
    return 0;
}

// Returns the number of false positives, given two binary segmentation stored in binary arrays of size numelmasked with HardClass2 as the reference
int FalsePositives_bis(bool * HardClass1, bool * HardClass2, int numelmasked ){
    if (HardClass1==NULL || HardClass2==NULL) {
        return -1;
    }
    bool * HardClass1_PTR=HardClass1;
    bool * HardClass2_PTR=HardClass2;
    int FP=0;
    for (int i=0; i<numelmasked; i++, HardClass1_PTR++, HardClass2_PTR++) {
        if (*HardClass1_PTR && !*HardClass2_PTR) {
            FP++;
        }
    }
    return FP;
}

float * FalsePositives(nifti_image * SoftSegmentation1, nifti_image * SoftSegmentation2){
    nifti_image * HardSegmentation1=HardSegmentation(SoftSegmentation1);
    int numbclasses1=SoftSegmentation1->nt*SoftSegmentation2->nu;
    nifti_image * HardSegmentation2=HardSegmentation(SoftSegmentation2);
    int numbclasses2=SoftSegmentation2->nt*SoftSegmentation2->nu;
    bool CompDim=(SoftSegmentation1->nx==SoftSegmentation2->nx)*(SoftSegmentation1->ny==SoftSegmentation2->ny)*(SoftSegmentation1->nz==SoftSegmentation2->nz);
    if(numbclasses1!=numbclasses2 || !CompDim){
        cout<<"Incompatible comparisons"<<endl;
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        return NULL;
    }
    else{
        float * FP=new float[numbclasses1+1];
        //        float CountNorm[numbclasses1+1];
        float * CountNorm = new float[numbclasses1+1];
        for(int c=0;c<=numbclasses1;c++){
            FP[c]=0;
            CountNorm[c]=0;
        }
        int numel=HardSegmentation1->nvox;
        float * HardSeg1_PTR=static_cast<float*>(HardSegmentation1->data);
        float * HardSeg2_PTR=static_cast<float*>(HardSegmentation2->data);
        for(int i=0;i<numel;i++,HardSeg1_PTR++,HardSeg2_PTR++){
            if((int)*HardSeg1_PTR!= (int)*HardSeg2_PTR && *HardSeg1_PTR>=0 ){
                FP[(int)*HardSeg1_PTR]++;
            }
            if((int)*HardSeg2_PTR>=0){
                CountNorm[(int)*HardSeg2_PTR]++;
            }
        }
        for(int c=0;c<numbclasses1;c++){
            FP[numbclasses1]+=FP[c];
            CountNorm[numbclasses1]+=CountNorm[c];
        }
        for(int c=0;c<=numbclasses1;c++){
            FP[c]/=CountNorm[c];
        }
        nifti_image_free(HardSegmentation1);
        HardSegmentation1=NULL;
        nifti_image_free(HardSegmentation2);
        HardSegmentation2=NULL;
        if(CountNorm!=NULL){
            delete [] CountNorm;
            CountNorm=NULL;
        }
        return FP;
    }
}

// Returns the number of active voxels given a soft segmentation image containing all classes. Equivalent to determining the numelmasked without the binary mask
int NumbActiveVoxels(nifti_image * SoftSegmentation){
    int numbActiveVoxels=0;
    if(SoftSegmentation==NULL){
        return 0;
    }
    int numel=SoftSegmentation->nx*SoftSegmentation->ny*SoftSegmentation->nz;
    int numbclasses=SoftSegmentation->nt*SoftSegmentation->nu;
    float * SoftSegmentationData=static_cast<float*>(SoftSegmentation->data);
    //    float * SoftSegmentationData_PTR=SoftSegmentationData;
    for(int i=0;i<numel;i++){
        float sumProba=0;
        for(int c=0;c<numbclasses;c++){
            sumProba+=SoftSegmentationData[c*numel+i];
        }
        if(sumProba>=1E-6){
            numbActiveVoxels++;
        }
    }
    return numbActiveVoxels;
}

// Returns the number of active voxels under Mask given the mask.
int NumbActiveVoxels_bis(nifti_image * Mask){
    int numbActiveVoxels=0;
    if (Mask==NULL) {
        return 0;
    }
    int numel=Mask->nvox;
    Mask=Binarisation(Mask);
    bool * Mask_PTR=static_cast<bool*>(Mask->data);
    for (int i=0; i<numel; i++, Mask_PTR++) {
        if (*Mask_PTR) {
            numbActiveVoxels++;
        }
    }
    return numbActiveVoxels;
}

// Returns the Hard Dice scores (using binary) for each tissue considered in the segmentation given two soft segmentations results and using the second image as reference
float * HardDiceScores(nifti_image* SoftSegmentation1, nifti_image* SoftSegmentation2){
    bool testSeg1=IsResultSegmentation(SoftSegmentation1);
    int numel1=SoftSegmentation1->nx*SoftSegmentation1->ny*SoftSegmentation1->nz;
    int numbclasses1=SoftSegmentation1->nu*SoftSegmentation1->nt;
    bool testSeg2=IsResultSegmentation(SoftSegmentation2);
    if(!testSeg2){
        MakeSoftSegmentation(SoftSegmentation2);
        testSeg2=IsResultSegmentation(SoftSegmentation2);
    }
    if(!testSeg1){
        MakeSoftSegmentation(SoftSegmentation1);
        testSeg1=IsResultSegmentation(SoftSegmentation1);
    }
    int numel2=SoftSegmentation2->nx*SoftSegmentation2->ny*SoftSegmentation2->nz;
    int numbclasses2=SoftSegmentation2->nu*SoftSegmentation2->nt;
    if(!testSeg1 || !testSeg2 || numbclasses2!=numbclasses1 || numel1!=numel2 ){
        cout<<"Incompatibility somewhere"<<endl;
        return NULL;
    }
    else{
        float * Data1=static_cast<float *>(SoftSegmentation1->data);
        float * Data2=static_cast<float *>(SoftSegmentation2->data);
        int numelnonmasked1=0;
        int numelnonmasked2=0;
        //        int Seg1[numbclasses1];
        //        int Seg2[numbclasses2];
        int*Seg1=new int[numbclasses1];
        int*Seg2=new int[numbclasses2];
        //        int Inter[numbclasses1];
        int * Inter=new int[numbclasses1];
        for(int c=0;c<numbclasses1;c++){
            Seg1[c]=0;
            Seg2[c]=0;
            Inter[c]=0;
        }
        for(int i=0;i<numel1;i++){
            float maxValue1=0;
            int maxClass1=-1;
            float maxValue2=0;
            int maxClass2=-1;
            for(int c=0;c<numbclasses1;c++){
                if(Data1[c*numel1+i]>maxValue1){
                    maxValue1=Data1[c*numel1+i];
                    maxClass1=c;
                }
                if(Data2[c*numel2+i]>maxValue2){
                    maxValue2=Data2[c*numel2+i];
                    maxClass2=c;
                }
            }
            if(maxValue1<=1E-6){
                maxClass1=-1;
                numelnonmasked1++;
            }
            if(maxValue2<=1E-6){
                maxClass2=-1;
                numelnonmasked2++;
            }
            if(maxClass1>=0){
                Seg1[maxClass1]++;
            }
            if(maxClass2>=0){
                Seg2[maxClass2]++;
            }
            if(maxClass1==maxClass2 && maxClass1>=0){
                Inter[maxClass1]++;
            }
        }
        float * HardDiceScore=new float[numbclasses1+1];
        int sumInter=0;
        int sumTotMasked=0;
        for(int c=0;c<numbclasses1;c++){
            HardDiceScore[c]=2.0*(float)Inter[c]/((float)Seg1[c]+(float)Seg2[c]);
            sumInter+=Inter[c];
            sumTotMasked+=Seg1[c];
        }
        if(Seg1!=NULL){
            delete [] Seg1;
            Seg1=NULL;
        }
        if(Seg2!=NULL){
            delete [] Seg2;
            Seg2=NULL;
        }
        if(Inter!=NULL){
            delete[] Inter;
            Inter=NULL;
        }
        HardDiceScore[numbclasses1]=(float)sumInter/(float)sumTotMasked;
        return HardDiceScore;
    }
}

// Same as before but using the probability maps instead of the binary results. SoftSegmentation2 is again the reference image
float * SoftDiceScores(nifti_image* SoftSegmentation1, nifti_image* SoftSegmentation2){
    bool testSeg1=IsResultSegmentation(SoftSegmentation1);
    int numel1=SoftSegmentation1->nx*SoftSegmentation1->ny*SoftSegmentation1->nz;
    int numbclasses1=SoftSegmentation1->nu*SoftSegmentation1->nt;
    bool testSeg2=IsResultSegmentation(SoftSegmentation2);
    int numel2=SoftSegmentation2->nx*SoftSegmentation2->ny*SoftSegmentation2->nz;
    int numbclasses2=SoftSegmentation2->nu*SoftSegmentation2->nt;
    if(!testSeg1 || !testSeg2 || numbclasses2!=numbclasses1 || numel1!=numel2 ){
        cout<<"Incompatibility somewhere"<<endl;
        return NULL;
    }
    else{
        float * Data1=static_cast<float *>(SoftSegmentation1->data);
        float * Data2=static_cast<float *>(SoftSegmentation2->data);
        //        int numelnonmasked1=0;
        //        int numelnonmasked2=0;
        //        float minSeg[numbclasses1];
        //        float maxSeg[numbclasses2];
        //        int Inter[numbclasses1];
        float * minSeg=new float[numbclasses1];
        float * maxSeg=new float[numbclasses2];
        int * Inter=new int[numbclasses1];
        for(int c=0;c<numbclasses1;c++){
            minSeg[c]=0;
            maxSeg[c]=0;
            Inter[c]=0;
        }
        for(int i=0;i<numel1;i++){
            for(int c=0;c<numbclasses1;c++){
                minSeg[c]+=min(Data1[c*numel1+i],Data2[c*numel1+i]);
                maxSeg[c]+=max(Data1[c*numel1+i],Data2[c*numel1+i]);
            }
            
        }
        float * SoftDiceScore=new float[numbclasses1+1];
        float sumInter=0;
        float sumTotMasked=0;
        for(int c=0;c<numbclasses1;c++){
            SoftDiceScore[c]=(float)minSeg[c]/((float)maxSeg[c]);
            sumInter+=minSeg[c];
            sumTotMasked+=maxSeg[c];
        }
        if(maxSeg!=NULL){
            delete [] maxSeg;
            maxSeg=NULL;
        }
        if(minSeg!=NULL){
            delete [] minSeg;
            minSeg=NULL;
        }
        if(Inter!=NULL){
            delete [] Inter;
            Inter=NULL;
        }
        SoftDiceScore[numbclasses1]=(float)sumInter/(float)sumTotMasked;
        return SoftDiceScore;
    }
}

nifti_image * PrepareCompareSoftSegmentationOutlierMult(vector<nifti_image*> PartialSeg,nifti_image *Mask){
    nifti_image * ResultSoftSegmentation=NULL;
    // First check compatibility of nifti_image in vector
    nifti_image* SoftSegmentationPrep=CreateDataImage(PartialSeg);
    int numel=SoftSegmentationPrep->nx*SoftSegmentationPrep->ny*SoftSegmentationPrep->nz;
    int numbclasses=SoftSegmentationPrep->nu*SoftSegmentationPrep->nt;
    // Create Mask with everything to 1 if Mask is NULL
    if(Mask==NULL){
        Mask=nifti_copy_nim_info(SoftSegmentationPrep);
        Mask->dim[0]=3;
        Mask->dim[4]=1;
        Mask->dim[5]=1;
        nifti_update_dims_from_array(Mask);
        Mask->data=(void *)calloc(Mask->nvox,sizeof(float));
        float * Mask_tmp=static_cast<float *>(Mask->data);
        for(int i=0;i<numel;i++,Mask_tmp++){
            *Mask_tmp=1;
        }
    }
    // Check compatibility of Mask with SoftSegmentationPrep
    if(Mask!=NULL){
        if(SoftSegmentationPrep->nx!=Mask->nx || SoftSegmentationPrep->ny!=Mask->ny || SoftSegmentationPrep->nz!=Mask->nz){
            cout<<"Impossible to use the mask"<<endl;
            return NULL;
        }
        else{
            // first binarise mask
            Binarisation(Mask);
            bool * Mask_PTR=static_cast<bool *>(Mask->data);
            float * SoftSegData=static_cast<float *>(SoftSegmentationPrep->data);
            float * OutlierData=new float[numel];
            for(int i=0;i<numel;i++){
                OutlierData[i]=0;
            }
            // Outlier class so that sum is one
            for(int i=0;i<numel;i++){
                if(Mask_PTR[i]>0){
                    float sumProba=0;
                    float maxProba=-1;
                    for(int c=0;c<numbclasses;c++){
                        if(SoftSegData[i+c*numel]>maxProba){
                            maxProba=SoftSegData[i+c*numel];
                        }
                        sumProba+=SoftSegData[i+c*numel];
                    }
                    OutlierData[i]=sumProba>1?0:1-sumProba;
                    // The mask won't consider the outlier part
                    if(maxProba<OutlierData[i]){
                        Mask_PTR[i]=0;
                    }
                }
            }
            // Adding a new class to the Partial Seg
            ResultSoftSegmentation=nifti_copy_nim_info(SoftSegmentationPrep);
            ResultSoftSegmentation->dim[4]++;
            nifti_update_dims_from_array(ResultSoftSegmentation);
            ResultSoftSegmentation->data=(void *)calloc(ResultSoftSegmentation->nvox,sizeof(float));
            float * ResultSoftSegmentation_PTR=static_cast<float *>(ResultSoftSegmentation->data);
            numbclasses=ResultSoftSegmentation->nu*ResultSoftSegmentation->nt;
            // Copying first classes from SoftSegData
            for(int c=0;c<numbclasses-1;c++){
                for(int i=0;i<numel;i++){
                    ResultSoftSegmentation_PTR[c*numel+i]=SoftSegData[c*numel+i];
                }
            }
            // Copying into last space Outliers data
            for(int i=0;i<numel;i++){
                ResultSoftSegmentation_PTR[numel*(numbclasses-1)+i]=OutlierData[i];
            }
            
            int numbclassesInit=PartialSeg.size();
            for(int c=0;c<numbclassesInit;c++){
                nifti_image_free(PartialSeg[c]);
                PartialSeg[c]=NULL;
            }
            PartialSeg.clear();
            
            return ResultSoftSegmentation;
        }
    }
    return ResultSoftSegmentation;
}

void PrepareCompareSoftSegmentationOutlierJoint(nifti_image* SegToCompare,nifti_image *Mask){
    // First check compatibility of nifti_image in vector
    int numel=SegToCompare->nx*SegToCompare->ny*SegToCompare->nz;
    int numbclasses=SegToCompare->nu*SegToCompare->nt;
    // Create Mask with everything to 1 if Mask is NULL
    if(Mask==NULL){
        Mask=nifti_copy_nim_info(SegToCompare);
        Mask->dim[0]=3;
        Mask->dim[4]=1;
        Mask->dim[5]=1;
        nifti_update_dims_from_array(Mask);
        Mask->data=(void *)calloc(Mask->nvox,sizeof(float));
        float * Mask_tmp=static_cast<float *>(Mask->data);
        for(int i=0;i<numel;i++,Mask_tmp++){
            *Mask_tmp=1;
        }
    }
    // Check compatibility of Mask with SoftSegmentationPrep
    if(Mask!=NULL){
        if(SegToCompare->nx!=Mask->nx || SegToCompare->ny!=Mask->ny || SegToCompare->nz!=Mask->nz){
            cout<<"Impossible to use the mask"<<endl;
            return;
        }
        else{
            // first binarise mask
            Binarisation(Mask);
            bool * Mask_PTR=static_cast<bool *>(Mask->data);
            float * SoftSegData=static_cast<float *>(SegToCompare->data);
            float * TotSeg=new float[(numbclasses+1)*numel];
            for(int i=0;i<numel*(numbclasses+1);i++){
                TotSeg[i]=0;
            }
            // Outlier class so that sum is one
            for(int i=0;i<numel;i++){
                if(Mask_PTR[i]>0){
                    float sumProba=0;
                    float maxProba=-1;
                    for(int c=0;c<numbclasses;c++){
                        if(SoftSegData[i+c*numel]>maxProba){
                            maxProba=SoftSegData[i+c*numel];
                        }
                        sumProba+=SoftSegData[i+c*numel];
                        TotSeg[i+c*numel]=SoftSegData[i+c*numel]; // So that SegToCompare Data is copied into TotSeg
                    }
                    TotSeg[i+numel*numbclasses]=sumProba>1?0:1-sumProba;
                    // The mask won't consider the outlier part
                    if(maxProba<TotSeg[i]){
                        Mask_PTR[i]=0;
                    }
                }
            }
            // Adding a new class to SegToCompare
            SegToCompare->dim[4]++;
            nifti_update_dims_from_array(SegToCompare);
            if(SoftSegData!=NULL){
                delete [] SoftSegData;
                SoftSegData=NULL;
            }
            SegToCompare->data=(void *)calloc(SegToCompare->nvox,sizeof(float));
            int Nvox=SegToCompare->nvox;
            float * SegToCompareData=static_cast<float *>(SegToCompare->data);
            for(int i=0;i<Nvox;i++){
                SegToCompareData[i]=TotSeg[i];
            }
            if(TotSeg!=NULL){
                delete [] TotSeg;
                TotSeg=NULL;
            }
        }
    }
}

nifti_image * PrepareCompareSoftSegmentations(vector<nifti_image*> PartialSeg,nifti_image* Mask){
    // First check compatibility of nifti_image in vector
    nifti_image* SoftSegmentationPrep=CreateDataImage(PartialSeg);
    int numel=SoftSegmentationPrep->nx*SoftSegmentationPrep->ny*SoftSegmentationPrep->nz;
    int numbclasses=SoftSegmentationPrep->nu*SoftSegmentationPrep->nt;
    // Check compatibility of Mask with SoftSegmentationPrep
    if(Mask!=NULL){
        if(SoftSegmentationPrep->nx!=Mask->nx || SoftSegmentationPrep->ny!=Mask->ny || SoftSegmentationPrep->nz!=Mask->nz){
            cout<<"Impossible to use the mask"<<endl;
            return NULL;
        }
        else{
            
            Binarisation(Mask);
            bool * Mask_PTR=static_cast<bool *>(Mask->data);
            float * SoftSegData=static_cast<float *>(SoftSegmentationPrep->data);
            for(int i = 0;i<numel;i++,Mask_PTR++){
                if(*Mask_PTR<=0){
                    for(int c=0;c<numbclasses;c++){
                        SoftSegData[i+c*numel]=0;
                    }
                }
                else{
                    float sumProb=0;
                    for(int c=0;c<numbclasses;c++){
                        sumProb+=SoftSegData[i+c*numel];
                    }
                    if(sumProb>1E-6){
                        for(int c=0;c<numbclasses;c++){
                            SoftSegData[i+c*numel]/=sumProb;
                        }
                    }
                    else{
                        for(int c=0;c<numbclasses;c++){
                            SoftSegData[i+c*numel]=0;
                        }
                    }
                }
            }
        }
        return SoftSegmentationPrep;
    }
    else{
        
        float * SoftSegData=static_cast<float *>(SoftSegmentationPrep->data);
        for(int i = 0;i<numel;i++){
            
            float sumProb=0;
            for(int c=0;c<numbclasses;c++){
                sumProb+=SoftSegData[i+c*numel];
            }
            if(sumProb>1E-6){
                for(int c=0;c<numbclasses;c++){
                    SoftSegData[i+c*numel]/=sumProb;
                }
            }
            else{
                for(int c=0;c<numbclasses;c++){
                    SoftSegData[i+c*numel]=0;
                }
            }
        }
    }
    return SoftSegmentationPrep;
}

// Changing image given as soft segmentation in order to make it of probability type
void MakeSoftSegmentation(nifti_image * SoftSegmentation){
    if(IsResultSegmentation(SoftSegmentation)){
        cout<<"no need to modify soft segmentation input"<<endl;
        return;
    }
    else{
        int numel=SoftSegmentation->nx*SoftSegmentation->ny*SoftSegmentation->nz;
        int numbclasses=SoftSegmentation->nu*SoftSegmentation->nt;
        float * SoftSegmentationData=static_cast<float *>(SoftSegmentation->data);
        for(int i=0;i<numel;i++){
            float sumProba=0;
            for(int c=0;c<numbclasses;c++){
                sumProba+=SoftSegmentationData[numel*c+i];
            }
            //            cout<<sumProba<<" ";
            if(sumProba>1E-6){
                for(int c=0;c<numbclasses;c++){
                    SoftSegmentationData[c*numel+i]/=sumProba;
                }
            }
            else{
                for(int c=0;c<numbclasses;c++){
                    SoftSegmentationData[c*numel+i]=0;
                }
            }
        }
        return;
    }
}

// Binarisation of the given image / mainly mask
nifti_image * Binarisation(nifti_image * Mask){
    if(Mask->datatype==DT_BINARY || Mask->nbyper==1){
        cout<< "Already binarised"<<endl;
        return Mask;
    }
    else{
        cout<<"Mask has to be binarised"<<endl;
        // First changing the values to have only 0 and 1
        float * Mask_PTR=static_cast<float *>(Mask->data); // consider that then data is float
        float * Mask_PTRtmp=Mask_PTR;
        int numel=Mask->nx*Mask->ny*Mask->nz;
        // if set as mask then it has been checked before that dimensions with dataimage are compatible
        bool *initialValue = new bool[numel];
        bool *initialValue_PTR=initialValue;
        for (int i=0; i<numel; i++,Mask_PTRtmp++,initialValue_PTR++) {
            (*Mask_PTRtmp)=(*Mask_PTRtmp)>0?1:0;// Set to 1 if strictly positive, 0 otherwise
            (*initialValue_PTR)=(bool)(*Mask_PTRtmp);
            
        }
        
        Mask->datatype=DT_BINARY;
        
        // the initial array is saved and freeed
        
        initialValue_PTR=initialValue;
        free(Mask->data);
        Mask->nbyper = sizeof(bool);
        Mask->data = (void *)calloc(Mask->nvox,sizeof(bool));
        bool *dataPtr = static_cast<bool *>(Mask->data);
        for (int i=0; i<numel; i++, dataPtr++,initialValue_PTR++) {
            (*dataPtr)=(bool)(*initialValue_PTR);
        }
        delete [] initialValue;
        return Mask;
    }
}

nifti_image * Floatisation(nifti_image * Image){
    if(Image->datatype==DT_FLOAT){
        cout<< "Already floatised"<<endl;
        return Image;
    }
    else{
        cout<<"Image has to be floatised"<<endl;
        // First changing the values to have only 0 and 1
        float * Image_PTR=static_cast<float *>(Image->data); // consider that then data is float
        float * Image_PTRtmp=Image_PTR;
        int numel=Image->nx*Image->ny*Image->nz;
        int numbclasses=Image->nu*Image->nt;
        // if set as mask then it has been checked before that dimensions with dataimage are compatible
        float *initialValue = new float[numel*numbclasses];
        float *initialValue_PTR=initialValue;
        for (int i=0; i<numel*numbclasses; i++,Image_PTRtmp++,initialValue_PTR++) {
            (*initialValue_PTR)=(float)(*Image_PTRtmp);
            
        }
        
        Image->datatype=DT_FLOAT;
        
        // the initial array is saved and freeed
        
        initialValue_PTR=initialValue;
        free(Image->data);
        Image->nbyper = sizeof(float);
        Image->data = (void *)calloc(Image->nvox,sizeof(float));
        float *dataPtr = static_cast<float *>(Image->data);
        for (int i=0; i<numel*numbclasses; i++, dataPtr++,initialValue_PTR++) {
            (*dataPtr)=(float)(*initialValue_PTR);
        }
        delete [] initialValue;
        return Image;
    }
}

// From the Mask image and the outlier image, create the opposite inlier image
nifti_image * CreateInlierNormResp(nifti_image * Mask, nifti_image * Outliers=NULL){
    nifti_image * MaskFloat=nifti_copy_nim_info(Mask);
    MaskFloat->datatype=DT_FLOAT;
    float * Mask_PTR=static_cast<float*>(Mask->data);
    MaskFloat->nbyper = sizeof(float);
    nifti_update_dims_from_array(MaskFloat);
    MaskFloat->data = (void *)calloc(MaskFloat->nvox,sizeof(float));
    float *MaskFloat_PTR=static_cast<float*>(MaskFloat->data);
    int numel =MaskFloat->nvox;
    for (int i=0; i<numel; i++) {
        MaskFloat_PTR[i]=0;
    }
    float * Outliers_PTR=NULL;
    if (Outliers!=NULL) {
        Outliers_PTR=static_cast<float *>(Outliers->data);
        for (int i=0; i<numel; i++,Mask_PTR++,MaskFloat_PTR++,Outliers_PTR++) {
            if (*Mask_PTR>0) {
                *MaskFloat_PTR=1-*Outliers_PTR;
            }
        }
    }
    
    else{
        for (int i=0; i<numel; i++,Mask_PTR++,MaskFloat_PTR++) {
            if (*Mask_PTR) {
                *MaskFloat_PTR=1;
            }
        }
    }
    return MaskFloat;
}

// Modify given image ImageToMask so that all non active voxels are set to 0 given Mask
void MaskImage(nifti_image * ImageToMask, nifti_image * Mask){
    // Check first if there is an image to mask
    if(ImageToMask==NULL){
        cout<<"No image to mask"<<endl;
        return;
    }
    // Check for dimension compatibility
    int numel=ImageToMask->nx*ImageToMask->ny*ImageToMask->nz;
    int numbclasses=ImageToMask->nt*ImageToMask->nu;
    bool Compatibility=0;
    if(Mask!=NULL){
        //    int numelMask=Mask->nx*Mask->ny*Mask->nz;
        Compatibility=(Mask->nx==ImageToMask->nx)*(Mask->ny==ImageToMask->ny)*(Mask->nz==ImageToMask->nz);
    }
    // if not return image with natural mask
    if(!Compatibility){
        Floatisation(ImageToMask);
        float * ImageData=static_cast<float *>(ImageToMask->data);
        for(int i=0;i<numel;i++){
            float sumVoxel=0;
            for(int c=0;c<numbclasses;c++){
                sumVoxel+=ImageData[numel*c+i];
            }
            if(sumVoxel<=1E-6){
                for(int c=0;c<numbclasses;c++){
                    ImageData[numel*c+i]=0;
                }
            }
        }
        return;
    }
    
    // else use mask to transform image
    else{
        Binarisation(Mask);
        Floatisation(ImageToMask);
        float * ImageData=static_cast<float*>(ImageToMask->data);
        bool * MaskData=static_cast<bool*>(Mask->data);
        for(int i=0;i<numel;i++){
            if(MaskData[i]==0){
                for(int c=0;c<numbclasses;c++){
                    ImageData[numel*c+i]=0;
                }
            }
        }
        return ;
    }
}




// Checking function returning a boolean to assess SoftSegmentation image as an image of probability type : that is sum over all 3D volumes is 1 or 0 everywhere.
bool IsResultSegmentation(nifti_image *SoftSegmentation){
    int numel=SoftSegmentation->nx*SoftSegmentation->ny*SoftSegmentation->nz;
    int numbclasses=SoftSegmentation->nu*SoftSegmentation->nt;
    int numelmasked=0;
    int numelnonmasked=0;
    int numelpb=0;
    float * SoftData=static_cast<float *>(SoftSegmentation->data);
    for(int i=0;i<numel;i++){
        float sumVoxel=0;
        for(int c=0;c<numbclasses;c++){
            sumVoxel+=SoftData[c*numel+i];
        }
        if(sumVoxel>=-1E-6&& sumVoxel<=1E-6){
            numelnonmasked++;
        }
        else if(sumVoxel <=1+1E-6 && sumVoxel >= 1-1E-6){
            numelmasked++;
        }
        else{
            numelpb++;
        }
        
    }
    if (numelpb>0){
        cout << "Number of voxels with problem is"<< numelpb<<" for image "<<SoftSegmentation<<endl;
        return 0;
    }
    else {
        return 1;
    }
}

// Returns the new image transforming SoftSegmentation into a probability type, usable as Segmentation result
nifti_image * MakeResultSegmentation(nifti_image * SoftSegmentation){
    int numel=SoftSegmentation->nx*SoftSegmentation->ny*SoftSegmentation->nz;
    int numbclasses=SoftSegmentation->nu*SoftSegmentation->nt;
    int numelmasked=0;
    int numelnonmasked=0;
    int numelpb=0;
    float * SoftData=static_cast<float *>(SoftSegmentation->data);
    for(int i=0;i<numel;i++){
        float sumVoxel=0;
        for(int c=0;c<numbclasses;c++){
            sumVoxel+=SoftData[c*numel+i];
        }
        if(sumVoxel>=-1E-6&& sumVoxel<=1E-6){
            numelnonmasked++;
        }
        else if(sumVoxel <=1+1E-6 && sumVoxel >= 1-1E-6){
            numelmasked++;
        }
        else{
            cout<< "sum pb voxel is "<< sumVoxel<<"  ";
            for(int c=0;c<numbclasses;c++){
                SoftData[c*numel+i]/=sumVoxel;
            }
            numelpb++;
        }
        
    }
    if (numelpb>0){
        cout << "Number of voxels with problem is"<< numelpb<<" for image "<<SoftSegmentation<<endl;
        return SoftSegmentation;
    }
    else {
        return SoftSegmentation;
    }
    
}

// Returns as a vector of float array the parameters of each subclass contained in SegImage relative to the image DataCorrected. Each float array is of size numbmodal + numbmodal*numbmodal + 1. First is stored the mean, then the covariance matrix to finish with the weight of the corresponding subclass
vector<float*> ParametersFromSeg(nifti_image * DataCorrected, nifti_image * Mask, nifti_image * SegImage){
    vector<float*> ParametersVector;
    int numbmodal=DataCorrected->nu*DataCorrected->nt;
    int numel=DataCorrected->nx*DataCorrected->ny*DataCorrected->nz;
    //    int numelmasked=this->GetNumberMaskedElements();
    PrecisionTYPE sumResp=0; // Initialisation of the denominator
    PrecisionTYPE MeanResult_tmp=0;
    //    PrecisionTYPE VarianceToUpdate_tmp=0;
    //float * PointerToDataBegin = static_cast<float *>(this->GetDataImage()->data);
    //    float * PointerToDataBegin=this->MakeDataBFCorrected();
    float * PointerToDataBegin=static_cast<float *>(DataCorrected->data);
    float * PointerToDataBegin_PTR=PointerToDataBegin;
    float * PointerToDataBegin_PTR1=PointerToDataBegin;
    float * PointerToDataBegin_PTR2=PointerToDataBegin;
    float * NormalisedResponsabilities=static_cast<float*>(SegImage->data);
    int numbclasses=SegImage->nu*SegImage->nt;
    //    int * L2S_PTR=this->GetL2S();
    
    float * Mask_PTR=static_cast<float*>(Mask->data);
    float * Mask_PTR2=Mask_PTR;
    
    // Number of masked elements
    int numelmasked=0;
    for (int i=0; i<numel; i++,Mask_PTR2++) {
        if (*Mask_PTR2>0) {
            numelmasked++;
        }
    }
    
    for (int c=0; c<numbclasses; c++) {// Creation of parameters for class c
        float * Parameters = new float [numbmodal*numbmodal+numbmodal+1];
        //        float Parameters[numbmodal*numbmodal+numbmodal+1];
        for(int m=0;m<numbmodal*numbmodal+numbmodal+1;m++){
            Parameters[m]=0;
        }
        sumResp=0;
        MeanResult_tmp=0;
        float* NormalisedResponsabilities_PTR=&NormalisedResponsabilities[c*numel];
        for (int m=0; m<numbmodal; m++) {
            sumResp=0;
            MeanResult_tmp=0;
            Mask_PTR2=Mask_PTR;
            PointerToDataBegin_PTR=&PointerToDataBegin[m*numel];
            NormalisedResponsabilities_PTR=&NormalisedResponsabilities[c*numel];
            // Determination of mean and weight
            for (int i=0; i<numel; i++,NormalisedResponsabilities_PTR++,PointerToDataBegin_PTR++,Mask_PTR2++) {
                if (*Mask_PTR2>0) {
                    sumResp+=(PrecisionTYPE)(*NormalisedResponsabilities_PTR);
                    MeanResult_tmp+=(PrecisionTYPE)(*NormalisedResponsabilities_PTR)*(*PointerToDataBegin_PTR);
                }
            }
            Parameters[numbmodal+numbmodal*numbmodal]=sumResp/numelmasked; // Determination of the weight
            if (sumResp>0) {
                Parameters[m]=MeanResult_tmp/sumResp;
            }
            else{
                Parameters[m]=MeanResult_tmp/numelmasked;
            }
        }
        
        // Variance determination
        for(int m1=0;m1<numbmodal;m1++){
            // First data pointer to the beginning of the modality m1 considered
            for(int m2=0;m2<numbmodal;m2++){
                PointerToDataBegin_PTR1=&PointerToDataBegin[m1*numel];
                PointerToDataBegin_PTR2=&PointerToDataBegin[m2*numel]; // Second Data pointer to the beginning of the modality m2 considered
                NormalisedResponsabilities_PTR=&NormalisedResponsabilities[c*numel]; // Reinitialisation of the responsabilities pointer to the beginning
                PrecisionTYPE VarianceToUpdate_tmp=0;
                Mask_PTR2=Mask_PTR;
                for(int i=0;i<numel;i++,PointerToDataBegin_PTR1++,PointerToDataBegin_PTR2++,NormalisedResponsabilities_PTR++,Mask_PTR2++){
                    // Update of the numerator of the Variance Calculation only if in the case of an active voxel
                    if (*Mask_PTR2>0) {
                        VarianceToUpdate_tmp+=(PrecisionTYPE)(*NormalisedResponsabilities_PTR)*((*PointerToDataBegin_PTR1)-Parameters[m1])*((*PointerToDataBegin_PTR2)-Parameters[m2]);
                    }
                    
                }
                if (sumResp !=0) {
                    Parameters[numbmodal + m1+m2*numbmodal]=(float)VarianceToUpdate_tmp/sumResp;
                    if (m1==m2) {
                        Parameters[numbmodal+m1+m2*numbmodal]=Parameters[numbmodal+m1+m2*numbmodal]<=1E-6?1E-6:Parameters[numbmodal+m1+m2*numbmodal]; // in order to avoid going to 0 if too sharp distribution but not changing non diagonal of variance
                    }
                    
                    
                }
                else{
                    Parameters[numbmodal+m1+m2*numbmodal]=VarianceToUpdate_tmp/numelmasked;// this->GetNumberMaskedElements();
                }
                // Use of the symmetry property of the Variance matrix
                Parameters[numbmodal+m2+m1*numbmodal]=Parameters[numbmodal+m1+m2*numbmodal];
            }
            
        }
        for (int i=0; i<=numbmodal+numbmodal*numbmodal; i++) {
            cout<<Parameters[i]<<" ";
        }
        float * ParametersNew=new float[numbmodal+numbmodal*numbmodal+1];
        for (int i=0; i<numbmodal+numbmodal*numbmodal+1; i++) {
            ParametersNew[i]=Parameters[i];
        }
        delete [] Parameters;
        Parameters=NULL;
        ParametersVector.push_back(ParametersNew);
    }
    float sumWeight=0;
    for (int c=0; c<numbclasses; c++) {
        sumWeight+=ParametersVector[c][numbmodal+numbmodal*numbmodal];
    }
    for (int c=0; c<numbclasses; c++) {
        ParametersVector[c][numbmodal+numbmodal*numbmodal]/=sumWeight;
    }
    return ParametersVector;
}

float * GetMaskHistogram(float * Data, bool * Mask, float Min, float Max, float sizeBin,int numbmodal,int numel){
    int numbSteps=(int)(Max-Min)/sizeBin;
    if (Mask==NULL) {
        return NULL;
    }
    float * Histogram=new float [numbSteps*numbmodal];
    for (int i=0; i<numbSteps*numbmodal; i++) {
        Histogram[i]=0;
    }
    for(int m=0;m<numbmodal; m++){
        for (int i=0; i<numel; i++) {
            if (Mask[i]){
            float tmpValue=(float)(Data[i+m*numel]-Min)/sizeBin-0.5;
            if (tmpValue<0) {
                Histogram[m*numbSteps]+=1;
            }
            else if (tmpValue>numbSteps-1){
                Histogram[m*numbSteps+numbSteps-1]+=1;
            }
            else{
                Histogram[m*numbSteps+(int)floorf(tmpValue)]+=(float)(1-(tmpValue-floorf(tmpValue)));
                Histogram[m*numbSteps+(int)floorf(tmpValue)+1]+=(float)(tmpValue-floorf(tmpValue));
            }

            }
        }
    }
    return Histogram;
}

// Update the histogram of the data weighted with NormResp for each of the modality in a vector of float pointer to each of the monomodal histogram
vector<float *> MakeDataHistogram(nifti_image* DataImage, nifti_image * Mask, nifti_image * Outliers){
    vector<float *> DataHistogram_VEC;
    nifti_image * InliersNormResp=CreateInlierNormResp(Mask,Outliers);
    // First check if there is Data to make histogram
    if (DataImage==NULL) {
        cout<<"No data to make histogram from"<<endl;
        return DataHistogram_VEC;
    }
    
    // Then if modality wanted in histogram is available
    //    int numbbinsGet=this->GetNumbbins();
    int numbbinsGet=128;
    if (numbbinsGet<=0) {
        cout<<"No proper number of bins asked for"<<endl;
        return DataHistogram_VEC;
    }
    float sizeBin=(float)1.0/numbbinsGet;
    int numel=DataImage->nx*DataImage->ny*DataImage->nz;
    int numbmodal=DataImage->nu*DataImage->nt;
    float tmpValue=0;
    
    float * Data=static_cast<float *>(DataImage->data);
    
    for (int m=0; m<numbmodal; m++) {
        float * InitDataHistToPushBack=new float[numbbinsGet];
        for(int i=0;i<numbbinsGet;i++){
            InitDataHistToPushBack[i]=0;
        }
        DataHistogram_VEC.push_back(InitDataHistToPushBack);
    }
    float * NormResp=static_cast<float*>(InliersNormResp->data);
    float * NormResp_PTR=NormResp;
    for (int m=0; m<numbmodal; m++) {
        float * DataHistogram_PTR=DataHistogram_VEC[m];
        float * Data_PTR=&Data[m*numel];
        NormResp_PTR=NormResp;
        PrecisionTYPE SumNormResp=0;
        tmpValue=0;
        // Case when NormResp is NULL
        if (NormResp_PTR==NULL) { // then consider that there are 1 everywhere
            for (int i=0; i<numel; i++, Data_PTR++) {
                tmpValue=(float)*Data_PTR/sizeBin-0.5;
                if (tmpValue<0) {
                    DataHistogram_PTR[0]+=1;
                }
                else if (tmpValue>numbbinsGet-1){
                    DataHistogram_PTR[numbbinsGet-1]+=1;
                }
                else{
                    DataHistogram_PTR[(int)floorf(tmpValue)]+=(float)(1-(tmpValue-floorf(tmpValue)));
                    DataHistogram_PTR[(int)floorf(tmpValue)+1]+=(float)(tmpValue-floorf(tmpValue));
                }
                SumNormResp++;
                //NormResp_PTR++;
                
            }
            
        }
        else{
            NormResp_PTR=NormResp;
            for (int i=0; i<numel; i++, Data_PTR++,NormResp_PTR++) {
                tmpValue=(float)*Data_PTR/sizeBin-0.5;
                if (tmpValue<0) {
                    DataHistogram_PTR[0]+=(float)*NormResp_PTR;
                }
                else if (tmpValue>numbbinsGet-1){
                    DataHistogram_PTR[numbbinsGet-1]+=(float)*NormResp_PTR;
                }
                else{
                    DataHistogram_PTR[(int)floorf(tmpValue)]+=(float)*NormResp_PTR*(1-(tmpValue-floorf(tmpValue)));
                    DataHistogram_PTR[(int)floorf(tmpValue)+1]+=(float)*NormResp_PTR*(tmpValue-floorf(tmpValue));
                }
                SumNormResp+=(float)*NormResp_PTR;
            }
            for (int i=0; i<numbbinsGet; i++) {
                DataHistogram_PTR[i]/=SumNormResp;
            }
            
        }
        DataHistogram_PTR=DataHistogram_VEC[m];
        
    }
    nifti_image_free(InliersNormResp);
    InliersNormResp=NULL;
    return DataHistogram_VEC;
}




/* Make the Histogram of the data given the mask and outlier beliefs taken out (in use only with EMS otherwise everything under mask taken into account)*/
float * MakeDataHistogramTotal(nifti_image * DataImage, nifti_image* Mask, nifti_image * Outliers = NULL){
    // First Create the NormMask image
    int numbbins=128;
    nifti_image * InlierNormResp=CreateInlierNormResp(Mask,Outliers);
    //    nifti_set_filenames(InlierNormResp, "/Users/Carole/Documents/PhD/TestInliers.nii.gz", 0, 0);
    //    nifti_image_write(InlierNormResp);
    int numbmodal=DataImage->nu*DataImage->nt;
    //        int numbchild=this->GetNumberChildren();
    int numel=DataImage->nx*DataImage->ny*DataImage->nz;
    // then check that the number of bins set for the tree is compatible with
    int numbbinsGet=(int)(numbbins/pow_int(2, (numbmodal-1)));
    if (numbbinsGet<=0) {
        return NULL;
    }
    int numelhist=(int)pow_int(numbbinsGet,numbmodal);
    //float * DataHistogram=new float[(int)powf(numbbins,numbmodal)]{0};
    float * DataHistogramTotal_PTR=new float[numelhist];//{0};
    for(int i=0;i<numelhist;i++){
        DataHistogramTotal_PTR[i]=0;
    }
    float sizeBin=(float)1.0/numbbinsGet;
    //        int *L2S_PTR=this->GetL2S();
    
    vector<float *> Data_PTRModalVector;
    //        float * Data=this->MakeDataBFCorrected();
    float * Data=static_cast<float*>(DataImage->data);
    
    for (int m=0; m<numbmodal; m++) {
        //Data_PTRModalVector.push_back(&static_cast<float*>(this->GetDataImage()->data)[m*numel]);
        Data_PTRModalVector.push_back(&Data[m*numel]);
    }
    float * NormResp_PTR=static_cast<float*>(InlierNormResp->data);
    float tmpValue[MaxNumbModal];//{0};
    
    for(int i=0;i<MaxNumbModal;i++){
        tmpValue[i]=0;
    }
    int twopowmodal=(int)pow_int(2,numbmodal);
    int twopowMaxmodal=(int)pow_int(2,MaxNumbModal);
    //        int indexTab[twopowMaxmodal];//{0};
    int *indexTab=new int[twopowMaxmodal];
    for(int i=0;i<twopowMaxmodal;i++){
        indexTab[i]=0;
    }
    //        float valuePerc[twopowMaxmodal];//{1};
    float *valuePerc=new float[twopowMaxmodal];
    for(int i=0;i<twopowMaxmodal;i++){
        valuePerc[i]=1;
    }
    int CountNormRespZero=0;
    float SumNormResp=0;
    for (int i=0; i<numel; i++) {
        for (int m=0; m<numbmodal; m++) {
            int twopowm=(int)pow_int(2,m);
            tmpValue[m]=*Data_PTRModalVector[m]/sizeBin-0.5;
            tmpValue[m]=tmpValue[m]>(numbbinsGet-1)?numbbinsGet-1:tmpValue[m];
            tmpValue[m]=tmpValue[m]<0?0:tmpValue[m];
            for (int c=0; c<twopowm; c++) {
                indexTab[c+twopowm]=indexTab[c];
                valuePerc[c+twopowm]=valuePerc[c];
            }
            int binspowm=(int)pow_int(numbbinsGet,m);
            int floorTmpValuem=(int)floorf(tmpValue[m]);
            for (int c=0; c<twopowm; c++) {
                indexTab[c]+=(int)(binspowm*floorTmpValuem);
                indexTab[c+twopowm]+=binspowm*floorTmpValuem+1;
                valuePerc[c]*=(1-tmpValue[m]+floorTmpValuem);
                valuePerc[c+twopowm]*=(tmpValue[m]-floorTmpValuem);
            }
        }
        float sumValuePerc=0;
        for (int c=0; c<twopowmodal; c++) {
            sumValuePerc+=valuePerc[c];
        }
        //cout<<"sumValuePerc "<< sumValuePerc<<" for index "<<i<<endl;
        if(NormResp_PTR!=NULL){
            
            for (int p=0; p<twopowmodal; p++) {
                DataHistogramTotal_PTR[indexTab[p]]+=(float)valuePerc[p]*(*NormResp_PTR);
                
            }
            if (*NormResp_PTR<1-1E-6) {
                CountNormRespZero++;
            }
            SumNormResp+=(PrecisionTYPE)*NormResp_PTR;
            NormResp_PTR++;
        }
        else{
            for(int p=0; p<twopowmodal; p++) {
                DataHistogramTotal_PTR[indexTab[p]]+=(float)valuePerc[p];
                
            }
            SumNormResp++;
        }
        
        for (int p=0; p<twopowmodal; p++) {
            indexTab[p]=0;
            valuePerc[p]=1;
        }
        for (int m=0; m<numbmodal; m++) {
            Data_PTRModalVector[m]++;
        }
    }
    //cout<<"CountNormRespZero is"<<CountNormRespZero<<endl;
    delete [] indexTab;
    indexTab=NULL;
    delete [] valuePerc;
    valuePerc=NULL;
    //                delete [] tmpValue;
    //                tmpValue=NULL;
    float SumDataHistogram=0;
    
    //        float NumberDataHistogramZero=0;
    //        int numelmasked=this->GetNumberMaskedElements();
    int binspowmodal=(int)pow_int(numbbinsGet,numbmodal);
    
    //Normalisation of the DataHistogram in order to properly calculate the KLD afterwards:
    for(int i=0;i<binspowmodal;i++){
        SumDataHistogram+=DataHistogramTotal_PTR[i];
    }
    if(SumDataHistogram>0){
        for(int i=0;i<binspowmodal;i++){
            DataHistogramTotal_PTR[i]/=SumDataHistogram;
        }
    }
    
    //        for (int i=0; i<binspowmodal; i++) {
    //            DataHistogramTotal_PTR[i]/=SumNormResp;
    //            SumDataHistogram+=DataHistogramTotal_PTR[i];
    //        }
    
    //        cout<<"Sum DataHistogram is "<<SumDataHistogram<<endl;
    //        if (Data!=NULL) {
    //            delete [] Data;
    //            Data=NULL;
    //        }
    
    nifti_image_free(InlierNormResp);
    InlierNormResp=NULL;
    return DataHistogramTotal_PTR;
}

// Returns the histogram of the distribution for numbbins
vector<float *> MakeDistHistogram(int numbmodal,vector<float *> ParametersVector){
    vector<float *> DistHistogramVector;
    
    int numbbinsGet=128;
    int numbclasses=ParametersVector.size();
    for (int m=0; m<numbmodal; m++) {
        float * DistHistogram=new float[numbbinsGet];
        for (int i=0; i<numbbinsGet; i++) {
            DistHistogram[i]=0;
        }
        for (int c=0; c<numbclasses; c++) {
            float * LeafHistogram=MakeGaussianDistributionHist(numbmodal, ParametersVector[c],m);
            float Weight=ParametersVector[c][numbmodal+numbmodal*numbmodal];
            for (int i=0; i<numbbinsGet; i++) {
                DistHistogram[i]+=LeafHistogram[i]*Weight;
            }
            delete [] LeafHistogram;
            LeafHistogram=NULL;
        }
        DistHistogramVector.push_back(DistHistogram);
    }
    
    return DistHistogramVector;
}



float * MakeDistHistogramTotal(int numbmodal,vector<float*> ParametersVector){
    int numbbins=128;
    int numbbinsGet=(int)(numbbins/pow(2, (numbmodal-1)));
    int binspowmodal=(int)pow(numbbinsGet,numbmodal);
    float * DistHistogramTotal=new float[binspowmodal];//{0};
    for(int i=0;i<binspowmodal;i++){
        DistHistogramTotal[i]=0;
    }
    
    int numbclasses=ParametersVector.size();
    for (int c=0; c<numbclasses; c++) {
        float * LeafHistogramTotal=MakeGaussianDistributionHistTotal(numbmodal, ParametersVector[c]);
        float Weight=ParametersVector[c][numbmodal+numbmodal*numbmodal];
        for (int i=0; i<binspowmodal; i++) {
            DistHistogramTotal[i]+=LeafHistogramTotal[i]*Weight;
        }
        delete [] LeafHistogramTotal;
        LeafHistogramTotal=NULL;
    }
    return DistHistogramTotal;
}


// Returns the complete histogram corresponding to the distribution with the given number of bins. To be used for the derivation of the KLD
float * MakeGaussianDistributionHist(int numbmodal, float * Parameters,int modal){
    //    int numbbins=128;
    // First initialise the Variance Matrix and inverted one
    //    matrix<float> VarianceMatrix=matrix<float>(numbmodal);
    float  VarianceToSet=Parameters[numbmodal+modal*numbmodal+modal];
    float  MeanB=Parameters[modal];
    
    
    //    matrix<float>VarianceMatrixCopy=matrix<float>(MaxNumbModal);
    //    VarianceMatrixCopy.copymatrix(VarianceMatrix);
    
    int numbbinsGet=128;
    float sizeBin=1.0/(float)numbbinsGet;
    //cout<<"the Variance determinant is "<<DeterminantVariance<<endl;
    float NormalisationFactor=1.0/(float)(powf(2*M_PI , 0.5)*powf(VarianceToSet, 0.5));
    float * GaussianDistribution = new float[numbbinsGet];//{0};
    for(int i=0;i<numbbinsGet;i++){
        GaussianDistribution[i]=0;
    }
    float * GaussianDistribution_PTR=GaussianDistribution;
    float InvertedVariance=0;
    if (VarianceToSet!=0) {
        InvertedVariance=1.0/VarianceToSet;
    }
    else{
        InvertedVariance=10E6;
    }
    float sumDist=0;
    float Value=0;
    for (int i=0; i<numbbinsGet; i++,GaussianDistribution_PTR++) {
        Value=i*sizeBin+0.5*sizeBin;
        *GaussianDistribution_PTR=NormalisationFactor*expf(-(float)0.5*InvertedVariance*(Value-MeanB)*(Value-MeanB))*sizeBin;
        sumDist+=*GaussianDistribution_PTR;
    }
    
    
    // Return result
    return GaussianDistribution;
}


// Returns the complete histogram corresponding to the distribution with the given number of bins. To be used for the derivation of the KLD
float * MakeGaussianDistributionHistTotal(int numbmodal, float * Parameters){
    int numbbins=128;
    // First initialise the Variance Matrix and inverted one
    //    matrix<float> VarianceMatrix=matrix<float>(numbmodal);
    float * VarianceToSet=&Parameters[numbmodal];
    float * MeanB=Parameters;
    
    TreeEM * Test=new TreeEM();
    float * VarianceMatrixToInvert=new float[numbmodal*numbmodal];
    for (int m1=0; m1<numbmodal; m1++) {
        for (int m2=0; m2<numbmodal; m2++) {
            VarianceMatrixToInvert[m1+m2*numbmodal]=VarianceToSet[m1+m2*numbmodal];
        }
    }
    
    //    matrix<float>VarianceMatrixCopy=matrix<float>(MaxNumbModal);
    //    VarianceMatrixCopy.copymatrix(VarianceMatrix);
    
    
    // Calculation of the factor in front of the exponential
    //    float DeterminantVariance=VarianceMatrix.determinant();
    float DeterminantVariance=Test->determinant(VarianceMatrixToInvert,numbmodal);
    float Mean[MaxNumbModal];
    for(int m=0;m<MaxNumbModal;m++){
        if(m<numbmodal){
            Mean[m]=MeanB[m];
        }
        else{
            Mean[m]=0;
        }
    }
    int numbbinsGet=(int)(numbbins/pow(2, (numbmodal-1)));
    float sizeBin=1.0/(float)numbbinsGet;
    //cout<<"the Variance determinant is "<<DeterminantVariance<<endl;
    float NormalisationFactor=1.0/(float)(powf(2*M_PI , (float)((float)numbmodal/2.0))*powf(DeterminantVariance, 0.5));
    //cout <<"The normalisation factor is "<<NormalisationFactor<<endl;
    //Initialisation of the needed element to calculate the inside of the exponential
    int binspowmodal=(int)pow(numbbinsGet,numbmodal);
    float * GaussianDistributionTotal = new float[binspowmodal];//{0};
    for(int i=0;i<binspowmodal;i++){
        GaussianDistributionTotal[i]=0;
    }
    float * GaussianDistribution_PTR=GaussianDistributionTotal;
    float InvertedVariance[MaxNumbModal*MaxNumbModal];
    for(int i=0;i<MaxNumbModal*MaxNumbModal;i++){
        InvertedVariance[i]=0;
    }
    if (numbmodal>1) {
        //        VarianceMatrix.invert();
        Test->invertMatrix(VarianceMatrixToInvert,numbmodal);
        //        matrix<float>TestMatrix=matrix<float>(MaxNumbModal);
        //        TestMatrix.settoproduct(VarianceMatrixCopy,VarianceMatrix);
        //        TestMatrix.comparetoidentity();
        //        bool success;
        for(int m1=0;m1<numbmodal;m1++){
            for (int m2=0; m2<numbmodal; m2++) {
                //                VarianceMatrix.getvalue(m1, m2, InvertedVariance[m1+m2*MaxNumbModal], success);
                InvertedVariance[m1+m2*MaxNumbModal]=VarianceMatrixToInvert[m1+m2*numbmodal];
            }
        }
        delete [] VarianceMatrixToInvert;
        VarianceMatrixToInvert=NULL;
    }
    else{
        //        bool success;
        //        VarianceMatrix.getvalue(0, 0, InvertedVariance[0], success);
        *InvertedVariance=(float)1.0/DeterminantVariance;
        //*InvertedVariance=1/(*InvertedVariance);
    }
    float temp;
    int  IndexConversion [MaxNumbModal];//{0};
    for(int i=0;i<MaxNumbModal;i++){
        IndexConversion[i]=0;
    }
    int Rem;
    // Calculation of the inside of the exponential
    //cout<<InvertedVariance[0]<<endl;
    int CountNegativeValues=0;
    for (int i=0; i<binspowmodal; i++) {
        Rem=i;
        
        // Conversion of the index i into the different index for each modality giving then the value to consider
        for (int m=numbmodal-1; m>=0; m--) {
            int binspowm=(int)pow(numbbinsGet,m);
            IndexConversion[m]=Rem/binspowm;
            Rem-=IndexConversion[m]*binspowm;
        }
        for (int m1=0; m1<numbmodal; m1++) {
            temp=0;
            for (int m2=0; m2<numbmodal; m2++) {
                temp+=((sizeBin*IndexConversion[m2]+0.5*sizeBin)-Mean[m2])*InvertedVariance[m2+m1*MaxNumbModal];
            }
            *GaussianDistribution_PTR=(*GaussianDistribution_PTR)+temp*((sizeBin*IndexConversion[m1]+0.5*sizeBin)-Mean[m1]);
        }
        if (*GaussianDistribution_PTR<0) {
            CountNegativeValues++;
        }
        GaussianDistribution_PTR++;
    }
    //cout<<"The number of negative values is "<<CountNegativeValues<<endl;
    // Filling the distribution array with the value
    GaussianDistribution_PTR=GaussianDistributionTotal;
    //cout << "Normalisation factor in GetGaussianDistHistTotal is "<<NormalisationFactor<<endl;
    float sumDist=0;
    //    int numelmasked=this->GetNumberMaskedElements();
    float sizeBinpowmodal=pow_int(sizeBin,numbmodal);
    for (int i=0;i<binspowmodal;i++,GaussianDistribution_PTR++){
        *GaussianDistribution_PTR=NormalisationFactor*expf(-0.5*(*GaussianDistribution_PTR))*sizeBinpowmodal;
        sumDist+=*GaussianDistribution_PTR;
    }
    //cout<<"sumDist in GetGaussianTotal is "<<sumDist<<endl;
    // Clearing space needing for inverse of variance
    
    
    // Return result
    return GaussianDistributionTotal;
}

// Returns the value of the total KLD not taking into account the voxels classified as Outliers and stored in Outliers Image.
float MakeKLDTot(nifti_image * DataImage, nifti_image* Mask,nifti_image* Seg, nifti_image*Outliers =NULL){
    int numbmodal=DataImage->nu*DataImage->nt;
    int numbbins=128;
    vector<float*> ParametersVector=ParametersFromSeg(DataImage, Mask, Seg);
    float * DistHistTot=MakeDistHistogramTotal(numbmodal, ParametersVector);
    float * DistHistTot_PTR=DistHistTot;
    float * DataHistTot=MakeDataHistogramTotal(DataImage, Mask,Outliers);
    float * DataHistTot_PTR=DataHistTot;
    int numbbinsGet=(int)(numbbins/pow_int(2, (numbmodal-1)));
    int binspowmodal=(int)pow_int(numbbinsGet,numbmodal);
    float ResultKLD=0;
    int CountNanDist=0;
    int CountNanData=0;
    for (int i=0; i<binspowmodal; i++,DistHistTot_PTR++,DataHistTot_PTR++) {
        float DistValue=(*DistHistTot_PTR)<=0.00001?0.00001:(*DistHistTot_PTR);
        if (DistValue !=DistValue) {
            CountNanDist++;
        }
        float DataValue=(*DataHistTot_PTR)<=0.00001?0.00001:(*DataHistTot_PTR);
        if (DataValue !=DataValue) {
            CountNanData++;
        }
        ResultKLD+=0.5*(logf(((DistValue)/(DataValue)))*(*DistHistTot_PTR)+logf(((DataValue)/(DistValue)))*(*DataHistTot_PTR)); // Use of the symmetric KLD between the two distributions
    }
    return ResultKLD;
}

// Same as before but returning this time the vector of partial modalities KLD
vector<float> MakeKLDVector(nifti_image * DataImage, nifti_image* Mask,nifti_image* Seg, nifti_image*Outliers =NULL){
    vector<float> ResultKLDVector;
    int numbmodal=DataImage->nu*DataImage->nt;
    int numbbins=128;
    vector<float*> ParametersVector=ParametersFromSeg(DataImage, Mask, Seg);
    vector<float *> DistHist=MakeDistHistogram(numbmodal, ParametersVector);
    
    vector<float *> DataHist=MakeDataHistogram(DataImage, Mask,Outliers);
    for (int m=0; m<numbmodal; m++) {
        float * DistHist_PTR=DistHist[m];
        float * DataHist_PTR=DataHist[m];
        float ResultKLD=0;
        int CountNanData=0;
        int CountNanDist=0;
        for (int i=0; i<numbbins; i++,DistHist_PTR++,DataHist_PTR++) {
            // Use of the symmetric KLD between the two distributions
            
            float DistValue=(*DistHist_PTR)<=0.00001?0.00001:(*DistHist_PTR);
            if (DistValue!=DistValue) {
                CountNanDist++;
            }
            float DataValue=(*DataHist_PTR)<=0.00001?0.00001:(*DataHist_PTR);
            if (DataValue!=DataValue) {
                CountNanData++;
            }
            ResultKLD+=0.5*(logf(((DistValue)/(DataValue)))*(*DistHist_PTR)+logf(((DataValue)/(DistValue)))*(*DataHist_PTR));
        }
        ResultKLDVector.push_back(ResultKLD);
    }
    return ResultKLDVector;
}

// Creates the Corrected Image given the non corrected image and the bias field image.
nifti_image * CreateBFCorrectedImage(nifti_image * DataImage, nifti_image* BFImage=NULL){
    // Check for good dimensionality correspondance
    if(BFImage==NULL){
        cout<<"No bias field correction to apply"<<endl;
        return DataImage;
    }
    if (DataImage->nx!=BFImage->nx || DataImage->nu!=BFImage->nu || DataImage->ny!=BFImage->ny || DataImage->nz!=BFImage->nz) {
        cout << "Dimensionality pb"<<endl;
        return DataImage;
    }
    else{
        TreeEM TempTree=TreeEM();
        TempTree.MultiplyNii(DataImage, BFImage);
    }
    return DataImage;
}

// Returns the image once normalisation has been performed
nifti_image * NormaliseImage(nifti_image * DataImage, nifti_image * Mask=NULL){
    // Build a basic Tree to perform the normalisation
    TreeEM Test=TreeEM(DataImage);
    Test.NormaliseDataImage();
    // Copy the result of the normalisation
    nifti_image* NormalisedData=nifti_copy_nim_info(Test.GetDataImage());
    NormalisedData->data=(void *)calloc(Test.GetDataImage()->nvox,sizeof(float));
    int numel=Test.GetDataImage()->nvox;
    float * NormalisedData_PTR=static_cast<float *>(NormalisedData->data);
    float * DataToCopy_PTR=static_cast<float *>(Test.GetDataImage()->data);
    for (int i=0; i<numel; i++,NormalisedData_PTR++,DataToCopy_PTR++) {
        *NormalisedData_PTR=*DataToCopy_PTR;
    }
    return NormalisedData;
}

//vector<nifti_image *> ReadFromFilenamesVector(vector<string> FilenamesVector){
//    int sizeVector=FilenamesVector.size();
//    std::cout<< "Number of Filenames is "<<sizeVector<<endl;
//    vector<nifti_image*> ImagesVector;
//    for (int f=0; f<sizeVector; f++) {
//        ImagesVector.push_back(nifti_image_read(FilenamesVector[f].c_str(), true));
//        //cout<< "Size of dimension x in image "<< nifti_image_read(FilenamesVector[f], true)->nx<<endl;
//    }
//    return ImagesVector;
//}


//    nifti_image * CreateDataImage(vector<nifti_image*> ImagesToSegment){
//        int finn=FirstNotNULL(ImagesToSegment);
//        int linn=LastNotNULL(ImagesToSegment);
//        std::cout<< "First not Null is "<<finn<< " and last is "<< linn<<endl;
//        if (linn-finn<0) {
//            std::cout<<"No Images To Segment"<<endl;
//            return NULL;
//        }
//        int nx=ImagesToSegment[finn]->nx;
//        int ny=ImagesToSegment[finn]->ny;
//        int nz=ImagesToSegment[finn]->nz;
//        nifti_image * CreatedImage=NULL;
//        if ((linn-finn)<0) { // no image in the vector
//            std::cout<<"no image in the vector"<<endl;
//            return CreatedImage;
//        }
//        else if((finn-linn)==0){ // only one image in the vector but can already be multimodal
//            std::cout<<"only one image in the vector"<<endl;
//            if (ImagesToSegment[finn]->datatype!=NIFTI_TYPE_FLOAT32){
//
//                seg_changeDatatype<float>(ImagesToSegment[finn]);
//            }
//            CreatedImage =nifti_copy_nim_info(ImagesToSegment[finn]);
//            float * ImageDataPtr=static_cast<float *>(ImagesToSegment[finn]->data);
//            CreatedImage->data = (void *) calloc(CreatedImage->nvox, sizeof(float));
//
//            float * CreatedImage_PTR_start=static_cast<float *>(CreatedImage->data);
//
//            float * CreatedImage_PTR=CreatedImage_PTR_start;
//            for (int i=0; i<CreatedImage->nvox; i++ ,CreatedImage_PTR++, ImageDataPtr ++) {
//                (*CreatedImage_PTR)=(*ImageDataPtr);
//            }
//            return CreatedImage;
//        }
//        else{ // for the moment only handle images with only 3 D and not 4D
//            std::cout<<"There are "<<linn-finn+1<<" images to consider"<<endl;
//
//            int numbmulti=0;
//            for (int i=finn; i<=linn; i++) {
//                if(ImagesToSegment[i]!=NULL){
//
//                    if (ImagesToSegment[finn]->datatype!=NIFTI_TYPE_FLOAT32){
//                        seg_changeDatatype<float>(ImagesToSegment[i]);
//                    }
//                    //                numbmulti+=ImagesToSegment[i]->nu*ImagesToSegment[i]->nt;
//                    numbmulti++;
//                }
//            }
//            CreatedImage =nifti_copy_nim_info(ImagesToSegment[finn]);
//            CreatedImage->dim[0]=4;
//            CreatedImage->dim[4]=numbmulti;
//            CreatedImage->dim[5]=1;
//            nifti_update_dims_from_array(CreatedImage);
//            CreatedImage->data = (void *) calloc(CreatedImage->nvox, sizeof(float));
//            float * CreatedImage_PTR_start=static_cast<float *>(CreatedImage->data);
//            float * ImageDataPtr;
//            float * CreatedImage_PTR=CreatedImage_PTR_start;
//            for (int m=finn; m<=linn; m++) {
//                if (ImagesToSegment[m]!=NULL) {
//                    if( ImagesToSegment[m]->nx!=nx || ImagesToSegment[m]->ny!=ny || ImagesToSegment[m]->nz!=nz){
//                        std::cout<<"Not compatible dimensions"<<endl;
//                    }
//                    else{
//                        int numel=ImagesToSegment[m]->nx*ImagesToSegment[m]->ny*ImagesToSegment[m]->nz;
//                        std::cout<<"Compatible dimensions"<<endl;
//                        seg_changeDatatype<float>(ImagesToSegment[m]);
//                        ImageDataPtr=static_cast<float *>(ImagesToSegment[m]->data);
//                        //                    for (int i=0; i<ImagesToSegment[m]->nvox; i++) {
//                        for(int i=0;i<numel;i++){
//                            (*CreatedImage_PTR)=(*ImageDataPtr);
//                            CreatedImage_PTR++;
//                            ImageDataPtr++;
//                        }
//                    }
//                }
//            }
//            //        for (int i=finn; i<=linn; i++) {
//            //            nifti_image_free(ImagesToSegment[i]);
//            //        }
//            //        ImagesToSegment.clear();
//            //        nifti_set_filenames(CreatedImage,"/Users/Carole/Documents/PhD/CreatedImage.nii.gz",0,0);
//            //        nifti_image_write(CreatedImage);
//            return CreatedImage;
//        }
//    }

/********************* METHODS TO REBUILD TREE AND SEG AND SUBSEQUENT ANALYSIS FROM TEXT FILE AND SEG TOT ***********************/

// Returns as vector of int, the list of modalities used in the model to obtain TreeEM. T1=1 T2=2 FLAIR=3 PD=4. Uses the text file where name of modalities is stored
vector<int> GetModalitiesFromTextFile(SEG_ANALYSIS * segment_analysis){
    vector<int> Modalities;
    if (segment_analysis->filename_TextFile==NULL) {
        return Modalities;
    }
    else {
        
        ifstream text (segment_analysis->filename_TextFile);
        //    text.open(TreeTextFile,ios::in);
        if(!text){
            std::cout<<"could not open the text file properly ! inGetModalities "<<segment_analysis->filename_TextFile<<endl;
            return Modalities;
        }
        else{
            std::string line;
            while(getline(text,line)){
                istringstream in(line);
                std:: string type;
                in >> type;
                if (type=="Modalities") {
                    std::string Modality="Modalities";
                    in >> Modality;
                    //                    cout<<Modality<<" ";
                    do{
                        if (Modality=="T1") {
                            Modalities.push_back(1);
                        }
                        else if(Modality=="T2"){
                            Modalities.push_back(2);
                        }
                        else if (Modality=="PD"){
                            Modalities.push_back(4);
                        }
                        else if (Modality=="FLAIR"){
                            Modalities.push_back(3);
                        }
                        in>>Modality;
                        //                        cout<<" * "<<Modality;
                    }while (in);
                }
            }
            return Modalities;
        }
    }
}

// Returns the Outliers mode from text file whose name is stored in segment_analysis.
int GetFlagOutliersFromTextFile(SEG_ANALYSIS * segment_analysis){
    int ResultFlagOutliers=0;
    if (segment_analysis->filename_TextFile==NULL) {
        return 0;
    }
    else {
        
        ifstream text (segment_analysis->filename_TextFile);
        //    text.open(TreeTextFile,ios::in);
        if(!text){
            std::cout<<"could not open the text file properly ! in GetFlagOutliersFromTextFile"<<endl;
            return 0;
        }
        else{
            std::string line;
            while(getline(text,line)){
                istringstream in(line);
                std:: string type;
                in >> type;
                
                if (type=="OutliersMode") {
                    in >> ResultFlagOutliers;
                }
                return ResultFlagOutliers;
            }
        }
    }
    return ResultFlagOutliers;
}
// When NormResp coming from overall segmentation has been plugged back into TreeSkeleton, reconstruct all other NormResp at other levels of the Tree. Especially needed when all files are not available at the same time to reconstruct perfectly the tree and still needed for analysis
void RebuildNormRespFromLeaves(TreeEM * TreeToRebuild){
    // we assume the tree has been properly rebuilt with the text file at least for the leaves
    // First set to NULL all Norm Resp that do not correspond to leaves.
    NullAllNonLeavesNormResp(TreeToRebuild);
    if (TreeToRebuild->GetNormResp()==NULL){
        int numbchild=TreeToRebuild->GetNumberChildren();
        for (int c=0; c<numbchild; c++) {
            RebuildNormRespFromLeaves(TreeToRebuild->GetChild(c));
        }
        float * NewNormRespToSet=SumNormRespChildren(TreeToRebuild);
        TreeToRebuild->SetNormResp(NewNormRespToSet);
        if (NewNormRespToSet!=NULL) {
            delete [] NewNormRespToSet;
            NewNormRespToSet=NULL;
        }
    }
}

// If Reconstructed tree used not good priors or pb with the files introduced, allows to reset all normResp that do not correspond to leaves and NULL priors as well
void NullAllNonLeavesNormResp(TreeEM * TreeToRebuild){
    if (TreeToRebuild->IsLeaf() || TreeToRebuild->GetNormResp()==NULL) {
        return;
    }
    else {
        TreeToRebuild->SetNormResp(NULL);
        int numbchild=TreeToRebuild->GetNumberChildren();
        for (int c=0; c<numbchild; c++) {
            NullAllNonLeavesNormResp(TreeToRebuild->GetChild(c));
        }
    }
}

// sum the norm resp of children to rebuild the norm resp of current node.
float * SumNormRespChildren(TreeEM * TreeToRebuild){
    float * ResultSumNormResp=NULL;
    int numelmasked=TreeToRebuild->GetNumberMaskedElements();
    if (TreeToRebuild->IsLeaf() && TreeToRebuild->GetNormResp()==NULL){
        return NULL;
    }
    if (TreeToRebuild->IsLeaf() && TreeToRebuild->GetNormResp()!=NULL) {
        ResultSumNormResp=new float[numelmasked];
        float * NormRespData=TreeToRebuild->GetNormResp();
        for (int i=0; i<numelmasked; i++) {
            ResultSumNormResp[i]=NormRespData[i];
        }
        return ResultSumNormResp;
    }
    else if(!TreeToRebuild->IsLeaf()){
        ResultSumNormResp=new float[numelmasked];
        for (int i=0; i<numelmasked; i++) {
            ResultSumNormResp[i]=0;
        }
        int numbchild=TreeToRebuild->GetNumberChildren();
        for (int c=0; c<numbchild; c++) {
            float * TmpNormResp=TreeToRebuild->GetChild(c)->GetNormResp();
            if (TmpNormResp!=NULL) {
                for (int i=0; i<numelmasked; i++) {
                    ResultSumNormResp[i]+=TmpNormResp[i];
                }
            }
        }
        return ResultSumNormResp;
    }
    return ResultSumNormResp;
}

// Give as vector of TreeNode the classes classified as WM outliers whereas should be considered as CSF (appears mostly when ICBM atlases with no atlas adaptation is performed and atrophy is very important).
vector<TreeEM *> FindCSFWMOutliers(TreeEM * TreeToAnalyse, vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    vector<TreeEM *> CSFWMOutliersVec;
    // First obtain list of all outliers related to WM
    vector<TreeEM *> WMOutliersVecToCheck=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexWM)->GetAllLeaves();
    int numbWMOutlierLeaves=WMOutliersVecToCheck.size();
    // Create SignComparison and ComparisonGCclasses according to modality.
    int * SignComparison=new int[numbmodal];
    int * ComparisonGC=new int[numbmodal];
    for (int m=0; m<numbmodal; m++) {
        switch (Modalities[m]) {
                case 1: {// T1 modality, must be hypo compared to GM
                    SignComparison[m]=-1;
                    ComparisonGC[m]=segment_analysis->IndexGM;
                }
                break;
                case 2: {// T2 modality, must be hyper compared to GM
                    SignComparison[m]=1;
                    ComparisonGC[m]=segment_analysis->IndexGM;
                }
                break;
                case 3:{ // FLAIR modality, must be hypo compared to GM
                    SignComparison[m]=-1;
                    ComparisonGC[m]=segment_analysis->IndexGM;
                }
                break;
            default:{
                SignComparison[m]=0;
                ComparisonGC[m]=segment_analysis->IndexGM;
            }
                break;
        }
    }
    // For each of the leaves under scrutiny, performs the comparison and select the ones that respect the comparison criteria in similar way as in FindLesionClasses
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    for (int l=0; l<numbWMOutlierLeaves; l++) {
        bool Check=1;
        if (WMOutliersVecToCheck[l]->GetDistributionType()!=2) { // At this stage, we do not consider the remaining uniform distributions...
            float * MeanLeaf=WMOutliersVecToCheck[l]->GetMeanDirect();
            for (int m=0; m<numbmodal; m++) {
                float CompDiff=MeanLeaf[m]-MeanGeneralClasses[ComparisonGC[m]][m];
                Check *=((CompDiff*SignComparison[m])>0);
                if (Check==0) {
                    break;
                }
            }
            if (Check) { // if all conditions apply then we consider that the WM outlier classified leave should be classified under the CSF mark.
                CSFWMOutliersVec.push_back(WMOutliersVecToCheck[l]);
            }
            delete [] MeanLeaf;
            MeanLeaf=NULL;
        }
    }
    
    //Clearing memory and returning result
    int numbGC=MeanGeneralClasses.size();
    for (int c=0; c<numbGC; c++) {
        delete [] MeanGeneralClasses[c];
        MeanGeneralClasses[c]=NULL;
    }
    delete [] SignComparison;
    delete [] ComparisonGC;
    SignComparison=NULL;
    ComparisonGC=NULL;
    return CSFWMOutliersVec;
}

// Performs a similar analysis as the one performed on the Gaussian WM outlier leaves but on the uniform component and return it as a nifti_image
nifti_image * FindCSFWMOutliersUniform(TreeEM * TreeToAnalyse, vector<int> Modalities, SEG_ANALYSIS * segment_analysis,nifti_image * CorrectionJuxta){
    int numel=TreeToAnalyse->GetNumberElements();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    // Initialise the result image
    nifti_image * CSFWMUniformImage=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    CSFWMUniformImage->dim[0]=3;
    CSFWMUniformImage->dim[4]=1;
    CSFWMUniformImage->dim[5]=1;
    nifti_update_dims_from_array(CSFWMUniformImage);
    CSFWMUniformImage->data=(void*)calloc(CSFWMUniformImage->nvox, sizeof(float));
    
    
    // As before create the SignComparison and the ComparisonGC used to detect the outliers classified under the WM uniform but truly belonging to the CSF tissue.
    int * SignComparison=new int[numbmodal];
    int * ComparisonGC=new int[numbmodal];
    for (int m=0; m<numbmodal; m++) {
        switch (Modalities[m]) {
                case 1: {// T1 modality, must be hypo compared to GM
                    SignComparison[m]=-1;
                    ComparisonGC[m]=segment_analysis->IndexGM;
                }
                break;
                case 2: {// T2 modality, must be hyper compared to GM
                    SignComparison[m]=1;
                    ComparisonGC[m]=segment_analysis->IndexGM;
                }
                break;
                case 3:{ // FLAIR modality, must be hypo compared to GM
                    SignComparison[m]=-1;
                    ComparisonGC[m]=segment_analysis->IndexGM;
                }
                break;
            default:{
                SignComparison[m]=0;
                ComparisonGC[m]=segment_analysis->IndexGM;
            }
                break;
        }
    }
    //    Realising the comparison based on the extracted uniform
    TreeEM * UniformWMOutlier=TreeToAnalyse->GetUniformLeavesVector()[segment_analysis->IndexWM]; // WARNING : we assume here a symmetric model where IndexWM is the same for the inlier and the outlier part of the model.
    float * CSFWMUniform_PTR=static_cast<float *>(CSFWMUniformImage->data);
    float * CorrectionJuxtaData=NULL;
    if (CorrectionJuxta!=NULL) {
        CorrectionJuxtaData=static_cast<float *>(CorrectionJuxta->data);
    }
    float * UniformToCheck=UniformWMOutlier->GetNormResp();
    float * DataCorrected=TreeToAnalyse->GetDataBFCorrected();
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    int j=0;
    for (int i=0; i<numel; i++,L2S_PTR++) {
        CSFWMUniform_PTR[i]=0;
        if (*L2S_PTR>=0) {
            // Realise the comparison
            float CompDiff=0;
            bool Check=1;
            for (int m=0; m<numbmodal; m++) {
                CompDiff=DataCorrected[m*numelmasked+j]-MeanGeneralClasses[ComparisonGC[m]][m];
                Check *=((CompDiff*SignComparison[m])>0);
                if (Check==0) {
                    break;
                }
            }
            if (Check) {
                if (CorrectionJuxtaData!=NULL) {
                    if(CorrectionJuxtaData[i]>0.001){
                        CSFWMUniform_PTR[i]=UniformToCheck[j];
                    }
                }
                else{
                    CSFWMUniform_PTR[i]=UniformToCheck[j];
                }
            }
            j++;
        }
    }
    
    //  Clearing memory and returning result
    int numbGC=MeanGeneralClasses.size();
    for (int c=0; c<numbGC; c++) {
        delete [] MeanGeneralClasses[c];
        MeanGeneralClasses[c]=NULL;
    }
    delete [] SignComparison;
    delete [] ComparisonGC;
    SignComparison=NULL;
    ComparisonGC=NULL;
    
    return CSFWMUniformImage;
}

//float * WeightLesionClasses(TreeEM * TreeToAnalyse, vector<TreeEM *> LesionClasses, float MahalThresh){
//    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
//    vector<float *> VarianceGeneralClass=TreeToAnalyse->GetVarianceGeneralClasses();
//    int numbLes=LesionClasses.size();
//    for(int l=0;l<numbLes;l++){
//        float MahalDL=CalculateMahalDist
//    }
//
//}

// Give as vector of TreeNode the Classes corresponding to lesions according to the Tree under analysis, the LesionRule under Rule structure, and the vector of modalities
vector<TreeEM *> FindLesionClasses(TreeEM * TreeToAnalyse,Rule * LesionRule, vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    vector<TreeEM *> LeavesOutliers=TreeToAnalyse->GetNodeOutlier()->GetAllLeaves();
    vector<TreeEM *> LesionClasses;
    int numbleaves=LeavesOutliers.size();
    vector<TreeEM *> InlierNodesVector=TreeToAnalyse->GetGeneralClassesVector();
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    bool * LesionLeavesBool=new bool[numbleaves];
    for (int l=0; l<numbleaves; l++) {
        LesionLeavesBool[l]=1; // Initially all OutliersLeaves considered as possible lesion classes
    }
    for (int l=0; l<numbleaves; l++) { // Taking out all uniform classes (separate handling if we want to)
        if (LeavesOutliers[l]->GetDistributionType()==2) {
            LesionLeavesBool[l]=0;
        }
    }
    int numbmodal=Modalities.size();
    cout<<"Checking modalities....";
    for (int m=0; m<numbmodal; m++) {
        cout<<"Modality "<<m <<" is "<<Modalities[m]<<" ";
    }
    cout<<"NumberTreeModalities "<<TreeToAnalyse->GetNumberModalities();
    cout<<endl;
    int numbmodalCheck=TreeToAnalyse->GetNumberModalities();
//    if (numbmodal < numbmodalCheck) { // if number of modalities in tree higher than number of modalities in image
//        cout<<"Inappropriate reading of number of modalities"<<endl;
//        int numbClasses=MeanGeneralClasses.size();
//        for (int c=0; c<numbClasses; c++) {
//            if (MeanGeneralClasses[c]!=NULL) {
//                delete [] MeanGeneralClasses[c];
//                MeanGeneralClasses[c]=NULL;
//            }
//        }
//        delete [] LesionLeavesBool;
//        LesionLeavesBool=NULL;
//        return LesionClasses;
//    }
//    else
    if (numbmodal > numbmodalCheck){ // Correspond to the case where using not right number of modalities because of progressive inclusion of modalities
        cout<<"Use of DataCorrected file with more modalities than what is used there"<<endl;
        cout<<"Previous modalities length is "<<Modalities.size();
        int DiffMod=numbmodal-numbmodalCheck;
        for (int msup=0; msup<DiffMod; msup++) {
            Modalities.pop_back();
        }
        cout<<" and new one is "<<Modalities.size()<<endl;
        
    }
    
    // Check if the considered leave respect the LesionRule
    int numbLesionClasses=0;
    for (int l=0; l<numbleaves; l++) {
        if (LesionLeavesBool[l]) {
            LesionLeavesBool[l]=CheckLeavesLesionRule(LeavesOutliers[l],LesionRule,MeanGeneralClasses);
        }
        if (LesionLeavesBool[l]) {
            numbLesionClasses++;
            LesionClasses.push_back(LeavesOutliers[l]);
        }
    }
    
    // Refine the selected LesionClasses
    // Get the global weight of each of the lesion class
    vector<TreeEM *> LeavesToCheck;
    vector<TreeEM *> LeavesTrulyLesions;
    int numbLesionInit=LesionClasses.size();
    for (int l=0; l<numbLesionInit; l++) {
        bool toCheck=ToCheckLesionLeave(LesionClasses[l],LesionRule,MeanGeneralClasses,Modalities);
        if (toCheck) {
            LeavesToCheck.push_back(LesionClasses[l]);
        }
        else{
            LeavesTrulyLesions.push_back(LesionClasses[l]);
        }
    }
    int numbLesionToCheck=LeavesToCheck.size();
    float * MeanTrueLesions=GetMeanDirectVector(LeavesTrulyLesions);
    cout << numbLesionToCheck<<" lesion classes to check"<<endl;
    for (int l=0;l<numbLesionToCheck;l++){
        bool reCheck=RefinedChecking(LeavesToCheck[l],LesionRule,MeanTrueLesions,TreeToAnalyse,LeavesTrulyLesions,Modalities,segment_analysis);
        if (reCheck) {
            LeavesTrulyLesions.push_back(LeavesToCheck[l]);
        }
        else{
            vector<int> HierarchyDiscarded=LeavesToCheck[l]->GetHierarchyVector();
            int sizeHierarch=HierarchyDiscarded.size();
            cout<<"Leaf ";
            for (int h=0; h<sizeHierarch; h++) {
                cout<<HierarchyDiscarded[h]<<" ";
            }
            
            cout << "not considered as lesion anymore"<<endl;
        }
    }
    
    //    Clearing memory and returning result
    int numbClasses=MeanGeneralClasses.size();
    for (int c=0; c<numbClasses; c++) {
        if (MeanGeneralClasses[c]!=NULL) {
            delete [] MeanGeneralClasses[c];
            MeanGeneralClasses[c]=NULL;
        }
    }
    if (MeanTrueLesions!=NULL) {
        delete [] MeanTrueLesions;
        MeanTrueLesions=NULL;
    }
    if (LesionLeavesBool!=NULL) {
        delete [] LesionLeavesBool;
        LesionLeavesBool=NULL;
    }
    
    if (segment_analysis->flag_checkInliers) {
        vector<TreeEM*> LesionClassesInliersToAdd=FindLesionClassesInliers(TreeToAnalyse, LesionRule, Modalities, segment_analysis);
        int sizeLCI=LesionClassesInliersToAdd.size();
        if (sizeLCI>0) {
            cout<<"There are inliers to consider as lesion like..."<<sizeLCI<<endl;
            for (int lci=0; lci<sizeLCI; lci++) {
                LeavesTrulyLesions.push_back(LesionClassesInliersToAdd[lci]);
            }
        }
    }
    
    
    int numbFinLesionClasses=LeavesTrulyLesions.size();
    cout<<numbFinLesionClasses<<" lesion classes";
    return LeavesTrulyLesions ;
}

vector <TreeEM *> FindClassesToInlier(TreeEM * TreeToAnalyse, vector<int> Modalities, vector<int> Rule){
    vector<TreeEM*> ResultsLeaves;
    int size_rule = Rule.size();
    int numbconditions = size_rule /4;
    int numelmasked = TreeToAnalyse->GetNumberMaskedElements();
    int numbmodal = TreeToAnalyse->GetNumberModalities();
    for(int i=0;i<numbconditions;i++){
        int source = Rule[i*4];
        int comp = Rule[i*4+1];
        int mod = Rule[i*4+2];
        int corresp_mod=0;
        int m_size = Modalities.size();
        for (int m=0;m<m_size;m++){
            if(Modalities[m]==mod){
                corresp_mod=m;
            }
        }
        int sign = Rule[i*4+3];
        vector<TreeEM*> TestedLeaves = TreeToAnalyse->GetNodeInlier()->GetChild(source)->GetAllLeaves();
        float * MeanToComp = GetMeanDataMulti(TreeToAnalyse->GetDataBFCorrected(),TreeToAnalyse->GetNodeInlier()->GetChild(comp)->GetNormResp(),numelmasked,numbmodal);
        int size_tested=TestedLeaves.size();
        for(int l=0;l<size_tested;l++){
            float * MeanTemp = GetMeanDataMulti(TreeToAnalyse->GetDataBFCorrected(),TestedLeaves[l]->GetNormResp(),numelmasked,numbmodal);
            if ((MeanTemp[corresp_mod]-MeanToComp[corresp_mod])*sign > 0){
                ResultsLeaves.push_back(TestedLeaves[l]);
            }
            delete[] MeanTemp;
        }
    }
    return ResultsLeaves;
}


vector<TreeEM*> FindLesionClassesInliersFLAIRonly(TreeEM * TreeToAnalyse, vector<int> Modalities, SEG_ANALYSIS * segment_analysis){
      vector<TreeEM*> PotentialInlierClasses;
      if (Modalities.size()>1 || Modalities[0]!=3){
          return PotentialInlierClasses;
      }
      vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
      float MeanGM = MeanGeneralClasses[segment_analysis->IndexGM][0];
      vector<float*> VarianceGeneralClasses = TreeToAnalyse->GetVarianceGeneralClassesVector();
      float VarGM = VarianceGeneralClasses[segment_analysis->IndexGM][0];
      cout << "Threshold mean inlier is " << MeanGM + 2*sqrt(VarGM) << endl;
      vector<TreeEM *>LeavesWMInlier=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetAllLeaves();
      for (int l = 0; l<LeavesWMInlier.size(); l++){
          float * MeanTemp = LeavesWMInlier[l]->GetMeanDirect();

          if (MeanTemp[0]> 2*sqrt(VarGM)+MeanGM){
              cout << "Mean for this test " << l <<" is "<< MeanTemp[0] << endl;
              PotentialInlierClasses.push_back(LeavesWMInlier[l]);
          }
      }
     return PotentialInlierClasses;
}

vector<TreeEM *> FindLesionClassesInliers(TreeEM * TreeToAnalyse,Rule * LesionRule, vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    vector<TreeEM *> PotentialInliersLesion;
    vector<TreeEM *>LeavesWMInlier=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetAllLeaves();
    int numbLeavesWMI=LeavesWMInlier.size();
    if(numbLeavesWMI<=1){
        return PotentialInliersLesion;
    }
    //    Get the leaf with maximal weight
    int indexLeafMax=0;
    float maxWeight=0;
    for(int l=0;l<numbLeavesWMI;l++){
        if(LeavesWMInlier[l]->GetNormWeight()>maxWeight){
            indexLeafMax=l;
            maxWeight=LeavesWMInlier[l]->GetNormWeight();
        }
    }
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    for (int l=0; l<numbLeavesWMI; l++) {
        bool LesionLeavesBool=CheckLeavesLesionRule(LeavesWMInlier[l],LesionRule,MeanGeneralClasses);
        if (LesionLeavesBool && l!=indexLeafMax) {
            PotentialInliersLesion.push_back(LeavesWMInlier[l]);
        }
    }
    
    int sizeGC=MeanGeneralClasses.size();
    for (int c=0; c<sizeGC; c++) {
        if (MeanGeneralClasses[c]!=NULL) {
            delete [] MeanGeneralClasses[c];
            MeanGeneralClasses[c]=NULL;
        }
    }
    return PotentialInliersLesion;
}

// Check if the subclass considered as possible lesion but under suspicion should be kept as lesion or should be discarded given the vector of truly lesion classes, the corresponding mean for the overall lesions, the tree to analyse and the list of modalities
bool RefinedChecking(TreeEM * LeaveToCheck,Rule * LesionRule, float * MeanTrueLesions, TreeEM * TreeToAnalyse, vector<TreeEM*> LeavesTrulyLesions,vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    if (!LeaveToCheck->IsLeaf() || LeaveToCheck->GetDistributionType()!=1) { // Check that we are trying to perform the refinement test on a leaf with Gaussian distribution
        cout <<"no refined checking since not a leaf"<<endl;
        return 1;
    }
    int numbmodal=Modalities.size();
    cout <<"numbmodal is "<<numbmodal;
    for (int m=0; m<numbmodal; m++) {
        cout << "Modality "<<m <<" is "<<Modalities[m];
    }
    cout<<endl;
    // Check if modalities considered in questionable correspond to available modalities
    int numbCheckingTests=LesionRule->RefinedCheck.size()/3;
    //    cout<<numbCheckingTests<<" checking tests"<<endl;
    bool * PossibleCheck= new bool[numbCheckingTests];
    int * CorrespondingModality=new int[numbCheckingTests];
    for (int q=0; q<numbCheckingTests; q++) {
        PossibleCheck[q]=0;
        CorrespondingModality[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->RefinedCheck[q*3]==Modalities[m]) {
                PossibleCheck[q]=1;
                CorrespondingModality[q]=m;
            }
        }
    }
    //Check if at least one of the questions is possible
    bool RefinedCheckPossible=0;
    for (int q=0; q<numbCheckingTests; q++) {
        if (PossibleCheck[q]) {
            RefinedCheckPossible=1;
            break;
        }
    }
    if (!RefinedCheckPossible) {
        cout<< "no possible refined check due to modality problem"<<endl;
        return 1; // consider as lesion even if questionable if no refined check possible
    }
    
    // Perform the questioning on the available questions
    bool RefinedCheck=1;
    //    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    //    int numbclasses=MeanGeneralClasses.size();
    //    float * MeanLesion=GetMeanDirectVector(LeavesTrulyLesions);
    //    MeanGeneralClasses.push_back(MeanLesion);
    //    int numbclasses=TreeToAnalyse->GetNumberGeneralClasses();
    float * CompareMeanRefined=CompareMeanLesion(LeavesTrulyLesions, LesionRule->RefinedCheck, TreeToAnalyse, Modalities);
    cout <<"Compare refined done in Refined checking"<<endl;
    float * MeanLeaf=LeaveToCheck->GetMean();
    for (int q=0; q<numbCheckingTests; q++) {
        if (PossibleCheck[q]) {
            float CompDiff=0;
            CompDiff=MeanLeaf[CorrespondingModality[q]]-CompareMeanRefined[q*numbmodal+CorrespondingModality[q]];
            //            if (LesionRule->RefinedCheck[q*3+2]>=numbclasses) {
            //                cout<<"Comparing to lesion set"<<endl;
            //                CompDiff=MeanLeaf[CorrespondingModality[q]]-MeanTrueLesions[CorrespondingModality[q]];
            //            }
            //            else{
            //            CompDiff=MeanLeaf[CorrespondingModality[q]]-MeanGeneralClasses[LesionRule->RefinedCheck[q*3+2]][CorrespondingModality[q]];
            //            }
            RefinedCheck*=(CompDiff*LesionRule->RefinedCheck[q*3+2]>0);
        }
    }
    
    // Check if we have to use RefineCheck2 : in use only if FLAIR not among the used modalities
    bool FLAIRUsed=0;
    for (int m=0; m<numbmodal; m++) {
        if (Modalities[m]==3) {
            FLAIRUsed=1;
            break;
        }
    }
    // If no FLAIR Used, must be more careful on the outliers classes from the GM to check : use of RefineCheck2
    vector<int> HierarchyVectorLeaf=LeaveToCheck->GetHierarchyVector();
    int OriginLeaveToCheck=HierarchyVectorLeaf[1];
    bool flag_GMOrigin=(OriginLeaveToCheck==segment_analysis->IndexGM);
    if (!FLAIRUsed && flag_GMOrigin) {
        float * CompareMeanRefined2=CompareMeanLesion(LeavesTrulyLesions, LesionRule->RefinedCheck2, TreeToAnalyse, Modalities);
        cout <<"no FLAIR so compare mean refined 2 performed"<<endl;
        int numbCheckingTests2=LesionRule->RefinedCheck2.size()/3;
        //        cout<<numbCheckingTests2<<" checking tests"<<endl;
        bool * PossibleCheck2= new bool[numbCheckingTests2];
        int * CorrespondingModality2=new int[numbCheckingTests2];
        for (int q=0; q<numbCheckingTests2; q++) {
            PossibleCheck2[q]=0;
            CorrespondingModality2[q]=-1;
            for (int m=0; m<numbmodal; m++) {
                if (LesionRule->RefinedCheck2[q*3]==Modalities[m]) {
                    PossibleCheck2[q]=1;
                    CorrespondingModality2[q]=m;
                }
            }
        }
        //Check if at least one of the questions is possible
        bool RefinedCheckPossible2=0;
        for (int q=0; q<numbCheckingTests2; q++) {
            if (PossibleCheck2[q]) {
                RefinedCheckPossible2=1;
                break;
            }
        }
        if (!RefinedCheckPossible2) {
            cout<< "no possible refined check 2 due to modality problem"<<endl;
            return RefinedCheck; // consider as lesion even if questionable if no refined check possible
        }
        
        // Perform the questioning on the available questions
        
        //        int numbclasses=TreeToAnalyse->GetNumberGeneralClasses();
        for (int q=0; q<numbCheckingTests2; q++) {
            float CompDiff2=0;
            if (PossibleCheck2[q]) {
                CompDiff2=MeanLeaf[CorrespondingModality2[q]]-CompareMeanRefined2[q*numbmodal+CorrespondingModality2[q]];
                RefinedCheck*=(CompDiff2*LesionRule->RefinedCheck2[q*3+2]>0);
            }
            
        }
        delete [] CompareMeanRefined;
        CompareMeanRefined=NULL;
        delete [] PossibleCheck2;
        PossibleCheck2=NULL;
        delete [] CorrespondingModality2;
        CorrespondingModality2=NULL;
        delete [] CompareMeanRefined2;
        CompareMeanRefined2=NULL;
    }
    
    
    // clearing memory and returning result
    delete [] CompareMeanRefined;
    CompareMeanRefined=NULL;
    delete [] PossibleCheck;
    PossibleCheck=NULL;
    delete[] CorrespondingModality;
    CorrespondingModality=NULL;
    return RefinedCheck;
    
}

// Determine if Considered leaf should be further checked : is it under suspicion or not.
bool ToCheckLesionLeave(TreeEM * LesionClassToCheck, Rule * LesionRule,vector<float *> MeanGeneralClasses,vector<int> Modalities){
    if (!LesionClassToCheck->IsLeaf() && LesionClassToCheck->GetDistributionType()!=1) {// Checking that we are considering a gaussian leaf
        cout << "we are not checking a gaussian leaf";
        return 0;
    }
    bool FLAIRUsed=0;
    int numbmodal=Modalities.size();
    for (int m=0; m<numbmodal; m++) {
        if (Modalities[m]==3) {
            FLAIRUsed=1;
            break;
        }
    }
    if(LesionRule->Questionable.size()==0 || FLAIRUsed){
        cout<<"nothing to question"<<endl;
        return 0;
    }
    //    if(LesionRule->Questionable.size()==0 ){
    //        cout<<"nothing to question"<<endl;
    //        return 0;
    //    }
    // Check if modalities considered in questionable correspond to available modalities
    int numbQuestionTests=LesionRule->Questionable.size()/3;
    bool * PossibleQuestions= new bool[numbQuestionTests];
    int * CorrespondingModality=new int[numbQuestionTests];
    for (int q=0; q<numbQuestionTests; q++) {
        PossibleQuestions[q]=0;
        CorrespondingModality[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->Questionable[q*3]==Modalities[m]) {
                PossibleQuestions[q]=1;
                CorrespondingModality[q]=m;
            }
        }
    }
    //Check if at least one of the questions is possible
    bool QuestionablePossible=0;
    for (int q=0; q<numbQuestionTests; q++) {
        if (PossibleQuestions[q]) {
            QuestionablePossible=1;
            break;
        }
    }
    if (!QuestionablePossible) {
        cout<< "no possible question due to modality problem"<<endl;
        return 0;
    }
    
    // Perform the questioning on the available questions
    bool ToCheckResult=1;
    float * MeanLeaf=LesionClassToCheck->GetMean();
    
    for (int q=0; q<numbQuestionTests; q++) {
        if (PossibleQuestions[q]) {
            float CompDiff=MeanLeaf[CorrespondingModality[q]]-MeanGeneralClasses[LesionRule->Questionable[q*3+2]][CorrespondingModality[q]];
            ToCheckResult*=(CompDiff*LesionRule->Questionable[q*3+1]>0);
        }
    }
    // clearing memory and returning result
    delete [] PossibleQuestions;
    PossibleQuestions=NULL;
    delete[] CorrespondingModality;
    CorrespondingModality=NULL;
    return ToCheckResult;
}

// Returns in vector of tree nodes, the leaves in inlier part of the model that would be related to outlier lesions given the lesion rule, the tree model, the list of modalities and the lesion image.
vector<TreeEM *> InlierSuspiciousClasses(Rule * LesionRule, TreeEM * TreeToAnalyse, vector<int> Modalities, nifti_image * LesionImageTot ){
    vector<TreeEM *> InlierSuspiciousClassesVector;
    if (LesionRule->CheckSuspiciousInliers.size()==0) { // Check that there are condition set in Rule to obtain the
        return InlierSuspiciousClassesVector;
    }
    float * MeanLesion=GetMeanLesion(LesionImageTot, TreeToAnalyse);
    
    // Then looking at the inlier classes
    int numbSuspiciousChecks=LesionRule->CheckSuspiciousInliers.size();
    vector<TreeEM *> VectorInliersToCheck=TreeToAnalyse->GetGeneralClassesVector();
    for (int s=0; s<numbSuspiciousChecks; s++) {
        vector<TreeEM *> VectorCurrentToCheck = VectorInliersToCheck[LesionRule->CheckSuspiciousInliers[s][0]]->GetAllLeaves();
        int numbClassesToCheck=VectorCurrentToCheck.size();
        int numbChecking=LesionRule->CheckSuspiciousInliers[s].size()-1;
        vector<int> CheckOfModality;
        for (int q=0; q<numbChecking; q++) {
            CheckOfModality.push_back(LesionRule->CheckSuspiciousInliers[s][1+q]);
        }
        int * CorrespondingModality=GetCorrespondingModality( Modalities, CheckOfModality);
        for (int c=0; c<numbClassesToCheck; c++) {
            bool Suspicious=1;
            float * MeanToCheck=VectorCurrentToCheck[c]->GetMean();
            for (int q=0; q<numbChecking; q++) {
                if (CorrespondingModality[q]>=0) {
                    Suspicious*=(((MeanToCheck[CorrespondingModality[q]]-MeanLesion[CorrespondingModality[q]])*LesionRule->CheckSuspiciousInliers[s][1+q])>0);
                }
                
            }
            if(Suspicious){
                InlierSuspiciousClassesVector.push_back(VectorCurrentToCheck[c]);
            }
        }
        delete [] CorrespondingModality;
        CorrespondingModality=NULL;
    }
    if (MeanLesion!=NULL) {
        delete [] MeanLesion;
        MeanLesion=NULL;
    }
    return InlierSuspiciousClassesVector;
}

// Goes one step further than previous function by building the image corresponding to suspicious inliers
nifti_image * SuspiciousImage(Rule * LesionRule, TreeEM * TreeToAnalyse, vector<int> Modalities, nifti_image * LesionImageTot){
    vector<TreeEM *> InlierSuspiciousClassesVector=InlierSuspiciousClasses(LesionRule,TreeToAnalyse,Modalities,LesionImageTot);
    int numbSuspicious=InlierSuspiciousClassesVector.size();
    int numel = TreeToAnalyse->GetNumberElements();
    if (numbSuspicious==0) { // No image built if no suspicious node
        return NULL;
    }
    else{
        nifti_image * LesionSuspiciousImage = nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
        LesionSuspiciousImage->dim[4]=numbSuspicious;
        if (numbSuspicious==1) { // According to number of suspicous nodes, final dimension of image can be modified
            LesionSuspiciousImage->dim[0]=3;
        }
        else{
            LesionSuspiciousImage->dim[0]=4;
        }
        // NormResp of suspicious classes concatenated in different 3D volumes
        nifti_update_dims_from_array(LesionSuspiciousImage);
        LesionSuspiciousImage->data=(void*)calloc(LesionSuspiciousImage->nvox, sizeof(float));
        float * LesionSuspiciousData=static_cast<float *>(LesionSuspiciousImage->data);
        float * LesionSuspiciousData_PTR=static_cast<float*>(LesionSuspiciousImage->data);
        int * L2S_PTR=TreeToAnalyse->GetL2S();
        for (int l=0; l<numbSuspicious; l++) {
            L2S_PTR=TreeToAnalyse->GetL2S();
            //        LesionImageData_PTR=&LesionImageData[indexLesion*numel];
            LesionSuspiciousData_PTR=&LesionSuspiciousData[l*numel];
            float * ToCopy_PTR=InlierSuspiciousClassesVector[l]->GetNormResp();
            //            TreeToAnalyse->SaveTmpResultMasked(ToCopy_PTR, "/Users/Carole/Documents/PhD/ToCopy.nii.gz");
            for(int i=0;i<numel;i++,L2S_PTR++,LesionSuspiciousData_PTR++){
                if (*L2S_PTR>=0) {
                    *LesionSuspiciousData_PTR=*ToCopy_PTR;
                    ToCopy_PTR++;
                }
            }
        }
        return LesionSuspiciousImage;
    }
}

// Returns in a integer array the index of modality given the type of modality and the checks.
int * GetCorrespondingModality(vector<int> Modalities, vector<int> ChecksVectorModality){
    int numbChecks=ChecksVectorModality.size();
    int numbmodal=Modalities.size();
    if (numbChecks ==0) {
        return NULL;
    }
    int * CorrespondingModality=new int [numbChecks];
    for (int q=0; q<numbChecks; q++) {
        CorrespondingModality[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (abs(ChecksVectorModality[q])==Modalities[m])
            CorrespondingModality[q]=m;
        }
    }
    return CorrespondingModality;
}


// Return the mean calculated when considering a vector of Leaves together. Assumes that the leaves come from the same tree with same corresoponding data image
float * GetMeanDirectVector(vector<TreeEM *> LeavesTrulyLesions){
    int numbLeavesLesion=LeavesTrulyLesions.size();
    if (numbLeavesLesion==0) {
        return NULL;
    }
    else if(numbLeavesLesion==1){
        return LeavesTrulyLesions[0]->GetMeanDirect();
    }
    else {
        int numelmasked=LeavesTrulyLesions[0]->GetNumberMaskedElements();
        int numbmodal=LeavesTrulyLesions[0]->GetNumberModalities();
        // Initialisation of new NormResp to consider for the calculation of the mean
        float * NormRespSum=new float [numelmasked];
        for (int i=0; i<numelmasked; i++) {
            NormRespSum[i]=0;
        }
        // Summing in NormRespSum
        for (int l=0; l<numbLeavesLesion; l++) {
            float * NormRespSum_PTR=NormRespSum;
            float * NormRespToAdd_PTR=LeavesTrulyLesions[l]->GetNormResp();
            for (int i=0; i<numelmasked; i++,NormRespSum_PTR++,NormRespToAdd_PTR++) {
                *NormRespSum_PTR+=*NormRespToAdd_PTR;
            }
        }
        // Calculation of the normalisation factor when calculating the mean
        float SumResp=0;
        for (int i=0; i<numelmasked; i++) {
            SumResp+=NormRespSum[i];
        }
        // Calculation of the mean
        float * MeanResult=new float[numbmodal];
        float * PointerToDataBegin=LeavesTrulyLesions[0]->GetDataBFCorrected();
        for (int m=0; m<numbmodal; m++) {
            float * PointerToDataBegin_PTR=&PointerToDataBegin[m*numelmasked];
            MeanResult[m]=0;
            for (int i=0; i<numelmasked; i++,PointerToDataBegin_PTR++) {
                MeanResult[m]+=NormRespSum[i]*(*PointerToDataBegin_PTR);
            }
        }
        //Normalisation of the mean
        for (int m=0; m<numbmodal; m++) {
            if (SumResp>0) {
                MeanResult[m]/=SumResp;
            }
            else {
                MeanResult[m]/=numelmasked;
            }
        }
        //clearing memory and returning final result
        delete [] NormRespSum;
        NormRespSum=NULL;
        return MeanResult;
    }
}

// From the Tree structure, the lesion rule and the vector of considered modalities build the lesion image by concatenating the corresponding 3D volumes. In this function, the uniform remaining part of the lesions are not treated.
nifti_image * ReconstructLesionImage(TreeEM * TreeToAnalyse,  Rule * LesionRule, vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    vector<TreeEM *> LesionClasses=FindLesionClasses(TreeToAnalyse, LesionRule, Modalities,segment_analysis);
    int numbLesionClasses=LesionClasses.size();
    //    cout<<numbLesionClasses<<" lesion classes";
    // Initialise nifti_image containing subcomponents answering the lesion rule
    nifti_image* LesionImage=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    LesionImage->dim[0]=4;
    LesionImage->dim[4]=numbLesionClasses;
    nifti_update_dims_from_array(LesionImage);
    LesionImage->data=(void *)calloc(LesionImage->nvox, sizeof(float));
    int numel=LesionImage->nx*LesionImage->ny*LesionImage->nz;
    float * LesionImageData=static_cast<float *>(LesionImage->data);
    float * LesionImageData_PTR=LesionImageData;
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    // Initialisation of LesionImage (filled with 0 at first)
    for (int i=0; i<numel*numbLesionClasses; i++) {
        LesionImageData[i]=0;
    }
    //    int indexLesion=0;
    for (int l=0; l<numbLesionClasses; l++) {
        L2S_PTR=TreeToAnalyse->GetL2S();
        //        LesionImageData_PTR=&LesionImageData[indexLesion*numel];
        LesionImageData_PTR=&LesionImageData[l*numel];
        float * ToCopy_PTR=LesionClasses[l]->GetNormResp();
        //            TreeToAnalyse->SaveTmpResultMasked(ToCopy_PTR, "/Users/Carole/Documents/PhD/ToCopy.nii.gz");
        for(int i=0;i<numel;i++,L2S_PTR++,LesionImageData_PTR++){
            if (*L2S_PTR>=0) {
                *LesionImageData_PTR=*ToCopy_PTR;
                ToCopy_PTR++;
            }
        }
    }
    return LesionImage;
}


//Build and return the image related to the lesion by adding weighted by their z-score the various Gaussian components as well as the elements coming from the remaining uniform distribution
nifti_image * ReconstructLesionImageTotWeighted(TreeEM *TreeToAnalyse, vector<TreeEM*> LesionClasses, nifti_image * LesionPartsFromUniform,vector<int>Modalities, SEG_ANALYSIS * segment_analysis,bool secondary, nifti_image * CorrectionJuxta){
    cout << "LesionClasses number "<< LesionClasses.size() << endl;

    string FilenamePA=nifti_makebasename(segment_analysis->filename_SegTot);
    int Index=FilenamePA.find_last_of('/');
    string FilenamePA_b=FilenamePA.substr(0,Index+1);

    string FilenamePA_e=FilenamePA.substr(Index+1,FilenamePA.length());
    string FilenameTesting=FilenamePA_b+"LesionInit_"+FilenamePA_e+".nii.gz";
    string FilenameMahal=FilenamePA_b+"LesionMahal_"+FilenamePA_e+".nii.gz";
    string FilenameWeighted=FilenamePA_b+"LesionWeighted_"+FilenamePA_e+".nii.gz";
    string FilenameWeighted2=FilenamePA_b+"LesionWeighted2_"+FilenamePA_e+".nii.gz";
    string FilenameData=FilenamePA_b+"DataRebuildTest_"+FilenamePA_e+".nii.gz";
    string FilenameTesting1=FilenamePA_b+"DataRebuildTest1_"+FilenamePA_e+".nii.gz";
    string FilenameNeighbour=FilenamePA_b+"NeighbourAdded_"+FilenamePA_e+".nii.gz";
    nifti_set_filenames(LesionPartsFromUniform,FilenameTesting.c_str(),0,0);
    nifti_image_write(LesionPartsFromUniform);
    //    First initialise the result
//    nifti_image* WeightedLesionImage=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
//    WeightedLesionImage->dim[0]=3;
//    WeightedLesionImage->dim[4]=1;
//    WeightedLesionImage->dim[5]=1;
//    nifti_update_dims_from_array(WeightedLesionImage);
//    WeightedLesionImage->data=(void *) calloc(WeightedLesionImage->nvox, sizeof(float));
    int numel=TreeToAnalyse->GetNumberElements();
    int numbLesion=LesionClasses.size();
    int * S2L=TreeToAnalyse->GetS2L();
    int * L2S=TreeToAnalyse->GetL2S();

    int numbmodal=TreeToAnalyse->GetNumberModalities();
    numbmodal=Modalities.size();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
//    float *WLIData=static_cast<float *>(WeightedLesionImage->data);
    float * WLIData=new float[numel];
    float ThresholdWeight=segment_analysis->weightThreshold;
    if (secondary){
        ThresholdWeight=2.0/3.0*ThresholdWeight;
    }
    for (int i=0; i<numel; i++) {
        WLIData[i]=0;
    }
//    float * DataImage=static_cast<float *>(TreeToAnalyse->GetDataImage()->data);
    float * DataImage=CreateLongPaddingMulti<float>(TreeToAnalyse->GetDataBFCorrected(), 0, TreeToAnalyse->GetL2S(), numel, numbmodal);
//   SaveTmpResult(&DataImage[numel],FilenameTesting1.c_str(),LesionPartsFromUniform);
   cout << "Data image test saved "<< endl;
    //    Second determination of variance for all inlier anatomical classes
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    float * MeanGenComp=MeanGeneralClasses[segment_analysis->weightCompClass];
    //    float * MeanGenComp=MeanGeneralClasses[segment_analysis->IndexGM];
    float * MeanGenCompWM=MeanGeneralClasses[segment_analysis->IndexWM];
    vector<float *> VarianceGeneralClasses=TreeToAnalyse->GetVarianceGeneralClassesVector();
    float * VarianceGenComp=VarianceGeneralClasses[segment_analysis->weightCompClass];
    //    float * VarianceGenComp=VarianceGeneralClasses[segment_analysis->IndexGM];
    float * VarianceGenCompWM=VarianceGeneralClasses[segment_analysis->IndexWM];
    //    for (int m1=0; m1<numbmodal; m1++) {
    //        for (int m2=0; m2<numbmodal; m2++) {
    //             cout<<VarianceGenComp[m1*numbmodal+m2]<<" ";
    //        }
    //        cout<<endl;
    //    }
    float * InvertVarianceGenComp=TreeToAnalyse->InvertMatrix(VarianceGenComp, numbmodal);
    float * InvertVarianceGenCompWM=TreeToAnalyse->InvertMatrix(VarianceGenCompWM, numbmodal);
    for (int m1=0; m1<numbmodal; m1++) {
        for (int m2=0; m2<numbmodal; m2++) {
            cout<<InvertVarianceGenComp[m1*numbmodal+m2]<<" ";
        }
        cout<<endl;
    }
    
    
    //    Only take into account relevant modalities used
    vector<int> PathoModalIndex;
    int numbmodalPatho=0;
    for (int m=0; m<numbmodal; m++) {
        if (Modalities[m]!=1) {
            PathoModalIndex.push_back(m);
            numbmodalPatho++;
        }
    }
    cout << numbmodalPatho <<" patho modalities "<< endl;
    
    //    for (int m=0; m<numbmodal; m++) {
    //        PathoModalIndex.push_back(m);
    //        numbmodalPatho++;
    //    }
    
    float * MeanGenCompSelected=new float[numbmodalPatho];
    float * MeanGenCompSelectedWM=new float[numbmodalPatho];
    for (int mp=0; mp<numbmodalPatho; mp++) {
        MeanGenCompSelected[mp]=MeanGenComp[PathoModalIndex[mp]];
        MeanGenCompSelectedWM[mp]=MeanGenCompWM[PathoModalIndex[mp]];
    }
    float * InvertVarianceSelected=new float[numbmodalPatho*numbmodalPatho];
    float * InvertVarianceSelectedWM=new float[numbmodalPatho*numbmodalPatho];
    for (int mp1=0; mp1<numbmodalPatho; mp1++) {
        for (int mp2=0; mp2<numbmodalPatho; mp2++) {
            InvertVarianceSelected[mp1*numbmodalPatho+mp2]=InvertVarianceGenComp[PathoModalIndex[mp1]*numbmodal+PathoModalIndex[mp2]];
            InvertVarianceSelectedWM[mp1*numbmodalPatho+mp2]=InvertVarianceGenCompWM[PathoModalIndex[mp1]*numbmodal+PathoModalIndex[mp2]];
        }
    }

    cout << "Variance inversion done"<<endl;
    
    
    
    
    int numbgen=VarianceGeneralClasses.size();
    //    Third for all classes in Lesion Class, build the vector of weights to assign according to the z score and the threshold value chosen for completely ascertain as lesion
    float * WeightLesionClasses=GetWeightLesionClasses(LesionClasses,TreeToAnalyse,segment_analysis);
    //    Consequently add these weighted components in the Weighted lesion image
    for (int l=0; l<numbLesion; l++) {
        float * NormRespToWeight=LesionClasses[l]->GetNormResp();
        float WeightToApply=WeightLesionClasses[l]>1?1:WeightLesionClasses[l];
        cout<<"The weight to apply for class "<<l<<" is "<<WeightToApply<<endl;
        float MaxNR=GetMax(NormRespToWeight, numelmasked);
        if (MaxNR>1) {
            cout<<"Potential NormResp problem"<<endl;
        }
        for (int i=0; i<numelmasked; i++) {
            WLIData[S2L[i]]+=WeightToApply*NormRespToWeight[i];
        }
    }
    
    
    //    Fourth, Take care elementwise of the image given from the uniform according to weight type
    float * OutNormResp=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    float * WMNormResp=TreeToAnalyse->GetNodeInlier()->GetNormResp();
    float * CorrectionJuxtaData=NULL;
    if (CorrectionJuxta!=NULL) {
        cout << "Correcting Juxta"<<endl;
        CorrectionJuxtaData=static_cast<float *>(CorrectionJuxta->data);
    }
    cout <<"juxta done"<<endl;
    nifti_image * WMI=HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp(), TreeToAnalyse, 0.5);
    cout << "WMI hard seg obtained"<<endl;
    float * WMI_init = CopyArray(static_cast<float*>(WMI->data),numel);
    nifti_image * GMI=HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp(),TreeToAnalyse,0.5);
    if(segment_analysis->flag_LesWMI>0){
        CorrectWMI(TreeToAnalyse,WMI,GMI,segment_analysis);
        cout << "Correcting for mahal WM within"<<endl;
    }
    float * WMI_corr = CopyArray(static_cast<float*>(WMI->data),numel);
    nifti_image * FullMaskNii=NULL;
    if (TreeToAnalyse->GetMask()==NULL){
        bool * MaskFull = ThresholdArray<float, bool>(WMI_init, -1, numel);
        FullMaskNii = CreateNiiFromArray(MaskFull, WMI, numel);
        delete [] MaskFull;
    }
    else{
        FullMaskNii=CreateNiiFromArray(static_cast<bool*>(TreeToAnalyse->GetMask()->data), WMI, numel);
    }
//    float * DataImage=CreateLongPaddingMulti<float>(TreeToAnalyse->GetDataBFCorrected(), 0, TreeToAnalyse->GetL2S(), numel, numbmodal);
   cout <<"Full Mask Nii obtained "<<endl;
   cout <<"numel time numbmodal "<< numel<< " "<<numbmodal<<" "<<DataImage<< endl;
    nifti_image * DataNii=CreateNiiFromArray(DataImage, TreeToAnalyse->GetDataImage(), numel*numbmodal);
    nifti_set_filenames(DataNii,FilenameData.c_str(),0,0);
            nifti_image_write(DataNii);
//    nifti_image * MahalImage=MahalDistMaps(WMI , FullMaskNii, TreeToAnalyse->GetDataImage());
    vector<int> DimVector;
    for(int d=0;d<3;d++){
        DimVector.push_back(DataNii->dim[d+1]);
    }
    cout << "Images obtained"<<endl;
    nifti_image * MahalImage=MahalDistMaps(WMI , FullMaskNii, DataNii);
    cout <<"Mahal obtained"<<endl;
    nifti_set_filenames(MahalImage,FilenameMahal.c_str(),0,0);
    nifti_image_write(MahalImage);
    nifti_image_free(WMI);
    nifti_image_free(FullMaskNii);
    float * MahalData=static_cast<float*>(MahalImage->data);
    std::vector<int>::iterator it;
    float * MahalToUse=NULL;
    it = find (Modalities.begin(), Modalities.end(), 3);
    int FLAIR_ind=it-Modalities.begin();
    if (it != Modalities.end()){
        MahalToUse=&MahalData[(FLAIR_ind+1)*numel];
    }
    else{
        MahalToUse=MahalData;
    }
    float * UniformData=static_cast<float *>(LesionPartsFromUniform->data);
    int numbClassesUnif=LesionPartsFromUniform->nu*LesionPartsFromUniform->nt;
    int CountPbSup1Lesion=0;
    float * NormRespWMO=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
    float * PriorsData=NULL;
    nifti_image * PriorsDGM = NULL;
    if (segment_analysis->flag_inPriorsDGM){
        PriorsDGM=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
        PriorsData=static_cast<float *>(PriorsDGM->data);
    }
    for (int i=0; i<numel; i++) {
        float ValueAdded=0;
        for (int c=0; c<numbClassesUnif; c++) {
            ValueAdded+=UniformData[c*numel+i];
        }
        if (L2S[i]>=0 && ValueAdded>=0.01) {
            float DataVec[10];
            for (int m=0; m<10; m++) {
                if (m<numbmodalPatho) {
                    DataVec[m]=DataImage[PathoModalIndex[m]*numel+i]; // In this tree, as reconstructed, the image correspond to the corrected version.
                }
                else{
                    DataVec[m]=0;
                }
            }
            float MahalDist=0;
//            cout <<"Choosing weighting"<<endl;
            switch (segment_analysis->flag_segWeighted) {
                    case 1:
//                     cout<<"Initial Mahal chosen"<<endl;
                    MahalDist=GetMahalDist(DataVec,MeanGenCompSelected,InvertVarianceSelected,numbmodalPatho);
                    break;
                    case 2:{
                        for (int m=0; m<numbmodalPatho; m++) {
                            MahalDist+=sqrtf((MeanGenCompSelected[m]-DataVec[m])*InvertVarianceSelected[m*numbmodalPatho+m]*(MeanGenCompSelected[m]-DataVec[m]));
                        }
                        MahalDist/=numbmodalPatho;
                    }
                    break;
                    case 4:{
                        float MahalDistGM=GetMahalDist(DataVec, MeanGenCompSelected, InvertVarianceSelected,numbmodalPatho);
                        float MahalDistWM=GetMahalDist(DataVec, MeanGenCompSelectedWM, InvertVarianceSelectedWM, numbmodalPatho);
                        MahalDist=0.5*(MahalDistGM+MahalDistWM);
                    }
                    break;
                default:
                    MahalDist=GetMahalDist(DataVec,MeanGenCompSelected,InvertVarianceSelected,numbmodalPatho);
                    MahalDist=MahalToUse[i];
                    break;
                    break;
            }
            if(CorrectionJuxta!=NULL){
                if (CorrectionJuxtaData[i]>0.01) {
                    ValueAdded+=CorrectionJuxtaData[i];
                    ValueAdded-=NormRespWMO[L2S[i]];
                }
                if (ValueAdded>1) {
                    CountPbSup1Lesion++;
                }
            }
            
            if (MahalDist>=ThresholdWeight) {
                WLIData[i]+=ValueAdded;
            }
            //            if (CorrectionJuxtaData!=NULL) {
            //                if(CorrectionJuxtaData[i]>0.01){
            //                    WLIData[i]+=ValueAdded;
            //                }
            //            }
            
            else{
                WLIData[i]+=MahalDist/(float)ThresholdWeight*ValueAdded;
            }
            if (WLIData[i]>1) {
                CountPbSup1Lesion++;
            }
            
            // Correction for within DGM ADDED APRIL 2016
            if (PriorsData!=NULL) {
                if( PriorsData[i]>0.5){
                    WLIData[i]=MahalDist/(float)(2*ThresholdWeight)*ValueAdded;
                    WLIData[i]=WLIData[i]>1?1:WLIData[i];

                }
                //            Correction for partially outliers not enough in WM
                if(MahalDist>ThresholdWeight+2 && OutNormResp[L2S[i]]>0.01 && WMNormResp[L2S[i]]>0.1 && PriorsData[i]<0.5 && it!=Modalities.end()){
                   WLIData[i]=1;
                            }
                if(secondary){
                    if(MahalDist>ThresholdWeight  && (WMNormResp[L2S[i]]>0.1 || PriorsData[i]>0.5) && it!=Modalities.end()){
                       WLIData[i]=1;
                                }
                }
            }


        }
    }
    if(PriorsData!=NULL && segment_analysis->flag_inPriorsICSF){
        cout <<"Use of priorICSF Neighbours"<<endl;
    float * NeighbourLesionsToAdd=AddingNeighbourLesions(WLIData,MahalToUse,TreeToAnalyse,segment_analysis);
//    SaveTmpResult(NeighbourLesionsToAdd,FilenameNeighbour.c_str(),LesionPartsFromUniform);
    cout <<"Addition possible from neighbours and WMI done" << endl;
    cout << CountNonZero(NeighbourLesionsToAdd,numel) << " number of lesion neighbour to add" <<endl;
    for(int i=0;i<numel;i++){
        if(it!=Modalities.end()){
        WLIData[i]+=NeighbourLesionsToAdd[i];
        }
        WLIData[i]=WLIData[i]>1?1:WLIData[i];
    }



    // CORRECTION FOR ARTEFACTS ALREADY IN THERE
    if (segment_analysis->flag_inArtefact && it == Modalities.end()){
        cout << "Correcting strongly for artefacts"<<endl;
        nifti_image * ArtefactsNii=ReadFromFilename(segment_analysis->filename_Artefact);
        float * ArtefactsData=static_cast<float*>(ArtefactsNii->data);
        for(int i=0;i<numel;i++){
            if (ArtefactsData[i]>0){
                WLIData[i]=0;
            }
        }
        nifti_image_free(ArtefactsNii);
        ArtefactsNii=NULL;
    }

    // CORRECTION FOR CEREBELLUM AND CORTICAL SHEET
    if (segment_analysis->flag_Parc && it!=Modalities.end()){
        nifti_image * ParcellationNii=ReadFromFilename(segment_analysis->filename_Parc);
        cout << "Using parcellation for cerebellar and cortical correction" << endl;
        float * ParcellationData=static_cast<float*>(ParcellationNii->data);
        int CorrectCerebellum=0;
        int CorrectVermices=0;
        int CorrectCortex=0;
        int CountPotDangerMod=0;
        float * MaskPotDanger=new float[numel];
        for(int i=0;i<numel;i++){
            MaskPotDanger[i]=0;
            if ((ParcellationData[i]>38.5 && ParcellationData[i]<44.6) || (ParcellationData[i]>71.5 && ParcellationData[i]<77.6) || ParcellationData[i]>100){
                MaskPotDanger[i]=1;
            }
            if (WLIData[i]>0 ){
                if (ParcellationData[i]>38.5 && ParcellationData[i]<44.6  && MahalToUse[i]<5){
                    if (segment_analysis->flag_correctCerr){
                    WLIData[i]=0;
                    }
                    else{
                       WLIData[i]=MahalToUse[i]>5?1:MahalToUse[i]/5;
                    }
//                    cout << WLIData[i]<<endl;
                    CorrectCerebellum++;
                }
                else if (ParcellationData[i]>71.5 && ParcellationData[i]<77.6 && MahalToUse[i]<5){
                    WLIData[i]=0;
                    CorrectVermices++;
                }
                else if (ParcellationData[i]>100 && MahalToUse[i]<6){
                    WLIData[i]=MahalToUse[i]>9?1:MahalToUse[i]/9;
                    CorrectCortex++;
                }
        }


    }
        float * DilatedDanger=Erosion_bis(MaskPotDanger,3,DimVector,0);
        for(int i=0;i<numel;i++){
            if(DilatedDanger[i]&&WLIData[i]>0){
                WLIData[i]=MahalToUse[i]>6?1:MahalToUse[i]/6;

                CountPotDangerMod++;
            }
        }
        delete [] MaskPotDanger;
        delete [] DilatedDanger;
        cout <<"Correct Cortex is "<<CorrectCortex<<" CorrectVermices "<<CorrectVermices<<" CorrectCerebellum "<<CorrectCerebellum<<" Modified Pot Danger "<< CountPotDangerMod<<endl;
                nifti_image * WeightedLesionImage=CreateNiiFromArray(WLIData,ParcellationNii,numel);
        nifti_image_free(ParcellationNii);
        ParcellationNii=NULL;

        nifti_set_filenames(WeightedLesionImage,FilenameWeighted.c_str(),0,0);
        nifti_image_write(WeightedLesionImage);
        nifti_image_free(WeightedLesionImage);
    }


    delete [] NeighbourLesionsToAdd;
    NeighbourLesionsToAdd=NULL;
    }
    delete [] WMI_corr;
    delete [] WMI_init;
    WMI_corr = NULL;
    WMI_init = NULL;
    cout<<"Count Pbsup1lesions is "<<CountPbSup1Lesion<<endl;
    //    Clearing memory before returning
    delete [] InvertVarianceGenComp;
    InvertVarianceGenComp=NULL;
    if (InvertVarianceGenCompWM!=NULL) {
        delete [] InvertVarianceGenCompWM;
        InvertVarianceGenCompWM=NULL;
    }
    if (MeanGenCompSelected!=NULL) {
        delete [] MeanGenCompSelected;
        MeanGenCompSelected=NULL;
    }
    if (MeanGenCompSelectedWM!=NULL) {
        delete [] MeanGenCompSelectedWM;
        MeanGenCompSelectedWM=NULL;
    }
    if (InvertVarianceSelected!=NULL) {
        delete [] InvertVarianceSelected;
        InvertVarianceSelected=NULL;
    }
    if (InvertVarianceSelectedWM!=NULL) {
        delete [] InvertVarianceSelectedWM;
        InvertVarianceSelectedWM=NULL;
    }
    for (int g=0; g<numbgen; g++) {
        delete [] MeanGeneralClasses[g];
        delete [] VarianceGeneralClasses[g];
        MeanGeneralClasses[g]=NULL;
        VarianceGeneralClasses[g]=NULL;
    }
    if (WeightLesionClasses!=NULL) {
        delete [] WeightLesionClasses;
        WeightLesionClasses=NULL;
    }
    if (DataImage!=NULL){
        delete [] DataImage;
        DataImage=NULL;
    }
    nifti_image * WeightedLesionImage=CreateNiiFromArray(WLIData,DataNii,numel);
    nifti_image_free(DataNii);
    nifti_image_free(MahalImage);
    MahalImage=NULL;
    
    if (PriorsData!=NULL){
        nifti_image_free(PriorsDGM);
        PriorsDGM=NULL;
    }

    nifti_set_filenames(WeightedLesionImage,FilenameWeighted2.c_str(),0,0);
    nifti_image_write(WeightedLesionImage);
    if (WLIData !=NULL){
        delete [] WLIData;
        WLIData=NULL;
    }
    return WeightedLesionImage;
}


float * AddingNeighbourLesions(float * WeightedLesionImage, float * MahalToUse,TreeEM *TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    int numel=TreeToAnalyse->GetNumberElements();
    int Dim[3];
    int Shift[3];
    float Pixdim[3];
    nifti_image * ImageRef=TreeToAnalyse->GetDataImage();
    for (int d=0; d<3; d++) {
        Dim[d]=ImageRef->dim[d+1];
        Pixdim[d]=ImageRef->pixdim[d+1];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
    }
    nifti_image * PriorsDGM=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
    nifti_image * PriorsICSF=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
    float * DGMData=static_cast<float*>(PriorsDGM->data);
    float * ICSFData=static_cast<float*>(PriorsICSF->data);
    float * Added=new float[numel];
    float * WM=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
    float * GM=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
    int * L2S=TreeToAnalyse->GetL2S();
    bool * ThresholdedLesion=ThresholdArray<float, bool>(WeightedLesionImage, 0.4, numel);
    bool * BorderLesion=CreateBorderFromBool(ThresholdedLesion, Dim, Shift);
    // for each element in BorderLesion, check if any of the neighbours fullfil one of the criteria
    int ListNeighbours[26];
    for(int i=0;i<numel;i++){
        Added[i]=0;
        if(BorderLesion[i]){
            GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 26);
            for(int n=0;n<26;n++){
                if(MahalToUse[ListNeighbours[n]]>3.5 && WM[L2S[ListNeighbours[n]]]>0.01){
                    Added[ListNeighbours[n]]=(MahalToUse[ListNeighbours[n]]-2)/3;
                }
                if(MahalToUse[ListNeighbours[n]]>5 && GM[L2S[ListNeighbours[n]]]>0.5 && DGMData[ListNeighbours[n]]+ICSFData[ListNeighbours[n]]>0.5){
                    Added[ListNeighbours[n]]=(MahalToUse[ListNeighbours[n]]-2)/3;
                }
            }
        }
                if(MahalToUse[i]>3.5 && WM[L2S[i]]>0.5 ){
                    Added[i]=(MahalToUse[i]-2)/3;
                }
            }
    nifti_image_free(PriorsICSF);
    nifti_image_free(PriorsDGM);
    delete [] BorderLesion;
    delete [] ThresholdedLesion;
    return Added;
        }



void CorrectDataAccordingToModa(TreeEM * TreeToAnalyse, vector<int> Modalities){
    int numbmodalTree=TreeToAnalyse->GetNumberModalities();
    int numbmodalVector=Modalities.size();
    if (numbmodalTree==numbmodalVector || numbmodalVector==0) {
        cout<<"Nothing to correct in terms of modalities for Tree"<<endl;
        return;
    }
    else{
        if (numbmodalVector<numbmodalTree) {
            nifti_image * DataToChange=TreeToAnalyse->GetDataImage();
            if (DataToChange!=NULL) {
                nifti_image * NewDataToSet=nifti_copy_nim_info(DataToChange);
                NewDataToSet->dim[0]=numbmodalVector==1?3:4;
                NewDataToSet->dim[4]=numbmodalVector;
                nifti_update_dims_from_array(NewDataToSet);
                NewDataToSet->data=(void *) calloc(NewDataToSet->nvox, sizeof(float));
                float * DataToChangeData=static_cast<float*>(DataToChange->data);
                float * NewDataToSetData=static_cast<float *>(NewDataToSet->data);
                int numbvox=NewDataToSet->nvox;
                for (int i=0; i<numbvox; i++) {
                    NewDataToSetData[i]=DataToChangeData[i];
                }
//                nifti_set_filenames(NewDataToSet, "/Users/Carole/Documents/PhD/SABRE_80/TempLook/187549I/NewData.nii.gz", 0, 0);
//                nifti_image_write(NewDataToSet);
                TreeToAnalyse->ChangeData(NewDataToSet);
                int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
                int numbvoxCorr=numbmodalVector*numelmasked;
                float * DataBFCorrectedToChange=TreeToAnalyse->GetDataBFCorrected();
                float * NewDataBFCorrected=new float[numbmodalVector*numelmasked];
                for (int i=0; i<numbvoxCorr; i++) {
                    NewDataBFCorrected[i]=DataBFCorrectedToChange[i];
                }
                TreeToAnalyse->SetDataBFCorrected(NewDataBFCorrected);
                if (NewDataBFCorrected!=NULL) {
                    delete [] NewDataBFCorrected;
                    NewDataBFCorrected=NULL;
                }
            }
        }
    }
}

//Return in a vector the weights associated with each lesion class
float * GetWeightLesionClasses(vector<TreeEM *>LesionClasses, TreeEM * TreeToAnalyse,SEG_ANALYSIS *segment_analysis){
    
    int numbLesion=LesionClasses.size();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    float * WeightMahal=new float[numbLesion];
    for (int l=0; l<numbLesion; l++) {
        WeightMahal[l]=0;
    }
    //    First calculate Mean General and variance general
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    vector<float *> VarianceGeneralClasses=TreeToAnalyse->GetVarianceGeneralClassesVector();
    //    Focus on MeanGenComp and VarianceGenComp
    float * MeanGenComp=MeanGeneralClasses[segment_analysis->weightCompClass];
    //    float * MeanGenComp=MeanGeneralClasses[segment_analysis->IndexGM];
    float * MeanGenCompWM=MeanGeneralClasses[segment_analysis->IndexWM];
    float * VarianceGenComp=VarianceGeneralClasses[segment_analysis->IndexGM];
    float * VarianceGenCompWM=VarianceGeneralClasses[segment_analysis->IndexWM];
    float * InvertVarianceGenComp=TreeToAnalyse->InvertMatrix(VarianceGenComp, numbmodal);
    float * InvertVarianceGenCompWM=TreeToAnalyse->InvertMatrix(VarianceGenCompWM, numbmodal);
    
    //    Select only the pathology related modalities :
    vector<int> Modalities=GetModalitiesFromTextFile(segment_analysis);
    if (Modalities.size()==0) {
        Modalities=segment_analysis->vecModalities;
    }
    numbmodal=TreeToAnalyse->GetNumberModalities();
    vector<int> PathoModalIndex;
    int numbmodalPatho=0;
    if (segment_analysis->flag_segWeighted<=4) {
        numbmodalPatho=0;
        for (int m=0; m<numbmodal; m++) {
            if (Modalities[m]!=1) {
                PathoModalIndex.push_back(m);
                numbmodalPatho++;
            }
        }
    }
    
    else{
        
        for (int m=0; m<numbmodal; m++) {
            PathoModalIndex.push_back(m);
            numbmodalPatho++;
        }
    }
    
    float * MeanGenCompSelected=new float[numbmodalPatho];
    float * MeanGenCompSelectedWM=new float[numbmodalPatho];
    for (int mp=0; mp<numbmodalPatho; mp++) {
        MeanGenCompSelected[mp]=MeanGenComp[PathoModalIndex[mp]];
        MeanGenCompSelectedWM[mp]=MeanGenCompWM[PathoModalIndex[mp]];
    }
    float * InvertVarianceSelected=new float[numbmodalPatho*numbmodalPatho];
    float * InvertVarianceSelectedWM=new float[numbmodalPatho*numbmodalPatho];
    for (int mp1=0; mp1<numbmodalPatho; mp1++) {
        for (int mp2=0; mp2<numbmodalPatho; mp2++) {
            InvertVarianceSelected[mp1*numbmodalPatho+mp2]=InvertVarianceGenComp[PathoModalIndex[mp1]*numbmodal+PathoModalIndex[mp2]];
            InvertVarianceSelectedWM[mp1*numbmodalPatho+mp2]=InvertVarianceGenCompWM[PathoModalIndex[mp1]*numbmodal+PathoModalIndex[mp2]];
        }
    }
    
    //    Vector of mahal distance
    for (int l=0; l<numbLesion; l++) {
        float * MeanToCompare=LesionClasses[l]->GetMeanDirect();
        float * SelectedMean=new float[numbmodalPatho];
        for (int mp=0; mp<numbmodalPatho; mp++) {
            SelectedMean[mp]=MeanToCompare[PathoModalIndex[mp]];
        }
        float MahalDistGen=GetMahalDist(MeanToCompare,MeanGenComp,InvertVarianceGenComp,numbmodal);
        cout<<"Mahal dist for class "<<l<<" is "<<MahalDistGen<<endl;
        float MahalDist=0;
        switch (segment_analysis->flag_segWeighted) {
                case 1:{
                    MahalDist=GetMahalDist(SelectedMean, MeanGenCompSelected, InvertVarianceSelected, numbmodalPatho);
                    for (int m=0; m<numbmodal; m++) {
                        cout<<"Partial Mahal is "<<sqrtf((MeanToCompare[m]-MeanGenComp[m])*(MeanToCompare[m]-MeanGenComp[m])*InvertVarianceGenComp[m*numbmodal+m])<<endl;
                    }
                }
                break;
                case 2:{
                    for (int m=0; m<numbmodalPatho; m++) {
                        MahalDist+=sqrtf((SelectedMean[m]-MeanGenCompSelected[m])*(SelectedMean[m]-MeanGenCompSelected[m])*InvertVarianceSelected[m*numbmodal+m]);
                    }
                    MahalDist/=numbmodalPatho;
                }
                break;
                case 4:{
                    float MahalDistGM=GetMahalDist(SelectedMean, MeanGenCompSelected, InvertVarianceSelected, numbmodalPatho);
                    float MahalDistWM=GetMahalDist(SelectedMean, MeanGenCompSelectedWM, InvertVarianceSelectedWM, numbmodalPatho);
                    MahalDist=0.5*(MahalDistWM+MahalDistGM);
                }
                break;
            default:{
                MahalDist=GetMahalDist(SelectedMean, MeanGenCompSelected, InvertVarianceSelected, numbmodalPatho);
                //                for (int m=0; m<numbmodalPatho; m++) {
                //                    MahalDist+=sqrtf((SelectedMean[m]-MeanGenCompSelected[m])*(SelectedMean[m]-MeanGenCompSelected[m])*InvertVarianceSelected[m*numbmodal+m]);
                //                }
                //                MahalDist/=numbmodalPatho;
            }
                break;
        }
        
        cout<<"Mahal dist for class "<<l<<" is "<<MahalDist<<endl;
        for (int m=0; m<numbmodal; m++) {
            cout<<"Partial Mahal is "<<sqrtf((MeanToCompare[m]-MeanGenComp[m])*(MeanToCompare[m]-MeanGenComp[m])*InvertVarianceGenComp[m*numbmodal+m])<<endl;
        }
        delete [] SelectedMean;
        SelectedMean=NULL;
        delete [] MeanToCompare;
        MeanToCompare=NULL;
        
        WeightMahal[l]=(MahalDist);
    }
    
    //        Depending on the option either consider directly compared to the threshold value of 3 for the Mahal distance or weight it compared to the maximal one obtained
    
    for (int l=0; l<numbLesion; l++) {
        WeightMahal[l]/=segment_analysis->weightThreshold;
    }
    if (segment_analysis->flag_segWeighted>=5) {
        cout<<"New weights to consider...";
        float MaxMahal=GetMax(WeightMahal, numbLesion);
        cout<<" max mahal is "<<MaxMahal<<endl;
        if (MaxMahal>1) {
            for (int l=0; l<numbLesion; l++) {
                WeightMahal[l]*=1.0/(MaxMahal);
                cout<<WeightMahal[l]<<" *** ";
            }
        }
        cout<<endl;
    }
    
    
    //    Clearing memory before returning
    delete [] InvertVarianceGenComp;
    InvertVarianceGenComp=NULL;
    if (InvertVarianceGenCompWM!=NULL) {
        delete [] InvertVarianceGenCompWM;
        InvertVarianceGenCompWM=NULL;
    }
    if (InvertVarianceSelectedWM!=NULL) {
        delete [] InvertVarianceSelectedWM;
        InvertVarianceSelectedWM=NULL;
    }
    delete [] InvertVarianceSelected;
    InvertVarianceSelected=NULL;
    delete [] MeanGenCompSelected;
    MeanGenCompSelected=NULL;
    int numbgen=MeanGeneralClasses.size();
    for (int g=0; g<numbgen; g++) {
        delete [] MeanGeneralClasses[g];
        delete [] VarianceGeneralClasses[g];
        MeanGeneralClasses[g]=NULL;
        VarianceGeneralClasses[g]=NULL;
    }
    
    return WeightMahal;
}

//Returns the float array of size numbmodal + numbmodal*numbmodal that contains the parameters (mean and covariance) for a given segmentation image considered float and the corresponding data
float * GetParamFromImages(nifti_image * Seg,nifti_image * Data,int Option=0){
    //    First Check compatibility between images
    bool flag_compatibility=CheckCompatibleDimensions(Seg, Data);
    if (!flag_compatibility) {
        return NULL;
    }
    int numel=Seg->nx*Seg->ny*Seg->nz;
    int numbmodal=Data->nu*Data->nt;
    int numbclasses=Seg->nu*Seg->nt;
    int sizeResultParam=numbclasses*numbmodal*(numbmodal+1);
    int sizeClassParam=numbmodal*(numbmodal+1);
    float * SegData=static_cast<float *>(Seg->data);
    float * ImageData=static_cast<float *>(Data->data);
    float * ResultParam=new float [sizeResultParam];
    for (int s=0; s<sizeResultParam; s++) {
        ResultParam[s]=0;
    }
    for (int c=0; c<numbclasses; c++) { // calculate the results per class
        float TotalElements=0;
        for(int i=0;i<numel;i++){
            float weight=0;
            switch (Option) {
                    case 0:{ // binary segmentation at threshold 0.5
                        if (SegData[i+numel*c]>0.5) {
                            weight=1;
                        }
                    }
                    break;
                    
                default:{
                    weight=SegData[i+numel*c];
                }
                    break;
            }
            
            for(int m=0;m<numbmodal;m++){
                ResultParam[m+c*sizeClassParam]+=weight*ImageData[m*numel+i];
            }
            TotalElements+=weight;
        }
        if(TotalElements>0){
            for(int m=0;m<numbmodal;m++){
                ResultParam[m+c*sizeClassParam]/=TotalElements;
            }
        }
        
        // Determination of the variance
        for(int i=0;i<numel;i++){
            float weight=0;
            switch (Option) {
                    case 0:{ // binary segmentation at threshold 0.5
                        if (SegData[i+numel*c]>0.5) {
                            weight=1;
                        }
                    }
                    break;
                    
                default:{
                    weight=SegData[i+numel*c];
                }
                    break;
            }
            for(int m1=0;m1<numbmodal;m1++){
                for(int m2=0;m2<numbmodal;m2++){
                    float Data1=ImageData[m1*numel+i];
                    float Data2=ImageData[m2*numel+i];
                    ResultParam[numbmodal+m1+m2*numbmodal+c*sizeClassParam]+=weight*(Data1-ResultParam[m1+c*sizeClassParam])*(Data2-ResultParam[m2+c*sizeClassParam]);
                }
            }
            
        }
        if(TotalElements>0){
            for(int m=0;m<numbmodal*numbmodal;m++){
                ResultParam[numbmodal+m+c*sizeClassParam]/=TotalElements;
            }
        }
    }
    return ResultParam;
}


float GetExtremaMahalDistLabel(int * OrderedLabel, int Label, float * MeanSeg, float * InvertedCovariance, nifti_image* DataComp,int OptionExtrema){
    int numel=DataComp->nx*DataComp->ny*DataComp->nz;
    int numbmodal=DataComp->nu*DataComp->nt;
    int maxLabel=GetMaxLabel(OrderedLabel, numel);
    if (Label>maxLabel || Label<1) {
        return -1;
    }
    float ExtremaMahal=OptionExtrema*-100;
    float * DataComp_PTR=static_cast<float *>(DataComp->data);
    for (int i=0 ; i<numel; i++) {
        if (OrderedLabel[i]==Label) {
            float MeanTmp[10];
            for (int m=0; m<10; m++) {
                if (m<numbmodal) {
                    MeanTmp[m]=DataComp_PTR[i+m*numel];
                }
                else{
                    MeanTmp[m]=0;
                }
            }
            float Mahal=GetMahalDist(MeanTmp, MeanSeg, InvertedCovariance, numbmodal);
            if ((Mahal-ExtremaMahal)*OptionExtrema>0) {
                ExtremaMahal=Mahal;
            }
        }
    }
    return ExtremaMahal;
}


// Calculate the Mahalanobis distance given the float array of the y and mean to compare as well as the covariance matrix and the number of modalities
float GetMahalDist(float * ValueArray, float * MeanArray, float * InvertVarianceArray, int numbmodal){
    float ResultMahal=0;
    
    for (int m1=0; m1<numbmodal; m1++) {
        float tmp=0;
        for (int m2=0; m2<numbmodal; m2++) {
            tmp+=InvertVarianceArray[m1*numbmodal+m2]*(ValueArray[m2]-MeanArray[m2]);
        }
        ResultMahal+=tmp*(ValueArray[m1]-MeanArray[m1]);
    }
    ResultMahal=sqrtf(ResultMahal);
    return ResultMahal;
}

// Build and return the image related to the lesion by adding all probabilities related to lesion both in gaussian lesion related subclasses and in uniform remaining parts of the model.
nifti_image * ReconstructLesionImageTot(TreeEM * TreeToAnalyse,Rule * LesionRule,vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    vector<TreeEM *> LesionClasses=FindLesionClasses(TreeToAnalyse, LesionRule, Modalities,segment_analysis);
    int numbLesionClasses=LesionClasses.size();
    int Shift[3];
    Shift[0]=1;
    Shift[1]=TreeToAnalyse->GetDataImage()->dim[2];
    Shift[2]=Shift[1]*TreeToAnalyse->GetDataImage()->dim[3];
    //    cout<<numbLesionClasses<<" lesion classes";
    // Initialise nifti_image containing subcomponents answering the lesion rule
    nifti_image* LesionImage=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    LesionImage->dim[0]=3;
    LesionImage->dim[4]=1;
    nifti_update_dims_from_array(LesionImage);
    LesionImage->data=(void *)calloc(LesionImage->nvox, sizeof(float));
    int numel=LesionImage->nx*LesionImage->ny*LesionImage->nz;
    float * LesionImageData=static_cast<float *>(LesionImage->data);
    float * LesionImageData_PTR=LesionImageData;
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    for (int i=0; i<numel; i++) {
        LesionImageData[i]=0;
    }
    for (int l=0; l<numbLesionClasses; l++) {
        L2S_PTR=TreeToAnalyse->GetL2S();
        LesionImageData_PTR=LesionImageData;
        float * ToCopy_PTR=LesionClasses[l]->GetNormResp();
        //            TreeToAnalyse->SaveTmpResultMasked(ToCopy_PTR, "/Users/Carole/Documents/PhD/ToCopy.nii.gz");
        for(int i=0;i<numel;i++,L2S_PTR++,LesionImageData_PTR++){
            //            if (i==76*Shift[0]+156*Shift[1]+68*Shift[2]) {
            //                cout<<"checking there for the moment "<<*ToCopy_PTR<<endl;
            //            }
            if (*L2S_PTR>=0) {
                *LesionImageData_PTR+=*ToCopy_PTR;
                ToCopy_PTR++;
            }
        }
    }
    // dealing with LesionUniformImage
    nifti_image * LesionUniform=LesionFromUniform(TreeToAnalyse, LesionRule, Modalities, LesionClasses,segment_analysis);
    if (LesionUniform!=NULL) {
        int numbunif=LesionUniform->dim[4];
        float * LesionUnifData=static_cast<float *>(LesionUniform->data);
        for (int u=0; u<numbunif; u++) {
            LesionImageData_PTR=LesionImageData;
            float * LesionUnifData_PTR=&LesionUnifData[numel*u];
            for (int i=0; i<numel; i++,LesionImageData_PTR++,LesionUnifData_PTR++) {
                //                if (i==76*Shift[0]+156*Shift[1]+68*Shift[2]) {
                //                    cout<<"checking there for the moment "<<*LesionUnifData_PTR<<endl;
                //                }
                *LesionImageData_PTR+=*LesionUnifData_PTR;
            }
        }
    }
    if (LesionUniform!=NULL) {
        nifti_image_free(LesionUniform);
        LesionUniform=NULL;
    }
    return LesionImage;
}

float * ProbaCorrWeight(TreeEM * TreeToAnalyse, RuleCorr* RuleCorrection, nifti_image* SegToAnalyse, vector<float*> MahalVec, SEG_ANALYSIS* segment_analysis){
    // First check that compatibility in terms of Modalities otherwise NULL
    int sizeModVec=segment_analysis->vecModalities.size();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    if (sizeModVec != numbmodal) {
        cout << "Impossible to do correction weighting due to modalities incompatibilities" << endl;
        return NULL;
    }
    if (SegToAnalyse==NULL) {
        return NULL;
    }
    int numel=TreeToAnalyse->GetNumberElements();
    float * CorrWeight=new float [numel];
    numbmodal=segment_analysis->vecModalities.size();
    int ValueBuffer=numbmodal+1;
    float * SegData=static_cast<float*>(SegToAnalyse->data);
    for (int i=0; i<numel; i++) {
        CorrWeight[i]=0;
        if (SegData[i]>0) {
            CorrWeight[i]=ValueBuffer;
            float ValueToAdd=0;
            for (int m=0; m<numbmodal; m++) {
                float ValueComp=MahalVec[m][i]*RuleCorrection->SignComparison[m];
                if (ValueComp>RuleCorrection->ZScoreComparisonMax[m]) {
                    ValueToAdd+=1;
                }
                else if (ValueComp<0){
                    ValueToAdd+=fmax(-RuleCorrection->ZScoreComparisonBuffer[m]/RuleCorrection->ZScoreComparisonMax[m]*fabs(ValueComp)/RuleCorrection->ZScoreComparisonBuffer[m],-1);
                }

                else if (ValueComp>RuleCorrection->ZScoreComparisonBuffer[m]){
                    ValueToAdd+=fmin(RuleCorrection->ZScoreComparisonBuffer[m]/RuleCorrection->ZScoreComparisonMax[m]*fabs(ValueComp)/RuleCorrection->ZScoreComparisonBuffer[m],1);
;
                }
            }
            CorrWeight[i]+=ValueToAdd/numbmodal;
        }
    }
    return CorrWeight;
}

int * ImproveCorrWeight(TreeEM * TreeToAnalyse, RuleCorr* RuleCorrection, nifti_image * SegToAnalyse, vector<float *> MahalVec, SEG_ANALYSIS * segment_analysis){
//    Initialise values
    int numel = TreeToAnalyse->GetNumberElements();
    vector<int> DimVector;
    int Dim[3];
    int Shift[3];
    for (int d=0; d<3; d++) {
        
        DimVector.push_back(SegToAnalyse->dim[d+1]);
        Dim[d]=DimVector[d];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
    }
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    int ValueBuffer=numbmodal+1;
//    Extend SegToAnalyse
    float * SegData=static_cast<float*>(SegToAnalyse->data);
    bool * SegBool=TranscribeArray<float, bool>(SegData, numel);
    bool * ExtendedSeg=ErosionTemplate(SegBool, 3, DimVector, 0);
    nifti_image * ExtendedSegNii=CreateNiiFromArray(ExtendedSeg, SegToAnalyse, numel);
//    GetCorrWeight for extended SegToAnalyse
    int * CorrWeightExtended=CreateCorrWeight(TreeToAnalyse, RuleCorrection, ExtendedSegNii, MahalVec, segment_analysis);
    
//    Find elements that should be corrected and look at their environment. If one of neighbours is not in SegToAnalyse but still connect to it and is more appropriate, add it to the segmentation
    int * CopyCorrWeight=MultiplyElementwiseChoose<int, bool, int>(CorrWeightExtended, SegBool, numel);
    int ListNeighbours1[18];
    int ListNeighbours2[18];
    int CountAdded=0;
    int CountDeleted=0;
    for (int i=0; i<numel; i++) {
        if (SegBool[i]) { // Check if in original Possibility
            if (CorrWeightExtended[i]<=ValueBuffer) { // Should be removed from segmentation
                // Delete it from CorrWeightExtended
                CopyCorrWeight[i]=0;
                CountDeleted++;
                GetListNeighbours_bis(ListNeighbours1, i, Dim, Shift, 18);
                for (int n=0; n<18; n++) {
                    if (!SegBool[ListNeighbours1[n]] && CopyCorrWeight[ListNeighbours1[n]]<=ValueBuffer) { // Only try with those that are not in SegBool nor in CopyCorrWeight
                        if (CorrWeightExtended[ListNeighbours1[n]]>ValueBuffer) {
//                            Check that one of the neighbours of this neighbour is in CopyCorrWeight
                            GetListNeighbours_bis(ListNeighbours2, ListNeighbours1[n], Dim, Shift, 18);
                            CopyCorrWeight[ListNeighbours1[n]]=10+CorrWeightExtended[ListNeighbours1[n]];
                            CountAdded++;
                            for (int n2=0; n2<18; n2++) {
                                if (CopyCorrWeight[ListNeighbours2[n2]]>ValueBuffer) {
                                    CopyCorrWeight[ListNeighbours1[n]]=CorrWeightExtended[ListNeighbours1[n]];
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    cout <<"Added by correction "<<CountAdded<<endl;
    cout <<"Deleted by correction "<<CountDeleted<<endl;
    return CopyCorrWeight;
}

int * CreateCorrWeight(TreeEM * TreeToAnalyse, RuleCorr * RuleCorrection, nifti_image * SegToAnalyse, vector<float*> MahalVec, SEG_ANALYSIS * segment_analysis){
    // First check that compatibility in terms of Modalities otherwise NULL
    int sizeModVec=segment_analysis->vecModalities.size();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    if (sizeModVec != numbmodal) {
        cout << "Impossible to do correction weighting due to modalities incompatibilities" << endl;
        return NULL;
    }
    if (SegToAnalyse==NULL) {
        return NULL;
    }
    int numel=TreeToAnalyse->GetNumberElements();
    int * CorrWeight=new int [numel];
    numbmodal=segment_analysis->vecModalities.size();
    int ValueBuffer=numbmodal+1;
    float * SegData=static_cast<float*>(SegToAnalyse->data);
    for (int i=0; i<numel; i++) {
        CorrWeight[i]=0;
        if (SegData[i]>0) {
            CorrWeight[i]=ValueBuffer;
            int ValueToAdd=0;
            for (int m=0; m<numbmodal; m++) {
                float ValueComp=MahalVec[m][i]*RuleCorrection->SignComparison[m];
                if (ValueComp>RuleCorrection->ZScoreComparisonMax[m]) {
                    ValueToAdd+=2;
                }
                else if (ValueComp<-1*RuleCorrection->ZScoreComparisonBuffer[m]){
                    ValueToAdd+=-1;
                }
                else if (ValueComp>RuleCorrection->ZScoreComparisonBuffer[m]){
                    ValueToAdd+=1;
                }
            }
            CorrWeight[i]+=ValueToAdd;
        }
    }
    return CorrWeight;
}


RuleCorr * BuildRuleCorrFromTextFile(SEG_ANALYSIS * segment_analysis){ // Building of rule for checking of consistency in segmentation depending on the different modalities.
    string FilenameRule;
    if (!segment_analysis->flag_RuleCorr) {
        cout<<"No text file given"<<endl;
        return NULL;
    }
    //       ifstream text(segment_analysis->filename_RuleTextFile);
    FilenameRule=segment_analysis->filename_RuleCorr;
    ifstream text(FilenameRule.c_str());
    //    ifstream text (segment_analysis->filename_RuleTextFile);
    //    text.open(TreeTextFile,ios::in);
    if(!text){
        std::cout<<"could not open the text file properly ! in BuildRuleFromTextFile"<<endl;
        return NULL;
    }
    else{ // Checked before that we are at the root so no worry on this side
        cout<<"Able to open "<<FilenameRule<<endl;
        RuleCorr * BuiltRule=new RuleCorr();
        std::string line;
        vector<int> ClassesCompPreVec;
        vector<int> SignCompVec;
        vector<float> ZScorePreVec;
        vector<float> ZScoreMaxVec;
        while(getline(text,line)){
            istringstream in(line);
            std:: string type;
            in >> type;
            if (type == "ClassComp") { // Populating ClassesCompPreVec
                int ClassComp=0;
                while(in >> ClassComp){
                    ClassesCompPreVec.push_back(ClassComp);
                }
            }
            if (type == "SignComp") { // Populating SignCompVec
                int SignComp=0;
                while(in >> SignComp){
                    SignCompVec.push_back(SignComp);
                }
            }
            if (type == "MaxComp") { // Populating MaxCompVec
                float MaxComp=0;
                while(in >> MaxComp){
                    ZScoreMaxVec.push_back(MaxComp);
                }
            }
            if (type == "BufferComp") { // Populating ClassesCompPreVec
                float BufComp=0;
                while(in >> BufComp){
                    ZScorePreVec.push_back(BufComp);
                }
            }
        }
            vector<int> Modalities=segment_analysis->vecModalities;
            int numbmodal=Modalities.size();
            for(int m=0;m<numbmodal;m++){
                BuiltRule->ClassesComparison.push_back(-1);
                BuiltRule->SignComparison.push_back(0);
                BuiltRule->ZScoreComparisonBuffer.push_back(0);
                BuiltRule->ZScoreComparisonMax.push_back(0);
            }
            int sizeComp=ClassesCompPreVec.size();
            int numbRules=sizeComp/2;
            std::vector<int>::iterator it;
            for(int r=0;r<numbRules;r++){
                it = find (Modalities.begin(), Modalities.end(), ClassesCompPreVec[2*r]);
                int Modind=it-Modalities.begin();
                BuiltRule->ClassesComparison[Modind]=ClassesCompPreVec[2*r+1];
            }
            sizeComp=SignCompVec.size();
             numbRules=sizeComp/2;
            for(int r=0;r<numbRules;r++){
                it = find (Modalities.begin(), Modalities.end(), SignCompVec[2*r]);
                int Modind=it-Modalities.begin();
                BuiltRule->SignComparison[Modind]=SignCompVec[2*r+1];
            }
            sizeComp=ZScorePreVec.size();
            numbRules=sizeComp/2;
            for(int r=0;r<numbRules;r++){
                it = find (Modalities.begin(), Modalities.end(), ClassesCompPreVec[2*r]);
                int Modind=it-Modalities.begin();
                BuiltRule->ZScoreComparisonBuffer[Modind]=ZScorePreVec[2*r+1];
            }
            sizeComp=ZScoreMaxVec.size();
            numbRules=sizeComp/2;
            for(int r=0;r<numbRules;r++){
                it = find (Modalities.begin(), Modalities.end(), ClassesCompPreVec[2*r]);
                int Modind=it-Modalities.begin();
                BuiltRule->ZScoreComparisonMax[Modind]=ZScoreMaxVec[2*r+1];
            }
        return BuiltRule;
        }
}


SimpleRule * BuildLCRuleFromTextFile(SEG_ANALYSIS * segment_analysis){
    string FilenameRule;
    if (!segment_analysis->flag_LCRuleTextFile) {
        cout<<"No text file given"<<endl;
        return NULL;
    }
    //       ifstream text(segment_analysis->filename_RuleTextFile);
    FilenameRule=segment_analysis->filename_LCRuleTextFile;
    ifstream text(FilenameRule.c_str());
    //    ifstream text (segment_analysis->filename_RuleTextFile);
    //    text.open(TreeTextFile,ios::in);
    if(!text){
        std::cout<<"could not open the text file properly ! in BuildRuleFromTextFile"<<endl;
        return NULL;
    }
    else{ // Checked before that we are at the root so no worry on this side
        cout<<"Able to open "<<FilenameRule<<endl;
        SimpleRule * BuiltRule=new SimpleRule();
        std::string line;
        vector<int> ClassesCompPreVec;
        vector<int> CompTypePreVec;
        vector<float> ZScorePreVec;
        vector<int> IndicesCorrespondance;
        IndicesCorrespondance.push_back(segment_analysis->IndexGM);
        IndicesCorrespondance.push_back(segment_analysis->IndexWM);
        IndicesCorrespondance.push_back(segment_analysis->IndexCSF);
        IndicesCorrespondance.push_back(segment_analysis->IndexOut);
        while(getline(text,line)){
            istringstream in(line);
            std:: string type;
            in >> type;
            if (type == "Modalities") { // Updating segment analysis
                int ModalityToCheck=0;
                while(in >> ModalityToCheck){
                    BuiltRule->Modalities.push_back(ModalityToCheck);
                }
            }
            if (type == "Origins") { // Updating segment analysis (used for saving files afterwards)
                int OriginsToAdd=-1;
                while(in >> OriginsToAdd){
                    BuiltRule->Origins.push_back(OriginsToAdd);
                }
            }
            if (type == "Classes") { // Updating segment analysis (used for saving files afterwards)
                int ClassesComp=-1;
                while(in >> ClassesComp){
                    ClassesCompPreVec.push_back(ClassesComp);
                }
            }
            if (type == "Type") { // Updating segment analysis (used for saving files afterwards)
                int CompType=-1;
                while(in >> CompType){
                    CompTypePreVec.push_back(CompType);
                }
            }
            if (type == "ZScore") { // Updating segment analysis (used for saving files afterwards)
                float ZScore=-1;
                while(in >> ZScore){
                    ZScorePreVec.push_back(ZScore);
                }
            }
    }
//        After reading the file, do the arrangement of Rules according to number of modalities for the arrays
        int numbModaRule=BuiltRule->Modalities.size();
        int numbRules=CompTypePreVec.size()/numbModaRule;
        int normSize=numbModaRule*numbRules;
        int preVecCompTypeSize=CompTypePreVec.size();
        int preVecClassesSize=ClassesCompPreVec.size();
        int preVecZScoreSize=ZScorePreVec.size();
//        Before anything, checking that there is the right amount of information for each category
        if (normSize!=preVecCompTypeSize) {
            delete  BuiltRule;
            return NULL;
        }
        if (normSize!=preVecClassesSize) {
            delete  BuiltRule;
            return NULL;
        }
        if (normSize!=preVecZScoreSize) {
            delete  BuiltRule;
            return NULL;
        }
        for (int r=0; r<numbRules; r++) {
            int * ClassesRule=new int[numbModaRule];
            int * TypeRule=new int[numbModaRule];
            float * ZScoreRule=new float[numbModaRule];
            for (int m=0; m<numbModaRule; m++) {
                ClassesRule[m]=ClassesCompPreVec[r*numbModaRule+m];
                TypeRule[m]=CompTypePreVec[r*numbModaRule+m];
                ZScoreRule[m]=ZScorePreVec[r*numbModaRule+m];
            }
            BuiltRule->ClassesComparison.push_back(ClassesRule);
            BuiltRule->ComparisonType.push_back(TypeRule);
            BuiltRule->ZScoreComparison.push_back(ZScoreRule);
        }
        cout<< BuiltRule->Origins.size()<<endl;
        return BuiltRule;
}
    
}

// Return the rule structure built from the rule text file and taking into account the Tree structure
Rule * BuildRuleFromTextFile(TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis,bool Type){
    
    string FilenameRule;
    if (Type) {
        if (!segment_analysis->flag_RuleTextFile) {
            cout<<"No text file given"<<endl;
            return NULL;
        }
        //       ifstream text(segment_analysis->filename_RuleTextFile);
        FilenameRule=segment_analysis->filename_RuleTextFile;
    }
    else{
        if (!segment_analysis->flag_OtherSeg) {
            cout<<"No text file given"<<endl;
            return NULL;
        }
        //        ifstream text(segment_analysis->filename_VesselRuleTextFile);
        FilenameRule=segment_analysis->filename_VesselRuleTextFile;
    }
    ifstream text(FilenameRule.c_str());
    //    ifstream text (segment_analysis->filename_RuleTextFile);
    //    text.open(TreeTextFile,ios::in);
    if(!text){
        std::cout<<"could not open the text file properly ! in BuildRuleFromTextFile"<<endl;
        return NULL;
    }
    else{ // Checked before that we are at the root so no worry on this side
        cout<<"Able to open "<<FilenameRule<<endl;
        int numbmodal=TreeToAnalyse->GetNumberModalities();
        //        int numbMainClasses=TreeToAnalyse->GetNumberGeneralClasses();
        int numbOutliersMainClasses=0;
        if (TreeToAnalyse->GetFlagOutliers()!=3 && TreeToAnalyse->GetFlagOutliers()<5) {
            numbOutliersMainClasses=1;
        }
        else{
            numbOutliersMainClasses=TreeToAnalyse->GetNodeOutlier()->GetNumberChildren();
        }
        
        // Initialisation of BuiltRule
        Rule * BuiltRule=new Rule();
        BuiltRule->CorrespondingGClassComparison=new int[numbmodal*numbOutliersMainClasses];
        BuiltRule->Acceptance=new bool[numbOutliersMainClasses];
        BuiltRule->AcceptanceUniform=new bool[numbOutliersMainClasses];
        BuiltRule->CorrespondingGClassComparisonUniform=new int[numbmodal*numbOutliersMainClasses];
        BuiltRule->SignComparison=new int[numbmodal*numbOutliersMainClasses];
        BuiltRule->SignComparisonUniform=new int[numbmodal*numbOutliersMainClasses];
        for (int o=0; o<numbOutliersMainClasses; o++) {
            BuiltRule->AcceptanceUniform[o]=0;
            BuiltRule->Acceptance[o]=0;
            for (int m=0; m<numbmodal; m++) {
                BuiltRule->CorrespondingGClassComparisonUniform[m*numbOutliersMainClasses+o]=1;
                BuiltRule->CorrespondingGClassComparison[m*numbOutliersMainClasses+o]=1;
                BuiltRule->SignComparisonUniform[m*numbOutliersMainClasses+o]=0;
                BuiltRule->SignComparison[m*numbOutliersMainClasses+o]=0;
            }
        }
        BuiltRule->Modalities=new int[numbmodal];
        vector<int> Modalities;
        if(segment_analysis->vecModalities.size()!=0){
            for (int m=0; m<numbmodal; m++) {
                BuiltRule->Modalities[m]=segment_analysis->vecModalities[m];
                Modalities.push_back(segment_analysis->vecModalities[m]);
            }
        }
        else{
            Modalities=GetModalitiesFromTextFile(segment_analysis);
            for (int m=0; m<numbmodal; m++) {
                BuiltRule->Modalities[m]=Modalities[m];
            }
        }
        std::string line;
        while(getline(text,line)){
            istringstream in(line);
            std:: string type;
            in >> type;
            if (type == "LesionRule") { // Updating segment analysis
                int LesionRule=0;
                in >> LesionRule;
                segment_analysis->LesionRuleType=LesionRule;
            }
            if (type == "LesionRuleUniform") { // Updating segment analysis (used for saving files afterwards)
                int LesionRuleUniform=0;
                in >> LesionRuleUniform;
                segment_analysis->LesionUniformRuleType=LesionRuleUniform;
            }
            if(type == "Acceptance"){
                int AcceptedClassOrigin=0;
                while(in >> AcceptedClassOrigin){
                    //                    in >> NeighborhoodClass;
                    if(AcceptedClassOrigin >= numbOutliersMainClasses){
                        cout<< "Impossible class acceptance offered"<<endl;
                        return BuiltRule;
                    }
                    BuiltRule->Acceptance[AcceptedClassOrigin]=1;
                }
            }
            if(type == "AcceptanceUniform"){
                int AcceptedClassUniformOrigin=0;
                while(in >> AcceptedClassUniformOrigin){
                    //                    in >> NeighborhoodClass;
                    if(AcceptedClassUniformOrigin >= numbOutliersMainClasses){
                        cout<< "Impossible class acceptance uniform offered"<<endl;
                        return BuiltRule;
                    }
                    BuiltRule->AcceptanceUniform[AcceptedClassUniformOrigin]=1;
                }
            }
            if(type == "Questionable"){
                int mod;
                int comp;
                int Cclass;
                while (in >> mod) {
                    in >>comp;
                    in>>Cclass;
                    BuiltRule->Questionable.push_back(mod);
                    BuiltRule->Questionable.push_back(comp);
                    BuiltRule->Questionable.push_back(Cclass);
                }
            }
            if (type == "QuestionableUniform") {
                int mod;
                int comp;
                int Cclass;
                while (in >> mod) {
                    in >>comp;
                    in>>Cclass;
                    BuiltRule->QuestionableUniform.push_back(mod);
                    BuiltRule->QuestionableUniform.push_back(comp);
                    BuiltRule->QuestionableUniform.push_back(Cclass);
                }
            }
            if (type == "InliersInclusion"){
                int mod;
                int comp;
                int Cclass; // comparison class
                int Aclass; // acceptance class
                while (in >> mod) {
                    in >>comp;
                    in>>Cclass;
                    in>>Aclass;
                    BuiltRule->InliersRule.push_back(mod);
                    BuiltRule->InliersRule.push_back(comp);
                    BuiltRule->InliersRule.push_back(Cclass);
                    BuiltRule->InliersRule.push_back(Aclass);
                }
            }
            if (type == "RefinedCheck") {
                int mod;
                int comp;
                int Cclass;
                while (in >> mod) {
                    in >>comp;
                    in>>Cclass;
                    BuiltRule->RefinedCheck.push_back(mod);
                    BuiltRule->RefinedCheck.push_back(comp);
                    BuiltRule->RefinedCheck.push_back(Cclass);
                }
            }
            if (type == "RefinedCheck2") {
                int mod;
                int comp;
                int Cclass;
                while (in >> mod) {
                    in >>comp;
                    in>>Cclass;
                    BuiltRule->RefinedCheck2.push_back(mod);
                    BuiltRule->RefinedCheck2.push_back(comp);
                    BuiltRule->RefinedCheck2.push_back(Cclass);
                }
            }
            if (type == "RefinedCheckUniform") {
                int mod;
                int comp;
                int Cclass;
                while (in >> mod) {
                    in >>comp;
                    in>>Cclass;
                    BuiltRule->RefinedCheckUniform.push_back(mod);
                    BuiltRule->RefinedCheckUniform.push_back(comp);
                    BuiltRule->RefinedCheckUniform.push_back(Cclass);
                }
            }
            if (type == "RefinedCheckUniform2") {
                int mod;
                int comp;
                int Cclass;
                while (in >> mod) {
                    in >>comp;
                    in>>Cclass;
                    BuiltRule->RefinedCheckUniform2.push_back(mod);
                    BuiltRule->RefinedCheckUniform2.push_back(comp);
                    BuiltRule->RefinedCheckUniform2.push_back(Cclass);
                }
            }
            if (type == "CheckSuspicious") {
                int suspInlier;
                int compModa;
                while (in >> suspInlier) {
                    in >> compModa;
                    int numbCheckSuspicious=BuiltRule->CheckSuspiciousInliers.size();
                    bool already=0;
                    for (int l=0; l<numbCheckSuspicious; l++) {
                        if(BuiltRule->CheckSuspiciousInliers[l][0]==suspInlier){
                            already=1;
                            BuiltRule->CheckSuspiciousInliers[l].push_back(compModa);
                        }
                    }
                    if (!already) {
                        vector<int> CheckToPush;
                        CheckToPush.push_back(suspInlier);
                        CheckToPush.push_back(compModa);
                        BuiltRule->CheckSuspiciousInliers.push_back(CheckToPush);
                    }
                }
            }
            if(type == "Modality"){
                int Mod;
                in >> Mod;
                // First check if Mod is among the modalities and keep the corresponding index
                bool CheckMod=0;
                int IndexModa=-1;
                for (int m=0; m<numbmodal; m++) {
                    if (Mod==Modalities[m]) {
                        IndexModa=m;
                        CheckMod=1;
                        break;
                    }
                }
                // Read the 4 lines that follow and contain the rules of comparison for the Gaussian and uniform leaves
                int CompValue;
                int ind2=0;
                int ind3=0;
                int ind4=0;
                int ind5=0;
                int CompClass;
                int CompValueUnif;
                int CompClassUnif;
                cout<< "check mode is "<<CheckMod<<" and numbOutliersMainClasses is "<<numbOutliersMainClasses<<endl;
                getline(text, line);
                istringstream in2(line);
                cout <<line<<endl;
                if (CheckMod) {
                    while (in2 >> CompValue) {
                        if (ind2<numbOutliersMainClasses) {
                            BuiltRule->SignComparison[IndexModa*numbOutliersMainClasses+ind2]=CompValue;
                            ind2++;
                        }
                    }
                }
                getline(text, line);
                istringstream in3(line);
                //                cout<<line<<endl;
                if (CheckMod) {
                    while (in3 >> CompClass){
                        if (ind3<numbOutliersMainClasses) {
                            BuiltRule->CorrespondingGClassComparison[IndexModa*numbOutliersMainClasses+ind3]=CompClass;
                            ind3++;
                        }
                    }
                }
                getline(text, line);
                istringstream in4(line);
                //                cout<<line<<endl;
                if (CheckMod) {
                    while (in4 >> CompValueUnif){
                        if (ind4<numbOutliersMainClasses) {
                            BuiltRule->SignComparisonUniform[IndexModa*numbOutliersMainClasses+ind4]=CompValueUnif;
                            ind4++;
                        }
                    }
                }
                getline(text, line);
                istringstream in5(line);
                //                cout<<line<<endl;
                if (CheckMod) {
                    while (in5 >> CompClassUnif){
                        if (ind5<numbOutliersMainClasses) {
                            BuiltRule->CorrespondingGClassComparisonUniform[IndexModa*numbOutliersMainClasses+ind5]=CompClassUnif;
                            ind5++;
                        }
                    }
                }
                
                //                if (CheckMod) {
                //                    while (in2 >> CompValue) {
                //                        if (ind2<numbOutliersMainClasses) {
                //                            BuiltRule->SignComparison[IndexModa*numbOutliersMainClasses+ind2]=in2;
                //                            ind2++;
                //                        }
                //                    }
                //                    while (in3 >> CompClass){
                //                        if (ind3<numbOutliersMainClasses) {
                //                            BuiltRule->CorrespondingGClassComparison[IndexModa*numbOutliersMainClasses+ind3]=in3;
                //                            ind3++;
                //                        }
                //                    }
                //                    while (in4 >> CompValueUnif){
                //                        if (ind3<numbOutliersMainClasses) {
                //                            BuiltRule->SignComparisonUniform[IndexModa*numbOutliersMainClasses+ind4]=in4;
                //                            ind4++;
                //                        }
                //                    }
                //                    while (in5 >> CompClassUnif){
                //                        if (ind5<numbOutliersMainClasses) {
                //                            BuiltRule->CorrespondingGClassComparisonUniform[IndexModa*numbOutliersMainClasses+ind5]=in5;
                //                            ind5++;
                //                        }
                //                    }
                //                }
            }
        }
        return BuiltRule;
    }
}

// Based on the lesion rule, and knowing the mean of the general classes, determines if considered leaf should be considered as lesion or not.
bool CheckLeavesLesionRule(TreeEM * Leaf,Rule * LesionRule,vector<float *> MeanGeneralClasses){
    // First Check if you are truly considering a leaf or not
    bool LesionAccept=1;
    if (!Leaf->IsLeaf()) {
        cout<<"Not testing a leaf"<<endl;
        LesionAccept=0;
        return LesionAccept;
    }
    int numbmodal=Leaf->GetNumberModalities();
    int numbOutliersClasses=1;
    if (Leaf->GetFlagOutliers()== 3 || Leaf->GetFlagOutliers() >=5) {
        numbOutliersClasses=Leaf->FindRoot()->GetNodeOutlier()->GetNumberChildren();
    }
    //    cout<<MeanGeneralClasses.size()<<" number of means to be compared to";
    vector<int> HierarchyLeaf=Leaf->GetHierarchyVector();
    float * MeanLeaf=Leaf->GetMeanDirect();
    //    cout<<"MeanLeaf ";
    //    for (int m=0;m<numbmodal;m++){
    //        cout<<MeanLeaf[m]<<" ";
    //    }
    //    cout<<endl;
    if (Leaf->GetFlagOutliers()==3 || Leaf->GetFlagOutliers()>=5) {
        int TissueOrigin=HierarchyLeaf[1];
        if (!LesionRule->Acceptance[TissueOrigin]) { // check if tissue considered for origin is accepted as origin for the lesion class
            //            cout<<"Tissue origin class not accepted"<<endl;
            LesionAccept=0;
        }
        else{
            float * CompDiff=new float[numbmodal];
            for (int m=0; m<numbmodal; m++) {
                CompDiff[m]=0;
                //                cout<<LesionRule->CorrespondingGClassComparison[m+TissueOrigin*numbmodal]<<" comparison to";
                CompDiff[m]=MeanLeaf[m]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparison[m+TissueOrigin*numbmodal]][m];
                CompDiff[m]=MeanLeaf[m]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparison[m*numbOutliersClasses+TissueOrigin]][m];
                //                cout<<"meanLeaf "<< m<<" "<<MeanLeaf[m]<<" and MGC "<<MeanGeneralClasses[LesionRule->CorrespondingGClassComparison[m*numbOutliersClasses+TissueOrigin]][m]<<endl;
                //                cout<< "test is"<<CompDiff[m]*LesionRule->SignComparison[m*numbOutliersClasses+TissueOrigin]<<endl;
                if (CompDiff[m]*LesionRule->SignComparison[m*numbOutliersClasses+TissueOrigin]<0) {
                    cout<<"Mean relationship not satisfied...";
                    LesionAccept=0;
                    break;
                }
            }
            delete [] CompDiff;
            CompDiff=NULL;
            
            cout <<"Leaf ";
            int sizeHierarch=HierarchyLeaf.size();
            for (int h=0; h<sizeHierarch; h++) {
                cout<<HierarchyLeaf[h]<<" ";
            }
            if (LesionAccept) {
                cout<<"accepted as lesion"<<endl;
            }
            else {
                cout <<"not accepted as lesion"<<endl;
            }
            if (MeanLeaf!=NULL) {
                delete [] MeanLeaf;
                MeanLeaf=NULL;
            }
            
            return LesionAccept;
        }
        if (MeanLeaf!=NULL) {
            delete [] MeanLeaf;
            MeanLeaf=NULL;
        }
        return LesionAccept;
    }
    if (MeanLeaf!=NULL) {
        delete [] MeanLeaf;
        MeanLeaf=NULL;
    }
    return LesionAccept;
}



// Trying to build in a simple way the lesion rules when considering a voxelwise segmentation

// Build and return the lesion image using the uniform distribution and concatenating the results obtained for each remaining uniform distribution
nifti_image * LesionVoxelwise(TreeEM * TreeToAnalyse, Rule * LesionRule, vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    if (TreeToAnalyse->GetFlagOutliers()==0) {
        cout<<"No outlier model considered"<<endl;
        return NULL;
    }



    vector<TreeEM*> VectorLeavesToUse=TreeToAnalyse->GetNodeOutlier()->GetAllLeaves();
    vector<TreeEM *> VectorLeavesToAdd;
    if(Modalities.size()==1 & Modalities[0]==3){
        VectorLeavesToAdd = FindLesionClassesInliersFLAIRonly(TreeToAnalyse, Modalities, segment_analysis);
    }
    if(segment_analysis->flag_checkInliers){
        VectorLeavesToAdd=FindLesionClassesInliers(TreeToAnalyse,LesionRule,Modalities,segment_analysis);
    }
    vector<TreeEM *> VecAllLeaves=TreeToAnalyse->GetAllLeaves();
    vector<TreeEM *> VecAllInliersLeaves=TreeToAnalyse->GetNodeInlier()->GetAllLeaves();
//    int sizeLT=VecAllLeaves.size();
    int sizeLI=VecAllInliersLeaves.size();
    int sizeTA=segment_analysis->vecLeavesToAdd.size();
    if(sizeTA>0){
        for (int sta=0 ; sta<sizeTA; sta++) {
            if(segment_analysis->vecLeavesToAdd[sta]<=sizeLI){
                VectorLeavesToAdd.push_back(VecAllInliersLeaves[segment_analysis->vecLeavesToAdd[sta]]);
            }
        }
    }
    int VLA=VectorLeavesToAdd.size();
    if (VLA>0) {
        for (int vla=0; vla<VLA; vla++) {
            VectorLeavesToUse.push_back(VectorLeavesToAdd[vla]);
        }
    }
    int numbToUse=VectorLeavesToUse.size();

    if (numbToUse==0) { // if no uniform, no need to go further down
        cout<<"No remaining leaves in the final model"<<endl;
        return NULL;
    }

    if(LesionRule->AcceptanceUniform==NULL){//meaning that we do not consider the uniform distribution in the description of the lesion components/ elements
        cout<<"No uniform taken into account"<<endl;
        return NULL;
    }
    //    float * Data=static_cast<float*>( TreeToAnalyse->GetDataImage()->data);
    //    float * Data_PTR= Data;
    float * Data_PTR=TreeToAnalyse->GetDataBFCorrected();
    int numbmodal=Modalities.size();

    // Creation and initialisation of LesionUniformImage
    nifti_image * LesionUniformImage = nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    LesionUniformImage->dim[4]=1;
    LesionUniformImage->dim[0]=3;
    nifti_update_dims_from_array(LesionUniformImage);
    LesionUniformImage->data=(void*)calloc(LesionUniformImage->nvox, sizeof(float));
    float * LesionData=static_cast<float*>(LesionUniformImage->data);
//    float * LesionData_PTR=LesionData;
    int numel=LesionUniformImage->nx*LesionUniformImage->ny*LesionUniformImage->nz;
    for (int i=0; i<numel; i++) {
        LesionData[i]=0;
    }

    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    TreeToAnalyse->AreNormRespValid();


    //Using QuestionableUniform and RefinedCheckingUniform if need be
    // Check if modalities considered in questionable correspond to available modalities
    int numbQuestionTests=LesionRule->QuestionableUniform.size()/3;
    bool * PossibleQuestions= new bool[numbQuestionTests];
    int * CorrespondingModalityQuestionUniform=new int[numbQuestionTests];
    for (int q=0; q<numbQuestionTests; q++) {
        PossibleQuestions[q]=0;
        CorrespondingModalityQuestionUniform[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->QuestionableUniform[q*3]==Modalities[m]) {
                PossibleQuestions[q]=1;
                CorrespondingModalityQuestionUniform[q]=m;
            }
        }
    }
    //Check if at least one of the questions is possible
    bool QuestionablePossible=0;
    for (int q=0; q<numbQuestionTests; q++) {
        if (PossibleQuestions[q]) {
            QuestionablePossible=1;
            break;
        }
    }
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int * S2L=TreeToAnalyse->GetS2L();
    int numbCheckingTests=LesionRule->RefinedCheckUniform.size()/3;
    bool * PossibleCheck= new bool[numbCheckingTests];
    int * CorrespondingModality=new int[numbCheckingTests];
    for (int q=0; q<numbCheckingTests; q++) {
        PossibleCheck[q]=0;
        CorrespondingModality[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->RefinedCheckUniform[q*3]==Modalities[m]) {
                PossibleCheck[q]=1;
                CorrespondingModality[q]=m;
            }
        }
    }
    // If rule regarding inliers, add elements satisfying condition
    if (LesionRule->InliersRule.size() > 0){
        int numbInclusion = LesionRule->InliersRule.size()/4;
        float * DataImage=CreateLongPaddingMulti<float>(TreeToAnalyse->GetDataBFCorrected(), 0, TreeToAnalyse->GetL2S(), numel, numbmodal);
        for(int inc=0;inc<numbInclusion;inc++){
            float CountAdded=0;
            vector<float> quantile;
            for(int m=0;m<numbmodal;m++){
                if (LesionRule->InliersRule[inc*4]==Modalities[m]){
                    cout << "modality is " << m << " " << Modalities[m] << " "<< LesionRule->InliersRule[inc*4+3]<< endl;
                    cout << sqrt(LesionRule->InliersRule[inc*4+1]*LesionRule->InliersRule[inc*4+1])/100 << " quantile "<< endl;
                    quantile.push_back(sqrt(LesionRule->InliersRule[inc*4+1]*LesionRule->InliersRule[inc*4+1])/100);
                    nifti_image *ToCompare = HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeInlier()->GetChild(LesionRule->InliersRule[inc*4+2])->GetNormResp(),TreeToAnalyse, 0.5);
                    float * ToCompareData=static_cast<float*>(ToCompare->data);
                    bool * ToCompareBool=TranscribeArray<float,bool>(ToCompareData,numel);
                    vector<float*> Quantiles = GetQuantilesMulti(DataImage, ToCompareBool,numel,numbmodal,quantile);
                    cout << Quantiles[m][0] << " quantiles for " << m << endl;
                    float * NormRespComp = TreeToAnalyse->GetNodeInlier()->GetChild(LesionRule->InliersRule[inc*4+3])->GetNormResp();
                    float * NormRespLong = CreateLong(NormRespComp,TreeToAnalyse->GetL2S(),numel);
                    for (int i=0;i<numel;i++){
                        if (DataImage[m*numel+i] * LesionRule->InliersRule[inc*4+1] > Quantiles[m][0]*LesionRule->InliersRule[inc*4+1] && NormRespLong[i]>0.2){
                            LesionData[i] += NormRespLong[i];
//                            cout << DataImage[m*numel+i] <<" "<< numel <<" "<< NormRespLong[i] <<" "<< endl;
                            CountAdded+=NormRespLong[i];
                        }
                    }
                    cout << CountAdded << "added from inliers rule "<< inc<<endl;
                    delete[] NormRespLong;
                    delete[] ToCompareBool;
                    nifti_image_free(ToCompare);
                }

            }
        }
        delete [] DataImage;
    }

    // For all lesion classes, check if all the rules apply; Here we consider only comparison to the mean of the classes.

        for(int i=0;i<numelmasked;i++){
            bool flag_ok=1;
            for (int q=0;q<numbCheckingTests;q++){
                if (PossibleCheck[q]){
                    int IndexClass=LesionRule->RefinedCheckUniform[q*3+2];
                    int typeComp=LesionRule->RefinedCheckUniform[q*3+1];
                    float Value=Data_PTR[CorrespondingModality[q]*numelmasked+i];
                    flag_ok*=(Value-MeanGeneralClasses[IndexClass][CorrespondingModality[q]])*typeComp>0;
                }
            }
            if (flag_ok==1){
                for (int u=0;u<numbToUse;u++){
                    LesionData[S2L[i]]+=VectorLeavesToUse[u]->GetNormResp()[i];
                }
            }
        }
        delete [] PossibleQuestions;
        delete [] CorrespondingModalityQuestionUniform;
        delete [] CorrespondingModality;
        delete [] PossibleCheck;
        int GenNumb=MeanGeneralClasses.size();
        for(int g=0;g<GenNumb;g++){
            delete MeanGeneralClasses[g];
            MeanGeneralClasses[g]=NULL;
        }
    return LesionUniformImage;

}











// Build and return the lesion image using the uniform distribution and concatenating the results obtained for each remaining uniform distribution
nifti_image * LesionFromTotOutliers(TreeEM * TreeToAnalyse, Rule * LesionRule, vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    if (TreeToAnalyse->GetFlagOutliers()==0) {
        cout<<"No outlier model considered"<<endl;
        return NULL;
    }
    
    
    
    vector<TreeEM*> VectorLeavesToUse=TreeToAnalyse->GetNodeOutlier()->GetAllLeaves();
    vector<TreeEM *> VectorLeavesToAdd;
    if(segment_analysis->flag_checkInliers){
        VectorLeavesToAdd=FindLesionClassesInliers(TreeToAnalyse,LesionRule,Modalities,segment_analysis);
    }
    vector<TreeEM *> VecAllLeaves=TreeToAnalyse->GetAllLeaves();
    vector<TreeEM *> VecAllInliersLeaves=TreeToAnalyse->GetNodeInlier()->GetAllLeaves();
//    int sizeLT=VecAllLeaves.size();
    int sizeLI=VecAllInliersLeaves.size();
    int sizeTA=segment_analysis->vecLeavesToAdd.size();
    if(sizeTA>0){
        for (int sta=0 ; sta<sizeTA; sta++) {
            if(segment_analysis->vecLeavesToAdd[sta]<=sizeLI){
                VectorLeavesToAdd.push_back(VecAllInliersLeaves[segment_analysis->vecLeavesToAdd[sta]]);
            }
        }
    }
    int VLA=VectorLeavesToAdd.size();
    if (VLA>0) {
        for (int vla=0; vla<VLA; vla++) {
            VectorLeavesToUse.push_back(VectorLeavesToAdd[vla]);
        }
    }
    int numbToUse=VectorLeavesToUse.size();
    
    if (numbToUse==0) { // if no uniform, no need to go further down
        cout<<"No remaining leaves in the final model"<<endl;
        return NULL;
    }
    
    if(LesionRule->AcceptanceUniform==NULL){//meaning that we do not consider the uniform distribution in the description of the lesion components/ elements
        cout<<"No uniform taken into account"<<endl;
        return NULL;
    }
    //    float * Data=static_cast<float*>( TreeToAnalyse->GetDataImage()->data);
    //    float * Data_PTR= Data;
    float * Data_PTR=TreeToAnalyse->GetDataBFCorrected();
    int numbmodal=Modalities.size();
    
    // Creation and initialisation of LesionUniformImage
    nifti_image * LesionUniformImage = nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    LesionUniformImage->dim[4]=numbToUse;
    if (numbToUse==1) {
        LesionUniformImage->dim[0]=3;
    }
    else{
        LesionUniformImage->dim[0]=4;
    }
    nifti_update_dims_from_array(LesionUniformImage);
    LesionUniformImage->data=(void*)calloc(LesionUniformImage->nvox, sizeof(float));
    float * LesionData=static_cast<float*>(LesionUniformImage->data);
    float * LesionData_PTR=LesionData;
    int numel=LesionUniformImage->nx*LesionUniformImage->ny*LesionUniformImage->nz;
    for (int i=0; i<numel*numbToUse; i++) {
        LesionData[i]=0;
    }
    
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    TreeToAnalyse->AreNormRespValid();
    
    
    //Using QuestionableUniform and RefinedCheckingUniform if need be
    // Check if modalities considered in questionable correspond to available modalities
    int numbQuestionTests=LesionRule->QuestionableUniform.size()/3;
    bool * PossibleQuestions= new bool[numbQuestionTests];
    int * CorrespondingModalityQuestionUniform=new int[numbQuestionTests];
    for (int q=0; q<numbQuestionTests; q++) {
        PossibleQuestions[q]=0;
        CorrespondingModalityQuestionUniform[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->QuestionableUniform[q*3]==Modalities[m]) {
                PossibleQuestions[q]=1;
                CorrespondingModalityQuestionUniform[q]=m;
            }
        }
    }
    //Check if at least one of the questions is possible
    bool QuestionablePossible=0;
    for (int q=0; q<numbQuestionTests; q++) {
        if (PossibleQuestions[q]) {
            QuestionablePossible=1;
            break;
        }
    }
    
    int numbCheckingTests=LesionRule->RefinedCheckUniform.size()/3;
    bool * PossibleCheck= new bool[numbCheckingTests];
    int * CorrespondingModality=new int[numbCheckingTests];
    for (int q=0; q<numbCheckingTests; q++) {
        PossibleCheck[q]=0;
        CorrespondingModality[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->RefinedCheckUniform[q*3]==Modalities[m]) {
                PossibleCheck[q]=1;
                CorrespondingModality[q]=m;
            }
        }
    }
    //Check if at least one of the checks is possible
    bool RefinedCheckPossible=0;
    for (int q=0; q<numbCheckingTests; q++) {
        if (PossibleCheck[q]) {
            RefinedCheckPossible=1;
            break;
        }
    }
    
    //Check if FLAIR
    bool FLAIRUsed=0;
    for (int m=0; m<numbmodal; m++) {
        if (Modalities[m]==3) {
            FLAIRUsed=1;
            break;
        }
    }
    bool * PossibleCheck2=NULL;
    int * CorrespondingModality2=NULL;
    int numbCheckingTests2=0;
    bool RefinedCheckPossible2=0;
    
    if (!FLAIRUsed) {
        numbCheckingTests2=LesionRule->RefinedCheckUniform2.size()/3;
        PossibleCheck2= new bool[numbCheckingTests2];
        CorrespondingModality2=new int[numbCheckingTests2];
        for (int q=0; q<numbCheckingTests2; q++) {
            PossibleCheck2[q]=0;
            CorrespondingModality2[q]=-1;
            for (int m=0; m<numbmodal; m++) {
                if (LesionRule->RefinedCheckUniform2[q*3]==Modalities[m]) {
                    PossibleCheck2[q]=1;
                    CorrespondingModality2[q]=m;
                }
            }
        }
        //Check if at least one of the checks is possible
        
        for (int q=0; q<numbCheckingTests2; q++) {
            if (PossibleCheck2[q]) {
                RefinedCheckPossible2=1;
                break;
            }
        }
    }
    
    if(PossibleCheck2==NULL){
        cout<< "Possible Check 2 NULL"<<endl;
    }
    
    int Shift[3];
    Shift[0]=1;
    Shift[1]=LesionUniformImage->dim[1];
    Shift[2]=Shift[1]*LesionUniformImage->dim[2];
    
    int TestInd=148*Shift[0]+119*Shift[1]+120*Shift[2];
    
    // Filling of LesionUniformImage according to rule
    for (int u=0; u<numbToUse; u++) {
        cout<< "checking for uniform... "<<u<<endl;
        if (TreeToAnalyse->GetFlagOutliers()==3 || TreeToAnalyse->GetFlagOutliers()>=5) {
            int * L2S_PTR=TreeToAnalyse->GetL2S();
            int * L2S=TreeToAnalyse->GetL2S();
            int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
            int numbOutliersClasses=TreeToAnalyse->GetNodeOutlier()->GetNumberChildren();
            float * NormResp_PTR=VectorLeavesToUse[u]->GetNormResp();
            //            TreeToAnalyse->SaveTmpResultMasked(NormResp_PTR, "/Users/Carole/Documents/PhD/TestUniform.nii.gz");
            vector<int> HierarchUnif=VectorLeavesToUse[u]->GetHierarchyVector();
            int TissueOrigin=HierarchUnif[1];
            if (!LesionRule->AcceptanceUniform[TissueOrigin] && (!segment_analysis->flag_TO||segment_analysis->flag_correctionLevel==1)) { // check if tissue considered for origin is accepted as origin for the lesion class
                               cout<<"Tissue origin class not accepted in uniform check for origin "<<TissueOrigin<<endl;
            }
            else{
                //                int numbGeneralClasses=TreeToAnalyse->GetChild(0)->GetNumberChildren();
                vector<TreeEM *> WMInliers=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetAllLeaves();
                float * MeanLesion=GetMeanDirectVector(WMInliers);
                float * CompareMeanQuestionableUniform=CompareMeanLesion(WMInliers, LesionRule->QuestionableUniform, TreeToAnalyse, Modalities);
                //                int qu=0;
                //                cout<<"Printing CompareMeanQuestionableUniform..."<<endl;
                //                for (int q=0; q<numbQuestionTests;q++ ) {
                //                    if (PossibleQuestions[q]) {
                //                        for (int m=0; m<numbmodal; m++) {
                //                            cout<< CompareMeanQuestionableUniform[qu*numbmodal+m]<<" ";
                //                        }
                //                        qu++;
                //                    }
                //                    cout<<endl;
                //                }
                //                cout << "Creating CompareMeanRefinedUniform"<<endl;
                cout <<"CompareMeanQuestionabeUniform done"<<endl;
                float * CompareMeanRefinedUniform=CompareMeanLesion(WMInliers,LesionRule->RefinedCheckUniform,TreeToAnalyse,Modalities);
                cout <<"CompareMeanRefinedUniform done"<<endl;
                float * CompareMeanRefinedUniform2=CompareMeanLesion(WMInliers, LesionRule->RefinedCheckUniform2, TreeToAnalyse, Modalities);
                cout <<"CompareMeanRefinedUniform2 done"<<endl;
                int CountVoxelToCheck=0;
                //                cout<< "Beginning comparison for uniform"<< endl;
                int CountChangeCompDiffFirstSign=0;
                for (int i=0; i<numel; i++,L2S_PTR++) {
                    bool CompDiff=1;
                    //                    if (i==76+156*Shift[1]+68*Shift[2]) {
                    //                        cout<<"Stay there for the moment..."<<endl;
                    //                    }
                    if (*L2S_PTR>=0) {
                        for (int m=0; m<numbmodal; m++) {
                            //                            float Diff=Data_PTR[m*numel+i]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m*numbOutliersClasses+TissueOrigin]][m];
                            float Diff=Data_PTR[m*numelmasked+L2S[i]]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m*numbOutliersClasses+TissueOrigin]][m];
                            CompDiff*=((Diff*LesionRule->SignComparisonUniform[m*numbOutliersClasses+TissueOrigin])>=0);
                        }
                        if (CompDiff==0) {
                            CountChangeCompDiffFirstSign++;
                        }
                        
                        if (CompDiff && (*NormResp_PTR>0)) { // Check further only supposed to be checked
                            bool ToCheckResult=1;
                            //                            if (QuestionablePossible) {
                            //
                            //                            }
                            if (QuestionablePossible && !FLAIRUsed) {
                                for (int q=0; q<numbQuestionTests; q++) {
                                    if (PossibleQuestions[q]) {
                                        float CompDiffQuestion=0;
                                        CompDiffQuestion=Data_PTR[CorrespondingModalityQuestionUniform[q]*numelmasked+L2S[i]]-CompareMeanQuestionableUniform[q*numbmodal+CorrespondingModalityQuestionUniform[q]];
                                        //                                    if (LesionRule->QuestionableUniform[q*3+2]>=numbGeneralClasses) {
                                        //                                        if (MeanLesion!=NULL) {
                                        //                                            CompDiffQuestion=Data_PTR[CorrespondingModalityQuestionUniform[q]*numel+i]-MeanLesion[CorrespondingModalityQuestionUniform[q]];
                                        //                                        }
                                        //
                                        //                                    }
                                        //                                    else {
                                        //                                        CompDiffQuestion=Data_PTR[CorrespondingModalityQuestionUniform[q]*numel+i]-MeanGeneralClasses[LesionRule->QuestionableUniform[q*3+2]][CorrespondingModalityQuestionUniform[q]];
                                        //                                    }
                                        ToCheckResult*=((CompDiffQuestion*LesionRule->QuestionableUniform[q*3+1])>0);
                                    }
                                }
                            }
                            else {
                                ToCheckResult=0;
                            }
                            if (ToCheckResult) {
                                CountVoxelToCheck++;
                                for (int q=0; q<numbCheckingTests; q++) {
                                    if (PossibleCheck[q]) {
                                        float CompDiffCheck=0;
                                        //                                        CompDiffCheck=Data_PTR[CorrespondingModality[q]*numel+i]-CompareMeanRefinedUniform[q*numbmodal+CorrespondingModality[q]];
                                        CompDiffCheck=Data_PTR[CorrespondingModality[q]*numelmasked+L2S[i]]-CompareMeanRefinedUniform[q*numbmodal+CorrespondingModality[q]];
                                        if (!FLAIRUsed && RefinedCheckPossible2 && TissueOrigin!=segment_analysis->IndexWM) {
                                            for (int q2=0;q2<numbCheckingTests2; q2++) {
                                                if (PossibleCheck2[q2]) {
                                                    float CompDiffCheck2=0;
                                                    //                                                    CompDiffCheck2=Data_PTR[CorrespondingModality2[q2]*numel+i]-CompareMeanRefinedUniform2[q2*numbmodal+CorrespondingModality2[q2]];
                                                    CompDiffCheck2=Data_PTR[CorrespondingModality2[q2]*numelmasked+L2S[i]]-CompareMeanRefinedUniform2[q2*numbmodal+CorrespondingModality2[q2]];
                                                    CompDiff*=((CompDiffCheck2*LesionRule->RefinedCheckUniform2[q2*3+1])>0);
                                                }
                                                
                                            }
                                        }
                                        CompDiff*=((CompDiffCheck*LesionRule->RefinedCheckUniform[q*3+1])>0);
                                    }
                                }
                            }
                            
                        }
                        if (i==TestInd) {
                            //                            cout<<*NormResp_PTR<<" "<<Data_PTR[1*numel+TestInd]<<endl;
                            cout<<*NormResp_PTR<<" "<<Data_PTR[1*numelmasked+L2S[TestInd]]<<endl;
                            //                            float TestLNormResp=MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[1*numbOutliersClasses+TissueOrigin]][1];
                            cout<<"Testing"<<endl;
                            //                            cout<<*NormResp_PTR<<" "<<Data_PTR[1*numel+TestInd]<<endl;
                        }
                        LesionData_PTR[u*numel+i]=(float)(* NormResp_PTR)*CompDiff;
                        NormResp_PTR++;
                    }
                }
                
                // Clearing memory
                if (CompareMeanRefinedUniform2!=NULL) {
                    delete [] CompareMeanRefinedUniform2;
                    CompareMeanRefinedUniform2=NULL;
                }
                
                delete [] MeanLesion;
                MeanLesion=NULL;
                delete [] CompareMeanRefinedUniform;
                CompareMeanRefinedUniform=NULL;
                delete [] CompareMeanQuestionableUniform;
                CompareMeanQuestionableUniform=NULL;
                cout<< CountVoxelToCheck<<" voxels checked for uniform "<< u<<" and changed at first check are "<<CountChangeCompDiffFirstSign<<" for "<<TreeToAnalyse->GetNumberMaskedElements()<<" elements"<<endl;
            }
            
            
        }
        else{ // case where max of one uniform and not driven spatially by hierarchy.
            int * L2S_PTR=TreeToAnalyse->GetL2S();
            int * L2S=L2S_PTR;
            int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
            float * NormResp_PTR=VectorLeavesToUse[u]->GetNormResp();
            for (int i=0; i<numel; i++,L2S_PTR++) {
                bool CompDiff=1;
                if (*L2S_PTR>=0) {
                    for (int m=0; m<numbmodal; m++) {
                        //                    float Diff=Data_PTR[m*numel+i]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m]][m];
                        float Diff=Data_PTR[m*numelmasked+L2S[i]]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m]][m];
                        CompDiff*=(Diff*LesionRule->SignComparisonUniform[m]>=0);
                    }
                    
                    LesionData_PTR[u*numel+i]=CompDiff*(* NormResp_PTR);
                    NormResp_PTR++;
                }
                
            }
        }
        
        
    }
    if (PossibleCheck2!=NULL) {
        delete [] PossibleCheck2;
        PossibleCheck2=NULL;
    }
    if (CorrespondingModality2!=NULL) {
        delete [] CorrespondingModality2;
        CorrespondingModality2=NULL;
    }
    int numbClasses=MeanGeneralClasses.size();
    for (int c=0; c<numbClasses; c++) {
        if (MeanGeneralClasses[c]!=NULL) {
            delete [] MeanGeneralClasses[c];
            MeanGeneralClasses[c]=NULL;
        }
    }
    delete [] PossibleCheck;
    PossibleCheck=NULL;
    delete [] CorrespondingModality;
    CorrespondingModality=NULL;
    delete [] PossibleQuestions;
    PossibleQuestions=NULL;
    delete [] CorrespondingModalityQuestionUniform;
    CorrespondingModalityQuestionUniform=NULL;
    return LesionUniformImage;
}












// Build and return the lesion image using the uniform distribution and concatenating the results obtained for each remaining uniform distribution
nifti_image * LesionFromUniform(TreeEM * TreeToAnalyse, Rule * LesionRule, vector<int> Modalities,vector<TreeEM *> LesionClasses,SEG_ANALYSIS * segment_analysis){
    if (TreeToAnalyse->GetFlagOutliers()==0) {
        cout<<"No outlier model considered"<<endl;
        return NULL;
    }
    
    vector<TreeEM*> UniformVectorLeaves=TreeToAnalyse->GetUniformLeavesVector();
    int numbUnif=UniformVectorLeaves.size();
    
    if (numbUnif==0) { // if no uniform, no need to go further down
        cout<<"No remaining uniform in the final model"<<endl;
        return NULL;
    }
    
    if(LesionRule->AcceptanceUniform==NULL){//meaning that we do not consider the uniform distribution in the description of the lesion components/ elements
        cout<<"No uniform taken into account"<<endl;
        return NULL;
    }
    //    float * Data=static_cast<float*>( TreeToAnalyse->GetDataImage()->data);
    //    float * Data_PTR= Data;
    float * Data_PTR=TreeToAnalyse->GetDataBFCorrected();
    int numbmodal=Modalities.size();
    
    // Creation and initialisation of LesionUniformImage
    nifti_image * LesionUniformImage = nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    LesionUniformImage->dim[4]=numbUnif;
    if (numbUnif==1) {
        LesionUniformImage->dim[0]=3;
    }
    else{
        LesionUniformImage->dim[0]=4;
    }
    nifti_update_dims_from_array(LesionUniformImage);
    LesionUniformImage->data=(void*)calloc(LesionUniformImage->nvox, sizeof(float));
    float * LesionData=static_cast<float*>(LesionUniformImage->data);
    float * LesionData_PTR=LesionData;
    int numel=LesionUniformImage->nx*LesionUniformImage->ny*LesionUniformImage->nz;
    for (int i=0; i<numel*numbUnif; i++) {
        LesionData[i]=0;
    }
    
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    TreeToAnalyse->AreNormRespValid();
    
    
    //Using QuestionableUniform and RefinedCheckingUniform if need be
    // Check if modalities considered in questionable correspond to available modalities
    int numbQuestionTests=LesionRule->QuestionableUniform.size()/3;
    bool * PossibleQuestions= new bool[numbQuestionTests];
    int * CorrespondingModalityQuestionUniform=new int[numbQuestionTests];
    for (int q=0; q<numbQuestionTests; q++) {
        PossibleQuestions[q]=0;
        CorrespondingModalityQuestionUniform[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->QuestionableUniform[q*3]==Modalities[m]) {
                PossibleQuestions[q]=1;
                CorrespondingModalityQuestionUniform[q]=m;
            }
        }
    }
    //Check if at least one of the questions is possible
    bool QuestionablePossible=0;
    for (int q=0; q<numbQuestionTests; q++) {
        if (PossibleQuestions[q]) {
            QuestionablePossible=1;
            break;
        }
    }
    
    int numbCheckingTests=LesionRule->RefinedCheckUniform.size()/3;
    bool * PossibleCheck= new bool[numbCheckingTests];
    int * CorrespondingModality=new int[numbCheckingTests];
    for (int q=0; q<numbCheckingTests; q++) {
        PossibleCheck[q]=0;
        CorrespondingModality[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (LesionRule->RefinedCheckUniform[q*3]==Modalities[m]) {
                PossibleCheck[q]=1;
                CorrespondingModality[q]=m;
            }
        }
    }
    //Check if at least one of the checks is possible
    bool RefinedCheckPossible=0;
    for (int q=0; q<numbCheckingTests; q++) {
        if (PossibleCheck[q]) {
            RefinedCheckPossible=1;
            break;
        }
    }
    
    //Check if FLAIR
    bool FLAIRUsed=0;
    for (int m=0; m<numbmodal; m++) {
        if (Modalities[m]==3) {
            FLAIRUsed=1;
            break;
        }
    }
    bool * PossibleCheck2=NULL;
    int * CorrespondingModality2=NULL;
    int numbCheckingTests2=0;
    bool RefinedCheckPossible2=0;
    
    if (!FLAIRUsed) {
        numbCheckingTests2=LesionRule->RefinedCheckUniform2.size()/3;
        PossibleCheck2= new bool[numbCheckingTests2];
        CorrespondingModality2=new int[numbCheckingTests2];
        for (int q=0; q<numbCheckingTests2; q++) {
            PossibleCheck2[q]=0;
            CorrespondingModality2[q]=-1;
            for (int m=0; m<numbmodal; m++) {
                if (LesionRule->RefinedCheckUniform2[q*3]==Modalities[m]) {
                    PossibleCheck2[q]=1;
                    CorrespondingModality2[q]=m;
                }
            }
        }
        //Check if at least one of the checks is possible
        
        for (int q=0; q<numbCheckingTests2; q++) {
            if (PossibleCheck2[q]) {
                RefinedCheckPossible2=1;
                break;
            }
        }
    }
    
    if(PossibleCheck2==NULL){
        cout<< "Possible Check 2 NULL"<<endl;
    }
    
    int Shift[3];
    Shift[0]=1;
    Shift[1]=LesionUniformImage->dim[1];
    Shift[2]=Shift[1]*LesionUniformImage->dim[2];
    
    int TestInd=148*Shift[0]+119*Shift[1]+120*Shift[2];
    
    // Filling of LesionUniformImage according to rule
    for (int u=0; u<numbUnif; u++) {
        cout<< "checking for uniform... "<<u<<endl;
        if (TreeToAnalyse->GetFlagOutliers()==3 || TreeToAnalyse->GetFlagOutliers()>=5) {
            int * L2S_PTR=TreeToAnalyse->GetL2S();
            int * L2S=TreeToAnalyse->GetL2S();
            int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
            int numbOutliersClasses=TreeToAnalyse->GetNodeOutlier()->GetNumberChildren();
            float * NormResp_PTR=UniformVectorLeaves[u]->GetNormResp();
            //            TreeToAnalyse->SaveTmpResultMasked(NormResp_PTR, "/Users/Carole/Documents/PhD/TestUniform.nii.gz");
            vector<int> HierarchUnif=UniformVectorLeaves[u]->GetHierarchyVector();
            int TissueOrigin=HierarchUnif[1];
            if (!LesionRule->AcceptanceUniform[TissueOrigin]) { // check if tissue considered for origin is accepted as origin for the lesion class
                //                cout<<"Tissue origin class not accepted in uniform check for origin "<<TissueOrigin<<endl;
            }
            else{
                //                int numbGeneralClasses=TreeToAnalyse->GetChild(0)->GetNumberChildren();
                float * MeanLesion=GetMeanDirectVector(LesionClasses);
                float * CompareMeanQuestionableUniform=CompareMeanLesion(LesionClasses, LesionRule->QuestionableUniform, TreeToAnalyse, Modalities);
                //                int qu=0;
                //                cout<<"Printing CompareMeanQuestionableUniform..."<<endl;
                //                for (int q=0; q<numbQuestionTests;q++ ) {
                //                    if (PossibleQuestions[q]) {
                //                        for (int m=0; m<numbmodal; m++) {
                //                            cout<< CompareMeanQuestionableUniform[qu*numbmodal+m]<<" ";
                //                        }
                //                        qu++;
                //                    }
                //                    cout<<endl;
                //                }
                //                cout << "Creating CompareMeanRefinedUniform"<<endl;
                cout <<"CompareMeanQuestionableUniform at line 7284 done"<<endl;                float * CompareMeanRefinedUniform=CompareMeanLesion(LesionClasses,LesionRule->RefinedCheckUniform,TreeToAnalyse,Modalities);
                cout <<"CompareMeanRefinedUniform at line 7285 done"<<endl;
                float * CompareMeanRefinedUniform2=CompareMeanLesion(LesionClasses, LesionRule->RefinedCheckUniform2, TreeToAnalyse, Modalities);
                cout <<"CompareMeanRefined2Uniform at line 7286 done"<<endl;
                int CountVoxelToCheck=0;
                //                cout<< "Beginning comparison for uniform"<< endl;
                int CountChangeCompDiffFirstSign=0;
                for (int i=0; i<numel; i++,L2S_PTR++) {
                    bool CompDiff=1;
                    //                    if (i==76+156*Shift[1]+68*Shift[2]) {
                    //                        cout<<"Stay there for the moment..."<<endl;
                    //                    }
                    if (*L2S_PTR>=0) { // if we are in the mask
                        for (int m=0; m<numbmodal; m++) {
                            //                            float Diff=Data_PTR[m*numel+i]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m*numbOutliersClasses+TissueOrigin]][m];
                            float Diff=Data_PTR[m*numelmasked+L2S[i]]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m*numbOutliersClasses+TissueOrigin]][m];
                            CompDiff*=((Diff*LesionRule->SignComparisonUniform[m*numbOutliersClasses+TissueOrigin])>=0);
                        }
                        if (CompDiff==0) {
                            CountChangeCompDiffFirstSign++;
                        }
                        
                        if (CompDiff && (*NormResp_PTR>0)) { // Check further only supposed to be checked
                            bool ToCheckResult=1;
                            //                            if (QuestionablePossible) {
                            //
                            //                            }
                            if (QuestionablePossible && !FLAIRUsed) {
//                                cout << "Trying to do QuestionablePossible for "<<i<<endl;
                                for (int q=0; q<numbQuestionTests; q++) {
                                    if (PossibleQuestions[q]) {
                                        float CompDiffQuestion=0;
                                        CompDiffQuestion=Data_PTR[CorrespondingModalityQuestionUniform[q]*numelmasked+L2S[i]]-CompareMeanQuestionableUniform[q*numbmodal+CorrespondingModalityQuestionUniform[q]];
                                        //                                    if (LesionRule->QuestionableUniform[q*3+2]>=numbGeneralClasses) {
                                        //                                        if (MeanLesion!=NULL) {
                                        //                                            CompDiffQuestion=Data_PTR[CorrespondingModalityQuestionUniform[q]*numel+i]-MeanLesion[CorrespondingModalityQuestionUniform[q]];
                                        //                                        }
                                        //
                                        //                                    }
                                        //                                    else {
                                        //                                        CompDiffQuestion=Data_PTR[CorrespondingModalityQuestionUniform[q]*numel+i]-MeanGeneralClasses[LesionRule->QuestionableUniform[q*3+2]][CorrespondingModalityQuestionUniform[q]];
                                        //                                    }
                                        ToCheckResult*=((CompDiffQuestion*LesionRule->QuestionableUniform[q*3+1])>0);
                                    }
                                }
//                                cout << "...done";
                            }
                            else {
                                ToCheckResult=0;
                            }
                            if (ToCheckResult) {
                                CountVoxelToCheck++;
//                                cout <<"one more voxel to check"<<endl;
                                for (int q=0; q<numbCheckingTests; q++) {
                                    if (PossibleCheck[q]) {
                                        float CompDiffCheck=0;
                                        //                                        CompDiffCheck=Data_PTR[CorrespondingModality[q]*numel+i]-CompareMeanRefinedUniform[q*numbmodal+CorrespondingModality[q]];
                                        CompDiffCheck=Data_PTR[CorrespondingModality[q]*numelmasked+L2S[i]]-CompareMeanRefinedUniform[q*numbmodal+CorrespondingModality[q]];
                                        if (!FLAIRUsed && RefinedCheckPossible2 && TissueOrigin!=segment_analysis->IndexWM) {
                                            for (int q2=0;q2<numbCheckingTests2; q2++) {
                                                if (PossibleCheck2[q2]) {
                                                    float CompDiffCheck2=0;
                                                    //                                                    CompDiffCheck2=Data_PTR[CorrespondingModality2[q2]*numel+i]-CompareMeanRefinedUniform2[q2*numbmodal+CorrespondingModality2[q2]];
                                                    CompDiffCheck2=Data_PTR[CorrespondingModality2[q2]*numelmasked+L2S[i]]-CompareMeanRefinedUniform2[q2*numbmodal+CorrespondingModality2[q2]];
                                                    CompDiff*=((CompDiffCheck2*LesionRule->RefinedCheckUniform2[q2*3+1])>0);
                                                    //cout << "Comp check 2 done for for "<< q2<< "and index "<<i<<endl;
                                                }
                                                
                                            }
                                        }
                                        CompDiff*=((CompDiffCheck*LesionRule->RefinedCheckUniform[q*3+1])>0);
                                    }
                                    //cout << "...done. ";
                                }
                            }
                            
                        }
                        if (i==TestInd) {
                            //                            cout<<*NormResp_PTR<<" "<<Data_PTR[1*numel+TestInd]<<endl;
                            cout<<*NormResp_PTR<<" "<<Data_PTR[1*numelmasked+L2S[TestInd]]<<endl;
                            //                            float TestLNormResp=MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[1*numbOutliersClasses+TissueOrigin]][1];
                            cout<<"Testing"<<endl;
                            //                            cout<<*NormResp_PTR<<" "<<Data_PTR[1*numel+TestInd]<<endl;
                        }
                        LesionData_PTR[u*numel+i]=(float)(* NormResp_PTR)*CompDiff;
                        NormResp_PTR++;
                    }
                }
                
                // Clearing memory
                if (CompareMeanRefinedUniform2!=NULL) {
                    delete [] CompareMeanRefinedUniform2;
                    CompareMeanRefinedUniform2=NULL;
                }
                
                delete [] MeanLesion;
                MeanLesion=NULL;
                delete [] CompareMeanRefinedUniform;
                CompareMeanRefinedUniform=NULL;
                delete [] CompareMeanQuestionableUniform;
                CompareMeanQuestionableUniform=NULL;
                cout<< CountVoxelToCheck<<" voxels checked for uniform "<< u<<" and changed at first check are "<<CountChangeCompDiffFirstSign<<" for "<<TreeToAnalyse->GetNumberMaskedElements()<<" elements"<<endl;
            }
            
            
        }
        else{ // case where max of one uniform and not driven spatially by hierarchy.
            int * L2S_PTR=TreeToAnalyse->GetL2S();
            int * L2S=L2S_PTR;
            int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
            float * NormResp_PTR=UniformVectorLeaves[u]->GetNormResp();
            for (int i=0; i<numel; i++,L2S_PTR++) {
                bool CompDiff=1;
                if (*L2S_PTR>=0) {
                    for (int m=0; m<numbmodal; m++) {
                        //                    float Diff=Data_PTR[m*numel+i]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m]][m];
                        float Diff=Data_PTR[m*numelmasked+L2S[i]]-MeanGeneralClasses[LesionRule->CorrespondingGClassComparisonUniform[m]][m];
                        CompDiff*=(Diff*LesionRule->SignComparisonUniform[m]>=0);
                    }
                    
                    LesionData_PTR[u*numel+i]=CompDiff*(* NormResp_PTR);
                    NormResp_PTR++;
                }
                
            }
        }
        
        
    }
    if (PossibleCheck2!=NULL) {
        delete [] PossibleCheck2;
        PossibleCheck2=NULL;
    }
    if (CorrespondingModality2!=NULL) {
        delete [] CorrespondingModality2;
        CorrespondingModality2=NULL;
    }
    int numbClasses=MeanGeneralClasses.size();
    for (int c=0; c<numbClasses; c++) {
        if (MeanGeneralClasses[c]!=NULL) {
            delete [] MeanGeneralClasses[c];
            MeanGeneralClasses[c]=NULL;
        }
    }
    delete [] PossibleCheck;
    PossibleCheck=NULL;
    delete [] CorrespondingModality;
    CorrespondingModality=NULL;
    delete [] PossibleQuestions;
    PossibleQuestions=NULL;
    delete [] CorrespondingModalityQuestionUniform;
    CorrespondingModalityQuestionUniform=NULL;
    return LesionUniformImage;
}

// Given the information in segment_analysis, the obtained total lesion image, and the tree structure, rebuild the final segmentation.
nifti_image * SummarizedSegmentation(TreeEM * TreeToAnalyse, vector<TreeEM *> LesionClasses, nifti_image * LesionUniform, vector<TreeEM *> CSFWMClasses, nifti_image * CSFWMUniform, SEG_ANALYSIS * segment_analysis, float * ICSF,nifti_image * TrueLesionSeg){
    // First create the image in which the final result will be stored.
    int numel=TreeToAnalyse->GetNumberElements();
    nifti_image * ResultSumSeg=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    int numbclasses=TreeToAnalyse->GetNumberGeneralClasses();
    ResultSumSeg->dim[0]=3+(numbclasses>1);
    ResultSumSeg->dim[4]=numbclasses;
    nifti_update_dims_from_array(ResultSumSeg);
    ResultSumSeg->data=(void *)calloc(ResultSumSeg->nvox, sizeof(float));
    float * ResultSumSegData=static_cast<float *>(ResultSumSeg->data);
    cout << "Build normal summ"<< endl;
    // First build normal segmentation without taking into account the lesion classification and only the Tree Structure: only need to add outlier and corresponding inlier segmentation for each main tissue
    // WARNING : We assume a symmetric model between inliers and outliers in this configuration
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    int j=0;
    TreeEM * NodeOutlier=TreeToAnalyse->GetNodeOutlier();
    for (int i=0; i<numel; i++, L2S_PTR++) {
        if (*L2S_PTR>=0) {
            for (int n=0; n<numbclasses; n++) {
                ResultSumSegData[i+numel*n]=TreeToAnalyse->GetNodeInlier()->GetChild(n)->GetNormResp()[j];
                if (NodeOutlier!=NULL) {
                    ResultSumSegData[i+numel*n]+=NodeOutlier->GetChild(n)->GetNormResp()[j];
                }
            }
            j++;
        }
    }
    cout << "Use lesion classes for summ"<< endl;
    // Use LesionClasses and if hierarchy does not correspond to white matter, take them away from initial class and add them in white matter seg.
    int numblesion=LesionClasses.size();
    
    if (TrueLesionSeg==NULL) { // Case we consider initial Lesion without further refinement.
        for (int l=0; l<numblesion; l++) {
            vector<int> HierarchyVector=LesionClasses[l]->GetHierarchyVector();
            if (HierarchyVector[1]!=segment_analysis->IndexWM) { // Case we have to transfer a lesion class to the WM final segmentation.
                L2S_PTR=TreeToAnalyse->GetL2S();
                int j=0;
                for (int i=0; i<numel; i++,L2S_PTR++) {
                    if (*L2S_PTR>=0) {
                        ResultSumSegData[i+numel*HierarchyVector[1]]-=LesionClasses[l]->GetNormResp()[j];
                        ResultSumSegData[i+numel*segment_analysis->IndexWM]+=LesionClasses[l]->GetNormResp()[j];
                        j++;
                    }
                }
            }
        }
    }
    else{
        float * TrueLesionSegData=static_cast<float *>(TrueLesionSeg->data);
        for (int l=0; l<numblesion; l++) {
            vector<int> HierarchyVector=LesionClasses[l]->GetHierarchyVector();
            if (HierarchyVector[1]!=segment_analysis->IndexWM) { // Case we have to transfer a lesion class to the WM final segmentation.
                L2S_PTR=TreeToAnalyse->GetL2S();
                int j=0;
                for (int i=0; i<numel; i++,L2S_PTR++) {
                    if (*L2S_PTR>=0) {
                        if (TrueLesionSegData[i]>0.1) { // Case where element truly considered as lesion
                            ResultSumSegData[i+numel*HierarchyVector[1]]-=LesionClasses[l]->GetNormResp()[j];
                            ResultSumSegData[i+numel*segment_analysis->IndexWM]+=LesionClasses[l]->GetNormResp()[j];
                        }
                        j++;
                    }
                }
            }
        }
    }
    
    cout << "Use Lesion uniform for summ "<< endl;
    // Similar work as before but this time based on the lesion uniform result
    if(LesionUniform!=NULL){
        float * LesionUniformData=static_cast<float *>(LesionUniform->data);
        int numbunif=LesionUniform->nu*LesionUniform->nt;
        if (numbunif!=numbclasses) {
            cout<<"Pb in symmetry"<<endl;
        }
        else{
            if (TrueLesionSeg==NULL) {
                for (int n=0; n<numbunif; n++) {
                    if (n!=segment_analysis->IndexWM) {
                        for (int i=0; i<numel; i++) {
                            ResultSumSegData[i+numel*n]-=LesionUniformData[i+n*numel];
                            ResultSumSegData[i+numel*segment_analysis->IndexWM]+=LesionUniformData[i+n*numel];
                        }
                    }
                }
            }
            else{ // Case we only change the classification for the elements that are truly considered as lesion.
                float * TrueLesionSegData=static_cast<float *>(TrueLesionSeg->data);
                for (int n=0; n<numbunif; n++) {
                    if (n!=segment_analysis->IndexWM) {
                        for (int i=0; i<numel; i++) {
                            if (TrueLesionSegData[i]>0.1) {
                                ResultSumSegData[i+numel*n]-=LesionUniformData[i+n*numel];
                                ResultSumSegData[i+numel*segment_analysis->IndexWM]+=LesionUniformData[i+n*numel];
                            }
                        }
                    }
                }
            }
            
        }
    }
    cout << "Taking care of WM CSF mix summ"<< endl;
    //    Now take care of the classes considered as WM instead of CSF
    L2S_PTR=TreeToAnalyse->GetL2S();
    int * S2L_PTR=TreeToAnalyse->GetS2L();
    int numbCW=CSFWMClasses.size();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    for (int w=0; w<numbCW; w++) {
        float * CSFWMToTransfer=CSFWMClasses[w]->GetNormResp();
        for (int i=0; i<numelmasked; i++) {
            ResultSumSegData[segment_analysis->IndexWM*numel+S2L_PTR[i]]-=CSFWMToTransfer[i];
            ResultSumSegData[segment_analysis->IndexCSF*numel+S2L_PTR[i]]+=CSFWMToTransfer[i];
        }
    }
    cout << "Taking care of WM CSF mix summ"<< endl;
    //    Similarly take care of misclassified as WM CSF outliers from uniform if not classified as lesion
    if (CSFWMUniform!=NULL) {
        float * CSFWMUniformData=static_cast<float *>(CSFWMUniform->data);
        for (int i=0; i<numel; i++) {
            ResultSumSegData[segment_analysis->IndexWM*numel+i]-=CSFWMUniformData[i];
            ResultSumSegData[segment_analysis->IndexCSF*numel+i]+=CSFWMUniformData[i];
        }
    }
    cout << "Taking care of Ventricle inside mix summ"<< endl;
    //    Take care of lesion classified voxels whereas inside ventricles
    if (ICSF!=NULL) {
        for (int i=0; i<numel; i++) {
            if (ICSF[i]>0.5) {
                ResultSumSegData[segment_analysis->IndexWM*numel+i]-=ResultSumSegData[segment_analysis->IndexWM*numel+i];
                ResultSumSegData[segment_analysis->IndexCSF*numel+i]+=ResultSumSegData[segment_analysis->IndexWM*numel+i];
            }
        }
    }
    
    cout << "Taking care normalisation summ"<< endl;
    // Before returning, normalise result
    L2S_PTR=TreeToAnalyse->GetL2S();
    int CountPbNorm=0;
    for (int i=0; i<numel; i++,L2S_PTR++) {
        float sumData=0;
        if (*L2S_PTR>=0) {
            for (int n=0; n<numbclasses; n++) {
                sumData+=ResultSumSegData[i+n*numel];
            }
            if (fabs(sumData-1)>1E-6) {
                CountPbNorm++;
            }
            if (sumData!=0 && sumData>1E-6) {
                for (int n=0; n<numbclasses; n++) {
                    ResultSumSegData[i+n*numel]/=sumData;
                }
            }
            else{
                for (int n=0; n<numbclasses; n++) {
                    ResultSumSegData[i+n*numel]/=numbclasses;
                }
                // classification as out
                for (int n=0; n<numbclasses; n++) {
                    ResultSumSegData[i+n*numel]=0;
                }
                ResultSumSegData[i+(numbclasses-1)*numel]=1;
            }
        }
    }
    cout<<"Numb total pb for sum data is "<<CountPbNorm<<endl;
    
    return ResultSumSeg;
}


//// Study subclass with respect to other neighbours and other general classes
LeafID * LeafCharacterisation(TreeEM * TreeToAnalyse, TreeEM * LeafStudy, SEG_ANALYSIS * segment_analysis, nifti_image * SummarisedSeg,float Threshold){
    if (!LeafStudy->IsLeaf()) {
        return NULL;
    }
    vector<int> HierarchyVector=LeafStudy->GetHierarchyVector();
    int * L2S=TreeToAnalyse->GetL2S();
    int * S2L=TreeToAnalyse->GetS2L();
    int Dim[3];
    Dim[0]=SummarisedSeg->nx;
    Dim[1]=SummarisedSeg->ny;
    Dim[2]=SummarisedSeg->nz;
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    
    //    Create the HardSegmentation
    nifti_image * GMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexGM, L2S);
    float * GMData=static_cast<float *>(GMHard->data);
    nifti_image * WMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexWM, L2S);
    float * WMData=static_cast<float *>(WMHard->data);
    nifti_image * CSFHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexCSF, L2S);
    float * CSFData=static_cast<float *>(CSFHard->data);
    nifti_image * OutHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexOut, L2S);
    float * OutData=static_cast<float *>(OutHard->data);
    nifti_image * InsideHard=HardSegmentationIndex(SummarisedSeg, HierarchyVector[1], L2S);
    float * InsideData=static_cast<float *>(InsideHard->data);
    float * DataCompare=LeafStudy->GetNormResp();
    //    Determine proportion of elements of Leaf above threshold that will actually be classified under this general cluster
    //    First count number of element above this threshold
    int GMCount=0;
    float GMNeighProp=0;
    int WMCount=0;
    float WMNeighProp=0;
    int CSFCount=0;
    float CSFNeighProp=0;
    int OutCount=0;
    float OutNeighProp=0;
    int TotCount=0;
    int InsideCount=0;
    float InsideNeighProp=0;
    int TotInside=0;
    //    int numel=TreeToAnalyse->GetNumberElements();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    for (int i=0; i<numelmasked; i++) {
        int IndexLong=S2L[i];
        if (InsideData[IndexLong]==1) {
            TotInside++;
        }
        if (DataCompare[i]>=Threshold) {
            TotCount++;
            
            int tmpGM=0;
            int tmpWM=0;
            int tmpCSF=0;
            int tmpOut=0;
            int tmpInside=0;
            
            
            if (GMData[IndexLong]==1) {
                GMCount++;
            }
            if (WMData[IndexLong]==1) {
                WMCount++;
            }
            if (CSFData[IndexLong]==1) {
                CSFCount++;
            }
            if (OutData[IndexLong]==1) {
                OutCount++;
            }
            if (InsideData[IndexLong]==1) {
                InsideCount++;
            }
            //                Here check the proportion of direct neighbours that are assigned under each of the general label
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, IndexLong, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (InsideData[ListNeighbours[n]]) {
                    tmpInside++;
                }
                if (GMData[ListNeighbours[n]]) {
                    tmpGM++;
                }
                else if (WMData[ListNeighbours[n]]){
                    tmpWM++;
                }
                else if (CSFData[ListNeighbours[n]]){
                    tmpCSF++;
                }
                else if(OutData[ListNeighbours[n]]){
                    tmpOut++;
                }
            }
            GMNeighProp+=float(tmpGM)/6.0;
            WMNeighProp+=float(tmpWM)/6.0;
            CSFNeighProp+=float(tmpCSF)/6.0;
            OutNeighProp+=float(tmpOut)/6.0;
            InsideNeighProp+=float(tmpInside)/6.0;
        }
    }
    float GMProp=0;
    float WMProp=0;
    float CSFProp=0;
    float OutProp=0;
    float InsideProp=0;
    if (TotCount>0) {
        GMNeighProp/=TotCount;
        WMNeighProp/=TotCount;
        CSFNeighProp/=TotCount;
        OutNeighProp/=TotCount;
        InsideNeighProp/=TotCount;
        GMProp=float(GMCount)/TotCount;
        WMProp=float(WMCount)/TotCount;
        CSFProp=float(CSFCount)/TotCount;
        OutProp=float(OutCount)/TotCount;
        InsideProp=float(InsideCount)/TotCount;
    }
    
    LeafID * LeafIDResult=new LeafID();
    int sizeHierarchy=HierarchyVector.size();
    for (int h=0; h<sizeHierarchy; h++) {
        LeafIDResult->HierarchyVector.push_back(HierarchyVector[h]);
    }
    LeafIDResult->Threshold=Threshold;
    LeafIDResult->RatioCSF=CSFProp;
    LeafIDResult->RatioGM=GMProp;
    LeafIDResult->RatioWM=WMProp;
    LeafIDResult->RatioOut=OutProp;
    LeafIDResult->RatioInside=InsideProp;
    LeafIDResult->NeighInside=InsideNeighProp;
    LeafIDResult->NeighCSF=CSFNeighProp;
    LeafIDResult->NeighGM=GMNeighProp;
    LeafIDResult->NeighWM=WMNeighProp;
    LeafIDResult->NeighOut=OutNeighProp;
    LeafIDResult->PropInsideContribution=float(InsideCount)/TotInside;
    
    //    Clearing before returning
    if (GMHard!=NULL) {
        nifti_image_free(GMHard);
        GMHard=NULL;
    }
    if (WMHard!=NULL) {
        nifti_image_free(WMHard);
        WMHard=NULL;
    }
    if (CSFHard!=NULL) {
        nifti_image_free(CSFHard);
        CSFHard=NULL;
    }
    if (OutHard!=NULL) {
        nifti_image_free(OutHard);
        OutHard=NULL;
    }
    if (InsideHard!=NULL) {
        nifti_image_free(InsideHard);
        InsideHard=NULL;
    }
    
    return LeafIDResult;
}


//Create the DGM segmentation using the DGM priors and the summarised image
nifti_image * DGMSegmentationPriors(nifti_image * SummarisedSeg, SEG_ANALYSIS * segment_analysis, nifti_image * DGMPriors,int * L2S){
    if (DGMPriors==NULL) {
        return NULL;
    }
    if (!CheckCompatibleDimensions(SummarisedSeg, DGMPriors)) {
        return NULL;
    }
    nifti_image * DGMSeg=nifti_copy_nim_info(DGMPriors);
    float * DGMData=static_cast<float *>(DGMPriors->data);
    nifti_image * HardSegGM=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexGM, L2S);
    float * GMSegData=static_cast<float *>(HardSegGM->data);
    DGMSeg->data=(void *) calloc(DGMSeg->nvox, sizeof(float));
    float * DGMSegData=static_cast<float *>(DGMSeg->data);
    int numel=DGMSeg->nvox;
    for (int i=0; i<numel; i++) {
        if (GMSegData[i]>0 && DGMData[i]>0) {
            DGMSegData[i]=1;
        }
    }
    return DGMSeg;
}


bool * VentricleSegmentationFromParc(TreeEM* TreeToAnalyse,SEG_ANALYSIS * segment_analysis){
   int numbmodal=TreeToAnalyse->GetNumberModalities();
   int numel=TreeToAnalyse->GetNumberElements();
    bool * VentrBool=new bool[numel];
    vector<float *> MeanVector=TreeToAnalyse->GetMeanGeneralClassesVector();
    vector<TreeEM*> VectorCSF;
    VectorCSF.push_back(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexCSF));
    VectorCSF.push_back(TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF));
    nifti_image * Parcellation = ReadFromFilename(segment_analysis->filename_Parc);
    float * DataCorrected=TreeToAnalyse->GetDataBFCorrected();
    float * ParcellationData=static_cast<float *>(Parcellation->data);
    float * NormRespCSF=AddNormResp(VectorCSF);
    int * L2S=TreeToAnalyse->GetL2S();
    float * NormRespCSFLong=CreateLong(NormRespCSF, L2S, numel);
    float * DataLong=CreateLongPaddingMulti<float>(DataCorrected,0.0,L2S,numel,TreeToAnalyse->GetNumberModalities());
    for (int i=0; i<numel; i++) {
        VentrBool[i]=0;
        if(ParcellationData[i]>49.5 && ParcellationData[i]<53.5){
            // WARNING WORKS ONLY WITH FLAIR PRESENT AND FIRST OR SECOND MODALITY
            if(NormRespCSFLong[i]>0.3 && DataLong[(numbmodal-1)*numel+i]<MeanVector[segment_analysis->IndexGM][numbmodal-1] ){
                VentrBool[i]=1;
            }
        }
    }
    SaveTmpResult(VentrBool,"/home/csudre/TestVentr.nii.gz",Parcellation);
    delete[] DataLong;
    delete[] NormRespCSFLong;
    delete[] NormRespCSF;
    for(int m=0;m<numbmodal;m++){
        delete [] MeanVector[m];
    }
    nifti_image_free(Parcellation);
    return VentrBool;
}

//Create a boolean array for ventricle segmentation when Tree and ICSF Priors can be available
bool * VentricleSegmentationDirect(TreeEM * TreeToAnalyse,  SEG_ANALYSIS * segment_analysis){
//    if(segment_analysis->flag_inVentricleSeg){
//        cout << "Direct Ventricle seg "<<endl;
//        nifti_image * VentrNii = ReadFromFilename(segment_analysis->filename_inVentricleSeg);
//        bool * VentrSeg=TranscribeArray<bool, bool>(static_cast<bool*>(VentrNii->data), VentrNii->nvox);
//        nifti_image_free(VentrNii);
//        return VentrSeg;
//    }
    
    nifti_image * ICSFPriors=NULL;
//    nifti_image * Parcellation=NULL;
//    if(segment_analysis->flag_Parc && segment_analysis->flag_VentrParc){
//        Parcellation=ReadFromFilename(segment_analysis->filename_Parc);
//    }
    if(segment_analysis->flag_inPriorsICSF){
        ICSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
    }
//    WARNING Like this we might put in ventricles some lesions
    if (ICSFPriors==NULL) {
        return NULL;
    }
    int numel=TreeToAnalyse->GetNumberElements();
    bool * VentSeg=new bool[numel];
    vector<TreeEM *> VectorCSF;
    VectorCSF.push_back(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexCSF));
    VectorCSF.push_back(TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF));
    float * ICSFData=static_cast<float *>(ICSFPriors->data);
    float * NormRespCSF=AddNormResp(VectorCSF);
    int * L2S=TreeToAnalyse->GetL2S();
    float * NormRespCSFLong=CreateLong(NormRespCSF, L2S, numel);
    for (int i=0; i<numel; i++) {
        VentSeg[i]=0;
        if (NormRespCSFLong[i]>0.3 && ICSFData[i]>0) {
            VentSeg[i]=1;
        }
    }
    delete [] NormRespCSFLong;
    delete [] NormRespCSF;
    nifti_image_free(ICSFPriors);
    NormRespCSF=NULL;
    NormRespCSFLong=NULL;
    ICSFPriors=NULL;
    return VentSeg;
}

//Create the ventricle segmentation using the ICSF priors and the summarised
nifti_image * VentricleSegmentationPriors(nifti_image * SummarisedSeg, SEG_ANALYSIS * segment_analysis, TreeEM * TreeToAnalyse, nifti_image * ICSFPriors){
    if (ICSFPriors==NULL) {
        return NULL;
    }
    if (!CheckCompatibleDimensions(SummarisedSeg, ICSFPriors)) {
        cout << "Dimensions are incompatible for ICSFPriors"<<endl;
        return NULL;
    }
    nifti_image * VentricleSeg=nifti_copy_nim_info(ICSFPriors);
    float * ICSFData=static_cast<float *>(ICSFPriors->data);
    nifti_image * HardSegCSF=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexCSF, TreeToAnalyse->GetL2S());
    float * CSFSegData=static_cast<float *>(HardSegCSF->data);
    VentricleSeg->data=(void *) calloc(VentricleSeg->nvox, sizeof(float));
    float * VentricleSegData=static_cast<float *>(VentricleSeg->data);
    int numel=VentricleSeg->nvox;
    for (int i=0; i<numel; i++) {
        if (CSFSegData[i]>0 && ICSFData[i]>0) {
            VentricleSegData[i]=1;
        }
    }
    if(HardSegCSF!=NULL){
        nifti_image_free(HardSegCSF);
        HardSegCSF=NULL;
    }
    return VentricleSeg;
}

//Create the ventricle segmentation (avoid having to use the parcellation)
nifti_image * VentricleSegmentation(nifti_image * SummarisedSeg,SEG_ANALYSIS * segment_analysis, TreeEM * TreeToAnalyse){
    //    First select the part that correspond to CSF
    //    float * SummarisedSegData=static_cast<float * >(SummarisedSeg->data);
    if (SummarisedSeg==NULL){
        cout << "SummarisedSeg is NULL"<<endl;
    }
    int numel=SummarisedSeg->nx*SummarisedSeg->ny*SummarisedSeg->nz;
//    cout << numel<< endl;
    //    Create the corresponding hard segmentation
    int * L2S=TreeToAnalyse->GetL2S();
    int * S2L=TreeToAnalyse->GetS2L();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    cout << "Doing Ventricle inside "<< endl;

    nifti_image * CSFHard=HardSegmentationIndex(SummarisedSeg,segment_analysis->IndexCSF,L2S);
    nifti_image * GMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexGM, L2S);
    nifti_image* WMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexWM, L2S);
    //    nifti_image * OutHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexOut, L2S);
    float * GMData=static_cast<float *>(GMHard->data);
    float * WMData=static_cast<float *>(WMHard->data);
    //    float * OutData=static_cast<float *>(OutHard->data);
    //    bool * OutSeg=TranscribeArray<float , bool>(OutData, numel);
    float * CSFData=static_cast<float *>(CSFHard->data);
    nifti_image * Parenchyma=nifti_copy_nim_info(GMHard);
    Parenchyma->data=(void *)calloc(GMHard->nvox, sizeof(float*));
    float * ParenchymaData=static_cast<float *>(Parenchyma->data);
    for (int i=0; i<numel; i++) {
        ParenchymaData[i]=WMData[i]+GMData[i];
    }
    cout << Parenchyma << endl;
    if (Parenchyma==NULL){
        cout << "Parenchyma Null "<< endl;
    }
//    nifti_set_filenames(Parenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/Parenchyma.nii.gz", 0, 0);
//    nifti_image_write(Parenchyma);
    
    vector<int> DimVector;
    for (int d=0; d<3; d++) {
        DimVector.push_back(GMHard->dim[d+1]);
    }
    float * ErodedParenchyma=Erosion_bis(ParenchymaData, 5, DimVector,0); // Correspond to a dilation of size 2 (2 on both sides + middle)
    
    bool * TmpParenchyma=TranscribeArray<float, bool>(ErodedParenchyma, numel);
    bool * OpposedParenchyma=OpposeBoolArray(TmpParenchyma, numel);
    
    
    
    nifti_image * ImageParenchyma=nifti_copy_nim_info(CSFHard);
    float VolumeVox=CSFHard->pixdim[1]*CSFHard->pixdim[2]*CSFHard->pixdim[3];
    ImageParenchyma->data=(void *) calloc(CSFHard->nvox, sizeof(float));
    float * ImageParenchyma_PTR=static_cast<float *>(ImageParenchyma->data);
    for (int i=0; i<numel; i++) {
        if(L2S[i]>=0){
            ImageParenchyma_PTR[i]=(float)OpposedParenchyma[i];
        }
        else{
            ImageParenchyma_PTR[i]=0;
        }
    }
    
//    nifti_set_filenames(ImageParenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/VentriclesTest.nii.gz", 0, 0);
//    nifti_image_write(ImageParenchyma);
    
    //    Find connected components of the background
    int * ComponentBackground=ComponentLabeling(ImageParenchyma,6);
    int * OrderedBackground=OrderedVolumeLabel(ComponentBackground, 3, numel,VolumeVox);
    
    for (int i=0; i<numel; i++) {
        if(L2S[i]>=0){
            ImageParenchyma_PTR[i]=(float)OrderedBackground[i];
        }
        else{
            ImageParenchyma_PTR[i]=0;
        }
    }
//    nifti_image_write(ImageParenchyma);
    
    
    
    //    Change value for image parenchyma opposed
    int Shift[3];
    Shift[0]=1;
    Shift[1]=DimVector[0];
    Shift[2]=Shift[1]*DimVector[1];
    int Dim[3];
    Dim[0]=DimVector[0];
    Dim[1]=DimVector[1];
    Dim[2]=DimVector[2];
    for (int i=0; i<numel; i++) {
        if(L2S[i]>=0){
            if (OpposedParenchyma[i]==1) {
                int ListNeighbours[26];
                GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 26);
                for (int n=0; n<26; n++) {
                    if (L2S[ListNeighbours[n]]<0) { // Meaning that one element of the connected component is neighbour to an element that is not in the mask
                        int LabelToChange=OrderedBackground[i];
                        for (int j=0; j<numel; j++) {
                            if (L2S[j]>=0) {
                                if (OrderedBackground[j]==LabelToChange) {
                                    OpposedParenchyma[j]=0;
                                }
                            }
                            
                        }
                        break;
                    }
                }
                // if on the border the corresponding connected component is put to the opposite
                //                    Detect the value for the corresponding label
                
            }
            
        }
    }
    
    //    Remaining 1 value in the modified image are the one that correspond to the filling to be made
    for (int i=0; i<numel; i++) {
        if (L2S[i]<0) {
            OpposedParenchyma[i]=0;
        }
        if (OpposedParenchyma[i]==1) {
            TmpParenchyma[i]=1;
        }
    }
    
    for (int i=0; i<numel; i++) {
        ImageParenchyma_PTR[i]=(float)TmpParenchyma[i];
    }
//    nifti_set_filenames(ImageParenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/VentriclesTest2.nii.gz", 0, 0);
//    nifti_image_write(ImageParenchyma);
    
//    nifti_set_filenames(Parenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/Parenchyma.nii.gz", 0, 0);
//    nifti_image_write(Parenchyma);
    
    //    Ventricles are not in initial parenchyma but are in final eroded ones and correspond to ones that are not close to out
    float * PotentialVentricles=new float[numel];
    for (int i=0; i<numel; i++) {
        PotentialVentricles[i]=0;
        if ((ErodedParenchyma[i])==0 && TmpParenchyma[i]==1) {
            PotentialVentricles[i]=1;
        }
    }
    for (int i=0; i<numel; i++) {
        ImageParenchyma_PTR[i]=(float)PotentialVentricles[i];
    }
//    nifti_set_filenames(ImageParenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/VentriclesTest2.nii.gz", 0, 0);
//    nifti_image_write(ImageParenchyma);
    
    delete [] ComponentBackground;
    delete [] OrderedBackground;
    ComponentBackground=NULL;
    OrderedBackground=NULL;
    
    ComponentBackground=ComponentLabeling(ImageParenchyma,6);
//    float VolumeVox=ImageParenchyma->pixdim[1]*ImageParenchyma->pixdim[2]*ImageParenchyma->pixdim[3];
    OrderedBackground=OrderedVolumeLabel(ComponentBackground, 3, numel,VolumeVox);
    nifti_image * Test=CreateNiiFromArray(OrderedBackground, ImageParenchyma,numel);
//    nifti_set_filenames(Test, "/Users/Carole/Documents/PhD/TemporaryResults/TestVentriclesOrdered", 0, 0);
//    nifti_image_write(Test);
    nifti_image_free(Test);
    
    //    For all of this potentially meaningful parts of the CSF, check distance to Out and distance to center of gravity
    bool * MaskForGravity=static_cast<bool*>(TreeToAnalyse->GetMask()->data);
    int IndexCenterGrav=GetCenterGravity(MaskForGravity, Dim);
    //    int * CoordinatesGravity=CorrespondingCoordinates(IndexCenterGrav, Dim, Shift);
    int * VolumeLabels=GetVolumeLabels(OrderedBackground, numel);
    int maxLabel=GetMaxLabel(OrderedBackground, numel);
    for (int l=1; l<maxLabel; l++) {
        float DistCenterGrav=GetDistanceLabelToPoint(OrderedBackground, l, TreeToAnalyse, IndexCenterGrav);
        cout<<"For label "<<l<<"dist to center grav is "<<DistCenterGrav<<endl;
        if (DistCenterGrav>=MaxRadius || VolumeLabels[l-1]<20) {
            cout<<"Have to discard label "<<l<<"with volume "<<VolumeLabels[l-1]<<" and distance to grav "<<DistCenterGrav<<endl;
            for (int i=0; i<numel; i++) {
                if (OrderedBackground[i]==l) {
                    OrderedBackground[i]=0;
                }
            }
        }
    }
    
    //    Once only the meaningful elements have been gathered, dilation of the obtained segmentation and combination with Parenchyma to keep
    bool * TmpVentricle=TranscribeArray<int, bool>(OrderedBackground, numel);
    float * Ventricles=TranscribeArray<bool, float>(TmpVentricle, numel);
    bool * OutMask=OpposeBoolArray(MaskForGravity, numel);
    //    Look into dilated parenchyma that is not parenchyma and see if neighbor to ventricles in 26 connectivity
    
    bool flag_change=0;
    bool flag_change2=1;
    int iteration=0;
    while (flag_change2) {
        //    float * VentriclesNew=CopyArray(Ventricles, numel);
        float * VentriclesNew=Erosion_bis(Ventricles, 9, DimVector, 0);
        
        for (int i=0; i<numel; i++) {
            if (ParenchymaData[i]==1) {
                VentriclesNew[i]=0;
            }
        }
        float * SusceptibleVentriclesBorder=SubtractArray(ErodedParenchyma,ParenchymaData,numel);
        for (int i=0; i<numel; i++) {
            if (VentriclesNew[i]==1) {
                SusceptibleVentriclesBorder[i]=0;
            }
        }
        
        for (int i=0; i<numel; i++) {
            ImageParenchyma_PTR[i]=SusceptibleVentriclesBorder[i];
        }
        delete [] SusceptibleVentriclesBorder;
        SusceptibleVentriclesBorder=NULL;
        
        
        //    Create Components for Dilated Parenchyma and store them
        delete [] ComponentBackground;
        delete [] OrderedBackground;
        ComponentBackground=NULL;
        OrderedBackground=NULL;
        ComponentBackground=ComponentLabeling(ImageParenchyma, 6);
        OrderedBackground=OrderedVolumeLabel(ComponentBackground, 3, numel,VolumeVox);
        
        for (int i=0; i<numel; i++) {
            if(L2S[i]>=0){
                ImageParenchyma_PTR[i]=(float)OrderedBackground[i];
            }
            else{
                ImageParenchyma_PTR[i]=0;
            }
        }
//        nifti_set_filenames(ImageParenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/InBetween.nii.gz", 0, 0);
//        nifti_image_write(ImageParenchyma);
        
        //    For the susceptible elements newly formed, if not too close to Out, include it in ventricles dilated before the rest. From there, check for small components far away from center of gravity
        
        maxLabel=GetMaxLabel(OrderedBackground, numel);
        int * OutMaskInt=TranscribeArray<bool, int>(OutMask, numel);
        for (int l=1; l<=maxLabel; l++) {
            bool * OrderedBoolTmp=CreateLesionBool(OrderedBackground, l, numel);
            int GravityCenter=GetCenterGravity(OrderedBoolTmp, Dim);
            float Dist=GetDistanceLabelToPoint(OutMaskInt, 1, TreeToAnalyse, GravityCenter);
            delete [] OrderedBoolTmp;
            //            float Dist=GetDistanceToSeg(OrderedBackground, l, TreeToAnalyse, OutMask );
            if (Dist<=10) { // Connected component susceptible to be added is to close to out
                cout<<"discarding label because Dist is "<<Dist <<" for label "<<l;
                for (int i=0; i<numel; i++) {
                    if (OrderedBackground[i]==l) {
                        OrderedBackground[i]=0;
                    }
                }
            }
        }
        delete [] OutMaskInt;
        
        //    Combine remaining component with DilatedVentricles
        for (int i=0; i<numel; i++) {
            if (OrderedBackground[i]>0) {
                VentriclesNew[i]=1;
            }
        }
        
        //    Redefine the connected components for the new set
        delete [] ComponentBackground;
        delete [] OrderedBackground;
        ComponentBackground=NULL;
        OrderedBackground=NULL;
        ComponentBackground=ComponentLabeling(VentriclesNew, 6, Dim, Shift);
        OrderedBackground=OrderedVolumeLabel(ComponentBackground, 3, numel,VolumeVox);
        
        //    For this new set of connected components check distance to center of mass. If too far away, discarded
        maxLabel=GetMaxLabel(OrderedBackground, numel);
        for (int l=1; l<=maxLabel; l++) {
            float Dist=GetDistanceLabelToPoint(OrderedBackground, l, TreeToAnalyse, IndexCenterGrav);
            if (Dist>=MaxRadius) { // Connected component susceptible to be added is to close to out
                cout<<"discarding label "<<l;
                for (int i=0; i<numel; i++) {
                    if (OrderedBackground[i]==l) {
                        OrderedBackground[i]=0;
                    }
                }
            }
        }
        
        //    Check temporary result
        for (int i=0; i<numel; i++) {
            if(L2S[i]>=0){
                ImageParenchyma_PTR[i]=(float)OrderedBackground[i];
                VentriclesNew[i]=(OrderedBackground[i]==1);
            }
            else{
                VentriclesNew[i]=0;
                ImageParenchyma_PTR[i]=0;
            }
        }
        
        //        CompareVentricles and VentricleNew
        int CountModified=0;
        int CountElements=0;
        for (int i=0; i<numelmasked; i++) {
            int IndexLong=S2L[i];
            if (Ventricles[IndexLong]!=VentriclesNew[IndexLong]) {
                Ventricles[IndexLong]=VentriclesNew[IndexLong];
                flag_change=1;
                CountModified++;
            }
            if (Ventricles[IndexLong]==1) {
                CountElements++;
            }
        }
        cout<<"Iteration "<<iteration<<" performed for Ventricle Segmentation "<< " with "<<CountModified<<" modifications so "<<(float)CountModified/CountElements*100.0<<" percent"<<endl;
        iteration++;
        
        
        delete [] VentriclesNew;
        VentriclesNew=NULL;
        if (!flag_change || iteration>1) {
            flag_change2=0;
        }
        flag_change=0;
        
//        nifti_set_filenames(ImageParenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/VentriclesTmp.nii.gz", 0, 0);
//        nifti_image_write(ImageParenchyma);
    }
    
    //    Closing for Ventricles
    float *VentriclesD=Erosion_bis(Ventricles, 3, DimVector, 0);
    float *VentriclesC=Erosion_bis(VentriclesD, 3, DimVector, 1);
    delete [] Ventricles;
    delete [] VentriclesD;
    for (int i=0; i<numelmasked; i++) {
        int IndexLong=S2L[i];
        ImageParenchyma_PTR[IndexLong]=VentriclesC[IndexLong];
        if (!CSFData[IndexLong]) {
            ImageParenchyma_PTR[IndexLong]=0;
        }
    }
//    nifti_set_filenames(ImageParenchyma, "/Users/Carole/Documents/PhD/TemporaryFiles/VentriclesFin.nii.gz", 0, 0);
//    nifti_image_write(ImageParenchyma);
    
    nifti_image_free(GMHard);
    nifti_image_free(WMHard);
    nifti_image_free(CSFHard);
    GMHard=NULL;
    WMHard=NULL;
    CSFHard=NULL;
    return ImageParenchyma;
}



//Extract pseudo mask for Laplace postprocessing when no parcellation is available
nifti_image * ExtractParenchyma(nifti_image * SummarisedSeg, nifti_image * VentricleSeg, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    //    int numel=TreeToAnalyse->GetNumberElements();
    int numel=SummarisedSeg->nx*SummarisedSeg->ny*SummarisedSeg->nz;
    //    Create the corresponding hard segmentation
    int * L2S=TreeToAnalyse->GetL2S();
    int * S2L=TreeToAnalyse->GetS2L();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    nifti_image * GMHard=HardSegmentationIndex(SummarisedSeg,segment_analysis->IndexGM,L2S);
    nifti_image * WMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexWM, L2S);
    //    nifti_image * OutHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexOut, L2S);
    nifti_image * CSFHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexCSF, L2S);
    //    float * OutHardData=static_cast<float *>(OutHard->data);
    float * WMData=static_cast<float *>(WMHard->data);
    float * VData=static_cast<float *>(VentricleSeg->data);
    float * GMData=static_cast<float *>(GMHard->data);
    //    bool * VHardSeg=TranscribeArray<float, bool>(VData, numel);
    float * CSFData=static_cast<float *>(CSFHard->data);
    //    Creating needed Dim and Shift
    int Dim[3];
    int Shift[3];
    Dim[0]=SummarisedSeg->nx;
    Dim[1]=SummarisedSeg->ny;
    Dim[2]=SummarisedSeg->nz;
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    vector<int>DimVector;
    DimVector.push_back(Dim[0]);
    DimVector.push_back(Dim[1]);
    DimVector.push_back(Dim[2]);
    
    //    Creating ECSF as CSF-Ventricle
    float * ECSF=SubtractArray(CSFData, VData, numel);
    vector<float *> ArrayParenchyma;
    ArrayParenchyma.push_back(GMData);
    ArrayParenchyma.push_back(WMData);
    float * Parenchyma=AddArray(ArrayParenchyma, numel);
    
    //    Dilated Version of ECSF
    float * ECSFD=Erosion_bis(ECSF, 3, DimVector, 0);
    //    Modified parenchyma with eroded ECSF
    for (int i=0; i<numelmasked; i++) {
        int IndexLong=S2L[i];
        if (ECSFD[IndexLong] && !WMData[IndexLong]) {
            Parenchyma[IndexLong]=0;
        }
    }
    
    //    Creation of image for check along the way
    nifti_image * TestImage=nifti_copy_nim_info(GMHard);
    TestImage->data=(void *) calloc(TestImage->nvox, sizeof(float));
    float * TestData=static_cast<float *>(TestImage->data);
    //    First test for storage here:
    for (int i=0; i<numel; i++) {
        TestData[i]=Parenchyma[i];
    }
//    nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/WMDGMInit.nii.gz", 0, 0);
//    nifti_image_write(TestImage);
    return TestImage;
    
}

//nifti_image * VentricleSegmentation_bis(nifti_image * SummarisedSeg, TreeEM * TreeToAnalyse, SEG_ANALYSIS *segment_analysis){
//    int numel=SummarisedSeg->nx*SummarisedSeg->ny*SummarisedSeg->nz;
//    //    Create the corresponding hard segmentation
//    int * L2S=TreeToAnalyse->GetL2S();
//    int * S2L=TreeToAnalyse->GetS2L();
//    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
//    nifti_image * GMHard=HardSegmentationIndex(SummarisedSeg,segment_analysis->IndexGM,L2S);
//    nifti_image * WMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexWM, L2S);
//    nifti_image * OutHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexOut, L2S);
//    nifti_image * CSFHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexCSF, L2S);
//    float * OutHardData=static_cast<float *>(OutHard->data);
//    float * WMData=static_cast<float *>(WMHard->data);
//    float * GMData=static_cast<float *>(GMHard->data);
//    float * CSFData=static_cast<float *>(CSFHard->data);
//    bool * MaskToUse=static_cast<bool*>(TreeToAnalyse->GetMask()->data);
//    //    Creating needed Dim and Shift
//    int Dim[3];
//    int Shift[3];
//    Dim[0]=SummarisedSeg->nx;
//    Dim[1]=SummarisedSeg->ny;
//    Dim[2]=SummarisedSeg->nz;
//    Shift[0]=1;
//    Shift[1]=Dim[0];
//    Shift[2]=Dim[1]*Shift[1];
//    vector<int>DimVector;
//    DimVector.push_back(Dim[0]);
//    DimVector.push_back(Dim[1]);
//    DimVector.push_back(Dim[2]);
//
////    First construction of parenchyma
//    vector<float *> ParenchymaVector;
//    ParenchymaVector.push_back(GMData);
//    ParenchymaVector.push_back(WMData);
////    Closing operation on parenchyma
//    float * Parenchyma=AddArray(ParenchymaVector, numel);
//    float * Parenchyma1=Erosion_bis(Parenchyma, 5, DimVector, 0);
//    float * Parenchyma2=Erosion_bis(Parenchyma1, 3, DimVector, 1);
//
//        //    Creation of image for check along the way
//        nifti_image * TestImage=nifti_copy_nim_info(GMHard);
//        TestImage->data=(void *) calloc(TestImage->nvox, sizeof(float));
//        float * TestData=static_cast<float *>(TestImage->data);
//        //    First test for storage here:
//        for (int i=0; i<numel; i++) {
//            TestData[i]=Parenchyma2[i];
//        }
//        nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/VentricleInit.nii.gz", 0, 0);
//        nifti_image_write(TestImage);
//
////    Obtaining connected components for CSF with Parenchyma closed for cutting
//    float * CSFClosed=new float [numel];
//    for (int i=0; i<numel; i++) {
//        if (L2S[i]>=0) {
//            CSFClosed[i]=((!Parenchyma2[i]*CSFData[i])>0);
//        }
//        else{
//            CSFClosed[i]=0;
//        }
//    }
//
//    //    First test for storage here:
//    for (int i=0; i<numel; i++) {
//        TestData[i]=CSFClosed[i];
//    }
//    nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/VentricleInit.nii.gz", 0, 0);
//    nifti_image_write(TestImage);
//
//    int * ComponentLabel=ComponentLabeling(CSFClosed, 6, Dim, Shift);
//    int * OrderedLabel=OrderedVolumeLabel(ComponentLabel, 4, numel);
//
//
//    //    First test for storage here:
//    for (int i=0; i<numel; i++) {
//        TestData[i]=OrderedLabel[i];
//    }
//    nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/VentricleInit.nii.gz", 0, 0);
//    nifti_image_write(TestImage);
//
//        int IndexCentreGravity=GetCenterGravity(MaskToUse, Dim);
//
////    Determination of Centre of gravity
////    Check for distance to out and to CenterGravity
//
//}

//// Separate DGM from CGM based on distance to out region from connected components of GM
//nifti_image * ExtractWMDGM(nifti_image * SummarisedSeg,nifti_image * VentricleSegmentation, SEG_ANALYSIS * segment_analysis, TreeEM * TreeToAnalyse){
////    int numel=TreeToAnalyse->GetNumberElements();
//    int numel=SummarisedSeg->nx*SummarisedSeg->ny*SummarisedSeg->nz;
//    //    Create the corresponding hard segmentation
//    int * L2S=TreeToAnalyse->GetL2S();
//    int * S2L=TreeToAnalyse->GetS2L();
//    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
//    nifti_image * GMHard=HardSegmentationIndex(SummarisedSeg,segment_analysis->IndexGM,L2S);
//    nifti_image * WMHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexWM, L2S);
//    nifti_image * OutHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexOut, L2S);
//    nifti_image * CSFHard=HardSegmentationIndex(SummarisedSeg, segment_analysis->IndexCSF, L2S);
//    float * OutHardData=static_cast<float *>(OutHard->data);
//    float * WMData=static_cast<float *>(WMHard->data);
//    float * VData=static_cast<float *>(VentricleSegmentation->data);
//    bool * VHardSeg=TranscribeArray<float, bool>(VData, numel);
//    float * CSFData=static_cast<float *>(CSFHard->data);
////    Creating needed Dim and Shift
//    int Dim[3];
//    int Shift[3];
//    Dim[0]=SummarisedSeg->nx;
//    Dim[1]=SummarisedSeg->ny;
//    Dim[2]=SummarisedSeg->nz;
//    Shift[0]=1;
//    Shift[1]=Dim[0];
//    Shift[2]=Dim[1]*Shift[1];
//    vector<int>DimVector;
//    DimVector.push_back(Dim[0]);
//    DimVector.push_back(Dim[1]);
//    DimVector.push_back(Dim[2]);
////    Combine WM and Ventricles
//    vector<float *> ArrayWMV;
//    ArrayWMV.push_back(WMData);
//    ArrayWMV.push_back(VData);
//
////    ArrayWMV.push_back(CSFData);
//    float * WMV=AddArray(ArrayWMV, numel);
//
//    ArrayWMV.clear();
//
//
//    //    Creation of image for check along the way
//    nifti_image * TestImage=nifti_copy_nim_info(GMHard);
//    TestImage->data=(void *) calloc(TestImage->nvox, sizeof(float));
//    float * TestData=static_cast<float *>(TestImage->data);
//    //    First test for storage here:
//    for (int i=0; i<numel; i++) {
//        TestData[i]=WMV[i];
//    }
//    nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/WMDGMInit.nii.gz", 0, 0);
//    nifti_image_write(TestImage);
//
//    ////    Create External CSF as CSF-Ventricles
//    float * ECSFData=SubtractArray(CSFData, VData, numel);
//    bool * ECSFH=TranscribeArray<float, bool>(ECSFData, numel);
//
////    Dilate WMV to be able to produce connected components
//    float * VD=Erosion_bis(VData, 9, DimVector, 0);
//    float * ECSFD=Erosion_bis(ECSFData, 3, DimVector, 0);
//    float * WMD=Erosion_bis(WMData, 3, DimVector, 0);
//    ArrayWMV.push_back(WMData);
//    ArrayWMV.push_back(VD);
////    ArrayWMV.push_back(ECSFD);
//    float * WMVD=AddArray(ArrayWMV, numel);
//    float * WMVD2=Erosion_bis(WMVD, 3, DimVector, 0);
//    float * WMVD3=Erosion_bis(WMVD2, 3, DimVector, 1);
//    //    First test for storage here:
//    for (int i=0; i<numel; i++) {
//        TestData[i]=WMVD3[i];
//    }
//    nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/WMDGMInit.nii.gz", 0, 0);
//    nifti_image_write(TestImage);
//
////    booleanise and oppose WMV dilated
//    bool * TmpWMV=TranscribeArray<float, bool>(WMVD3, numel);
//    bool * BackgroundWMV=OpposeBoolArray(TmpWMV, numel);
////    Change Background WMV so that it is only 1 within the mask and if the Hard classif is GM
//    for (int i=0; i<numel; i++) {
//        if (L2S[i]<0) {
//            BackgroundWMV[i]=0;
//        }
////        else if(ECSFData[i]==0){
////            BackgroundWMV[i]=0;
////        }
//    }
//
//    float * TmpBckWMV=TranscribeArray<bool, float>(BackgroundWMV, numel);
//
////    Create the connected components from the WMVBackground segmentation
//    int * ComponentLabel=ComponentLabeling(TmpBckWMV, 6, Dim, Shift);
//    int * OrderedLabels=OrderedVolumeLabel(ComponentLabel, 3, numel);
//
////    From the connected components, discard those that are too close to border of mask. For that need to make the oppose of the brain mask and check for distance.
//    bool * MaskInit=static_cast<bool *>(TreeToAnalyse->GetMask()->data);
//    bool * OppMask=OpposeBoolArray(MaskInit, numel);
//    int maxLabel=GetMaxLabel(OrderedLabels, numel);
//    for (int l=1; l<=maxLabel; l++) {
//        float Dist=GetDistanceToSeg(OrderedLabels, l, TreeToAnalyse, OppMask);
//        float DistVentricles=GetDistanceToSeg(OrderedLabels, l, TreeToAnalyse, VHardSeg);
//        if (Dist <=15||DistVentricles>=20) { // Too close to border of Mask to be considered as DGM or too far from ventricles
//            cout<< "Dist out "<<Dist <<" and to ventricles "<< DistVentricles<<" for label "<<l<<endl;
//
//            for (int i=0; i<numel; i++) {
//                if (OrderedLabels[i]==l) {
//                    OrderedLabels[i]=0;
//                }
//            }
//        }
//    }
//
//
//    for (int i=0; i<numel; i++) {
//        TestData[i]=OrderedLabels[i];
//    }
//    nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/WMDGMInit.nii.gz", 0, 0);
//    nifti_image_write(TestImage);
//
////    Create the WM+DGM by simply combining OrderedLabels and WMData
//    float * WMDGMData=new float [numel];
//    for (int i=0; i<numel; i++) {
//        if (L2S[i]>=0) {
//            WMDGMData[i]=((WMData[i]+OrderedLabels[i]-CSFData[i])>0);
//        }
//        else{
//            WMDGMData[i]=0;
//        }
//    }
//
//
////    Take care of voxels in the in between zone brought by dilated WMV
//    float * SusceptibleInBetween=SubtractArray(WMVD, WMV, numel);
//    for (int i=0; i<numelmasked; i++) {
//        if (WMDGMData[S2L[i]]==1) {
//            SusceptibleInBetween[S2L[i]]=0;
//        }
//    }
//    delete [] ComponentLabel;
//    delete [] OrderedLabels;
//    ComponentLabel=NULL;
//    OrderedLabels=NULL;
//    ComponentLabel=ComponentLabeling(SusceptibleInBetween, 6, Dim, Shift);
//    OrderedLabels=OrderedVolumeLabel(ComponentLabel, 2, numel);
//    delete [] SusceptibleInBetween;
//    SusceptibleInBetween=NULL;
////    For all the elements in intermediate zone, check distance to border of mask
//    maxLabel=GetMaxLabel(OrderedLabels, numel);
//    for (int l=1; l<=maxLabel; l++) {
//        float Dist=GetDistanceToSeg(OrderedLabels, l, TreeToAnalyse, OppMask);
//        if (Dist <=15) { // Too close to border of Mask to be considered as DGM
//            for (int i=0; i<numelmasked; i++) {
//                if (OrderedLabels[S2L[i]]==l) {
//                    OrderedLabels[S2L[i]]=0;
//                }
//            }
//        }
//    }
//
//    for (int i=0; i<numel; i++) {
//        if (L2S[i]>=0) {
//            WMDGMData[i]=((WMDGMData[i]+OrderedLabels[i])*(1-CSFData[i])>0);
//        }
//        else{
//            WMDGMData[i]=0;
//        }
//    }
//    delete [] ComponentLabel;
//    delete [] OrderedLabels;
//
//    //    Creation of image for check along the way
//    //    First test for storage here:
//    for (int i=0; i<numel; i++) {
//        TestData[i]=WMDGMData[i];
//    }
//
//    nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/WMDGMExtract.nii.gz", 0, 0);
//    nifti_image_write(TestImage);
//
//
////    Iterate between dilation of elements obtained, subtraction to see what would be added, and check for distance to outer
//    bool flag_change=0;
//    bool flag_change2=1;
//    int iteration=0;
//    vector<float *> WMVVector;
//    WMVVector.push_back(VData);
//    WMVVector.push_back(WMDGMData);
//    delete [] WMVD;
//    WMVD=0;
//    WMVD=AddArray(WMVVector, numel);
//    while (flag_change2) {
//        float * WMVDNew=Erosion_bis(WMVD, 11, DimVector, 0);
//        bool * WMVDExtend=TranscribeArray<float, bool>(WMVDNew, numel);
//        bool * WMVDOpp=OpposeBoolArray(WMVDExtend, numel);
//        for (int i=0; i<numel; i++) {
//            if (L2S[i]<0) {
//                WMVDOpp[i]=0;
//            }
//        }
//        for (int i=0; i<numel; i++) {
//            if (WMVDOpp[i]==1) {
//                if (ECSFData[i]==1) {
//                    WMVDOpp[i]=0;
//                }
//            }
//        }
//        float * WMVDO=TranscribeArray<bool, float>(WMVDOpp, numel);
////        Create connected components over possible to add
//        ComponentLabel=ComponentLabeling(WMVDO, 6, Dim , Shift);
//        OrderedLabels=OrderedVolumeLabel(ComponentLabel, 1, numel);
//
//        delete [] WMVDExtend;
//        delete [] WMVDOpp;
//        delete [] WMVDO;
//        WMVDExtend=NULL;
//        WMVDOpp=NULL;
//        WMVDO=NULL;
//        maxLabel=GetMaxLabel(OrderedLabels, numel);
//        for (int l=1; l<=maxLabel; l++) {
//            float Dist=GetDistanceToSeg(OrderedLabels, l, TreeToAnalyse, OppMask);
//            if (Dist <=20) { // Too close to ECSF to be considered as DGM
//                for (int i=0; i<numelmasked; i++) {
//                    if (OrderedLabels[S2L[i]]==l) {
//                        OrderedLabels[S2L[i]]=0;
//                    }
//                }
//            }
//        }
//        int CountAdded=0;
//        for (int i=0; i<numel; i++) {
//            if (L2S[i]>=0) {
//                TestData[i]=OrderedLabels[i];
//                if (OrderedLabels[i]>0 && CSFData[i]==0) {
//                    CountAdded++;
//                    flag_change=1;
//                    WMDGMData[i]=1;
//                    WMVD[i]=1;
//                }
//            }
//        }
//
//        nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/WMDGMTest.nii.gz", 0, 0);
//        nifti_image_write(TestImage);
//
//        cout<<"Adding "<<CountAdded<<endl;
//        delete [] ComponentLabel;
//        delete [] OrderedLabels;
//
////        Take care of new in between
//        float * WMVDiff=SubtractArray(WMVDNew, WMVD, numel);
//        ComponentLabel=ComponentLabeling(WMVDiff, 6, Dim, Shift);
//        OrderedLabels=OrderedVolumeLabel(ComponentLabel, 1, numel);
//
//
//        if(!flag_change||iteration >3){
//            flag_change2=0;
//        }
//        iteration++;
//
//        for (int i=0; i<numel; i++) {
//            TestData[i]=WMDGMData[i];
//        }
//         nifti_set_filenames(TestImage, "/Users/Carole/Documents/PhD/TemporaryFiles/WMDGMTest2.nii.gz", 0, 0);
//            nifti_image_write(TestImage);
//
//    }
//    delete [] WMV;
//    delete [] WMVD;
//    delete [] OppMask;
//    delete [] TmpBckWMV;
//    delete [] TmpWMV;
//    delete [] BackgroundWMV;
//
//    cout<<"Extraction DGM performed"<<endl;
//
//    return TestImage;
//}

//Create the final corrected soft or hard segmentation for the lesion classified voxels using the vector of lesion identity card as defined earlier
nifti_image * LesionReconstructTrueSegOutlier_ter(int * OrderedLabelsLesion, nifti_image * LesionInitialSeg, nifti_image * SummarisedSeg, vector<Outlier *> VectorOutlier, TreeEM * TreeToAnalyse, int TypeSeg,SEG_ANALYSIS * segment_analysis){
    int Dim[3];
    Dim[0]=LesionInitialSeg->nx;
    Dim[1]=LesionInitialSeg->ny;
    Dim[2]=LesionInitialSeg->nz;
    int numel=TreeToAnalyse->GetNumberElements();
    
    //    Segmentation of the lesion according to other elements
    cout<<"Doing the hard segmentation of initial seg for true les..."<<endl;
    nifti_image * HardLesInit=NULL;
    switch (segment_analysis->flag_segType) {
            case 1:
            HardLesInit=HardSegmentationThreshold(LesionInitialSeg, 0.5);
            break;
            case 2:
            HardLesInit=HardSegmentationLesionReconstruct(LesionInitialSeg, TreeToAnalyse);
            break;
            case 3:
            HardLesInit=HardSegmentationLesionReconstruct_bis(LesionInitialSeg, SummarisedSeg, TreeToAnalyse, segment_analysis);
            break;
        default:
            HardLesInit=HardSegmentationLesionReconstruct_bis(LesionInitialSeg, SummarisedSeg, TreeToAnalyse, segment_analysis);
            break;
    }
    
    
    int * LesionClassified=OutlierClassification(OrderedLabelsLesion, VectorOutlier, Dim);
    nifti_image * ImageLesionClassif=CreateNiiFromArray(LesionClassified, LesionInitialSeg,numel);
    //    nifti_set_filenames(ImageLesionClassif, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTest.nii.gz", 0, 0);
    //    nifti_image_write(ImageLesionClassif);
    //    nifti_set_filenames(HardLesInit, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTestHard.nii.gz", 0, 0);
    //    nifti_image_write(HardLesInit);
    // Save in a nifti image the final lesions to consider (taking out the FP lesiony elements)
    nifti_image * HardLesionCorrected=CorrectionLesionFromClassif(ImageLesionClassif, LesionInitialSeg);
    
    //    nifti_set_filenames(HardLesionCorrected, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTestHardCorr.nii.gz", 0, 0);
    //    nifti_image_write(HardLesionCorrected);
    
    
    // From the final hard lesion corrected, save in nifti image result the binary seg or the soft one.
    nifti_image * FinalLesionSeg=nifti_copy_nim_info(LesionInitialSeg);
    FinalLesionSeg->data=(void *) calloc(numel, sizeof(float));
    float * HardLesionCorrectedData=static_cast<float *>(HardLesionCorrected->data);
    float * HardLesInitData=static_cast<float *>(HardLesInit->data);
    float * LesionInitialSegData=static_cast<float *>(LesionInitialSeg->data);
    float * FinalLesionSegData=static_cast<float *>(FinalLesionSeg->data);
    if (TypeSeg) { // Case where we want the probabilistic values and not only the binary ones
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1 && HardLesInitData[i]>0.1) {
                FinalLesionSegData[i]=LesionInitialSegData[i];
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    else{ // Case where we save the binary result
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1 && HardLesInitData[i]>0.1) {
                FinalLesionSegData[i]=1;
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    
    // Clear memory before returning the image result
//    nifti_set_filenames(FinalLesionSeg, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTestHardCorrFin.nii.gz", 0, 0);
//    nifti_image_write(FinalLesionSeg);
    
    delete [] LesionClassified;
    
    LesionClassified=NULL;
    
    nifti_image_free(ImageLesionClassif);
    nifti_image_free(HardLesionCorrected);
    nifti_image_free(HardLesInit);
    ImageLesionClassif=NULL;
    HardLesionCorrected=NULL;
    HardLesInit=NULL;
    
    return FinalLesionSeg;
}







//Create the final corrected soft or hard segmentation for the lesion classified voxels using the vector of lesion identity card as defined earlier
nifti_image * LesionReconstructTrueSeg_ter(int * OrderedLabelsLesion, nifti_image * LesionInitialSeg, nifti_image * SummarisedSeg, vector<Lesion *> VectorLesion, TreeEM * TreeToAnalyse, int TypeSeg,SEG_ANALYSIS * segment_analysis){
    int Dim[3];
    Dim[0]=LesionInitialSeg->nx;
    Dim[1]=LesionInitialSeg->ny;
    Dim[2]=LesionInitialSeg->nz;
    int numel=TreeToAnalyse->GetNumberElements();
    
    //    Segmentation of the lesion according to other elements
    cout<<"Doing the hard segmentation of initial seg for true les..."<<endl;
    nifti_image * HardLesInit=NULL;
    switch (segment_analysis->flag_segType) {
            case 1:
            HardLesInit=HardSegmentationThreshold(LesionInitialSeg, 0.5);
            break;
            case 2:
            HardLesInit=HardSegmentationLesionReconstruct(LesionInitialSeg, TreeToAnalyse);
            break;
            case 3:
            HardLesInit=HardSegmentationLesionReconstruct_bis(LesionInitialSeg, SummarisedSeg, TreeToAnalyse, segment_analysis);
            break;
        default:
            HardLesInit=HardSegmentationLesionReconstruct_bis(LesionInitialSeg, SummarisedSeg, TreeToAnalyse, segment_analysis);
            break;
    }
    
    
    int * LesionClassified=LesionClassification(OrderedLabelsLesion, VectorLesion, Dim);
    nifti_image * ImageLesionClassif=CreateNiiFromArray(LesionClassified, LesionInitialSeg,numel);
//    nifti_set_filenames(ImageLesionClassif, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTest.nii.gz", 0, 0);
//    nifti_image_write(ImageLesionClassif);
//    nifti_set_filenames(HardLesInit, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTestHard.nii.gz", 0, 0);
//    nifti_image_write(HardLesInit);
    // Save in a nifti image the final lesions to consider (taking out the FP lesiony elements)
    nifti_image * HardLesionCorrected=CorrectionLesionFromClassif(ImageLesionClassif, LesionInitialSeg);
    
//    nifti_set_filenames(HardLesionCorrected, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTestHardCorr.nii.gz", 0, 0);
//    nifti_image_write(HardLesionCorrected);
    
    
    // From the final hard lesion corrected, save in nifti image result the binary seg or the soft one.
    nifti_image * FinalLesionSeg=nifti_copy_nim_info(LesionInitialSeg);
    FinalLesionSeg->data=(void *) calloc(numel, sizeof(float));
    float * HardLesionCorrectedData=static_cast<float *>(HardLesionCorrected->data);
    float * HardLesInitData=static_cast<float *>(HardLesInit->data);
    float * LesionInitialSegData=static_cast<float *>(LesionInitialSeg->data);
    float * FinalLesionSegData=static_cast<float *>(FinalLesionSeg->data);
    if (TypeSeg) { // Case where we want the probabilistic values and not only the binary ones
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1 && HardLesInitData[i]>0.1) {
                FinalLesionSegData[i]=LesionInitialSegData[i];
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    else{ // Case where we save the binary result
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1 && HardLesInitData[i]>0.1) {
                FinalLesionSegData[i]=1;
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    
    // Clear memory before returning the image result
//    nifti_set_filenames(FinalLesionSeg, "/Users/Carole/Documents/PhD/TemporaryFiles/ImageTestHardCorrFin.nii.gz", 0, 0);
//    nifti_image_write(FinalLesionSeg);
    
    delete [] LesionClassified;
    
    LesionClassified=NULL;
    
    nifti_image_free(ImageLesionClassif);
    nifti_image_free(HardLesionCorrected);
    nifti_image_free(HardLesInit);
    ImageLesionClassif=NULL;
    HardLesionCorrected=NULL;
    HardLesInit=NULL;
    
    return FinalLesionSeg;
}



// Create the final corrected soft or hard segmentation for the lesion classified voxels
nifti_image * LesionCorrectedTrueSeg_bis(nifti_image * LesionInitialSeg, nifti_image * SummarisedSeg, TreeEM * TreeToAnalyse, bool TypeSeg, SEG_ANALYSIS * segment_analysis,nifti_image * VentricleSeg ){
    int numel=TreeToAnalyse->GetNumberElements();
    
    cout<<"Doing the hard segmentation of initial seg ..."<<endl;
    nifti_image * HardLesInit=NULL;
    switch (segment_analysis->flag_segType) {
            case 1:
            HardLesInit=HardSegmentationThreshold(LesionInitialSeg, 0.5);
            break;
            case 2:
            HardLesInit=HardSegmentationLesionReconstruct(LesionInitialSeg, TreeToAnalyse);
            break;
            case 3:
            HardLesInit=HardSegmentationLesionReconstruct_bis(LesionInitialSeg, SummarisedSeg, TreeToAnalyse, segment_analysis);
            break;
        default:
            HardLesInit=HardSegmentationLesionReconstruct_bis(LesionInitialSeg, SummarisedSeg, TreeToAnalyse, segment_analysis);
            break;
    }
    //    nifti_image * HardLesInit=HardSegmentationLesionReconstruct_bis(LesionInitialSeg, SummarisedSeg, TreeToAnalyse, segment_analysis);
    
    //    nifti_set_filenames(HardLesInit, "/Users/Carole/Documents/PhD/TemporaryFiles/TestStrange/TestHard.nii.gz", 0, 0);
    //    nifti_image_write(HardLesInit);
    
    float * HardLesInitData=static_cast<float *>(HardLesInit->data);
    //    int * Dim=new int[3];
    int Dim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=HardLesInit->dim[d+1];
    }
    // Create the separated connected lesion components
    int * LabelComponent=ComponentLabeling(HardLesInit,6,0.5);
    // Refine and order by decreasing volume the found lesions.
    float VolumeVox=HardLesInit->pixdim[1]*HardLesInit->pixdim[2]*HardLesInit->pixdim[3];
    int * OrderedLabelsLesion=OrderedVolumeLabel(LabelComponent, 3, numel,VolumeVox);
    
    //    Create SummarisedSeg decoupled
    nifti_image * SummarisedSegDec=SummarisedSegDecoupled(SummarisedSeg, LesionInitialSeg, segment_analysis->IndexWM);
    
    // Create the vector of lesion structures corresponding to the refined lesion (refined by volume)
    vector<Lesion *> VectorLesion=GetVectorLesion_bis(OrderedLabelsLesion, SummarisedSegDec, TreeToAnalyse, segment_analysis,VentricleSeg);
    // According to the vector of lesion structure and the overall model, gives the code classification for the lesion
    int * LesionClassified=LesionClassification(OrderedLabelsLesion, VectorLesion, Dim);
    nifti_image * ImageLesionClassif=CreateNiiFromArray(LesionClassified, LesionInitialSeg,numel);
    // Save in a nifti image the final lesions to consider (taking out the FP lesiony elements)
    nifti_image * HardLesionCorrected=CorrectionLesionFromClassif(ImageLesionClassif, LesionInitialSeg);
    
    // From the final hard lesion corrected, save in nifti image result the binary seg or the soft one.
    nifti_image * FinalLesionSeg=nifti_copy_nim_info(LesionInitialSeg);
    FinalLesionSeg->data=(void *) calloc(numel, sizeof(float));
    float * HardLesionCorrectedData=static_cast<float *>(HardLesionCorrected->data);
    float * LesionInitialSegData=static_cast<float *>(LesionInitialSeg->data);
    float * FinalLesionSegData=static_cast<float *>(FinalLesionSeg->data);
    if (TypeSeg) { // Case where we want the probabilistic values and not only the binary ones
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1 && HardLesInitData[i]>0.1) {
                FinalLesionSegData[i]=LesionInitialSegData[i];
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    else{ // Case where we save the binary result
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1 && HardLesInitData[i]>0.1) {
                FinalLesionSegData[i]=1;
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    
    // Clear memory before returning the image result
    int numblesion=VectorLesion.size();
    for (int l=0; l<numblesion; l++) {
        delete VectorLesion[l];
        VectorLesion[l]=NULL;
    }
    VectorLesion.clear();
    
    delete [] LabelComponent;
    //    delete [] Dim;
    delete [] LesionClassified;
    delete [] OrderedLabelsLesion;
    LabelComponent=NULL;
    //    Dim=NULL;
    LesionClassified=NULL;
    OrderedLabelsLesion=NULL;
    
    nifti_image_free(ImageLesionClassif);
    nifti_image_free(HardLesionCorrected);
    nifti_image_free(HardLesInit);
    nifti_image_free(SummarisedSegDec);
    SummarisedSegDec=NULL;
    ImageLesionClassif=NULL;
    HardLesionCorrected=NULL;
    HardLesInit=NULL;
    
    return FinalLesionSeg;
    
}




// Create the final corrected soft or hard segmentation for the lesion classified voxels
nifti_image * LesionCorrectedTrueSeg(nifti_image * LesionInitialSeg, TreeEM * TreeToAnalyse, bool TypeSeg, SEG_ANALYSIS * segment_analysis ){
    int numel=TreeToAnalyse->GetNumberElements();
    nifti_image * HardLesInit=HardSegmentationLesionReconstruct(LesionInitialSeg, TreeToAnalyse);
    //    int * Dim=new int[3];
    int Dim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=HardLesInit->dim[d+1];
    }
    // Create the separated connected lesion components
    int * LabelComponent=ComponentLabeling(HardLesInit,6,0.5);
    // Refine and order by decreasing volume the found lesions.
    float VolumeVox=HardLesInit->pixdim[1]*HardLesInit->pixdim[2]*HardLesInit->pixdim[3];
    int * OrderedLabelsLesion=OrderedVolumeLabel(LabelComponent, 3, numel,VolumeVox);
    
    // Create the vector of lesion structures corresponding to the refined lesion (refined by volume)
    vector<Lesion *> VectorLesion=GetVectorLesion(OrderedLabelsLesion, TreeToAnalyse, segment_analysis);
    // According to the vector of lesion structure and the overall model, gives the code classification for the lesion
    int * LesionClassified=LesionClassification(OrderedLabelsLesion, VectorLesion, Dim);
    nifti_image * ImageLesionClassif=CreateNiiFromArray(LesionClassified, LesionInitialSeg,numel);
    // Save in a nifti image the final lesions to consider (taking out the FP lesiony elements)
    nifti_image * HardLesionCorrected=CorrectionLesionFromClassif(ImageLesionClassif, LesionInitialSeg);
    
    // From the final hard lesion corrected, save in nifti image result the binary seg or the soft one.
    nifti_image * FinalLesionSeg=nifti_copy_nim_info(LesionInitialSeg);
    FinalLesionSeg->data=(void *) calloc(numel, sizeof(float));
    float * HardLesionCorrectedData=static_cast<float *>(HardLesionCorrected->data);
    float * LesionInitialSegData=static_cast<float *>(LesionInitialSeg->data);
    float * FinalLesionSegData=static_cast<float *>(FinalLesionSeg->data);
    if (TypeSeg) { // Case where we want the probabilistic values and not only the binary ones
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1) {
                FinalLesionSegData[i]=LesionInitialSegData[i];
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    else{ // Case where we save the binary result
        for (int i=0; i<numel; i++) {
            if (HardLesionCorrectedData[i]>0.1) {
                FinalLesionSegData[i]=1;
            }
            else{
                FinalLesionSegData[i]=0;
            }
        }
    }
    
    // Clear memory before returning the image result
    int numblesion=VectorLesion.size();
    for (int l=0; l<numblesion; l++) {
        delete VectorLesion[l];
        VectorLesion[l]=NULL;
    }
    VectorLesion.clear();
    
    delete [] LabelComponent;
    //    delete [] Dim;
    delete [] LesionClassified;
    delete [] OrderedLabelsLesion;
    LabelComponent=NULL;
    //    Dim=NULL;
    LesionClassified=NULL;
    OrderedLabelsLesion=NULL;
    
    nifti_image_free(ImageLesionClassif);
    nifti_image_free(HardLesionCorrected);
    nifti_image_free(HardLesInit);
    ImageLesionClassif=NULL;
    HardLesionCorrected=NULL;
    HardLesInit=NULL;
    
    return FinalLesionSeg;
    
}


// Create ObjectIn or ObjectOut from Parcellation image and LesionFinal image
bool * CreateObjectsFromParcelLesSeg(nifti_image * ParcellationImage, nifti_image * LesionTot, vector<int> LabelVector, int LesionHandling){
    int numel=ParcellationImage->nvox;
    // Check relative compatibility between LesionTot and ParcellationImage
    if (LesionTot!=NULL) {
        bool flag_compatible=CheckCompatibleDimensions(ParcellationImage, LesionTot);
        if (!flag_compatible) {
            return NULL;
        }
    }
    if (LesionTot==NULL) {
        LesionHandling=0;
    }
    // First create the object obtained by simple association of the parcellation labels cited in LabelVector.
    bool * ObjectFinal=CreateBoolObjectFromParcellation(ParcellationImage, LabelVector);
    // Second according to LesionHandling, keep, add or remove lesion part
    float * LesionData=static_cast<float *>(LesionTot->data);
    switch (LesionHandling) {
            case 1: // case where if not already in ObjectFinal, we add the corresponding voxels to the bool array object
        {
            for (int i=0; i<numel; i++) {
                if (ObjectFinal[i]==0 && LesionData[i]>0.2) {
                    ObjectFinal[i]=1;
                }
            }
        }
            break;
            case 2:{ // case where we remove the voxels from ObjectFinal that correspond to a lesion.
                for (int i=0; i<numel; i++) {
                    if (ObjectFinal[i]==1 && LesionData[i]>0.2) {
                        ObjectFinal[i]=0;
                    }
                }
            }
            break;
        default:
            break;
    }
    
    return ObjectFinal;
}



// Create the result image while using the binary segmentations for the result type wanted
nifti_image * ResultImageFromSeg(nifti_image * BinarySeg, nifti_image * RefSeg, nifti_image * Mask, ResultType RT){
    if(RefSeg==NULL){
        cout<< "Nothing to compare to"<<endl;
        return NULL;
    }
    if (BinarySeg==NULL) {
        cout<< "No comparison to do"<<endl;
        return NULL;
    }
    if (!CheckCompatibleDimensions(BinarySeg,RefSeg)) {
        cout<<"Incompatible dimensions"<<endl;
        return NULL;
    }
    nifti_image * ResultImageComp=nifti_copy_nim_info(BinarySeg);
    ResultImageComp->data = (void *) calloc(ResultImageComp->nvox, sizeof(float));
    float * ResultData_PTR=static_cast<float *>(ResultImageComp->data);
    float * BinarySegData_PTR=static_cast<float *>(BinarySeg->data);
    bool * RefSegData_PTR=static_cast<bool *>(RefSeg->data);
    bool * MaskData_PTR=static_cast<bool *>(Mask->data);
    //    nifti_set_filenames(BinarySeg, "/Users/Carole/Documents/PhD/TemporaryFiles/BinarySeg.nii.gz", 0, 0);
    //    nifti_image_write(BinarySeg);
    //    nifti_set_filenames(RefSeg, "/Users/Carole/Documents/PhD/TemporaryFiles/RefSeg.nii.gz", 0, 0);
    //    nifti_image_write(RefSeg);
    //    nifti_set_filenames(Mask, "/Users/Carole/Documents/PhD/TemporaryFiles/Mask.nii.gz", 0, 0);
    //    nifti_image_write(Mask);
    
    int numel = Mask->nx*Mask->ny*Mask->nz;
    int CountElements=0;
    if (Mask!=NULL) {
        switch (RT) {
                case TP:{
                    for (int i=0; i<numel; i++,MaskData_PTR++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                        *ResultData_PTR=0;
                        if (*MaskData_PTR) {
                            if ((*RefSegData_PTR)*(*BinarySegData_PTR>0.5)) {
                                *ResultData_PTR=1;
                                CountElements++;
                            }
                        }
                    }
                }
                break;
                case TN:{
                    for (int i=0; i<numel; i++,MaskData_PTR++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                        *ResultData_PTR=0;
                        if (*MaskData_PTR) {
                            if (*RefSegData_PTR*(*BinarySegData_PTR>0.5)) {
                                *ResultData_PTR=1;
                                CountElements++;
                            }
                        }
                    }
                }
                break;
                case FN :{
                    for (int i=0; i<numel; i++,MaskData_PTR++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                        *ResultData_PTR=0;
                        if (*MaskData_PTR) {
                            if (*RefSegData_PTR && !(*BinarySegData_PTR>0.5)) {
                                *ResultData_PTR=1;
                                CountElements++;
                            }
                        }
                    }
                }
                break;
            default: {
                for (int i=0; i<numel; i++,MaskData_PTR++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                    *ResultData_PTR=0;
                    if (*MaskData_PTR) {
                        if (!(*RefSegData_PTR) && (*BinarySegData_PTR>0.5)) {
                            *ResultData_PTR=1;
                            CountElements++;
                        }
                    }
                }
            }// FP
                
                break;
        }
    }
    
    
    else{ // case where we do not have the mask, very similar
        switch (RT) {
                case TP:{
                    for (int i=0; i<numel; i++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                        *ResultData_PTR=0;
                        if (*RefSegData_PTR*(*BinarySegData_PTR>0.5)) {
                            *ResultData_PTR=1;
                        }
                    }
                }
                break;
                case TN:{
                    for (int i=0; i<numel; i++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                        *ResultData_PTR=0;
                        if (*RefSegData_PTR*(*BinarySegData_PTR>0.5)) {
                            *ResultData_PTR=1;
                        }
                    }
                }
                break;
                case FN :{
                    for (int i=0; i<numel; i++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                        *ResultData_PTR=0;
                        if (*RefSegData_PTR && !(*BinarySegData_PTR>0.5)) {
                            *ResultData_PTR=1;
                        }
                    }
                }
                break;
            default: {
                for (int i=0; i<numel; i++,BinarySegData_PTR++,RefSegData_PTR++,ResultData_PTR++) {
                    *ResultData_PTR=0;
                    if (!(*RefSegData_PTR) && (*BinarySegData_PTR>0.5)) {
                        *ResultData_PTR=1;
                    }
                }
            }// FP
                break;
        }
    }
    cout<< "number of elements put to 1 in image are "<<CountElements;
    //    nifti_set_filenames(ResultImageComp, "/Users/Carole/Documents/PhD/TemporaryFiles/ResultImageComp.nii.gz", 0, 0);
    //    nifti_image_write(ResultImageComp);
    return ResultImageComp;
}

// Given the Tree model and thus the data image and the LesionImage, determine the corresponding mean for the lesions
float * GetMeanLesion(nifti_image * LesionImage, TreeEM * TreeToAnalyse){
    if(LesionImage == NULL){
        return NULL;
    }
    else {
        int numbmodal=TreeToAnalyse->GetNumberModalities();
        int numel=TreeToAnalyse->GetNumberElements();
        int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
        float * MeanLesion=new float [numbmodal];
        for (int m=0; m<numbmodal; m++) {
            MeanLesion[m]=0;
        }
        float * Lesion_PTR=static_cast<float*>(LesionImage->data);
//        float * Data_PTR=static_cast<float *>(TreeToAnalyse->GetDataImage()->data);
        float * Data_PTR=TreeToAnalyse->GetDataBFCorrected();
        float SumResp=0;
        int * L2S_PTR=TreeToAnalyse->GetL2S();
        for (int i=0; i<numel; i++,Lesion_PTR++,L2S_PTR++) {
            if (*L2S_PTR>=0) {
                for (int m=0; m<numbmodal; m++) {
//                    MeanLesion[m]+=*Lesion_PTR*Data_PTR[m*numel+i];
                    MeanLesion[m]+=*Lesion_PTR*Data_PTR[m*numelmasked+*L2S_PTR];
                }
            }
            SumResp+=*Lesion_PTR;
        }
        for (int m=0; m<numbmodal; m++) {
            if (SumResp>0) {
                MeanLesion[m]/=SumResp;
            }
            else{
                MeanLesion[m]/=numelmasked;
            }
        }
        
        return MeanLesion;
    }
}

// Returns the float array containing the Mean against which the comparison must be made
float * CompareMeanLesion(vector<TreeEM *> LesionClasses,vector<int> CheckVector,TreeEM * TreeToAnalyse,vector<int> Modalities){
    if (CheckVector.size()==0) {
        return NULL;
    }
    int numbmodal=Modalities.size();
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    int numbGeneralClasses=MeanGeneralClasses.size();
    float * MeanLesion=GetMeanDirectVector(LesionClasses);
    MeanGeneralClasses.push_back(MeanLesion);
    int numbChecks=CheckVector.size()/3;
    cout << numbChecks << "checks to perform" << endl;
    float * compMean=new float[numbmodal*numbChecks];
    for (int q=0; q<numbChecks; q++) {
        for (int m=0; m<numbmodal; m++) {
            compMean[q*numbmodal+m]=0;
        }
    }
    
    if (MeanLesion==NULL) { // in the case where there is no lesion class, must be possible to compare to something...
        for (int q=0; q<numbChecks; q++) {
            if (CheckVector[q*3+2]>=numbGeneralClasses) {
                CheckVector[q*3+2]-=numbGeneralClasses;
            }
        }
    }
    
    bool * PossibleCheck= new bool[numbChecks];
    int * CorrespondingModality=new int[numbChecks];
    int numbPossibleChecks=0;
    for (int q=0; q<numbChecks; q++) {
        PossibleCheck[q]=0;
        CorrespondingModality[q]=-1;
        for (int m=0; m<numbmodal; m++) {
            if (CheckVector[q*3]==Modalities[m]) {
                PossibleCheck[q]=1;
                numbPossibleChecks++;
                CorrespondingModality[q]=m;
            }
        }
    }
    
    if (numbPossibleChecks==0) { // Meaning that there is a modality problem and there will therefore be no comparison to make
        delete [] PossibleCheck;
        delete [] CorrespondingModality;
        int numbClasses=MeanGeneralClasses.size();
        for (int c=0; c<numbClasses; c++) {
            if (MeanGeneralClasses[c]!=NULL) {
                delete [] MeanGeneralClasses[c];
                MeanGeneralClasses[c]=NULL;
            }
        }
        return compMean;
    }
    
    for (int q=0; q<numbChecks; q++) {
        if (PossibleCheck[q]) {
            int mmm=abs(CheckVector[q*3+1]); // Take the absolute value to take out the operation sign of the comparison and only consider the operation type mmm stands short for mean min max
            switch (mmm) {
                    case 1: // Correspond to case when we compare to mean of the considered class (mean of lesion classes in MeanGeneralClasses as well now)
                    cout<<"Class to check" << CheckVector[q*3+2]<<endl;
                    cout<<"Mean to put "<<MeanGeneralClasses[CheckVector[q*3+2]][1]<<endl;
                    compMean[q*numbmodal+CorrespondingModality[q]]=MeanGeneralClasses[CheckVector[q*3+2]][CorrespondingModality[q]];
                    break;
                    case 2: {
                        // Taking maximum value for the considered class in the wanted modality
                        vector<TreeEM *> LeavesToConsiderVector=TreeToAnalyse->GetAllLeavesAnatomicalClass(CheckVector[q*3+2]);
                        if (LeavesToConsiderVector.size()==0) {
                            LeavesToConsiderVector=LesionClasses;
                        }
                        int numbLeavestoConsider=LeavesToConsiderVector.size();
                        if (numbLeavestoConsider>0) {
                            float * MeansToConsider=GetMeanToAssess(LeavesToConsiderVector,CorrespondingModality[q]);
                            compMean[q*numbmodal+CorrespondingModality[q]]=ExtremaFromArray(MeansToConsider,numbLeavestoConsider,1);
                            if (MeansToConsider!=NULL) {
                                delete [] MeansToConsider;
                                MeansToConsider=NULL;
                            }
                            
                            
                        }
                        
                    }
                    break;
                    case 3: {// Taking minimum value for the considered class in the wanted modality
                        vector<TreeEM *> LeavesToConsiderVector=TreeToAnalyse->GetAllLeavesAnatomicalClass(CheckVector[q*3+2]);
                        if (LeavesToConsiderVector.size()==0) {
                            LeavesToConsiderVector=LesionClasses;
                        }
                        int numbLeavestoConsider=LeavesToConsiderVector.size();
                        if (numbLeavestoConsider>0) {
                            float * MeansToConsider=GetMeanToAssess(LeavesToConsiderVector,CorrespondingModality[q]);
                            compMean[q*numbmodal+CorrespondingModality[q]]=ExtremaFromArray(MeansToConsider,numbLeavestoConsider,-1);
                            delete [] MeansToConsider;
                            MeansToConsider=NULL;
                        }
                    }
                    break;
                default:{
//                    cout<<"Strange that choice is 0"<<endl;
//                    vector<TreeEM *> LeavesToConsiderVector=TreeToAnalyse->GetAllLeavesAnatomicalClass(CheckVector[q*3+2]);
//                    if (LeavesToConsiderVector.size()==0) {
//                        LeavesToConsiderVector=LesionClasses;
//                    }
//                    int numbLeavestoConsider=LeavesToConsiderVector.size();
//                    if (numbLeavestoConsider>0) {
//                        float * MeansToConsider=GetMeanToAssess(LeavesToConsiderVector,CorrespondingModality[q]);
//                        compMean[q*numbmodal+CorrespondingModality[q]]=ExtremaFromArray(MeansToConsider,numbLeavestoConsider,-1);
//                        delete [] MeansToConsider;
//                        MeansToConsider=NULL;
//                    }
                }
                    break;
            }
        }
    }
    delete [] PossibleCheck;
    PossibleCheck=NULL;
    delete [] CorrespondingModality;
    CorrespondingModality=NULL;
    int numbClasses=MeanGeneralClasses.size();
    for (int c=0; c<numbClasses; c++) {
        if (MeanGeneralClasses[c]!=NULL) {
            delete [] MeanGeneralClasses[c];
            MeanGeneralClasses[c]=NULL;
        }
    }
    cout << "comparaison to Mean done "<<endl;
    return compMean;
    
}

// Given the different nodes to consider for a mean comparison and the modality on which the comparison must be made, returns in a float array the means used for comparison. The modality integer corresponds to the index of the mean array to consider for each node
float * GetMeanToAssess(vector<TreeEM *> LeavesToConsiderVector, int modality){
    int numbLeavesToConsider=LeavesToConsiderVector.size();
    float * MeansToAssess=new float [numbLeavesToConsider];
    for (int l=0; l<numbLeavesToConsider; l++) {
        float * MeanTemp=LeavesToConsiderVector[l]->GetMean(); // Uses the parameter and do not recalculate the mean if available
        if(MeanTemp==NULL){
            cout << "No mean so not leave or other problem"<<endl;
            float * MeanTempBis=LeavesToConsiderVector[l]->GetMeanDirect(); // Have to use the MeanDirect if no parameter available
            MeansToAssess[l]=MeanTempBis[modality];
            delete [] MeanTempBis;
            MeanTempBis=NULL;
        }
        else{
            MeansToAssess[l]=MeanTemp[modality];
        }
    }
    return MeansToAssess;
}

// Given a float array, its size and the extrema type, returns the value of the corresponding extremum, extrema Type =1 for Max and -1 for min
float ExtremaFromArray(float * ArrayToAssess, int size, int extremaType){
    float extremaValue=-1E18 * extremaType;
    for (int i=0; i<size; i++) {
        if ((ArrayToAssess[i]-extremaValue)*extremaType>0) {
            extremaValue=ArrayToAssess[i];
        }
    }
    return extremaValue;
}

//Build Rule structure according to parameter
Rule * BuildingRule(TreeEM * TreeToAnalyse, int RuleType, int UniformRuleType, vector<int> Modalities){
    int numbmodal=Modalities.size();
    int numbmodalCheck=TreeToAnalyse->GetNumberModalities();
    if (numbmodalCheck!=numbmodal) {
        cout<<"Incompatibility Modalities"<<endl;
        return NULL;
    }
    Rule * BuiltRule=new Rule();
    BuiltRule->Modalities=new int[numbmodal];
    for (int m=0; m<numbmodal; m++) {
        BuiltRule->Modalities[m]=Modalities[m];
    }
    
    
    if (TreeToAnalyse->GetFlagOutliers()!=3 && TreeToAnalyse->GetFlagOutliers()<5) {
        //        RuleType=0;
        BuiltRule->SignComparison=new int[numbmodal];
        for (int m=0; m<numbmodal; m++) {
            switch (Modalities[m]) {
                    case 1:
                    BuiltRule->SignComparison[m]=0;
                    break;
                    case 2:
                    BuiltRule->SignComparison[m]=1;
                    break;
                    case 3:
                    BuiltRule->SignComparison[m]=1;
                    break;
                    case 4:
                    BuiltRule->SignComparison[m]=1;
                default:
                    BuiltRule->SignComparison[m]=1;
                    break;
            }
        }
        BuiltRule->CorrespondingGClassComparison=new int[numbmodal];
        for (int m=0; m<numbmodal; m++) { // We compare always to white matter
            BuiltRule->CorrespondingGClassComparison[m]=1;
        }
        if(UniformRuleType>1){ // Cases where we take uniform distribution into redefinition of lesions
            BuiltRule->SignComparisonUniform=new int[numbmodal];
            for (int m=0; m<numbmodal; m++) {
                switch (Modalities[m]) {
                        case 1:
                        BuiltRule->SignComparisonUniform[m]=0;
                        break;
                        case 2:
                        BuiltRule->SignComparisonUniform[m]=1;
                        break;
                        case 3:
                        BuiltRule->SignComparisonUniform[m]=1;
                        break;
                        case 4:
                        BuiltRule->SignComparisonUniform[m]=1;
                    default:
                        BuiltRule->SignComparisonUniform[m]=1;
                        break;
                }
            }
            BuiltRule->CorrespondingGClassComparisonUniform=new int[numbmodal];
            for (int m=0; m<numbmodal; m++) { // We compare always to white matter
                BuiltRule->CorrespondingGClassComparisonUniform[m]=1;
            }
            
        }
        return BuiltRule;
    }
    if (TreeToAnalyse->GetFlagOutliers()==3) {
        int numbGClasses=TreeToAnalyse->GetNumberGeneralClasses();
        BuiltRule->SignComparison=new int[numbmodal*numbGClasses];
        BuiltRule->CorrespondingGClassComparison=new int[numbGClasses*numbmodal];
        BuiltRule->Acceptance=new bool[numbGClasses];
        
        
        // Taking care of UniformRuleType
        if (UniformRuleType>0) {
            BuiltRule->SignComparisonUniform=new int[numbmodal*numbGClasses];
            BuiltRule->CorrespondingGClassComparisonUniform=new int[numbGClasses*numbmodal];
            BuiltRule->AcceptanceUniform=new bool[numbGClasses];
            for (int c=0; c<numbGClasses; c++) {
                BuiltRule->AcceptanceUniform[c]=1;
                for (int m=0; m<numbmodal; m++) {
                    BuiltRule->CorrespondingGClassComparisonUniform[m+c*numbmodal]=1; // By default, comparison against WM
                }
            }
            for (int m=0; m<numbmodal; m++) { // Creating the set of comparison for each anatomical spatial tissue class.
                switch (Modalities[m]) {
                        case 1:{
                            for (int c=0; c<numbGClasses; c++) {
                                BuiltRule->SignComparisonUniform[m+c*numbmodal]=0;
                            }
                        }
                        break;
                        case 2:{
                            for (int c=0; c<numbGClasses; c++) {
                                BuiltRule->SignComparisonUniform[m+c*numbmodal]=1;
                            }
                        }
                        break;
                        case 3:{
                            for (int c=0; c<numbGClasses; c++) {
                                BuiltRule->SignComparisonUniform[m+c*numbmodal]=1;
                            }
                        }
                        break;
                        case 4:{
                            for (int c=0; c<numbGClasses; c++) {
                                BuiltRule->SignComparisonUniform[m+c*numbmodal]=1;
                            }
                        }
                    default:{
                        for (int c=0; c<numbGClasses; c++) {
                            BuiltRule->SignComparisonUniform[m+c*numbmodal]=1;
                        }
                    }
                        break;
                }
            }
            switch (UniformRuleType) {
                    case 1: // Accept from all origin except NonBrain and comparison for all to WM
                    BuiltRule->AcceptanceUniform[3]=0;
                    break;
                    case 2: {// Accept only from GM and WM origin and comparison against WM
                        BuiltRule->AcceptanceUniform[3]=0;
                        BuiltRule->AcceptanceUniform[2]=0;
                    }
                    break;
                    case 3:{ // Accept only from WM origin and comparison against WM
                        BuiltRule->AcceptanceUniform[3]=0;
                        BuiltRule->AcceptanceUniform[2]=0;
                        BuiltRule->AcceptanceUniform[0]=0;
                    }
                    break;
                    case 4: {// Accept from WM and GM origin and comparison against WM for WM origin and against GM for GM origin
                        BuiltRule->AcceptanceUniform[3]=0;
                        BuiltRule->AcceptanceUniform[2]=0;
                        for (int m=0; m<numbmodal; m++) {
                            BuiltRule->CorrespondingGClassComparisonUniform[m*numbGClasses]=0;
                        }
                    }
                    break;
                default:
                    break;
            }
        }
        for (int c=0; c<numbGClasses; c++) {
            BuiltRule->Acceptance[c]=1;
            for (int m=0; m<numbmodal; m++) {
                BuiltRule->CorrespondingGClassComparison[m+c*numbmodal]=1; // By default, comparison against WM
            }
        }
        for (int m=0; m<numbmodal; m++) { // Creating the set of comparison for each anatomical spatial tissue class.
            switch (Modalities[m]) {
                    case 1:{
                        for (int c=0; c<numbGClasses; c++) {
                            BuiltRule->SignComparison[m+c*numbmodal]=0;
                        }
                    }
                    break;
                    case 2:{
                        for (int c=0; c<numbGClasses; c++) {
                            BuiltRule->SignComparison[m+c*numbmodal]=1;
                        }
                    }
                    break;
                    case 3:{
                        for (int c=0; c<numbGClasses; c++) {
                            BuiltRule->SignComparison[m+c*numbmodal]=1;
                        }
                    }
                    break;
                    case 4:{
                        for (int c=0; c<numbGClasses; c++) {
                            BuiltRule->SignComparison[m+c*numbmodal]=1;
                        }
                    }
                default:{
                    for (int c=0; c<numbGClasses; c++) {
                        BuiltRule->SignComparison[m+c*numbmodal]=1;
                    }
                }
                    break;
            }
        }
        
        switch (RuleType) {
                case 1: // Accept from all origin except NonBrain and comparison for all to WM
                BuiltRule->Acceptance[3]=0;
                break;
                case 2: {// Accept only from GM and WM origin and comparison against WM
                    BuiltRule->Acceptance[3]=0;
                    BuiltRule->Acceptance[2]=0;
                }
                break;
                case 3:{ // Accept only from WM origin and comparison against WM
                    BuiltRule->Acceptance[3]=0;
                    BuiltRule->Acceptance[2]=0;
                    BuiltRule->Acceptance[0]=0;
                }
                break;
                case 4: {// Accept from WM and GM origin and comparison against WM for WM origin and against GM for GM origin
                    BuiltRule->Acceptance[3]=0;
                    BuiltRule->Acceptance[2]=0;
                    for (int m=0; m<numbmodal; m++) {
                        BuiltRule->CorrespondingGClassComparison[m*numbGClasses]=0;
                    }
                }
                break;
            default:
                break;
        }
        return BuiltRule;
    }
    return BuiltRule;
}


// ************************* FUNCTIONS TO BUILD WM ID card ******************************

// Creation of Ventricle Distance map based on Euclidean distance (changed to Laplacian distance possibly afterwards)
nifti_image * EuclideanDistanceMap(nifti_image * ReferenceSeg, nifti_image * MaskSeg){
    if (ReferenceSeg==NULL || MaskSeg==NULL) {
        return NULL;
    }
    if (!CheckCompatibleDimensions(ReferenceSeg, MaskSeg)) {
        return NULL;
    }
    nifti_image * EuclideanResult=nifti_copy_nim_info(ReferenceSeg);
    int numel=ReferenceSeg->nvox;
    EuclideanResult->data=(void *) calloc(EuclideanResult->nvox, sizeof(float));
    float * EuclideanResultData=static_cast<float *>(EuclideanResult->data);
    nifti_image * HardRef=HardSegmentationThreshold(ReferenceSeg, 0.5);
    nifti_image * HardMask=HardSegmentationThreshold(MaskSeg, 0.5);
    int * RefBoolInt=TranscribeArray<float, int>(static_cast<float *>(HardRef->data), numel );
    bool * MaskBool=TranscribeArray<float, bool>(static_cast<float *>(HardMask->data), numel);
    int Dim[3];
    int Shift[3];
    float PixDim[3];
    float SumPixDim=0;
    float SumDim=0;
    for (int d=0; d<3; d++) {
        Dim[d]=ReferenceSeg->dim[d+1];
        SumDim+=Dim[d];
        PixDim[d]=ReferenceSeg->pixdim[d+1];
        SumPixDim+=PixDim[d];
    }
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    
    vector<int> IndicesBorder=GetIndicesBorderLesion(RefBoolInt, 1, Dim, Shift);
    int numbVoxelsDist=IndicesBorder.size();
    for (int i=0; i<numel; i++) {
        if (MaskBool[i]) {
            EuclideanResultData[i]=SumDim*SumPixDim;
            for (int j=0; j<numbVoxelsDist; j++) {
                float TmpDist=GetDistanceBetweenPoints(IndicesBorder[j], i, Dim, PixDim);
                if (EuclideanResultData[i]>TmpDist) {
                    EuclideanResultData[i]=TmpDist;
                }
                if (EuclideanResultData[i]<=0) {
                    break;
                }
            }
        }
        else{
            EuclideanResultData[i]=0;
        }
    }
    
    //    Clearing before returning
    if (RefBoolInt!=NULL) {
        delete [] RefBoolInt;
        RefBoolInt=NULL;
    }
    if (MaskBool!=NULL) {
        delete [] MaskBool;
        MaskBool=NULL;
    }
    if (HardRef!=NULL) {
        nifti_image_free(HardRef);
        HardRef=NULL;
    }
    if (HardMask!=NULL) {
        nifti_image_free(HardMask);
        HardMask=NULL;
    }
    return EuclideanResult;
}

// Creation of an image from the inlier and the Mahalanobis distance maps given the tree, the reference class and the threshold
nifti_image * PotentialLesionInliers(TreeEM * TreeToAnalyse, int IndexClass, float Threshold){
    int numel=TreeToAnalyse->GetNumberElements();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    float * TempInliers=CreateLong(TreeToAnalyse->GetNodeInlier()->GetChild(IndexClass)->GetNormResp(), TreeToAnalyse->GetL2S(), numel);
    nifti_image * TempInliersNii=CreateNiiFromArray(TempInliers, TreeToAnalyse->GetDataImage(), numel);
    float * DataValues=CreateLongPaddingMulti<float>(TreeToAnalyse->GetDataBFCorrected(), 0, TreeToAnalyse->GetL2S(), numel, numbmodal);
    nifti_image * DataNii=CreateNiiFromArray(DataValues, TreeToAnalyse->GetDataImage(), numel*numbmodal);
//    nifti_image * MahalDist=MahalDistMaps(TempInliersNii, TempInliersNii, TreeToAnalyse->GetDataImage());
    nifti_image * MahalDist=MahalDistMaps(TempInliersNii, TempInliersNii, DataNii);
//    Then threshold the MahalDistImage at each modality to gather the outliers. Note that in this case the thresholding is more conservative since it has to be a complete outlier for one modality to be considered as such.
//    int numbmodal=TreeToAnalyse->GetNumberModalities();
    float * DataMahalDist=static_cast<float *>(MahalDist->data);
    bool * FinalThresholded=new bool[numel];
    for (int i=0; i<numel; i++) {
        FinalThresholded[i]=0;
    }
    for (int m=0; m<numbmodal; m++) {
        bool *BoolThresholdedArray=ThresholdArray<float, bool>(&DataMahalDist[numel*(m+1)], Threshold, numel);
        OROperationBool(FinalThresholded, BoolThresholdedArray, FinalThresholded, numel);
        delete [] BoolThresholdedArray;
        BoolThresholdedArray=NULL;
    }
    nifti_image * PotentialResult=CreateNiiFromArray(FinalThresholded, TempInliersNii, numel);
    delete [] FinalThresholded;
    nifti_image_free(MahalDist);
    nifti_image_free(TempInliersNii);
    FinalThresholded=NULL;
    MahalDist=NULL;
    TempInliersNii=NULL;
    return PotentialResult;
}

void RegionGrowing(float * Map, int* Dim, int* Shift, int Neigh, float * MapFilling, float Thresh, nifti_image * ImageSave){
    // Initialisation of the map
    int Neighbours[6];
    set<int> SetToCheck;
    int numel = Dim[0]*Dim[1]*Dim[2];
    for(int i=0;i<numel;i++){
        if(Map[i]>0){
            GetListNeighbours_bis(Neighbours,i,Dim,Shift,6);
            for(int n=0;n<6;n++){
                if (Map[Neighbours[n]]==0 && MapFilling[Neighbours[n]]>=Thresh){
                    Map[Neighbours[n]] = MapFilling[Neighbours[n]];
                    SetToCheck.insert(Neighbours[n]);
                }
            }
            SetToCheck.insert(i);
        }
    }
    SaveTmpResult(Map,"/Users/csudre/Temp/LAMBJO1/Test.nii.gz",ImageSave);
    while(SetToCheck.size()>0){
        Map[*SetToCheck.begin()] = MapFilling[*SetToCheck.begin()];
        GetListNeighbours_bis(Neighbours,*SetToCheck.begin(),Dim,Shift,6);
        SetToCheck.erase(SetToCheck.begin());
        for(int n = 0;n<6;n++){
            if (Map[Neighbours[n]]==0 && MapFilling[Neighbours[n]]>=Thresh){
                Map[Neighbours[n]] = MapFilling[Neighbours[n]];
                SetToCheck.insert(Neighbours[n]);
            }
        }
        if (SetToCheck.size() < 10){
            cout << "Length of set is "<< SetToCheck.size();
        }
    }
    return;
}

//Creation of MahalDistance map globally and per modality given the compared tissue (generally WM) image, the segmented image and the DataToCompare To
nifti_image * MahalDistMaps(nifti_image * TissueComp, nifti_image * SegToAnalyse, nifti_image * DataToCompare){
    //    First check compatibility between images
    if (TissueComp==NULL || SegToAnalyse==NULL || DataToCompare==NULL) {
        cout <<"one is NULL !!" << TissueComp << " "<< SegToAnalyse<<" "<< DataToCompare<<endl;
        return NULL;
    }
    bool flag_compatibility=CheckCompatibleDimensions(TissueComp, SegToAnalyse)*CheckCompatibleDimensions(SegToAnalyse, DataToCompare);
    if (!flag_compatibility) {
        cout <<"one is incompatible !!"<<endl;
        return NULL;
    }
    //    Determine the parameters for the tissue and the needed inverted covariance matrix as well as numbers needed
    int numel =TissueComp->nx*TissueComp->ny*TissueComp->nz;
//    cout << numel<<endl;
    int numbmodal=DataToCompare->nu*DataToCompare->nt;
//    cout << numbmodal<<endl;
    float * ParamTissue=GetParamFromImages(TissueComp, DataToCompare);
//    cout << "Got params !"<<endl;
    TreeEM * TreeTmp=NULL;
    float * InvertedCovarianceTissue=TreeTmp->InvertMatrix(&ParamTissue[numbmodal], numbmodal);
    //    Initialise result;
//    cout <<"Got inverted cov ! "<<endl;
    nifti_image * MahalDistanceMaps=nifti_copy_nim_info(TissueComp);
    MahalDistanceMaps->dim[0]=4;
    MahalDistanceMaps->dim[4]=numbmodal+1;
    nifti_update_dims_from_array(MahalDistanceMaps);
    int numelResults=MahalDistanceMaps->nvox;
    MahalDistanceMaps->data=(void *) calloc(MahalDistanceMaps->nvox, sizeof(float));
    float * MahalData=static_cast<float *>(MahalDistanceMaps->data);
    //    float * TissueData=static_cast<float *>(TissueComp->data);
    float * SegData=static_cast<float *>(SegToAnalyse->data);
    float * ImageData=static_cast<float *>(DataToCompare->data);
    string FilenamePA=nifti_makebasename(DataToCompare->fname);
    int Index=FilenamePA.find_last_of('/');
    string FilenamePA_b=FilenamePA.substr(0,Index+1);
 
    string FilenamePA_e=FilenamePA.substr(Index+1,FilenamePA.length());
    string FilenameTestingMahal=FilenamePA_b+"DataTestMahal_"+FilenamePA_e+".nii.gz";
//    nifti_set_filenames(DataToCompare, FilenameTesting.c_str(), 0, 0);
//    nifti_image_write(DataToCompare);
    for (int i=0; i<numelResults; i++) {
        MahalData[i]=0;
    }
    
    //    Calculating the Mahalanobis distance Globally and for each modality. When doing it for each modality, the sign of the difference between mean and values is also included
    for (int i=0; i<numel; i++) {
        if (SegData[i]>0.5) {
            float ValueTmp[10];
            for (int m=0; m<10; m++) {
                if (m<numbmodal) {
                    ValueTmp[m]=ImageData[i+m*numel];
                }
                else {
                    ValueTmp[m]=0;
                }
            }
            MahalData[i]=GetMahalDist(ValueTmp, ParamTissue, InvertedCovarianceTissue, numbmodal);
            for (int m=0; m<numbmodal; m++) {
                float SignDiff=ValueTmp[m]>ParamTissue[m]?1:-1;
                MahalData[i+(m+1)*numel]=GetMahalDist(&ValueTmp[m], &ParamTissue[m], &InvertedCovarianceTissue[m+m*numbmodal], 1)*SignDiff;
            }
        }
    }
    
    //    Clearing before returning
    if (ParamTissue!=NULL) {
        delete [] ParamTissue;
        ParamTissue=NULL;
    }
    if (InvertedCovarianceTissue!=NULL) {
        delete [] InvertedCovarianceTissue;
        InvertedCovarianceTissue=NULL;
    }
    nifti_set_filenames(MahalDistanceMaps,FilenameTestingMahal.c_str(),0,0);
    nifti_image_write(MahalDistanceMaps);
    return MahalDistanceMaps;
}



// Creation of severity image from total lesion segmentation

nifti_image * SeverityMap(TreeEM * TreeToAnalyse,nifti_image * SegToAnalyse, vector<int> Modalities, SEG_ANALYSIS * segment_analysis){
    float * Data_PTR=static_cast<float *>(TreeToAnalyse->GetDataImage()->data);
    float * SegToAnalyse_PTR=static_cast<float *>(SegToAnalyse->data);
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    int numel=TreeToAnalyse->GetNumberElements();
    int indexCSF=segment_analysis->IndexCSF;
    int indexWM=segment_analysis->IndexWM;
    vector<TreeEM *> GeneralClasses=TreeToAnalyse->GetGeneralClassesVector();
    TreeEM * TreeCSF=GeneralClasses[indexCSF];
    TreeEM * TreeWM=GeneralClasses[indexWM];
    float * MeanCSF=TreeCSF->GetMeanDirect();
    float * MeanWM=TreeWM->GetMeanDirect();
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    int T1Index=-1;
    for (int m=0; m<numbmodal; m++) {
        if(Modalities[m]==1){
            T1Index=m;
            break;
        }
    }
    if (T1Index==-1) {
        if (MeanCSF!=NULL) {
            delete [] MeanCSF;
            MeanCSF=NULL;
        }
        if (MeanWM!=NULL) {
            delete [] MeanWM;
            MeanWM=NULL;
        }
        return NULL;
    }
    nifti_image * SeverityMap=nifti_copy_nim_info(SegToAnalyse);
    SeverityMap->data=(void*)calloc(SeverityMap->nvox, sizeof(float));
    float * SeverityMap_PTR=static_cast<float *>(SeverityMap->data);
    float * Data_PTRm=&Data_PTR[T1Index*numel];
    for (int i=0; i<numel; i++,L2S_PTR++,SeverityMap_PTR++,SegToAnalyse_PTR++,Data_PTRm++) {
        if (*L2S_PTR>=0 && *SegToAnalyse_PTR>0.5) {
            *SeverityMap_PTR=(*Data_PTRm-MeanWM[T1Index])/(MeanCSF[T1Index]-MeanWM[T1Index]);
        }
        else{
            *SeverityMap_PTR=0;
        }
    }
    if (MeanCSF!=NULL) {
        delete [] MeanCSF;
        MeanCSF=NULL;
    }
    if (MeanWM!=NULL) {
        delete [] MeanWM;
        MeanWM=NULL;
    }
    return SeverityMap;
}

// Global function that enable writing the WM ID card
void WriteWMLIdentityCard(TreeEM * TreeToAnalyse, Rule * LesionRule, vector<int> Modalities,SEG_ANALYSIS * segment_analysis){
    // First prepare text file to build ID card for WM lesion
    ofstream TxtFile(segment_analysis->filename_WMCard);
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    // First get index corresponding to WM / comparable inlier from Rule
    int indexWM=segment_analysis->IndexWM;
    for (int m=0; m<numbmodal; m++) {
        float MaxData=TreeToAnalyse->GetMaxDataModal(m);
        TxtFile<<"Max "<<numbmodal<<MaxData<<endl;
        float MinData=TreeToAnalyse->GetMinDataModal(m);
        TxtFile<<"Min "<<numbmodal<<MinData<<endl;
    }
    
    // Then get number of classes for it, global mean, global variance, min of above 0.5, max of above 0.5 (classified under it...)
    vector<TreeEM *> GeneralClasses=TreeToAnalyse->GetGeneralClassesVector();
    TreeEM * TreeWM=GeneralClasses[indexWM];
    float * MeanWM=TreeWM->GetMeanDirect();
    float * VarianceWM=TreeWM->GetVarianceDirect();
    int numbWMLeaves=TreeWM->GetNumberAllLeaves();
    float * minWMInlier=TreeWM->GetExtremaDataSeg(-1);
    float * maxWMInlier=TreeWM->GetExtremaDataSeg(1);
    
    // Writing General WM information in WMCard
    TxtFile<<"General WM Inlier "<<endl;
    TxtFile << "MeanWM ";
    for (int m=0; m<numbmodal; m++) {
        TxtFile<<MeanWM[m]<<" ";
    }
    TxtFile<<endl;
    TxtFile << "TrueCovWM ";
    for (int m=0; m<numbmodal*numbmodal; m++) {
        TxtFile<<VarianceWM[m]<<" ";
    }
    TxtFile<<endl;
    TxtFile<<"NumbLeavesWMInlier "<<numbWMLeaves<<endl;
    TxtFile<<"minWMInlier ";
    for (int m=0; m<numbmodal; m++) {
        TxtFile<<minWMInlier[m]<<" ";
    }TxtFile<<endl;
    TxtFile<<"maxWMInlier ";
    for (int m=0; m<numbmodal; m++) {
        TxtFile<<maxWMInlier[m]<<" ";
    }TxtFile<<endl;
    TxtFile<<endl;
    
    // Previous for the corresponding inlier subclasses if any and put the corresponding hierarchy vector
    vector<TreeEM *> WMLeavesVector=TreeWM->GetAllLeaves();
    for (int l=0; l<numbWMLeaves; l++) {
        float * MeanWMLeaf=WMLeavesVector[l]->GetMeanDirect();
        float * VarianceWMLeaf=WMLeavesVector[l]->GetVarianceDirect();
        float * VarianceConstWMLeaf=WMLeavesVector[l]->GetVariance();
        float * minWMLeaf=WMLeavesVector[l]->GetExtremaDataSeg(-1);
        float * maxWMLeaf=WMLeavesVector[l]->GetExtremaDataSeg(1);
        vector<int> HierarchyLeave=WMLeavesVector[l]->GetHierarchyVector();
        
        int lengthHierarch=HierarchyLeave.size();
        TxtFile <<"Class ";
        for (int h=0; h<lengthHierarch; h++) {
            TxtFile<<HierarchyLeave[h]<<" ";
        }
        TxtFile<<endl;
        TxtFile << "MeanLeafWM ";
        for (int m=0; m<numbmodal; m++) {
            TxtFile<<MeanWMLeaf[m]<<" ";
        }
        TxtFile<<endl;
        TxtFile << "TrueCovLeafWM ";
        for (int m=0; m<numbmodal*numbmodal; m++) {
            TxtFile<<VarianceWMLeaf[m]<<" ";
        }
        TxtFile<<endl;
        TxtFile << "ConstCovLeafWM ";
        for (int m=0; m<numbmodal*numbmodal; m++) {
            TxtFile<<VarianceConstWMLeaf[m]<<" ";
        }
        TxtFile<<endl;
        TxtFile<<"minWMLeaf ";
        for (int m=0; m<numbmodal; m++) {
            TxtFile<<minWMLeaf[m]<<" ";
        }TxtFile<<endl;
        TxtFile<<"maxWMLeaf ";
        for (int m=0; m<numbmodal; m++) {
            TxtFile<<maxWMLeaf[m]<<" ";
        }TxtFile<<endl;
        
        //Clearing memory when not needed anymore
        delete [] minWMLeaf;
        delete [] maxWMLeaf;
        delete [] MeanWMLeaf;
        delete [] VarianceWMLeaf;
        
        minWMLeaf=NULL;
        maxWMLeaf=NULL;
        MeanWMLeaf=NULL;
        VarianceWMLeaf=NULL;
    }
    
    // Taking care of Gaussian related lesion classes
    TxtFile<<endl;
    TxtFile<<"Outlier Lesion "<<endl;
    // giving hierarchy, true mean and variance, variance constraint if exist, min, max, distance to general inlier multi and mono modal
    vector<TreeEM *> LesionClasses=FindLesionClasses(TreeToAnalyse, LesionRule, Modalities,segment_analysis);
    int numbLesions=LesionClasses.size();
    TxtFile<< "NumbLesionClasses "<<numbLesions<<endl;
    for (int l=0; l<numbLesions; l++) {
        float * MeanWMLeaf=LesionClasses[l]->GetMeanDirect();
        float * VarianceWMLeaf=LesionClasses[l]->GetVarianceDirect();
        float * VarianceConstWMLeaf=LesionClasses[l]->GetVariance();
        float * minWMLeaf=LesionClasses[l]->GetExtremaDataSeg(-1);
        float * maxWMLeaf=LesionClasses[l]->GetExtremaDataSeg(1);
        vector<int> HierarchyLeaveLesion=LesionClasses[l]->GetHierarchyVector();
        
        int lengthHierarch=HierarchyLeaveLesion.size();
        TxtFile <<"Class ";
        for (int h=0; h<lengthHierarch; h++) {
            TxtFile<<HierarchyLeaveLesion[h]<<" ";
        }
        TxtFile<<endl;
        TxtFile << "MeanLeafWM ";
        for (int m=0; m<numbmodal; m++) {
            TxtFile<<MeanWMLeaf[m]<<" ";
        }
        TxtFile<<endl;
        TxtFile << "TrueCovLeafWM ";
        for (int m=0; m<numbmodal*numbmodal; m++) {
            TxtFile<<VarianceWMLeaf[m]<<" ";
        }
        TxtFile<<endl;
        TxtFile << "ConstCovLeafWM ";
        for (int m=0; m<numbmodal*numbmodal; m++) {
            TxtFile<<VarianceConstWMLeaf[m]<<" ";
        }
        TxtFile<<endl;
        TxtFile<<"minWMLeaf ";
        for (int m=0; m<numbmodal; m++) {
            TxtFile<<minWMLeaf[m]<<" ";
        }TxtFile<<endl;
        TxtFile<<"maxWMLeaf ";
        for (int m=0; m<numbmodal; m++) {
            TxtFile<<maxWMLeaf[m]<<" ";
        }TxtFile<<endl;
        
        //Clearing memory when not needed anymore
        delete [] minWMLeaf;
        delete [] maxWMLeaf;
        delete [] MeanWMLeaf;
        delete [] VarianceWMLeaf;
        
        minWMLeaf=NULL;
        maxWMLeaf=NULL;
        MeanWMLeaf=NULL;
        VarianceWMLeaf=NULL;
    }
    
    //    Clearing memory before exiting
    if (MeanWM!=NULL) {
        delete [] MeanWM;
        MeanWM=NULL;
    }
    if (VarianceWM!=NULL) {
        delete [] VarianceWM;
        VarianceWM=NULL;
    }
    if (minWMInlier!=NULL) {
        delete [] minWMInlier;
        minWMInlier=NULL;
    }
    if (maxWMInlier!=NULL) {
        delete [] maxWMInlier;
        maxWMInlier=NULL;
    }
}


/* **************** FUNCTIONS TO BUILD LINKED LESIONS ************************ */
//int * BuildConnectedComponents(nifti_image * SegToAnalyse, float threshold, vector<vector<int> > EquivalenceComp){
//    int * Dim=new int[3];
//    // for dimension record
//    for(int m=0;m<3;m++){
//        Dim[m]=SegToAnalyse->dim[m+1];
//    }
//    int RegionCounter=0;
//    int numel = Dim[0]*Dim[1]*Dim[2];
//    int * ConnectedComp=new int[numel];
//    for(int i=0;i<numel;i++){
//        ConnectedComp[i]=0;
//    }
//    float * SegToAnalyseData=static_cast<float *>(SegToAnalyse->data);
//    for(int x=1;x<Dim[0]-1;x++){
//        for(int y=1;y<Dim[1]-1;y++){
//            for(int z=1;z<Dim[2]-1;z++){
//                int CurrentIndex=x*Dim[1]*Dim[2]+y*Dim[2]+z;
//                int * IndexToLook=GetListNeighbourToLook(CurrentIndex,Dim);
//                if(SegToAnalyseData[x*Dim[1]*Dim[2]+y*Dim[2]+z]>=threshold){
//                    bool type=0;
//                    float minLabel;
//                    vector<int> VectorLabels;
//                    for(int i=0;i<9;i++){
//                        if(SegToAnalyseData[IndexToLook[i]]>=threshold){
//                            type=1;
//                            if(ConnectedComp[IndexToLook[i]]>0){
//                                VectorLabels.push_back((int)ConnectedComp[IndexToLook[i]]);
//                            }
//                        }
//                    }
//                    if(type){ // meaning that we have to change value of ConnectedComp
//                        if(VectorLabels.size()==0){ // if beginning of new region
//                            cout << "begin new region"<<endl;
//                            RegionCounter++;
//                            ConnectedComp[CurrentIndex]=RegionCounter;
//                        }
//                        else{
//                            ConnectedComp[CurrentIndex]=VectorLabels[0];
//                            // Update equivalence vector
//                            int lsize=VectorLabels.size();
//                            for(int l =0;l<lsize;l++){
//                                if(EquivalenceComp.size()>VectorLabels[l]){ // Meaning that there is already a vector for label l
//                                    for(int l2=0;l2<lsize;l2++){
//                                        if(find(EquivalenceComp[VectorLabels[l]].begin(), EquivalenceComp[VectorLabels[l]].end(), VectorLabels[l2])==EquivalenceComp[VectorLabels[l]].end()){
//                                            EquivalenceComp[VectorLabels[l]].push_back(VectorLabels[l2]);
//                                        }
//                                    }
//                                }
//                                else{
//                                    EquivalenceComp.push_back(VectorLabels);
//                                }
//                            }
//                        }
//                    }
//
//                }
//            }
//        }
//    }
//    // Then summarize all equivalence components
//    vector<int> CorrespondanceEquivalence;
//    int numblabels=EquivalenceComp.size();
//    for(int l=0;l<numblabels;l++){
//        int minLabel=1E10;
//        int numbequivalence=EquivalenceComp[l].size();
//        for(int l2=0;l2<numbequivalence;l2++){
//            if(EquivalenceComp[l][l2]<minLabel){
//                minLabel=EquivalenceComp[l][l2];
//            }
//        }
//        if(l<minLabel){
//            CorrespondanceEquivalence.push_back(l);
//        }
//        else{
//            CorrespondanceEquivalence.push_back(minLabel);
//        }
//    }
//    for(int i=0;i<numel;i++){
//        if(ConnectedComp[i]>0){
//            int CurrentLabel=ConnectedComp[i];
//            ConnectedComp[i]=CorrespondanceEquivalence[CurrentLabel];
//        }
//    }
//
//}

//Returns according to the indices (used for the minimum path from center of gravity to centre of gravity of lesion) the proportion of the traversed tissues Used when building the vector of lesions, the Hard Segmentation is a binary image

float * ProportionIndicesSegmentation( vector<int> IndicesPath, nifti_image * HardSegmentation){
    if(HardSegmentation==NULL || IndicesPath.size()==0){
        return NULL;
    }
    int numbIndices=IndicesPath.size();
    bool * HardSegData=static_cast<bool *>(HardSegmentation->data);
    int numbclasses=HardSegmentation->nu*HardSegmentation->nt;
    float * ProportionResult=new float[numbclasses];
    for (int c=0; c<numbclasses; c++) {
        ProportionResult[c]=0;
    }
    int numel=HardSegmentation->nx*HardSegmentation->ny*HardSegmentation->nz;
    for (int i=0; i<numbIndices; i++) {
        for (int c=0; c<numbclasses; c++) {
            if (HardSegData[IndicesPath[i]+c*numel]) {
                ProportionResult[c]++;
                break;
            }
        }
    }
    for (int c=0; c<numbclasses; c++) {
        ProportionResult[c]/=1.0*numbIndices;
    }
    return ProportionResult;
}


//Returns as a boolean the possibility that there are CSF elements on both sides of the centre of gravity of the lesion that are neighbour to the lesion.
bool InBetweenVentriclesLesionDetection(int * LesionLabeling, int Label, nifti_image * SummarisedDecoupled, SEG_ANALYSIS * segment_analysis, TreeEM * TreeToAnalyse){
    bool ResultIBV=0;
    int numel=TreeToAnalyse->GetNumberElements();
    int Dim[3];
    int Shift[3];
    for(int d=0;d<3;d++){
        Dim[d]=SummarisedDecoupled->dim[d+1];
    }
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    bool * LesionBool=CreateLesionBool(LesionLabeling,Label, numel);
    bool * OpposeLesion=OpposeBoolArray(LesionBool, numel);
    int * OpposeLesionInt=TranscribeArray<bool, int>(OpposeLesion, numel);
    vector<int> VectorIndicesBorderLesion=GetIndicesBorderLesion(OpposeLesionInt, 1, Dim, Shift);
    //    int numbBorder=VectorIndicesBorderLesion.size();
    //    nifti_image * HardCSFSeg=HardSegmentationIndex(SummarisedDecoupled, segment_analysis->IndexGM, TreeToAnalyse->GetL2S());
    
    //    NOT FINISHED AND USED AT THE TIME
    return ResultIBV;
}


float * ProportionFromBoolVec(bool * BoolToAssess, vector<bool *> VectorBool,int numel){
    int sizeVec=VectorBool.size();
    float *ProportionResults=new float[sizeVec];
    for (int s=0; s<sizeVec; s++) {
        ProportionResults[s]=0;
    }
    int numbEl=0;
    for (int i=0; i<numel; i++) {
        if (BoolToAssess[i]) {
            numbEl++;
            for (int s=0; s<sizeVec; s++) {
                if (VectorBool[s][i]) {
                    ProportionResults[s]++;
                    break;
                }
            }
        }
    }
    for (int s=0; s<sizeVec; s++) {
        ProportionResults[s]/=1.0*numbEl;
    }
    return ProportionResults;
}

//Returns for the given lesion Label the proportion of voxels on its border belonging to either one of the given segmentation tissues
float * ProportionNeighboursLesion(int * LesionLabeling, int Label, nifti_image *SummarisedDecoupled,SEG_ANALYSIS * segment_analysis){
    if(SummarisedDecoupled==NULL){
        return NULL;
    }
    //    int BorderType=1;
    int Dim[3];
    int Shift[3];
    for(int d=0;d<3;d++){
        Dim[d]=SummarisedDecoupled->dim[d+1];
    }
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    int numel=SummarisedDecoupled->nx*SummarisedDecoupled->ny*SummarisedDecoupled->nz;
    int numbclasses = SummarisedDecoupled->nu*SummarisedDecoupled->nt -1;
    int IndexOut=segment_analysis->IndexOut;
    IndexOut=IndexOut<numbclasses?IndexOut:numbclasses;
    //    Create the oppose bool array to the one corresponding to the lesion and create indices border for this one
    bool * LesionBool=CreateLesionBool(LesionLabeling,Label, numel);
    bool * OpposeLesion=OpposeBoolArray(LesionBool, numel);
    int * OpposeLesionInt=TranscribeArray<bool, int>(OpposeLesion, numel);
    vector<int> VectorIndicesBorderLesion=GetIndicesBorderLesion(OpposeLesionInt, 1, Dim, Shift);
    int numbBorder=VectorIndicesBorderLesion.size();
    if (numbBorder==0) {
        if(LesionBool!=NULL){
            delete [] LesionBool;
        }
        if(OpposeLesion!=NULL){
            delete [] OpposeLesion;
        }
        if(OpposeLesionInt!=NULL){
            delete [] OpposeLesionInt;
        }
        return NULL;
    }
    
    //    Create and fill the proportion array
    float * ResultProportion=new float[numbclasses+1];
    for (int i=0; i<=numbclasses; i++) {
        ResultProportion[i]=0;
    }
    float * SummarisedData=static_cast<float *>(SummarisedDecoupled->data);
    for (int i=0; i<numbBorder; i++) {
        float Max=-1;
        int IndexMax=-1;
        for (int c=0; c<numbclasses; c++) {
            if (SummarisedData[VectorIndicesBorderLesion[i]+c*numel]>Max) {
                IndexMax=c;
                Max=SummarisedData[VectorIndicesBorderLesion[i]+c*numel];
            }
        }
        if (Max>0) {
            ResultProportion[IndexMax]++;
        }
        else{
            ResultProportion[IndexOut]++;
        }
    }
    for (int c=0; c<=numbclasses; c++) {
        ResultProportion[c]/=1.0*numbBorder;
    }
    //    Clearing before returning
    if(LesionBool !=NULL){
        delete [] LesionBool;
        LesionBool=NULL;
    }
    if(OpposeLesion!=NULL){
        delete [] OpposeLesion;
        OpposeLesion=NULL;
    }
    if (OpposeLesionInt!=NULL) {
        delete [] OpposeLesionInt;
        OpposeLesionInt=NULL;
    }
    
    return ResultProportion;
}

//Returns the binary segmentation of a given lesion given its label and the number of elements considered
bool * CreateLesionBool(int * LesionLabeling, int Label,int numel ){
    //    Check if Label is compatible
    int maxLabel=GetMaxLabel(LesionLabeling, numel);
    if (maxLabel<Label) {
        return NULL;
    }
    bool * LesionBool=new bool[numel];
    for (int i=0; i<numel; i++) {
        if (LesionLabeling[i]==Label) {
            LesionBool[i]=1;
        }
        else{
            LesionBool[i]=0;
        }
    }
    return LesionBool;
}


// Given a border boolean array of size numel, the integer array of the lesion labels, a certain label and the needed information about dimension check if corresponding lesion can be considered as neighbourhing the border : that is if there is one voxel in the labelled lesion whose one of the 6 closest neighbor is in the border
bool IsLesionCloseToBorder(int * LesionLabeling, int Label, bool * BorderCSF, int *Dim, int *Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int maxLabel=GetMaxLabel(LesionLabeling, numel);
    if(Label<1 || Label >maxLabel){
        cout<<"Pb in assessment of lesion due to bad label"<<endl;
        return 0;
    }
    if (BorderCSF==NULL) {
        return 0;
    }
    vector<int> LesionIndices=GetListIndicesLabel(LesionLabeling, Dim, Label);
    int SizeLabel=LesionIndices.size();
    for (int l=0; l<SizeLabel; l++) {
        //        int * ListNeighbours=Get6Neighbours(LesionIndices[l], Dim,Shift);
        int ListNeighbours[18];
        GetListNeighbours_bis(ListNeighbours, LesionIndices[l], Dim, Shift, 18);
        //        int * ListNeighbours=GetListNeighbours(LesionIndices[l], Dim, Shift, 6);
        for (int n=0; n<18; n++) {
            if (LesionIndices[l]!=ListNeighbours[n] && BorderCSF[ListNeighbours[n]]==1) {
                return 1;
            }
        }
        //        delete [] ListNeighbours;
        //        ListNeighbours=NULL;
    }
    return 0;
}

void GetListNeighbours_bis(int * ListNeighbours, int CurrentIndex, int * Dim, int * Shift,int NeighbouringType){
    //    int * CorrespondingIndex=new int[3];
    int CorrespondingIndex[3];
    int tmp=CurrentIndex;
    for(int i=2;i>=0;i--){
        CorrespondingIndex[i]=(int)tmp/Shift[i];
        tmp-=CorrespondingIndex[i]*Shift[i];
    }
    int numel=Dim[0]*Dim[1]*Dim[2];
    int neigh=0;
    
    switch (NeighbouringType) {
            case 6:{
                for (int n=0; n<6; n++) {
                    ListNeighbours[n]=0;
                }
                for(int x=-1;x<=1;x++){
                    for(int y=-1;y<=1;y++){
                        for(int z=-1;z<=1;z++){
                            if((abs(z)+abs(x)+abs(y))==1){ // the voxel itself is not part of its list of neighbours
                                //                            int * newIndex=new int[3];
                                int newIndex[3];
                                newIndex[0]=CorrespondingIndex[0]+x;
                                newIndex[1]=CorrespondingIndex[1]+y;
                                newIndex[2]=CorrespondingIndex[2]+z;
                                bool outBorder=0;
                                for(int d=0;d<3;d++){
                                    if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                                        outBorder=1;
                                        break;
                                    }
                                }
                                neigh=abs(x)*0 + abs(y)*2 + abs(z)*4; // Simply to be sure that in list first 2 correspond to WE, then NS then TB
                                if(x+y+z>0){
                                    neigh++;
                                }
                                if(!outBorder){
                                    ListNeighbours[neigh]=newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2];
                                    if(ListNeighbours[neigh]>numel || ListNeighbours[neigh]<0){
                                        cout<<"Pb with neigh "<<neigh;
                                    }
                                }
                                else{
                                    ListNeighbours[neigh]=(CurrentIndex);
                                }
                                //                            delete [] newIndex;
                                //                            newIndex=NULL;
                            }
                        }
                    }
                }
            }
            break;
            case 18:{
                for (int n=0; n<18; n++) {
                    ListNeighbours[n]=0;
                }
                for(int x=-1;x<=1;x++){
                    for(int y=-1;y<=1;y++){
                        for(int z=-1;z<=1;z++){
                            int SumNeigh=abs(x)+abs(y)+abs(z);
                            if(SumNeigh>=1 && SumNeigh<=2){ // the voxel itself is not part of its list of neighbours
                                //                            int * newIndex=new int[3];
                                int newIndex[3];
                                newIndex[0]=CorrespondingIndex[0]+x;
                                newIndex[1]=CorrespondingIndex[1]+y;
                                newIndex[2]=CorrespondingIndex[2]+z;
                                
                                bool outBorder=0;
                                for(int d=0;d<3;d++){
                                    if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                                        outBorder=1;
                                        break;
                                    }
                                }
                                if(!outBorder){
                                    ListNeighbours[neigh]=(newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2]);
                                    if(ListNeighbours[neigh]>numel || ListNeighbours[neigh]<0){
                                        cout<<"Pb with neigh "<<neigh;
                                    }
                                }
                                else{
                                    ListNeighbours[neigh]=(CurrentIndex);
                                }
                                neigh++;
                            }
                        }
                    }
                }
                
            }
            break;
            case 26:{
                for (int n=0; n<26; n++) {
                    ListNeighbours[n]=0;
                }
                for(int x=-1;x<=1;x++){
                    for(int y=-1;y<=1;y++){
                        for(int z=-1;z<=1;z++){
                            if((abs(z)||abs(x)||abs(y))){ // the voxel itself is not part of its list of neighbours
                                //                            int * newIndex=new int[3];
                                int newIndex[3];
                                newIndex[0]=CorrespondingIndex[0]+x;
                                newIndex[1]=CorrespondingIndex[1]+y;
                                newIndex[2]=CorrespondingIndex[2]+z;
                                
                                bool outBorder=0;
                                for(int d=0;d<3;d++){
                                    if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                                        outBorder=1;
                                        break;
                                    }
                                }
                                if(!outBorder){
                                    ListNeighbours[neigh]=(newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2]);
                                    if(ListNeighbours[neigh]>numel || ListNeighbours[neigh]<0){
                                        cout<<"Pb with neigh "<<neigh;
                                    }
                                }
                                else{
                                    ListNeighbours[neigh]=(CurrentIndex);
                                }
                                neigh++;
                            }
                        }
                    }
                }
                
            }
            break;
        default:
            break;
    }
}

int * GetListNeighboursToLook(int CurrentIndex, int * Dim, int * Shift){
    int * ListNeighbourToLook = new int[26];
    int neigh=0;
    vector<int> CorrespondingIndex;
    //    for(int i=0;i<3;i++){
    //        CorrespondingIndex.push_back(0);
    //    }
    int tmp=CurrentIndex;
    //    int * Shift = new int[3];
    //    Shift[0]=1;
    //    Shift[1]=Dim[0];
    //    Shift[2]=Dim[0]*Dim[1];
    
    //    for(int i=2;i>=0;i--){
    ////        CorrespondingIndex.push_back((int)tmp/Shift[i]);
    //        CorrespondingIndex[i]=(int)tmp/Shift[i];
    //        tmp-=CorrespondingIndex[i]*Shift[i];
    //    }
    
    
    int CurrZ=(int)tmp/Shift[2];
    tmp-=CurrZ*Shift[2];
    int CurrY=(int)tmp/Shift[1];
    tmp-=CurrY*Shift[1];
    int CurrX=tmp;
    
    
    int numel=Dim[0]*Dim[1]*Dim[2];
    //    bool Border=0;
    //    for(int i=0;i<3;i++){
    //        if(CorrespondingIndex[i]==0){
    //            Border=1;
    //            break;
    //        }
    //        if(CorrespondingIndex[i]==Dim[i]-1){
    //            Border=1;
    //            break;
    //        }
    //    }
    
    for(int x=-1;x<=1;x++){
        for(int y=-1;y<=1;y++){
            for(int z=-1;z<=1;z++){
                if((abs(z)||abs(x)||abs(y))){ // the voxel itself is not part of its list of neighbours
                    //                    int * newIndex=new int[3];
                    int newIndex[3];
                    //                    newIndex[0]=CorrespondingIndex[0]+x;
                    //                    newIndex[1]=CorrespondingIndex[1]+y;
                    //                    newIndex[2]=CorrespondingIndex[2]+z;
                    
                    newIndex[0]=CurrX+x;
                    newIndex[1]=CurrY+y;
                    newIndex[2]=CurrZ+z;
                    
                    
                    bool outBorder=0;
                    for(int d=0;d<3;d++){
                        if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                            outBorder=1;
                            break;
                        }
                    }
                    if(!outBorder){
                        ListNeighbourToLook[neigh]=newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2];
                        if(ListNeighbourToLook[neigh]>numel || ListNeighbourToLook[neigh]<0){
                            cout<<"Pb with neigh "<<neigh;
                        }
                    }
                    else{
                        ListNeighbourToLook[neigh]=CurrentIndex;
                    }
                    neigh++;
                }
            }
        }
    }
    //cout <<neigh;
    
    //Checking validity of index list
    for(int n=0;n<26;n++){
        if(ListNeighbourToLook[n]<0 || ListNeighbourToLook[n]>numel){
            cout<<"Pb with NeighbourToLookList "<<endl;
        }
    }
    //    delete [] CorrespondingIndex;
    //    CorrespondingIndex=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    return ListNeighbourToLook;
}

// Returns in a array of integers the indices of the neighbours of the CurrentIndex given information of the dimensions of the image and the type of adjacency chosen (6 - 18 - 26)
int * GetListNeighbours(int CurrentIndex, int * Dim, int * Shift, int NeighbourhingType){
    int *ListNeighbours=NULL;
    //    int * CorrespondingIndex=new int[3];
    int CorrespondingIndex[3];
    int tmp=CurrentIndex;
    for(int i=2;i>=0;i--){
        CorrespondingIndex[i]=(int)tmp/Shift[i];
        tmp-=CorrespondingIndex[i]*Shift[i];
    }
    int numel=Dim[0]*Dim[1]*Dim[2];
    int neigh=0;
    
    switch (NeighbourhingType) {
            case 6:{
                ListNeighbours=new int[6];
                for (int n=0; n<6; n++) {
                    ListNeighbours[n]=0;
                }
                for(int x=-1;x<=1;x++){
                    for(int y=-1;y<=1;y++){
                        for(int z=-1;z<=1;z++){
                            if((abs(z)+abs(x)+abs(y))==1){ // the voxel itself is not part of its list of neighbours
                                //                            int * newIndex=new int[3];
                                int newIndex[3];
                                newIndex[0]=CorrespondingIndex[0]+x;
                                newIndex[1]=CorrespondingIndex[1]+y;
                                newIndex[2]=CorrespondingIndex[2]+z;
                                bool outBorder=0;
                                for(int d=0;d<3;d++){
                                    if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                                        outBorder=1;
                                        break;
                                    }
                                }
                                neigh=abs(x)*0 + abs(y)*2 + abs(z)*4; // Simply to be sure that in list first 2 correspond to WE, then NS then TB
                                if(x+y+z>0){
                                    neigh++;
                                }
                                if(!outBorder){
                                    ListNeighbours[neigh]=newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2];
                                    if(ListNeighbours[neigh]>numel || ListNeighbours[neigh]<0){
                                        cout<<"Pb with neigh "<<neigh;
                                    }
                                }
                                else{
                                    ListNeighbours[neigh]=(CurrentIndex);
                                }
                                //                            delete [] newIndex;
                                //                            newIndex=NULL;
                            }
                        }
                    }
                }
            }
            break;
            case 18:{
                ListNeighbours=new int[18];
                for (int n=0; n<18; n++) {
                    ListNeighbours[n]=0;
                }
                for(int x=-1;x<=1;x++){
                    for(int y=-1;y<=1;y++){
                        for(int z=-1;z<=1;z++){
                            int SumNeigh=abs(x)+abs(y)+abs(z);
                            if(SumNeigh>=1 && SumNeigh<=2){ // the voxel itself is not part of its list of neighbours
                                //                            int * newIndex=new int[3];
                                int newIndex[3];
                                newIndex[0]=CorrespondingIndex[0]+x;
                                newIndex[1]=CorrespondingIndex[1]+y;
                                newIndex[2]=CorrespondingIndex[2]+z;
                                
                                bool outBorder=0;
                                for(int d=0;d<3;d++){
                                    if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                                        outBorder=1;
                                        break;
                                    }
                                }
                                if(!outBorder){
                                    ListNeighbours[neigh]=(newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2]);
                                    if(ListNeighbours[neigh]>numel || ListNeighbours[neigh]<0){
                                        cout<<"Pb with neigh "<<neigh;
                                    }
                                }
                                else{
                                    ListNeighbours[neigh]=(CurrentIndex);
                                }
                                neigh++;
                                //                            delete [] newIndex;
                                //                            newIndex=NULL;
                            }
                        }
                    }
                }
                
            }
            break;
            case 26:{
                ListNeighbours=new int[26];
                for (int n=0; n<26; n++) {
                    ListNeighbours[n]=0;
                }
                for(int x=-1;x<=1;x++){
                    for(int y=-1;y<=1;y++){
                        for(int z=-1;z<=1;z++){
                            if((abs(z)||abs(x)||abs(y))){ // the voxel itself is not part of its list of neighbours
                                //                            int * newIndex=new int[3];
                                int newIndex[3];
                                newIndex[0]=CorrespondingIndex[0]+x;
                                newIndex[1]=CorrespondingIndex[1]+y;
                                newIndex[2]=CorrespondingIndex[2]+z;
                                
                                bool outBorder=0;
                                for(int d=0;d<3;d++){
                                    if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                                        outBorder=1;
                                        break;
                                    }
                                }
                                if(!outBorder){
                                    ListNeighbours[neigh]=(newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2]);
                                    if(ListNeighbours[neigh]>numel || ListNeighbours[neigh]<0){
                                        cout<<"Pb with neigh "<<neigh;
                                    }
                                }
                                else{
                                    ListNeighbours[neigh]=(CurrentIndex);
                                }
                                neigh++;
                                //                            delete [] newIndex;
                                //                            newIndex=NULL;
                            }
                        }
                    }
                }
                
            }
            break;
        default:
            break;
    }
    //    delete [] CorrespondingIndex;
    //    CorrespondingIndex=NULL;
    return ListNeighbours;
}

// Returns in a integer array the indices of the 6 closest neighbours of CurrentIndex given the information about the dimension of the image in Dim and Shift
int * Get6Neighbours(int CurrentIndex, int * Dim, int * Shift){
    int * ListNeighbourToLook = new int[6];
    int neigh=0;
    //    int * CorrespondingIndex=new int[3];
    int CorrespondingIndex[3];
    int tmp=CurrentIndex;
    //    int * Shift = new int[3];
    //    Shift[0]=1;
    //    Shift[1]=Dim[0];
    //    Shift[2]=Dim[0]*Dim[1];
    for(int i=2;i>=0;i--){
        CorrespondingIndex[i]=(int)tmp/Shift[i];
        tmp-=CorrespondingIndex[i]*Shift[i];
    }
    int numel=Dim[0]*Dim[1]*Dim[2];
    //    bool Border=0;
    //    for(int i=0;i<3;i++){
    //        if(CorrespondingIndex[i]==0){
    //            Border=1;
    //            break;
    //        }
    //        if(CorrespondingIndex[i]==Dim[i]-1){
    //            Border=1;
    //            break;
    //        }
    //    }
    
    for(int x=-1;x<=1;x++){
        for(int y=-1;y<=1;y++){
            for(int z=-1;z<=1;z++){
                if((abs(z)+abs(x)+abs(y))==1){ // the voxel itself is not part of its list of neighbours
                    //                    int * newIndex=new int[3];
                    int newIndex[3];
                    newIndex[0]=CorrespondingIndex[0]+x;
                    newIndex[1]=CorrespondingIndex[1]+y;
                    newIndex[2]=CorrespondingIndex[2]+z;
                    bool outBorder=0;
                    for(int d=0;d<3;d++){
                        if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                            outBorder=1;
                            break;
                        }
                    }
                    neigh=abs(x)*0 + abs(y)*2 + abs(z)*4; // Simply to be sure that in list first 2 correspond to WE, then NS then TB
                    if(x+y+z>0){
                        neigh++;
                    }
                    if(!outBorder){
                        ListNeighbourToLook[neigh]=newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2];
                        if(ListNeighbourToLook[neigh]>numel || ListNeighbourToLook[neigh]<0){
                            cout<<"Pb with neigh "<<neigh;
                        }
                    }
                    else{
                        ListNeighbourToLook[neigh]=CurrentIndex;
                    }
                }
            }
        }
    }
    //cout <<neigh;
    
    //Checking validity of index list
    for(int n=0;n<6;n++){
        if(ListNeighbourToLook[n]<0 || ListNeighbourToLook[n]>numel){
            cout<<"Pb with NeighbourToLookList "<<endl;
        }
    }
    //    delete [] CorrespondingIndex;
    //    CorrespondingIndex=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    return ListNeighbourToLook;
}

// Build and returns the image with the different lesion labels according to the image containing the lesion as probability or binary. The threshold is set to 0.5 by default. Might be changed afterwards
nifti_image * ImageComponentLabeling(nifti_image * SegToAnalyse, SEG_ANALYSIS * segment_analysis){
    if(segment_analysis->flag_connect==0){
        cout<<"No connecting labels asked for"<<endl;
        return NULL;
    }
    float thresh=0.5;
    int numel=SegToAnalyse->nvox;
    int * ComponentLabels=ComponentLabeling(SegToAnalyse,segment_analysis->Neigh, thresh);
    nifti_image * ImageLabelsConnect=nifti_copy_nim_info(SegToAnalyse);
    ImageLabelsConnect->data=(void *)calloc(numel, sizeof(float));
    float * LabelsData_PTR=static_cast<float *>(ImageLabelsConnect->data);
    for(int i=0;i<numel;i++){
        LabelsData_PTR[i]=ComponentLabels[i];
    }
    delete [] ComponentLabels;
    ComponentLabels=NULL;
    return ImageLabelsConnect;
}

int * ComponentLabeling(float * ImageToLabel, int Neigh, int * Dim, int * Shift, float thresh){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int Label=0;
    //Initialisation of looked elements and labels
    int * PositionTmp=new int[numel];
    int * ComponentsLabel=new int[numel];
    for (int i=0;i<numel;i++){
        PositionTmp[i]=0;
        ComponentsLabel[i]=0;
    }
    for(int x=0;x<Dim[0];x++){
        for(int y=0;y<Dim[1];y++){
            for(int z=0;z<Dim[2];z++){
                int CurrentIndex=x*Shift[0]+y*Shift[1]+z*Shift[2];
                if(ImageToLabel[CurrentIndex]>thresh && PositionTmp[CurrentIndex]==0 && ComponentsLabel[CurrentIndex]==0){
                    PositionTmp[CurrentIndex]=1;
                    ComponentsLabel[CurrentIndex]=Label++;
                    //                    cout<<"Changing to label "<<Label<<endl;
                    int Times=0;
                    RecurseCompLabel(ImageToLabel,PositionTmp,Label,ComponentsLabel,Neigh,Dim,Shift,thresh,Times);
                    //                    cout<<"out of loop Now Times is "<<endl;
                }
            }
        }
    }
//        cout<<"Final label is "<<Label<<endl;
    
    //    nifti_image * ImageBorderCSF=nifti_copy_nim_info(SegToAnalyse);
    //    ImageBorderCSF->data=(void *) calloc(SegToAnalyse->nvox, sizeof(float));
    //    float * ImageBorderCSF_PTR=static_cast<float *>(ImageBorderCSF->data);
    //    for (int i=0; i<numel; i++) {
    //        ImageBorderCSF_PTR[i]=(float)ComponentsLabel[i];
    //    }
    //    nifti_set_filenames(ImageBorderCSF, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE09/BorderComponent.nii.gz", 0, 0);
    //    nifti_image_write(ImageBorderCSF);
    
    RepassComponentsLabel(ComponentsLabel, Neigh,Dim,Shift);
    RefineNeighbourhood(ComponentsLabel,Dim,Shift);
    RelabelComponents(ComponentsLabel,Dim);
    delete [] PositionTmp;
    PositionTmp=NULL;
    int maxLabel=-1;
    for(int i=0;i<numel;i++){
        if(ComponentsLabel[i]>maxLabel){
            maxLabel=ComponentsLabel[i];
        }
    }
    cout<<"Number of components is "<<maxLabel;
    return ComponentsLabel;
}

// Returns in an integer array of size numelmasked the lesion labels given the image lesion as probabilities or binary, the neighborhood adjacency rule and the threshold.
int * ComponentLabeling(nifti_image * SegToAnalyse, int Neigh, float thresh){
    //    int * Dim=new int[3];
    int Dim[3];
    // for dimension record
    for(int m=0;m<3;m++){
        Dim[m]=SegToAnalyse->dim[m+1];
    }
    int numel=Dim[0]*Dim[1]*Dim[2];
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    float * Data=static_cast<float *>(SegToAnalyse->data);
    cout<<"Count NonZero before labeling is "<<CountNonZero(Data, numel);
    int Label=0;
    //Initialisation of looked elements and labels
    int * PositionTmp=new int[numel];
    int * ComponentsLabel=new int[numel];
    for (int i=0;i<numel;i++){
        PositionTmp[i]=0;
        ComponentsLabel[i]=0;
    }
    for(int x=0;x<Dim[0];x++){
        for(int y=0;y<Dim[1];y++){
            for(int z=0;z<Dim[2];z++){
                int CurrentIndex=x*Shift[0]+y*Shift[1]+z*Shift[2];
                if(Data[CurrentIndex]>thresh && PositionTmp[CurrentIndex]==0 && ComponentsLabel[CurrentIndex]==0){
                    PositionTmp[CurrentIndex]=1;
                    Label=Label+1;
                    ComponentsLabel[CurrentIndex]=Label;
                    //                    cout<<"Changing to label "<<Label<<endl;
                    int Times=0;
                    RecurseCompLabel(Data,PositionTmp,Label,ComponentsLabel,Neigh,Dim,Shift,thresh,Times);
                    //                    cout<<"out of loop Now Times is "<<endl;
                }
            }
        }
    }
//    cout<<"Final label is "<<Label<<endl;
    
    //    nifti_image * ImageBorderCSF=nifti_copy_nim_info(SegToAnalyse);
    //    ImageBorderCSF->data=(void *) calloc(SegToAnalyse->nvox, sizeof(float));
    //    float * ImageBorderCSF_PTR=static_cast<float *>(ImageBorderCSF->data);
    //    for (int i=0; i<numel; i++) {
    //        ImageBorderCSF_PTR[i]=(float)ComponentsLabel[i];
    //    }
    //    nifti_set_filenames(ImageBorderCSF, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE09/BorderComponent.nii.gz", 0, 0);
    //    nifti_image_write(ImageBorderCSF);
    cout<<"Non zero ComponentsLabel before repass is "<<CountNonZero(ComponentsLabel, numel);
    RepassComponentsLabel(ComponentsLabel, Neigh,Dim,Shift);
    //    cout<<"Non zero ComponentsLabel before refine is "<<CountNonZero(ComponentsLabel, numel);
    RefineNeighbourhood(ComponentsLabel,Dim,Shift);
    cout<<"Non zero ComponentsLabel before relabel is "<<CountNonZero(ComponentsLabel, numel);
    RelabelComponents(ComponentsLabel,Dim);
    //    cout<<"Non zero ComponentsLabel at the end is "<<CountNonZero(ComponentsLabel, numel);
    delete [] PositionTmp;
    PositionTmp=NULL;
    //    delete [] Dim;
    //    Dim=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    int maxLabel=-1;
    for(int i=0;i<numel;i++){
        if(ComponentsLabel[i]>maxLabel){
            maxLabel=ComponentsLabel[i];
        }
    }
    cout<<"Number of components is "<<maxLabel;
    return ComponentsLabel;
    
}


// Returns in an integer array of size numelmasked the lesion labels given the image lesion as probabilities or binary, the neighborhood adjacency rule and the threshold.
int * ComponentLabelingNotRefined(nifti_image * SegToAnalyse, int Neigh, float thresh){
    //    int * Dim=new int[3];
    int Dim[3];
    // for dimension record
    for(int m=0;m<3;m++){
        Dim[m]=SegToAnalyse->dim[m+1];
    }
    int numel=Dim[0]*Dim[1]*Dim[2];
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    float * Data=static_cast<float *>(SegToAnalyse->data);
    cout<<"Count NonZero before labeling is "<<CountNonZero(Data, numel);
    int Label=0;
    //Initialisation of looked elements and labels
    int * PositionTmp=new int[numel];
    int * ComponentsLabel=new int[numel];
    for (int i=0;i<numel;i++){
        PositionTmp[i]=0;
        ComponentsLabel[i]=0;
    }
    for(int x=0;x<Dim[0];x++){
        for(int y=0;y<Dim[1];y++){
            for(int z=0;z<Dim[2];z++){
                int CurrentIndex=x*Shift[0]+y*Shift[1]+z*Shift[2];
                if(Data[CurrentIndex]>=thresh && PositionTmp[CurrentIndex]==0 && ComponentsLabel[CurrentIndex]==0){
                    PositionTmp[CurrentIndex]=1;
                    Label=Label+1;
                    ComponentsLabel[CurrentIndex]=Label;
                    //                    cout<<"Changing to label "<<Label<<endl;
                    int Times=0;
                    RecurseCompLabel(Data,PositionTmp,Label,ComponentsLabel,Neigh,Dim,Shift,thresh,Times);
                    //                    cout<<"out of loop Now Times is "<<endl;
                }
            }
        }
    }
    cout<<"Final label is "<<Label<<endl;
    
    //    nifti_image * ImageBorderCSF=nifti_copy_nim_info(SegToAnalyse);
    //    ImageBorderCSF->data=(void *) calloc(SegToAnalyse->nvox, sizeof(float));
    //    float * ImageBorderCSF_PTR=static_cast<float *>(ImageBorderCSF->data);
    //    for (int i=0; i<numel; i++) {
    //        ImageBorderCSF_PTR[i]=(float)ComponentsLabel[i];
    //    }
    //    nifti_set_filenames(ImageBorderCSF, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE09/BorderComponent.nii.gz", 0, 0);
    //    nifti_image_write(ImageBorderCSF);
    cout<<"Non zero ComponentsLabel before repass is "<<CountNonZero(ComponentsLabel, numel);
    RepassComponentsLabel(ComponentsLabel, Neigh,Dim,Shift);
    cout<<"Non zero ComponentsLabel after repass is "<<CountNonZero(ComponentsLabel, numel);
    //    RefineNeighbourhood(ComponentsLabel,Dim,Shift);
    //    cout<<"Non zero ComponentsLabel before relabel is "<<CountNonZero(ComponentsLabel, numel);
    RelabelComponents(ComponentsLabel,Dim);
    cout<<"Non zero ComponentsLabel at the end is "<<CountNonZero(ComponentsLabel, numel);
    delete [] PositionTmp;
    PositionTmp=NULL;
    //    delete [] Dim;
    //    Dim=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    int maxLabel=-1;
    for(int i=0;i<numel;i++){
        if(ComponentsLabel[i]>maxLabel){
            maxLabel=ComponentsLabel[i];
        }
    }
    cout<<"Number of components is "<<maxLabel;
    return ComponentsLabel;
    
}






// Given the integer array of the lesion label, refine the neighborhood, delete labels if there are not considered as coherent enough. A label is coherent enough if at least two elements in it are neighbours by more than a corner
void RefineNeighbourhood(int * ComponentLabel, int * Dim, int * Shift){
    int numel = Dim[0]*Dim[1]*Dim[2];
    int maxLabel=GetMaxLabel(ComponentLabel, numel);
    int CountRefinedExcluded=0;
    for (int l=0; l<maxLabel; l++) {
        vector<int> IndicesLabel=GetListIndicesLabel(ComponentLabel,Dim,l+1);
        int sizeLabel=IndicesLabel.size();
        if (sizeLabel>0) {
            bool flag_accept=IsCoherentEnough(IndicesLabel,Dim,Shift);
            if (!flag_accept) {
                CountRefinedExcluded++;
                for (int i=0; i<sizeLabel; i++) {
                    ComponentLabel[IndicesLabel[i]]=0;
                }
            }
        }
    }
    //    cout<<"RefinedNeighborhood excluded is "<<CountRefinedExcluded<<endl;
}

// Given the integer array of labels give the list of indices corresponding to a certain label
vector<int> GetListIndicesLabel(int * ComponentLabel, int * Dim, int Label){
    vector<int> ListIndicesLabel;
    // First check if possible label
    int numel = Dim[0]*Dim[1]*Dim[2];
    int maxLabel=GetMaxLabel(ComponentLabel, numel);
    if (Label<1 || Label>maxLabel) {
        cout<<"Inconsistency with asked label"<<endl;
        return ListIndicesLabel;
    }
    for (int i=0; i<numel; i++) {
        if (ComponentLabel[i]==Label) {
            ListIndicesLabel.push_back(i);
        }
    }
    return ListIndicesLabel;
}

// Check about the coherence of a certain label given the list of indices corresponding to this label and the dimension information enabling to build neighborhood rules.
bool IsCoherentEnough(vector<int> IndicesLabel,int * Dim, int * Shift){
    bool Coherence=0;
    int SizeLabel=IndicesLabel.size();
    int i=0;
    while (!Coherence && i<SizeLabel) {
        //        int * List6Neigh=Get6Neighbours(IndicesLabel[i], Dim,Shift);
        int List6Neigh[6];
        GetListNeighbours_bis(List6Neigh, IndicesLabel[i], Dim, Shift, 6);
        //        int * List6Neigh=GetListNeighbours(IndicesLabel[i], Dim, Shift, 6);
        for (int n=0; n<6; n++) {
            for (int j=0; j<SizeLabel; j++) {
                if (List6Neigh[n]==IndicesLabel[j] && IndicesLabel[i]!=IndicesLabel[j]) {
                    Coherence=1;
                    break;
                }
            }
            if (Coherence) {
                break;
            }
        }
        //        delete [] List6Neigh;
        //        List6Neigh=NULL;
        //        delete [] List6Neigh;
        //        List6Neigh=NULL;
        i++;
    }
    return Coherence;
}

// Check if Label asked for is present in the integer array ComponentLabel given the size of this array numel.
bool IsLabelPresent(int Label, int * ComponentLabel,int numel){
    // First Check if Label to check is available in the componentLabel array
    for(int i=0;i<numel;i++){
        if(ComponentLabel[i]==Label){
            return 1;
        }
    }
    return 0;
}

// Check if the Lesion considered in Label is acceptable in term of size
bool IsLesionAcceptable(int Label, int * ComponentLabel, int MiniSize, int numel){
    bool presenceLabel=IsLabelPresent(Label, ComponentLabel, numel);
    if(!presenceLabel){
        return 0;
    }
    int LabelSize=GetLabelSize( Label, ComponentLabel, numel);
    if(LabelSize >MiniSize){
        return 1;
    }
    return 0;
}

// Returns the size in number of voxels of the lesion characterised by label Label
int GetLabelSize(int Label, int * ComponentLabel, int numel){
    bool presenceLabel=IsLabelPresent(Label, ComponentLabel, numel);
    if(!presenceLabel){
        return 0;
    }
    int SizeLabel=0;
    for(int i=0;i<numel;i++){
        if(ComponentLabel[i]==Label){
            SizeLabel++;
        }
    }
    return SizeLabel;
}

// For all the Labels in the integer array containing the Labels, return in an integer array of size numbLabels the number of voxels of each lesion label
int * GetVolumeLabels(int * ComponentLabel, int numel){
    int maxLabel=-1;
    for(int i=0;i<numel;i++){
        if(ComponentLabel[i]>maxLabel){
            maxLabel=ComponentLabel[i];
        }
    }
    if(maxLabel==0){
        return NULL;
    }
    int * VolumeLabels=new int [maxLabel];
    for(int l=0;l<maxLabel;l++){
        VolumeLabels[l]=0;
    }
    for(int l=1;l<=maxLabel;l++){
        int TmpVolume=0;
        for(int i=0;i<numel;i++){
            if(ComponentLabel[i]==l){
                TmpVolume++;
            }
        }
        VolumeLabels[l-1]=TmpVolume;
    }
    return VolumeLabels;
}

// Correspondance between Label as it is obtained initially and index in term of decreasing volume
int * GetCorrespondanceOrderedVolume(int * VolumeLabels, int maxLabel){
    int * CorrespondingOrderedLabels=new int[maxLabel];
    int * CorrespondanceOrderedLabels=new int[maxLabel];
    for(int l=0;l<maxLabel;l++){
        CorrespondingOrderedLabels[l]=l+1;
        CorrespondanceOrderedLabels[l]=l+1;
    }
    bool flag_swap=1;
    while(flag_swap==1){
        flag_swap=0;
        for(int l=0;l<maxLabel-1;l++){
            if(VolumeLabels[l]<VolumeLabels[l+1]){
                int tmp1=VolumeLabels[l];
                int tmp2=VolumeLabels[l+1];
                int indTmp1=CorrespondingOrderedLabels[l];
                int indTmp2=CorrespondingOrderedLabels[l+1];
                VolumeLabels[l]=tmp2;
                VolumeLabels[l+1]=tmp1;
                CorrespondingOrderedLabels[l]=indTmp2;
                CorrespondingOrderedLabels[l+1]=indTmp1;
                flag_swap=1;
            }
        }
    }
    for(int l1=0;l1<maxLabel;l1++){
        for(int l2=1;l2<maxLabel+1;l2++){
            if(CorrespondingOrderedLabels[l1]==l2){
                CorrespondanceOrderedLabels[l2-1]=l1+1;
            }
        }
    }
    delete [] CorrespondingOrderedLabels;
    CorrespondingOrderedLabels=NULL;
    return CorrespondanceOrderedLabels;
}

// Returns the modified array of integer of size numel containing the initial labels into the labels by ordered volume
int * OrderedVolumeLabel(int * ComponentLabels, float MiniSize, int numel,float VolumeVox,float MaxSize){
    int maxLabel=GetMaxLabel(ComponentLabels, numel);
    int * VolumeLabels=GetVolumeLabels(ComponentLabels, numel);
    float * OldVolumeLabels=new float [maxLabel];
    for (int l=0; l<maxLabel; l++) {
        OldVolumeLabels[l]=VolumeLabels[l]*VolumeVox;
    }
    int * OrderedLabels=GetCorrespondanceOrderedVolume(VolumeLabels, maxLabel);
    int * NewComponentsOrderedLabel=new int[numel];
    for(int i=0;i<numel;i++){
        NewComponentsOrderedLabel[i]=ComponentLabels[i];
        if(ComponentLabels[i]!=0){
            NewComponentsOrderedLabel[i]=OrderedLabels[ComponentLabels[i]-1];
        }
        if(ComponentLabels[i]>0 && (OldVolumeLabels[ComponentLabels[i]-1]<MiniSize || OldVolumeLabels[ComponentLabels[i]-1]>MaxSize)){
//            cout<<"Discarding because below mini size of "<<MiniSize<<endl;
            NewComponentsOrderedLabel[i]=0;
        }
    }
    int minLabel=maxLabel;
    for(int i=0;i<numel;i++){
        if(NewComponentsOrderedLabel[i]>0 && NewComponentsOrderedLabel[i]<minLabel){
            minLabel=NewComponentsOrderedLabel[i];
        }
    }
    if (minLabel>1){
        cout << "min Label is "<< minLabel<<endl;
        for(int i=0;i<numel;i++){
            if (NewComponentsOrderedLabel[i]>0){
                NewComponentsOrderedLabel[i]-=minLabel-1;
            }
        }
    }
    cout<<" new max Label is "<<GetMaxLabel(NewComponentsOrderedLabel, numel);
    delete [] VolumeLabels;
    delete [] OrderedLabels;
    delete [] OldVolumeLabels;
    VolumeLabels=NULL;
    OrderedLabels=NULL;
    OldVolumeLabels=NULL;
    return NewComponentsOrderedLabel;
}

// Return the lesion structure corresponding to a specific label given the labelisation of the connected component and the Tree structure.
Lesion * BuildLesionFromConnectedLabels(int * OrderedLabels, TreeEM * TreeToAnalyse, int Label,SEG_ANALYSIS * segment_analysis){
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if (Label<1 || Label > maxLabel){
        cout<<"Corresponding lesion does not exist";
        return NULL;
    }
    Lesion * LesionLabel=new Lesion();
    int Size=GetLabelSize(Label, OrderedLabels, numel);
    float Volume=Size*TreeToAnalyse->GetDataImage()->pixdim[1]*TreeToAnalyse->GetDataImage()->pixdim[2]*TreeToAnalyse->GetDataImage()->pixdim[3];
    LesionLabel->Volume=Volume;
    float InnerSurface=GetSurface(OrderedLabels,TreeToAnalyse, Label, 1);
    LesionLabel->Surface=InnerSurface;
    LesionLabel->SAV=InnerSurface/Volume;
    TreeEM * TreeWM=TreeToAnalyse->GetGeneralClassesVector()[segment_analysis->IndexWM];
    float * MeanWM=TreeWM->GetMeanDirect();
    float * VarianceWM=TreeWM->GetVarianceDirect();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    float * ParamLabel=GetParamLabel(OrderedLabels, TreeToAnalyse,Label);
    if (ParamLabel!=NULL) {
        float * MeanLabel=new float [numbmodal];
        float * VarianceLabel=new float [numbmodal * numbmodal];
        float * RatioLabel=new float [numbmodal];
        for(int m1=0;m1<numbmodal;m1++){
            MeanLabel[m1]=ParamLabel[m1];
            RatioLabel[m1]=MeanLabel[m1]/MeanWM[m1];
            for(int m2=0;m2<numbmodal;m2++){
                VarianceLabel[m1+m2*numbmodal]=ParamLabel[numbmodal+m1+m2*numbmodal];
            }
        }
        LesionLabel->Variance=VarianceLabel;
        LesionLabel->Mean=MeanLabel;
        LesionLabel->RatioToNormal=RatioLabel;
    }
    
    float DistanceToCSF=GetDistanceToNormalTissue(OrderedLabels, Label, TreeToAnalyse, 2,segment_analysis);
    float DistanceToGM=GetDistanceToNormalTissue(OrderedLabels, Label, TreeToAnalyse, 0,segment_analysis);
    float DistanceToWM=GetDistanceToNormalTissue(OrderedLabels, Label, TreeToAnalyse,1,segment_analysis);
    float DistanceToOut=GetDistanceToNormalTissue(OrderedLabels, Label, TreeToAnalyse, 3, segment_analysis);
    LesionLabel->DistanceCSF=DistanceToCSF;
    LesionLabel->DistanceGM=DistanceToGM;
    LesionLabel->DistanceWM=DistanceToWM;
    LesionLabel->DistanceOut=DistanceToOut;
    
    // Clearing memory and returning result
    delete [] MeanWM;
    MeanWM=NULL;
    delete [] VarianceWM;
    VarianceWM=NULL;
    if (ParamLabel!=NULL) {
        delete [] ParamLabel;
        ParamLabel=NULL;
    }
    
    return LesionLabel;
}

// Returns the lesion intensity structure
LesionIntensity * BuildLesionIntensityFromConnectedLabel(int * OrderedLabels, int Label, float * MeanWMSeg, float * CovarianceWMSeg, nifti_image * DataCompImage, nifti_image * MahalDistImage){
    //    First check compatibility of data
    int numel=DataCompImage->nx*DataCompImage->ny*DataCompImage->nz;
    int numbmodal=DataCompImage->nu*DataCompImage->nt;
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if (Label>maxLabel || Label<1) {
        cout<<"Corresponding lesion does not exist";
        return NULL;
    }
    //    GetParamLabel to be able to make the comparisons
    float * ParamLabel=GetParamLabel(OrderedLabels, DataCompImage, Label);
    int sizeParam=numbmodal+numbmodal*numbmodal;
    int Volume=GetLabelSize(Label, OrderedLabels, numel);
    LesionIntensity * Lesion=new LesionIntensity();
    Lesion->Volume=Volume;
    for (int m=0; m<sizeParam; m++) {
        Lesion->Param.push_back(ParamLabel[m]);
    }
    Lesion->MahalDistance.push_back(GetMahalDist(ParamLabel, MeanWMSeg, CovarianceWMSeg, numbmodal));
    for (int m=0; m<numbmodal; m++) {
        Lesion->MeanRatio.push_back(ParamLabel[m]/MeanWMSeg[m]);
        Lesion->MahalDistance.push_back(GetMahalDist(&ParamLabel[m], &MeanWMSeg[m], &CovarianceWMSeg[m+numbmodal*m], 1));
    }
    float MinMahal=GetExtremaMahalDistLabel(OrderedLabels,Label,MeanWMSeg,CovarianceWMSeg,DataCompImage,-1);
    float MaxMahal=GetExtremaMahalDistLabel(OrderedLabels,Label,MeanWMSeg,CovarianceWMSeg,DataCompImage,1);
    Lesion->ExtremaMahal.push_back(MinMahal);
    Lesion->ExtremaMahal.push_back(MaxMahal);
    bool * LesionBool=CreateLesionBool(OrderedLabels, Label, numel);
    float * Quantilisation=QuantiliseMask(LesionBool, MahalDistImage);
    if (Quantilisation!=NULL) {
        for (int i=0; i<(numbmodal+1)*3; i++) {
            Lesion->Quantilisation.push_back(Quantilisation[i]);
        }
        delete [] Quantilisation;
        Quantilisation=NULL;
    }
    
    float * MahalDistData=static_cast<float *>(MahalDistImage->data);
    for (int i=1; i<10; i++) {
        float ProportionMahalUnder=GetProportionUnder<float,bool>(MahalDistData, LesionBool, 0.5*i, numel);
        Lesion->ProportionMahal.push_back(ProportionMahalUnder);
    }
    
    
    //    Clear memory before returning
    delete [] ParamLabel;
    ParamLabel=NULL;
    delete [] LesionBool;
    LesionBool=NULL;
    return Lesion;
}


// Return the lesion simple structure corresponding to a specific label given the labelisation of the connected component and the Tree structure.
LesionSimple * BuildLesionSimpleFromConnectedLabels(int * OrderedLabels, nifti_image * InitialSeg, int Label,int BorderType){
    int numel=InitialSeg->nx*InitialSeg->ny*InitialSeg->nz;
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if (Label<1 || Label > maxLabel){
        cout<<"Corresponding lesion does not exist";
        return NULL;
    }
    LesionSimple * LesionLabel=new LesionSimple();
    int Size=GetLabelSize(Label, OrderedLabels, numel);
    float Volume=Size*InitialSeg->pixdim[1]*InitialSeg->pixdim[2]*InitialSeg->pixdim[3];
    LesionLabel->Volume=Volume;
    float InnerSurface=GetSurfaceImage(OrderedLabels, InitialSeg, Label, BorderType);
    LesionLabel->Surface=InnerSurface;
    LesionLabel->SAV=InnerSurface/Volume;
    return LesionLabel;
}




// Return the lesion structure corresponding to a specific label given the labelisation of the connected component and the Tree structure.
Lesion * BuildLesionFromConnectedLabels_bis(int * OrderedLabels, TreeEM * TreeToAnalyse, bool * HardSegSummarised, int Label,SEG_ANALYSIS * segment_analysis){
    int numel=TreeToAnalyse->GetNumberElements();
    int Dim[3];
    int Shift[3];
    float PixDim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=TreeToAnalyse->GetDataImage()->dim[d+1];
        PixDim[d]=TreeToAnalyse->GetDataImage()->pixdim[d+1];
    }
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if (Label<1 || Label > maxLabel){
        cout<<"Corresponding lesion does not exist";
        return NULL;
    }
    bool * LesionBool=CreateLesionBool(OrderedLabels, Label, numel);
    Lesion * LesionLabel=new Lesion();
    int Size=GetLabelSize(Label, OrderedLabels, numel);
    float Volume=Size*TreeToAnalyse->GetDataImage()->pixdim[1]*TreeToAnalyse->GetDataImage()->pixdim[2]*TreeToAnalyse->GetDataImage()->pixdim[3];
    LesionLabel->Volume=Volume;
    float InnerSurface=GetSurface(OrderedLabels,TreeToAnalyse, Label, 1);
    LesionLabel->Surface=InnerSurface;
    LesionLabel->SAV=InnerSurface/Volume;
    LesionLabel->Compactness=sqrt(pow_int(InnerSurface, 3)/pow_int(Volume, 2));
    TreeEM * TreeWM=TreeToAnalyse->GetGeneralClassesVector()[segment_analysis->IndexWM];
    if (Volume!=0) {
        int * BoundingBoxLabel=FindBoundingBox(LesionBool,Dim,Shift );
        if (BoundingBoxLabel!=NULL) {
            LesionLabel->BoundingBox=new int[6];
            for (int i=0; i<6; i++) {
                LesionLabel->BoundingBox[i]=BoundingBoxLabel[i];
            }
            delete [] BoundingBoxLabel;
            BoundingBoxLabel=NULL;
        }
    }
    
    float * MeanWM=TreeWM->GetMeanDirect();
    float * VarianceWM=TreeWM->GetVarianceDirect();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    float * ParamLabel=GetParamLabel(OrderedLabels, TreeToAnalyse,Label);
    if (ParamLabel!=NULL) {
        float * MeanLabel=new float [numbmodal];
        float * VarianceLabel=new float [numbmodal * numbmodal];
        float * RatioLabel=new float [numbmodal];
        for(int m1=0;m1<numbmodal;m1++){
            MeanLabel[m1]=ParamLabel[m1];
            RatioLabel[m1]=MeanLabel[m1]/MeanWM[m1];
            for(int m2=0;m2<numbmodal;m2++){
                VarianceLabel[m1+m2*numbmodal]=ParamLabel[numbmodal+m1+m2*numbmodal];
            }
        }
        LesionLabel->Variance=VarianceLabel;
        LesionLabel->Mean=MeanLabel;
        LesionLabel->RatioToNormal=RatioLabel;
    }
    
    bool * HardSegOut=new bool[numel];
    bool * HardSegSummarisedOut=&HardSegSummarised[numel*segment_analysis->IndexOut];
    int * L2S=TreeToAnalyse->GetL2S();
    for (int i=0; i<numel; i++) {
        if (L2S[i]<0 || HardSegSummarisedOut[i]==1) {
            HardSegOut[i]=1;
        }
        else{
            HardSegOut[i]=0;
        }
    }
    
    
    //    float DistanceToCSF=GetDistanceToSeg(OrderedLabels, Label,TreeToAnalyse, &HardSegSummarised[numel *segment_analysis->IndexCSF]);
    float DistanceToCSF=GetDistanceBetweenSeg(LesionBool, &HardSegSummarised[numel*segment_analysis->IndexCSF], Dim, Shift, PixDim);
    float DistanceToGM=GetDistanceToSeg(OrderedLabels, Label,TreeToAnalyse, &HardSegSummarised[numel *segment_analysis->IndexGM]);
    float DistanceToWM=GetDistanceToSeg(OrderedLabels, Label,TreeToAnalyse, &HardSegSummarised[numel *segment_analysis->IndexWM]);
    float DistanceToOut=GetDistanceToSeg(OrderedLabels, Label,TreeToAnalyse, HardSegOut);
    LesionLabel->DistanceCSF=DistanceToCSF;
    LesionLabel->DistanceGM=DistanceToGM;
    LesionLabel->DistanceWM=DistanceToWM;
    LesionLabel->DistanceOut=DistanceToOut;
    
    // Clearing memory and returning result
    delete [] MeanWM;
    MeanWM=NULL;
    delete [] VarianceWM;
    VarianceWM=NULL;
    delete [] LesionBool;
    LesionBool=NULL;
    if (ParamLabel!=NULL) {
        delete [] ParamLabel;
        ParamLabel=NULL;
    }
    delete [] HardSegOut;
    HardSegOut=NULL;
    
    return LesionLabel;
}



// Returns in a float array the parameters related to the Label studied. Of size numbmodal + numbmodal*numbmodal, contains the mean and the covariance matrix related to the specified label.
float * GetParamLabel(int * OrderedLabels, nifti_image * DataCompImage, int Label){
    if (DataCompImage==NULL) {
        cout<<"No data to get params for label"<<endl;
        return NULL;
    }
    int numel=DataCompImage->nx*DataCompImage->ny*DataCompImage->nz;
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if(Label<1 || Label>maxLabel){
        cout<<"Label inconsistent with max Label"<<endl;
        return NULL;
    }
    int numbmodal = DataCompImage->nu*DataCompImage->nt;
    float * Data_PTR=static_cast<float *>(DataCompImage->data);
    float * ParamLabel=new float[numbmodal+numbmodal*numbmodal];
    for(int i=0;i<numbmodal+numbmodal*numbmodal;i++){
        ParamLabel[i]=0;
    }
    
    // Determination of the mean
    int numberLabel=0;
    for(int i=0;i<numel;i++){
        if(OrderedLabels[i]==Label){
            numberLabel++;
            for(int m=0;m<numbmodal;m++){
                ParamLabel[m]+=Data_PTR[m*numel+i];
            }
        }
    }
    if(numberLabel>0){
        for(int m=0;m<numbmodal;m++){
            ParamLabel[m]/=numberLabel;
        }
    }
    
    // Determination of the variance
    for(int i=0;i<numel;i++){
        if(OrderedLabels[i]==Label){
            for(int m1=0;m1<numbmodal;m1++){
                for(int m2=0;m2<numbmodal;m2++){
                    float Data1=Data_PTR[m1*numel+i];
                    float Data2=Data_PTR[m2*numel+i];
                    ParamLabel[numbmodal+m1+m2*numbmodal]+=(Data1-ParamLabel[m1])*(Data2-ParamLabel[m2]);
                }
            }
            
        }
    }
    
    if(numberLabel>0){
        for(int m=0;m<numbmodal*numbmodal;m++){
            ParamLabel[numbmodal+m]/=numberLabel;
        }
    }
    
    return ParamLabel;
    
}






// Returns in a float array the parameters related to the Label studied. Of size numbmodal + numbmodal*numbmodal, contains the mean and the covariance matrix related to the specified label.
float * GetParamLabel(int * OrderedLabels, TreeEM * TreeToAnalyse, int Label){
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if(Label<1 || Label>maxLabel){
        cout<<"Label inconsistent with max Label"<<endl;
        return NULL;
    }
    int numbmodal = TreeToAnalyse->GetNumberModalities();
    float * Data_PTR=static_cast<float *>(TreeToAnalyse->GetDataImage()->data);
    float * ParamLabel=new float[numbmodal+numbmodal*numbmodal];
    for(int i=0;i<numbmodal+numbmodal*numbmodal;i++){
        ParamLabel[i]=0;
    }
    
    // Determination of the mean
    int numberLabel=0;
    for(int i=0;i<numel;i++){
        if(OrderedLabels[i]==Label){
            numberLabel++;
            for(int m=0;m<numbmodal;m++){
                ParamLabel[m]+=Data_PTR[m*numel+i];
            }
        }
    }
    if(numberLabel>0){
        for(int m=0;m<numbmodal;m++){
            ParamLabel[m]/=numberLabel;
        }
    }
    
    // Determination of the variance
    for(int i=0;i<numel;i++){
        if(OrderedLabels[i]==Label){
            for(int m1=0;m1<numbmodal;m1++){
                for(int m2=0;m2<numbmodal;m2++){
                    float Data1=Data_PTR[m1*numel+i];
                    float Data2=Data_PTR[m2*numel+i];
                    ParamLabel[numbmodal+m1+m2*numbmodal]+=(Data1-ParamLabel[m1])*(Data2-ParamLabel[m2]);
                }
            }
            
        }
    }
    
    if(numberLabel>0){
        for(int m=0;m<numbmodal*numbmodal;m++){
            ParamLabel[numbmodal+m]/=numberLabel;
        }
    }
    
    return ParamLabel;
    
}

//Return in a float array the proportion of voxels in the considered boolean segmentation that are on one side or the other of a given voxel.
float * ProportionCompareGravity(bool * SegStudied, int IndexCentreGrav, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    //    Corresponding indices of Gravity
    int CorrGrav[3];
    int tmpGrav=IndexCentreGrav;
    CorrGrav[2]=tmpGrav/Shift[2];
    tmpGrav=IndexCentreGrav-CorrGrav[2]*Shift[2];
    CorrGrav[1]=tmpGrav/Shift[1];
    CorrGrav[0]=tmpGrav-CorrGrav[1]*Shift[1];
    
    //    Initialise count and proportion for location relative to centre of gravity
    int CountTot=0;
    int CountRel[6];
    for (int l=0; l<6; l++) {
        CountRel[l]=0;
    }
    
    for (int i=0; i<numel; i++) {
        if (SegStudied[i]) {
            CountTot++;
            //            Corresponding grid indices
            int CorrInd[3];
            int tmp=i;
            CorrInd[2]=tmp/Shift[2];
            tmp=i-CorrInd[2]*Shift[2];
            CorrInd[1]=tmp/Shift[1];
            CorrInd[0]=tmp-CorrInd[1]*Shift[1];
            
            //            Differences with respect to centre of gravity and corresponding counting
            //            int DiffX=CorrGrav[0]-CorrInd[0];
            //            int DiffY=CorrGrav[1]-CorrInd[1];
            //            int DiffZ=CorrGrav[2]-CorrInd[2];
            for (int d=0; d<3; d++) {
                CountRel[2*d+(CorrGrav[d]>CorrInd[d])]++;
            }
        }
    }
    
    //    Calculation of proportion
    float * ResultPropWRGrav=new float[6];
    for (int l=0; l<6; l++) {
        ResultPropWRGrav[l]=(float)CountRel[l]/CountTot;
    }
    return ResultPropWRGrav;
}


vector<int> GetIndicesMinPath(int IndexBegin, int IndexEnd, int * Dim,int * Shift,float * PixDim){
    
    //    float DistBE=GetDistanceBetweenPoints(IndexBegin, IndexEnd, Dim, PixDim);
    int IndexTmp=IndexBegin;
    vector<int > IndicesMinimumPath;
    IndicesMinimumPath.push_back(IndexBegin);
    while (IndexTmp!=IndexEnd) {
        int ListNeighbours[26];
        GetListNeighbours_bis(ListNeighbours, IndexTmp, Dim, Shift, 26);
        float DistanceTmp[26];
        for (int n=0; n<26; n++) {
            DistanceTmp[n]=GetDistanceBetweenPoints(ListNeighbours[n], IndexEnd, Dim, PixDim);
        }
        int IndexMin=GetIndexMin(DistanceTmp,26);
        IndexTmp=ListNeighbours[IndexMin];
        IndicesMinimumPath.push_back(IndexTmp);
    }
    return IndicesMinimumPath;
}

void CorrectedCentreGrav(bool* Mask, int * CentreGravCoord, int * Dim, int * Shift, float * PixDim){
//    int CoordTest[3];
    int KeptIndex=0;
    int numel=Dim[0]*Dim[1]*Dim[2];
    float DistanceMin=numel;
    int IndexCG=CentreGravCoord[0]+Shift[1]*CentreGravCoord[1]+CentreGravCoord[2]*Shift[2];
    if (Mask[IndexCG]) {
        return;
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                float DistanceTest=GetDistanceBetweenPoints(i, IndexCG, Dim, PixDim);
                if (DistanceTest<DistanceMin) {
                    KeptIndex=i;
                    DistanceMin=DistanceTest;
                }
                
            }
        }
    }
    CorrespondingCoordinates_bis(CentreGravCoord, KeptIndex, Dim, Shift);
    return;
}

int GetCenterGravity(bool * Mask, int * Dim){
    //    Initialisation
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    
    float Xind=0;
    float Yind=0;
    float Zind=0;
    int NZCount=0;
    
    //  Sum over all non zero elements for mean x, y,z
    for (int x=0; x<Dim[0]; x++) {
        for (int y=0; y<Dim[1]; y++) {
            for (int z=0; z<Dim[2]; z++) {
                int Index=x+y*Shift[1]+z*Shift[2];
                if (Mask[Index]) {
                    Xind+=x;
                    Yind+=y;
                    Zind+=z;
                    NZCount++;
                }
            }
        }
    }
    
    //    Mean according to NZCount
    if (NZCount!=0) {
        Xind/=NZCount;
        Yind/=NZCount;
        Zind/=NZCount;
    }
    
    return (int)(round(Xind)+round(Yind)*Shift[1]+round(Zind)*Shift[2]);
}


float GetDistanceSegToPoint(int Index, bool* Seg, int* Dim, int*Shift, float* PixDim){
    int numel = Dim[0]*Dim[1]*Dim[2];
    int * SegInt = TranscribeArray<bool, int>(Seg,numel);
    vector<int> BorderLesion=GetIndicesBorderLesion(SegInt,1,Dim,Shift);
    int numbborder=BorderLesion.size();
    //    cout<<"Border size is "<<numbborder<<endl;
    //    bool flag_reached=0;
    //    int Radius=0;
    float Distance=0;
    if (SegInt[Index]==1) {
        cout<<"Center of gravity in label"<<endl;
        return 0;
    }
    // Then while tissue of reference is not reached, look at list around neighbour at specific radius to see if obtained there for all element in border of lesion
    if(numbborder>0){
        float * DistancePointToBorder=new float[numbborder];
        for (int p=0; p<numbborder; p++) {
            DistancePointToBorder[p]=GetDistanceBetweenPoints(BorderLesion[p], Index, Dim, PixDim);
        }
        Distance=GetMin(DistancePointToBorder, numbborder);

    }
    //    cout<<"Distance is "<<Radius;

    return Distance;
}

float GetDistanceLabelToPoint(int * OrderedLabels, int Label, TreeEM* TreeToAnalyse, int IndexPoint){
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if(Label<1 || Label>maxLabel){
        cout<<"Incompatible label asked for in distance calculation"<<endl;
        return -1;
    }
    //    int IndexTissue=-1;
    
    //    int * Dim=new int[3];
    int Dim[3];
    for(int d=0;d<3;d++){
        Dim[d]=TreeToAnalyse->GetDataImage()->dim[d+1];
    }
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    float PixDim[3];
    PixDim[0]=TreeToAnalyse->GetDataImage()->pixdim[1];
    PixDim[1]=TreeToAnalyse->GetDataImage()->pixdim[2];
    PixDim[2]=TreeToAnalyse->GetDataImage()->pixdim[3];
    
    // Creation of list of neighbours with increasing radius for each element of border of lesion
    // For each element in lesion, check first if one of the border and get the vector of indices at the border of the lesion.
    vector<int> BorderLesion=GetIndicesBorderLesion(OrderedLabels,Label,Dim,Shift);
    int numbborder=BorderLesion.size();
    //    cout<<"Border size is "<<numbborder<<endl;
    //    bool flag_reached=0;
    //    int Radius=0;
    float Distance=0;
    if (OrderedLabels[IndexPoint]==Label) {
        cout<<"Center of gravity in label"<<endl;
        return 0;
    }
    // Then while tissue of reference is not reached, look at list around neighbour at specific radius to see if obtained there for all element in border of lesion
    if(numbborder>0){
        float * DistancePointToBorder=new float[numbborder];
        for (int p=0; p<numbborder; p++) {
            DistancePointToBorder[p]=GetDistanceBetweenPoints(BorderLesion[p], IndexPoint, Dim, PixDim);
        }
        //        vector<int> IndicesReached;
        //        vector<int> IndicesSource;
        //        while(!flag_reached && Radius<MaxRadius){
        //            Radius++;
        //
        //            //        vector<float> DistanceToReach;
        //            for(int i=0;i<numbborder;i++){
        //                vector<int> IndicesExplored=GetIndicesToExplore(BorderLesion[i],OrderedLabels,Radius,Dim);
        //                int numbExplo=IndicesExplored.size();
        //                for(int e=0;e<numbExplo;e++){
        //                    if(IndicesExplored[e]==IndexPoint){
        //                        flag_reached=1;
        //                        IndicesReached.push_back(IndicesExplored[e]);
        //                        IndicesSource.push_back(BorderLesion[i]);
        //                    }
        //                }
        //            }
        //            //            cout<<"Finished at this radius"<<endl;
        //        }
        //        Distance=GetMinDistanceFromIndicesVectors(IndicesSource, IndicesReached, TreeToAnalyse, Dim, Shift);
        //            Distance=GetMinDistanceFromIndicesVectors( IndicesSource, IndicesReached,TreeToAnalyse,Dim,Shift);
        Distance=GetMin(DistancePointToBorder, numbborder);
        
    }
    //    cout<<"Distance is "<<Radius;
    
    return Distance;
}


//Return the minimal distance for the distance to the segmented tissue
float GetDistanceBetweenSeg(bool * Seg1, bool * Seg2, int * Dim, int * Shift, float * PixDim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    float minPixDim=GetMin(PixDim, 3);
    int * Seg1Int=TranscribeArray<bool, int>(Seg1, numel );
    int * Seg2Int=TranscribeArray<bool, int>(Seg2, numel);
    vector<int> IndicesBorderSeg1 =GetIndicesBorderLesion(Seg1Int, 1, Dim, Shift);
    vector<int> IndicesBorderSeg2=GetIndicesBorderLesion(Seg2Int, 1, Dim, Shift);
    int numbBorder1=IndicesBorderSeg1.size();
    int numbBorder2=IndicesBorderSeg2.size();
    float minDistance=1000;
    for (int i=0; i<numbBorder1; i++) {
        for (int j=0; j<numbBorder2; j++) {
            float TmpDistance=GetDistanceBetweenPoints(IndicesBorderSeg1[i], IndicesBorderSeg2[j], Dim, PixDim);
            minDistance=minDistance>TmpDistance?TmpDistance:minDistance;
            if (minDistance<=minPixDim) {
                break;
            }
        }
        if (minDistance<=minPixDim) {
            break;
        }
    }
    delete [] Seg1Int;
    delete [] Seg2Int;
    Seg1Int=NULL;
    Seg2Int=NULL;
    return minDistance;
}


// Return an upper bound for the distance to segmented tissue (based on radius first before corresponding distance calculated)
float GetDistanceToSeg(int * OrderedLabels, int Label, TreeEM * TreeToAnalyse, bool * HardSeg){
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if(Label<1 || Label>maxLabel){
        cout<<"Incompatible label asked for in distance calculation"<<endl;
        return -1;
    }
    //    int IndexTissue=-1;
    
    //    int * Dim=new int[3];
    int Dim[3];
    for(int d=0;d<3;d++){
        Dim[d]=TreeToAnalyse->GetDataImage()->dim[d+1];
    }
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    
    // Creation of list of neighbours with increasing radius for each element of border of lesion
    // For each element in lesion, check first if one of the border and get the vector of indices at the border of the lesion.
    vector<int> BorderLesion=GetIndicesBorderLesion(OrderedLabels,Label,Dim,Shift);
    int numbborder=BorderLesion.size();
    //    cout<<"Border size is "<<numbborder<<endl;
    bool flag_reached=0;
    int Radius=0;
    float Distance=0;
    // Then while tissue of reference is not reached, look at list around neighbour at specific radius to see if obtained there for all element in border of lesion
    if(numbborder>0){
        vector<int> IndicesReached;
        vector<int> IndicesSource;
        while(!flag_reached && Radius<MaxRadius){
            Radius++;
            
            //        vector<float> DistanceToReach;
            for(int i=0;i<numbborder;i++){
                vector<int> IndicesExplored=GetIndicesToExplore(BorderLesion[i],OrderedLabels,Radius,Dim);
                int numbExplo=IndicesExplored.size();
                for(int e=0;e<numbExplo;e++){
                    if(HardSeg[IndicesExplored[e]]){
                        flag_reached=1;
                        IndicesReached.push_back(IndicesExplored[e]);
                        IndicesSource.push_back(BorderLesion[i]);
                    }
                }
            }
            //            cout<<"Finished at this radius"<<endl;
        }
        Distance=GetMinDistanceFromIndicesVectors(IndicesSource, IndicesReached, TreeToAnalyse, Dim, Shift);
        //            Distance=GetMinDistanceFromIndicesVectors( IndicesSource, IndicesReached,TreeToAnalyse,Dim,Shift);
        
    }
    //    cout<<"Distance is "<<Radius;
    
    return Distance;
}





// Return an upper bound for the distance to normal tissue (based on radius first before corresponding distance calculated)
float GetDistanceToNormalTissue(int * OrderedLabels, int Label, TreeEM * TreeToAnalyse, int TissueType, SEG_ANALYSIS * segment_analysis){
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if(Label<1 || Label>maxLabel){
        cout<<"Incompatible label asked for in distance calculation"<<endl;
        return -1;
    }
    int IndexTissue=-1;
    
    //    int * Dim=new int[3];
    int Dim[3];
    for(int d=0;d<3;d++){
        Dim[d]=TreeToAnalyse->GetDataImage()->dim[d+1];
    }
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    switch(TissueType){
            case 0:
            IndexTissue=segment_analysis->IndexGM;
            break;
            case 1:
            IndexTissue=segment_analysis->IndexWM;
            break;
            case 2:
            IndexTissue=segment_analysis->IndexCSF;
            break;
            case 3:
            IndexTissue=segment_analysis->IndexOut;
            break;
        default:
            IndexTissue=segment_analysis->IndexCSF;
            break;
            
    }
    
    if(IndexTissue<0 || IndexTissue>TreeToAnalyse->GetNumberGeneralClasses()){
        return -1;
    }
    
    // Determination of the Tissue hard segmentation that corresponds
    TreeEM * TreeTissueRef=TreeToAnalyse->GetGeneralClassesVector()[IndexTissue];
    if (TreeTissueRef==NULL) {
        cout<<"Pb in getting TreeTissueRef"<<endl;
    }
    bool * HardSegTissueRef=new bool[numel];
    float * NormRespTissueRef=TreeTissueRef->GetNormResp();
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    int j=0;
    for(int i=0;i<numel;i++){
        HardSegTissueRef[i]=0;
        if(L2S_PTR[i]>=0){
            if(NormRespTissueRef[j]>=0.5){
                HardSegTissueRef[i]=1;
            }
            j++;
        }
    }
    
    // Creation of list of neighbours with increasing radius for each element of border of lesion
    // For each element in lesion, check first if one of the border and get the vector of indices at the border of the lesion.
    vector<int> BorderLesion=GetIndicesBorderLesion(OrderedLabels,Label,Dim,Shift);
    int numbborder=BorderLesion.size();
    //    cout<<"Border size is "<<numbborder<<endl;
    bool flag_reached=0;
    int Radius=0;
    float Distance=0;
    // Then while tissue of reference is not reached, look at list around neighbour at specific radius to see if obtained there for all element in border of lesion
    if(numbborder>0){
        vector<int> IndicesReached;
        vector<int> IndicesSource;
        while(!flag_reached && Radius<MaxRadius){
            Radius++;
            
            //        vector<float> DistanceToReach;
            for(int i=0;i<numbborder;i++){
                vector<int> IndicesExplored=GetIndicesToExplore(BorderLesion[i],OrderedLabels,Radius,Dim);
                int numbExplo=IndicesExplored.size();
                for(int e=0;e<numbExplo;e++){
                    if(HardSegTissueRef[IndicesExplored[e]]){
                        flag_reached=1;
                        IndicesReached.push_back(IndicesExplored[e]);
                        IndicesSource.push_back(BorderLesion[i]);
                    }
                }
            }
            //            cout<<"Finished at this radius"<<endl;
        }
        Distance=GetMinDistanceFromIndicesVectors(IndicesSource, IndicesReached, TreeToAnalyse, Dim, Shift);
        //            Distance=GetMinDistanceFromIndicesVectors( IndicesSource, IndicesReached,TreeToAnalyse,Dim,Shift);
        
    }
    //    cout<<"Distance is "<<Radius;
    //    delete [] Dim;
    //    Dim=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    delete [] HardSegTissueRef;
    HardSegTissueRef=NULL;
    
    return Distance;
}

// from the lists of corresponding end-points, determine the minimum distance. Need to take pixdim into account as well as Dim hence the need for TreeEM or at least the corresponding image
float GetMinDistanceFromIndicesVectors(vector<int> IndicesSource, vector<int> IndicesReached, TreeEM * TreeToAnalyse,int * Dim, int * Shift){
    // First check that the vectors are compatible
    // in size :
    if (IndicesReached.size()!=IndicesSource.size()) {
        cout<<"Incompatible size of endpoints lists"<<endl;
        return 0;
    }
    int numbDist=IndicesSource.size();
    int numel=Dim[0]*Dim[1]*Dim[2];
    //    float * PixDimSquared=new float[3];
    float PixDimSquared[3];
    float MaxPixDimSquared=0;
    for (int d=0; d<3; d++) {
        PixDimSquared[d]=powf(TreeToAnalyse->GetDataImage()->pixdim[d+1],2);
        if (MaxPixDimSquared<PixDimSquared[d]) {
            MaxPixDimSquared=PixDimSquared[d];
        }
    }
    // in value
    // Populate the vector of distance result
    vector<float> DistanceResult;
    float DistanceMin=MaxRadius*sqrt(MaxPixDimSquared);
    if (numbDist==0) {
        return DistanceMin;
    }
    for (int i=0; i<numbDist; i++) {
        if (IndicesSource[i]!=IndicesReached[i]) {
            if (IndicesSource[i]>=0 && IndicesSource[i]<numel) { // Ensure the value looked at for the index source is correct
                if (IndicesReached[i]>=0 && IndicesReached[i]<numel) { // Ensure the value looked at for the index reached is correct
                    // Transformation in x y z coordinates for index source and index reached
                    int tmps=IndicesSource[i];
                    int tmpr=IndicesReached[i];
                    //                    int * IndexCorrReached=new int [3];
                    //                    int * IndexCorrSource=new int [3];
                    int IndexCorrReached[3];
                    int IndexCorrSource[3];
                    float DistanceSquared=0;
                    for (int d=2; d>=0; d--) {
                        IndexCorrReached[d]=tmpr/Shift[d];
                        IndexCorrSource[d]=tmps/Shift[d];
                        tmpr-=IndexCorrReached[d]*Shift[d];
                        tmps-=IndexCorrSource[d]*Shift[d];
                        DistanceSquared+=(IndexCorrReached[d]-IndexCorrSource[d])*(IndexCorrReached[d]-IndexCorrSource[d])*PixDimSquared[d];
                    }
                    DistanceResult.push_back(sqrt(DistanceSquared));
                    //                    delete [] IndexCorrSource;
                    //                    delete [] IndexCorrReached;
                    //                    IndexCorrSource=NULL;
                    //                    IndexCorrReached=NULL;
                }
            }
        }
    }
    
    int DistanceSize=DistanceResult.size();
    
    for (int i=0; i<DistanceSize; i++) {
        if (DistanceResult[i]<DistanceMin) {
            DistanceMin=DistanceResult[i];
        }
    }
    //    delete [] PixDimSquared;
    //    PixDimSquared=NULL;
    return DistanceMin;
}

// Returns in a vector of indices the list of indices of voxels belonging to lesion that are at the border with another tissue.
vector<int> GetIndicesBorderLesionExt (int * OrderedLabels, int Label, int * Dim, int * Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    bool * LesionBool=CreateLesionBool(OrderedLabels, Label, numel);
    bool * OpposedLesionBool=OpposeBoolArray(LesionBool, numel);
    int * OpposedInt=TranscribeArray<bool, int>(OpposedLesionBool, numel);
    vector<int> IndicesResults=GetIndicesBorderLesion(OpposedInt, 1, Dim, Shift);
    delete [] LesionBool;
    delete [] OpposedLesionBool;
    delete [] OpposedInt;
    LesionBool=NULL;
    OpposedLesionBool=NULL;
    OpposedInt=NULL;
    return IndicesResults;
}

// Returns in a vector of indices the list of indices of voxels belonging to lesion that are at the border with another tissue.
vector<int> GetIndicesBorderLesion (int * OrderedLabels, int Label, int * Dim, int * Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    vector<int>VectorIndicesBorderLesion;
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    if (Label<1 || Label>maxLabel) {
        cout<<"No appropriate label value for indices of border lesion"<<endl;
        return VectorIndicesBorderLesion;
    }
    for(int i=0;i<numel;i++){
        if(OrderedLabels[i]==Label){
            bool flag_border=0;
            //            int * List6Neighbours=Get6Neighbours(i, Dim,Shift);
            int List6Neighbours[6];
            GetListNeighbours_bis(List6Neighbours, i, Dim, Shift, 6);
            //            int * List6Neighbours=GetListNeighbours(i, Dim, Shift, 6);
            for(int n=0;n<6;n++){
                if(OrderedLabels[List6Neighbours[n]]!=Label){
                    flag_border=1;
                }
            }
            if (flag_border) {
                VectorIndicesBorderLesion.push_back(i);
            }
            //            delete [] List6Neighbours;
            //            List6Neighbours=NULL;
        }
    }
    return VectorIndicesBorderLesion;
}


// Returns a pointer to an integer array that instead of containing the labels, contains the outlier classification from 0 to 4 0=FP, 1 close to CSF, 2 close to CSF 3 Subcortical 1 and 4 Subcortical 2
int * OutlierClassification(int * ComponentLabel, vector<Outlier *> OutlierVectorToClassify,int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int maxLabel=GetMaxLabel(ComponentLabel, numel);
    int numbLesionToClassify=OutlierVectorToClassify.size();
    if (maxLabel > numbLesionToClassify) {
        cout<<"Inconsistence between vector of lesions and labeling with maxLabel "<<maxLabel<<" and numbLesionToClassify "<<numbLesionToClassify<<endl;
        return NULL;
    }
    int * OutlierClassification=new int[numel];
    for (int i=0; i<numel; i++) {
        OutlierClassification[i]=0;
    }
    for (int i=0; i<numel; i++) {
        if (ComponentLabel[i]>0) {
            int l=ComponentLabel[i];
            if (OutlierVectorToClassify[l-1]->OutlierClass  ==-20){
                OutlierClassification[i]=-20;
            }
            else{
             OutlierClassification[i]=OutlierVectorToClassify[l-1]->LesionType;
            }
        }
    }
    return OutlierClassification;
}




// Returns a pointer to an integer array that instead of containing the labels, contains the lesion classification from 0 to 4 0=FP, 1 close to CSF, 2 close to CSF 3 Subcortical 1 and 4 Subcortical 2
int * LesionClassification(int * ComponentLabel, vector<Lesion *> LesionToClassify,int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int maxLabel=GetMaxLabel(ComponentLabel, numel);
    int numbLesionToClassify=LesionToClassify.size();
    if (maxLabel > numbLesionToClassify) {
        cout<<"Inconsistence between vector of lesions and labeling with maxLabel "<<maxLabel<<" and numbLesionToClassify "<<numbLesionToClassify<<endl;
        return NULL;
    }
    int * LesionClassification=new int[numel];
    for (int i=0; i<numel; i++) {
        LesionClassification[i]=-1;
    }
    int * Volume=GetVolumeLabels(ComponentLabel, numel);
    for (int l=0; l<numbLesionToClassify; l++) {
        if (LesionToClassify[l]->LesionCode==-2) {
            LesionCodeImproved(LesionToClassify[l]);
        }
        vector<int> LabelIndices=GetListIndicesLabel(ComponentLabel, Dim, l+1);
        int sizeLabel=LabelIndices.size();
        if (sizeLabel==0) {
            cout<<"Lesion is actually void now"<<endl;
        }
        for (int s=0; s<sizeLabel; s++) {
            LesionClassification[LabelIndices[s]]=LesionToClassify[l]->LesionType;
        }
    }
    if (Volume!=NULL) {
        delete [] Volume;
        Volume=NULL;
    }
    return LesionClassification;
}

// Given the vector of lesion structures defined, count the number of lesions separated into the different types defined
int * CountLesionType(vector<Lesion*>LesionVector){
    int * CountperType=new int[5];
    for (int t=0; t<5; t++) {
        CountperType[t]=0;
    }
    int numbLesion=LesionVector.size();
    for (int l=0; l<numbLesion; l++) {
        int Type=LesionVector[l]->LesionType;
        if (Type>=0 && Type<5) {
            CountperType[Type]++;
            
        }
    }
    return CountperType;
}



// Similar as before but instead of giving the number of lesion per type, gives the volume
float * VolumeLesionType(vector<Lesion*>LesionVector){
    float * VolumeperType=new float[5];
    for (int t=0; t<5; t++) {
        VolumeperType[t]=0;
    }
    int numbLesion=LesionVector.size();
    for (int l=0; l<numbLesion; l++) {
        int Type=LesionVector[l]->LesionType;
        if (Type>=0 && Type<5) {
            VolumeperType[Type]+=LesionVector[l]->Volume;
            
        }
    }
    return VolumeperType;
}

// Given the vector of lesion structure given, returns the total volume of lesion segmented
float TotVolumeLesion(vector<Lesion *> LesionVector){
    int numbLesion=LesionVector.size();
    float VolumeTot=0;
    for (int l=0; l<numbLesion; l++) {
        int Type=LesionVector[l]->LesionType;
        if (Type>0 && Type<5) {
            VolumeTot+=LesionVector[l]->Volume;
        }
    }
    return VolumeTot;
}

// Modify the lesion structure in order to accomodate for the code. The code is given according to the Neighborhood criteria to the borders of the different tissues. NeighbourWMI if lesion close to border of WM inliers. GMC if close to border of combined GM and CSF, CSF if close to border of parenchyma where parenchyma contains both inlier and outlier
void LesionCode(Lesion * LesionToCode){
    LesionToCode->LesionCode=100*LesionToCode->NeighbourWMI+10*LesionToCode->NeighbourGMC+1*LesionToCode->NeighbourCSF*(LesionToCode->DistanceOut>=MaxRadius)+LesionToCode->NeighbourOut*1000+(LesionToCode->DistanceOut<5)*1000;
    switch (LesionToCode->LesionCode) {
            case 111: // Close to CSF of type 1
            LesionToCode->LesionType=PV;
            if (LesionToCode->ProportionWM<0.1) {
                cout<<"Possible reclassification as FP of lesion of type 1";
                if(LesionToCode->DistanceVentricle>10 || LesionToCode->DistanceVentricle<0){
                    cout<<"Need to reclassify as FP";
                    LesionToCode->LesionType=Out;
                }
                cout<<endl;
            }
            break;
            case 101: // Close to CSF of type 2
            LesionToCode->LesionType=PVNGM;
            break;
            case 100:// Subcortical of Type 1 (only neighbour to WMI)
            LesionToCode->LesionType=SC1;
            break;
            case 110:{ // Subcortical of type 2
                LesionToCode->LesionType=SC2;
                if(LesionToCode->ProportionWM<LesionToCode->ProportionGM){
                    cout<<"Possible reclassification as FP of lesion of type 4 ";
                    if(( LesionToCode->DistanceVentricle>LesionToCode->DistanceCSF && LesionToCode->DistanceVentricle>10 && LesionToCode->ProportionWM<0.10)){
                        cout<<"...reclassif as FP belonging to cortical sheet ";
                        LesionToCode->LesionType=CS;
                    }
                    if (LesionToCode->ProportionWM<LesionToCode->ProportionCSF) {
                        LesionToCode->LesionType=IV;
                        cout<<"... FP probably in ventricle ";
                    }
                    cout<<endl;
                }
                else if(LesionToCode->ProportionWM-LesionToCode->ProportionGM<0.15 && LesionToCode->DistanceGrav <10 && LesionToCode->ProportionCSF>0.10 && LesionToCode->SPPotProp>0.5){
                    cout<<"Reclassification as part of Septum pellucidum";
                    LesionToCode->LesionType=SP;
                }
            }
            break;
        default: // All FP
            
            LesionToCode->LesionType=Out;
            break;
    }
}


// Modify the lesion structure in order to accomodate for the code. The code is given according to the Neighborhood criteria to the borders of the different tissues. NeighbourWMI if lesion close to border of WM inliers. GMC if close to border of combined GM and CSF, CSF if close to border of parenchyma where parenchyma contains both inlier and outlier
void LesionCodeImprovedT1T2(Lesion * LesionToCode){
    LesionToCode->LesionCode=100*LesionToCode->NeighbourWMI+10*(LesionToCode->NeighbourGMC>0)+1*LesionToCode->NeighbourVentricle+5*((LesionToCode->ProportionCSF>0)-LesionToCode->NeighbourVentricle)+(LesionToCode->ProportionOut>0 && LesionToCode->NeighbourOut)*1000+(LesionToCode->DistanceOut<3)*1000;
    switch (LesionToCode->LesionCode) {
            case 111: {// Close to CSF of type 1
                LesionToCode->LesionType=PV;
                //            if (LesionToCode->ProportionWM<0.1) {
                //                cout<<"Possible reclassification as FP of lesion of type 1";
                //                if(LesionToCode->DistanceVentricle>10 || LesionToCode->DistanceVentricle<0){
                //                    cout<<"Need to reclassify as FP";
                //                    LesionToCode->LesionType=Out;
                //                }
                //                cout<<endl;
                //            }
                if (LesionToCode->ProportionWM<LesionToCode->ProportionGM) {
                    if (abs(LesionToCode->VectorDiffGrav[0])<=3) {
                        if (LesionToCode->VectorDiffGrav[2]<0) {
                            cout<<"Need to reclassify as 3 Ventricle flow ";
                            LesionToCode->LesionType=TV;
                        }
                    }
                }
                
                if (LesionToCode->ProportionGM < 0.55 && LesionToCode->ProportionWM<0.55 && LesionToCode->DistanceGrav <30 && LesionToCode->SPPotProp>0.5) {
                    cout <<" Need to reclassify as SP";
                    if (abs(LesionToCode->VectorDiffGrav[0])<4*LesionToCode->DistanceVentricle) {
                        cout<<"...change effective";
                        LesionToCode->LesionType=SP;
                    }
                    
                }
            }
            break;
            case 115 : // Close to ECSF, WM and GM but not to ventricle
            LesionToCode->LesionType=SC2;
            //            if (LesionToCode->ProportionWM<0.75) {
            //                if(LesionToCode->DistanceAcceptedGM>3 && !LesionToCode->DGMBelonging){
            //                    cout<<"Probably artefacts either CS or Flow Ventricles";
            //                    LesionToCode->LesionType=CS;
            //                }
            //            }
            break;
            case 96:{ // Only near WM and CSF Ventricle
                cout<<"Near WM and ventricle only";
                LesionToCode->LesionType=PVNGM;
            }
            break;
            case 11:{ // Only close to ventricle and GM but not to WM
                if (LesionToCode->DistanceGrav<33) {
                    LesionToCode->LesionType=IV;
                    cout<<"Probably IV ";
                }
                else{
                    LesionToCode->LesionType=PVD;
                }
            }
            break;
            case 16:{
                cout<<"Probably CS";
                LesionToCode->LesionType=CS;
            }
            break;
            case 116:{ // Close at the same time to external CSF and Ventricles
                LesionToCode->LesionType=PV;
                if (LesionToCode->ProportionGM < 0.55 && LesionToCode->ProportionWM<0.55 && LesionToCode->DistanceGrav <30 && LesionToCode->SPPotProp>0.5) {
                    cout <<" Need perhaps to reclassify as SP";
                    if (abs(LesionToCode->VectorDiffGrav[0])<4*LesionToCode->DistanceVentricle) {
                        cout<<"...changed effective";
                        LesionToCode->LesionType=SP;
                    }
                    
                }
            }
            case 101: // Close to CSF of type 2
            LesionToCode->LesionType=PVNGM;
            break;
            case 100:// Subcortical of Type 1 (only neighbour to WMI)
            LesionToCode->LesionType=SC1;
            break;
            case 106:{// Mostly close to WM and partly to CSF
                LesionToCode->LesionType=PVNGM;
                if(LesionToCode->ProportionCSF==0){
                    if (LesionToCode->ProportionWM>LesionToCode->ProportionGM) {
                        cout<<"no problem pure SC";
                        LesionToCode->LesionType=SC2;
                    }
                    else if (LesionToCode->DGMBelonging) {
                        cout<<"DGM Belonging no reclassification ";
                    }
                    else if(LesionToCode->ProportionCSF==0 && LesionToCode->DistanceVentricle<=LesionToCode->DistanceCSF && LesionToCode->DistanceVentricle<5){
                        cout<<"Close enough to ventricles not to be considered as belonging to cortical sheet ";
                        LesionToCode->LesionType=PV;
                    }
                    else if(LesionToCode->ProportionCSF==0 && LesionToCode->ProportionGM-LesionToCode->ProportionWM < 0.15){
                        cout<<"probably pure SC very close to CS";
                        LesionToCode->LesionType=SC2;
                    }
                    //                else if(LesionToCode->DistanceAcceptedGM==-1 || LesionToCode->DistanceAcceptedGM >LesionToCode->DistanceGM){
                    //                    cout<<"...reclassif as FP belonging to cortical sheet ";
                    //                    LesionToCode->LesionType=CS;
                    //                }
                    cout<<endl;
                }
            }
            break;
            case 110:{ // Subcortical of type 2
                LesionToCode->LesionType=SC2;
                if(LesionToCode->ProportionWM<LesionToCode->ProportionGM){
                    cout<<"Possible reclassification as FP of lesion of type 4 ";
                    if (LesionToCode->DGMBelonging) {
                        cout <<" DGM lesion probable : no reclassification ";
                    }
                    else if(LesionToCode->ProportionWM>0.15){
                        cout<<"suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    else if(LesionToCode->ProportionWM>0.10 && LesionToCode->DistanceCSF>2){
                        cout<<"extremely suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    else if (LesionToCode->ProportionCSF==0){
                        cout<<"more than extremely suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    else{
                        cout<<"... need to be classified as CS ";
                        LesionToCode->LesionType=CS;
                    }
                    //                else if(LesionToCode->DistanceAcceptedGM==-1 || LesionToCode->DistanceAcceptedGM >LesionToCode->DistanceGM){
                    //                    cout<<"...reclassif as FP belonging to cortical sheet ";
                    //                    LesionToCode->LesionType=CS;
                    //                }
                    cout<<endl;
                }
            }
            break;
            case 1115:{ // Quite close to the Out part but might be accepted nonetheless
                LesionToCode->LesionType=SCS2;
                if (LesionToCode->DistanceAcceptedGM<LesionToCode->DistanceOut && LesionToCode->ProportionWM>LesionToCode->ProportionCSF && LesionToCode->ProportionWM>0.25) {
                    cout<<"Suspicious cortical sheet lesion ";
                    LesionToCode->LesionType=SCS2;
                }
                if (LesionToCode->Volume>10000 && LesionToCode->DistanceVentricle==0 && LesionToCode->ProportionWM>0.3){
                    cout << "Probably massive lesion with issues at border";
                    LesionToCode->LesionType=PV;
                }
                else if(LesionToCode->ProportionCSF>LesionToCode->ProportionWM){
                    cout<<"Cortical sheet near out mask ";
                    LesionToCode->LesionType=CS;
                }
                else if(LesionToCode->ProportionOut>0){
                    cout<<" Certainly out ";
                    LesionToCode->LesionType=Out;
                }
            }
            break;
            case 1110:{ // Very probable cortical sheet close to out accepted only if WM proportion is high enough
                if (LesionToCode->ProportionWM>0.25) {
                    cout<<"Very suspicious lesion near cortical sheet ";
                    LesionToCode->LesionType=SCS;
                }
                else{
                    cout <<"Cortical sheet lesion near out ";
                    LesionToCode->LesionType=SCS2;
                }
            }
            break;
        default: {// All FP
            if (LesionToCode->ProportionWM>0.85 && LesionToCode->LesionCode<1000) {
                cout<<"Not considered but probably lesion WM ";
                LesionToCode->LesionType=SC2;
            }
            cout<<"Probably out ";
            LesionToCode->LesionType=Out;
        }
            break;
    }
}


// Modify the lesion structure in order to accomodate for the code. The code is given according to the Neighborhood criteria to the borders of the different tissues. NeighbourWMI if lesion close to border of WM inliers. GMC if close to border of combined GM and CSF, CSF if close to border of parenchyma where parenchyma contains both inlier and outlier
void LesionCodeImprovedLevel3(Lesion * LesionToCode){
    LesionToCode->LesionCode=100*LesionToCode->NeighbourWMI+10*LesionToCode->NeighbourGMC+1*LesionToCode->NeighbourVentricle+5*((LesionToCode->ProportionCSF>0)-LesionToCode->NeighbourVentricle)+(LesionToCode->ProportionOut>0 && LesionToCode->NeighbourOut)*1000+(LesionToCode->DistanceOut<3)*1000;
    switch (LesionToCode->LesionCode) {
            case 111:{ // Close to CSF of type 1
                LesionToCode->LesionType=PV;
                //            if (LesionToCode->ProportionWM<0.1) {
                //                cout<<"Possible reclassification as FP of lesion of type 1";
                //                if(LesionToCode->DistanceVentricle>10 || LesionToCode->DistanceVentricle<0){
                //                    cout<<"Need to reclassify as FP";
                //                    LesionToCode->LesionType=Out;
                //                }
                //                cout<<endl;
                //            }
                //            if (LesionToCode->ProportionWM<LesionToCode->ProportionGM) {
                //                if (fabs(LesionToCode->VectorDiffGrav[0])<=3) {
                //                    if (LesionToCode->VectorDiffGrav[2]<0) {
                //                        cout<<"Need to reclassify as 3 Ventricle flow ";
                //                        LesionToCode->LesionType=TV;
                //                    }
                //                }
                //            }
                
                if (LesionToCode->ProportionGM < 0.55 && LesionToCode->ProportionWM<0.55 && LesionToCode->DistanceGrav <30) {
                    cout <<"Possible need to reclassify as SP";
                    if (abs(LesionToCode->VectorDiffGrav[0])<4*LesionToCode->DistanceVentricle && LesionToCode->SPPotProp>0.5) {
                        cout<<"...change effective";
                        LesionToCode->LesionType=SP;
                    }
                    
                }
            }
            break;
            case 115 :{ // Close to ECSF, WM and GM but not to ventricle
                LesionToCode->LesionType=SC2;
                //            if (LesionToCode->ProportionWM<0.75) {
                //                if(LesionToCode->DistanceAcceptedGM>3 && !LesionToCode->DGMBelonging){
                //                    cout<<"Probably artefacts either CS or Flow Ventricles";
                //                    LesionToCode->LesionType=CS;
                //                }
                //            }
            }
            break;
            case 96:{ // Only near WM and CSF Ventricle
                cout<<"Near WM and ventricle only";
                LesionToCode->LesionType=PVNGM;
            }
            break;
            case 11:{ // Only close to ventricle and GM but not to WM
                if (LesionToCode->DistanceGrav<33) {
                    LesionToCode->LesionType=IV;
                    cout<<"Probably IV ";
                }
                else{
                    LesionToCode->LesionType=PVD;
                }
            }
            break;
            case 16:{
                cout<<"Probably CS";
                LesionToCode->LesionType=CS;
            }
            break;
            case 116:{ // Close at the same time to external CSF and Ventricles
                LesionToCode->LesionType=PV;
                if (LesionToCode->ProportionGM < 0.55 && LesionToCode->ProportionWM<0.55 && LesionToCode->DistanceGrav <30) {
                    cout <<" Need perhaps to reclassify as SP";
                    if (abs(LesionToCode->VectorDiffGrav[0])<4*LesionToCode->DistanceVentricle && LesionToCode->SPPotProp>0.5) {
                        cout<<"...changed effective";
                        LesionToCode->LesionType=SP;
                    }
                    
                }
            }
            case 101: // Close to CSF of type 2
            LesionToCode->LesionType=PVNGM;
            break;
            case 100:// Subcortical of Type 1 (only neighbour to WMI)
            LesionToCode->LesionType=SC1;
            break;
            case 106:{// Mostly close to WM and partly to CSF
                LesionToCode->LesionType=PVNGM;
                if(LesionToCode->ProportionCSF==0){
                    if (LesionToCode->ProportionWM>LesionToCode->ProportionGM) {
                        cout<<"no problem pure SC";
                        LesionToCode->LesionType=SC2;
                    }
                    else if (LesionToCode->DGMBelonging) {
                        cout<<"DGM Belonging no reclassification ";
                    }
                    else if(LesionToCode->ProportionCSF==0 && LesionToCode->DistanceVentricle<=LesionToCode->DistanceCSF && LesionToCode->DistanceVentricle<5){
                        cout<<"Close enough to ventricles not to be considered as belonging to cortical sheet ";
                        LesionToCode->LesionType=PV;
                    }
                    else if(LesionToCode->ProportionCSF==0 && LesionToCode->ProportionGM-LesionToCode->ProportionWM < 0.15){
                        cout<<"probably pure SC very close to CS";
                        LesionToCode->LesionType=SC2;
                    }
                    else if(LesionToCode->DistanceAcceptedGM==-1 || LesionToCode->DistanceAcceptedGM >LesionToCode->DistanceGM){
                        cout<<"...reclassif as FP belonging to cortical sheet ";
                        LesionToCode->LesionType=CS;
                    }
                    cout<<endl;
                }
            }
            break;
            case 110:{ // Subcortical of type 2
                LesionToCode->LesionType=SC2;
                if(LesionToCode->ProportionWM<LesionToCode->ProportionGM){
                    cout<<"Possible reclassification as FP of lesion of type 4 ";
                    if (LesionToCode->DGMBelonging) {
                        cout <<" DGM lesion probable : no reclassification ";
                    }
                    else if(LesionToCode->ProportionWM>0.15){
                        cout<<"suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    else if(LesionToCode->ProportionWM>0.10 && LesionToCode->DistanceCSF>2){
                        cout<<"extremely suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    //                else if(LesionToCode->ProportionCSF==0){
                    //                    cout<<" more than extremely CS suspicious but still accepted as lesion ";
                    //                    LesionToCode->LesionType=SCS;
                    //                }
                    else if(LesionToCode->DistanceAcceptedGM==-1 || LesionToCode->DistanceAcceptedGM >LesionToCode->DistanceGM){
                        cout<<"...reclassif as FP belonging to cortical sheet ";
                        LesionToCode->LesionType=CS;
                    }
                    cout<<endl;
                }
            }
            break;
            case 1115:{ // Quite close to the Out part but might be accepted nonetheless
                LesionToCode->LesionType=SCS2;
                if (LesionToCode->DistanceAcceptedGM<LesionToCode->DistanceOut && LesionToCode->ProportionWM>LesionToCode->ProportionCSF && LesionToCode->ProportionWM>0.25) {
                    cout<<"Suspicious cortical sheet lesion ";
                    LesionToCode->LesionType=SCS2;
                }
                else if(LesionToCode->ProportionCSF>LesionToCode->ProportionWM){
                    cout<<"Cortical sheet near out mask ";
                    LesionToCode->LesionType=CS;
                }
                else if(LesionToCode->ProportionOut>0){
                    cout<<" Certainly out ";
                    LesionToCode->LesionType=Out;
                }
            }
            break;
            case 1110:{ // Very probable cortical sheet close to out accepted only if WM proportion is high enough
                if (LesionToCode->ProportionWM>0.25) {
                    cout<<"Very suspicious lesion near cortical sheet ";
                    LesionToCode->LesionType=SCS;
                }
                else{
                    cout <<"Cortical sheet lesion near out ";
                    LesionToCode->LesionType=SCS2;
                }
            }
            break;
        default: {// All FP
            if (LesionToCode->ProportionWM>0.85 && LesionToCode->LesionCode<1000) {
                cout<<"Not considered but probably lesion WM ";
                LesionToCode->LesionType=SC2;
            }
            cout<<"Probably out ";
            LesionToCode->LesionType=Out;
        }
            break;
    }
}





// Modify the lesion structure in order to accomodate for the code. The code is given according to the Neighborhood criteria to the borders of the different tissues. NeighbourWMI if lesion close to border of WM inliers. GMC if close to border of combined GM and CSF, CSF if close to border of parenchyma where parenchyma contains both inlier and outlier
void LesionCodeImproved(Lesion * LesionToCode){
    LesionToCode->LesionCode=100*LesionToCode->NeighbourWMI+10*LesionToCode->NeighbourGMC+1*LesionToCode->NeighbourVentricle+5*((LesionToCode->ProportionCSF>0)-LesionToCode->NeighbourVentricle)+(LesionToCode->ProportionOut>0 && LesionToCode->NeighbourOut && !LesionToCode->NeighbourVentricle)*1000+(LesionToCode->DistanceOut<3 && !LesionToCode->NeighbourVentricle)*1000;
    switch (LesionToCode->LesionCode) {
            case 111:{ // Close to CSF of type 1
                LesionToCode->LesionType=PV;
                if(LesionToCode->DistanceVentricle==0 && LesionToCode->ProportionWM<LesionToCode->ProportionCSF){
                    LesionToCode->LesionType=IV;
                    cout<<"certainly inside ventricles"<<endl;
                }
                else if (LesionToCode->ProportionWM<0.1) {
                    cout<<"Possible reclassification as FP of lesion of type 1";
                    if(LesionToCode->DistanceVentricle>10 || LesionToCode->DistanceVentricle<0){
                        cout<<"Need to reclassify as FP";
                        LesionToCode->LesionType=Out;
                    }
                    else if(LesionToCode->DistanceCSF<LesionToCode->DistanceVentricle){
                        cout<<"Reclassification as FP probably CS";
                        LesionToCode->LesionType=CS;
                    }
                    else if (abs(LesionToCode->VectorDiffGrav[0])<=3) {
                        if (LesionToCode->VectorDiffGrav[2]<0) {
                            cout<<"Need to reclassify as 3 Ventricle flow ";
                            LesionToCode->LesionType=TV;
                        }
                    }
                    else if(LesionToCode->ProportionCSF>LesionToCode->ProportionGM){
                        cout<<"Reclassification as inside ventricle";
                        LesionToCode->LesionType=IV;
                    }
                    else if(LesionToCode->PropICSF>0.45){
                        cout<<"Reclassification as inside ventricle";
                        LesionToCode->LesionType=IV;
                    }
                    else if(LesionToCode->DistanceGrav<20){
                        cout<<"Within SP";
                        LesionToCode->LesionType=SP;
                    }
                    cout<<endl;
                }
                else if (LesionToCode->ProportionGM < 0.55 && LesionToCode->ProportionWM<0.55 ) {
                    cout <<"Possible need to reclassify as SP";
                    if (abs(LesionToCode->VectorDiffGrav[0])<4*LesionToCode->DistanceVentricle || abs(LesionToCode->VectorDiffGrav[0])<5){
                        if( LesionToCode->SPPotProp>0.3 && LesionToCode->DistanceGrav <30) {
                            cout<<"...change effective";
                            LesionToCode->LesionType=SP;
                        }
                        if (LesionToCode->SPPotProp>=0.5) {
                            cout<<"... change effective";
                            LesionToCode->LesionType=SP;
                        }
                        if(LesionToCode->DistanceGrav<15){
                            cout<<"... change effective";
                            LesionToCode->LesionType=SP;
                        }
                    }
                    if (abs(LesionToCode->VectorDiffGrav[0])<=5) {
                        if (LesionToCode->VectorDiffGrav[2]<0) {
                            cout<<"Need to reclassify as 3 Ventricle flow ";
                            LesionToCode->LesionType=TV;
                        }
                    }
                    else if(LesionToCode->PropICSF>0.45 && LesionToCode->ProportionCSF>LesionToCode->ProportionWM && LesionToCode->ProportionCSF>LesionToCode->ProportionGM){
                        cout<<"Reclassification as inside ventricle";
                        LesionToCode->LesionType=IV;
                    }
                }
                else if (LesionToCode->ProportionWM<LesionToCode->ProportionGM) {
                    if (abs(LesionToCode->VectorDiffGrav[0])<=6) {
                        if (LesionToCode->VectorDiffGrav[2]<0) {
                            cout<<"Need to reclassify as 3 Ventricle flow ";
                            LesionToCode->LesionType=TV;
                        }
                    }
                    if(abs(LesionToCode->VectorDiffGrav[0])<=4 && abs(LesionToCode->VectorDiffGrav[1])<=6 && abs(LesionToCode->VectorDiffGrav[2])<=6){
                        cout<<"Probably SP ";
                        LesionToCode->LesionType=SP;
                    }
                    if (LesionToCode->DistanceVentricle>LesionToCode->DistanceCSF) {
                        if(LesionToCode->VectorDiffGrav[2]<0){
                            cout<<"Probably in 4th ventricle";
                            LesionToCode->LesionType=FV;
                        }
                    }
                    if(LesionToCode->ProportionCSF>LesionToCode->ProportionWM && LesionToCode->PropICSF>0.45){
                        cout<<"Probably CP";
                        LesionToCode->LesionType=IV;
                    }
                    if (std::abs(LesionToCode->VectorDiffGrav[0])<3 && fabs(LesionToCode->ProportionCSF-LesionToCode->ProportionWM)<=0.03) {
                        cout<<"Certainly SP";
                        LesionToCode->LesionType=SP;
                    }
                    if (abs(LesionToCode->VectorDiffGrav[0])+abs(LesionToCode->VectorDiffGrav[1])<=5 && LesionToCode->SPPotProp>0.1) {
                        cout<<"In enlarged SP";
                        LesionToCode->LesionType=SP;
                    }
                    
                }
                else if(LesionToCode->ProportionWM<0.75){
                    if (abs(LesionToCode->VectorDiffGrav[0])+abs(LesionToCode->VectorDiffGrav[2])<=5 && LesionToCode->SPPotProp>0.25) {
                        cout<<"In enlarged SP";
                        LesionToCode->LesionType=SP;
                    }
                    if (abs(LesionToCode->VectorDiffGrav[0])+abs(LesionToCode->VectorDiffGrav[1])<=5 && LesionToCode->ProportionWM<LesionToCode->ProportionGM && LesionToCode->SPPotProp>0.1) {
                        cout<<"In enlarged SP";
                        LesionToCode->LesionType=SP;
                    }
                }
                
                
            }
            break;
            case 115 :{ // Close to ECSF, WM and GM but not to ventricle
                LesionToCode->LesionType=SC2;
                if (LesionToCode->ProportionWM<0.70) {
                    if(LesionToCode->DistanceAcceptedGM>3 && !LesionToCode->DGMBelonging){
                        cout<<"Probably artefacts either CS or Flow Ventricles";
                        LesionToCode->LesionType=CS;
                    }
                }
            }
            break;
            case 96:{ // Only near WM and CSF Ventricle
                cout<<"Near WM and ventricle only";
                LesionToCode->LesionType=PVNGM;
            }
            break;
            case 11:{ // Only close to ventricle and GM but not to WM
                if (LesionToCode->DistanceGrav<33) {
                    LesionToCode->LesionType=IV;
                    cout<<"Probably IV ";
                }
                else{
                    LesionToCode->LesionType=PVD;
                }
            }
            break;
            case 16:{
                cout<<"Probably CS";
                LesionToCode->LesionType=CS;
            }
            break;
            case 116:{ // Close at the same time to external CSF and Ventricles
                LesionToCode->LesionType=PV;
                if (LesionToCode->ProportionGM < 0.55 && LesionToCode->ProportionWM<0.55 && LesionToCode->DistanceGrav <30) {
                    cout <<" Need perhaps to reclassify as SP";
                    if (abs(LesionToCode->VectorDiffGrav[0])<4*LesionToCode->DistanceVentricle && LesionToCode->SPPotProp>0.5) {
                        cout<<"...changed effective";
                        LesionToCode->LesionType=SP;
                    }
                    
                }
            }
            case 101: // Close to CSF of type 2
            LesionToCode->LesionType=PVNGM;
            break;
            case 100:// Subcortical of Type 1 (only neighbour to WMI)
            LesionToCode->LesionType=SC1;
            break;
            case 106:{// Mostly close to WM and partly to CSF
                LesionToCode->LesionType=PVNGM;
                if(LesionToCode->ProportionCSF==0){
                    if (LesionToCode->ProportionWM>LesionToCode->ProportionGM) {
                        cout<<"no problem pure SC";
                        LesionToCode->LesionType=SC2;
                    }
                    else if (LesionToCode->DGMBelonging) {
                        cout<<"DGM Belonging no reclassification ";
                    }
                    else if(LesionToCode->ProportionCSF==0 && LesionToCode->DistanceVentricle<=LesionToCode->DistanceCSF && LesionToCode->DistanceVentricle<5){
                        cout<<"Close enough to ventricles not to be considered as belonging to cortical sheet ";
                        LesionToCode->LesionType=PV;
                    }
                    else if(LesionToCode->ProportionCSF==0 && LesionToCode->ProportionGM-LesionToCode->ProportionWM < 0.15){
                        cout<<"probably pure SC very close to CS";
                        LesionToCode->LesionType=SC2;
                    }
                    else if(LesionToCode->DistanceAcceptedGM==-1 || LesionToCode->DistanceAcceptedGM >LesionToCode->DistanceGM){
                        cout<<"...reclassif as FP belonging to cortical sheet ";
                        LesionToCode->LesionType=CS;
                    }
                    cout<<endl;
                }
            }
            break;
            case 110:{ // Subcortical of type 2
                LesionToCode->LesionType=SC2;
                if(LesionToCode->ProportionWM<LesionToCode->ProportionGM){
                    cout<<"Possible reclassification as FP of lesion of type 4 ";
                    if (LesionToCode->DGMBelonging) {
                        cout <<" DGM lesion probable : no reclassification ";
                    }
                    else if(LesionToCode->ProportionWM>0.15){
                        cout<<"suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    else if(LesionToCode->ProportionWM>0.1 && LesionToCode->DistanceCSF>2){
                        cout<<"extremely suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    else if(LesionToCode->ProportionWM>0.05 && LesionToCode->DistanceCSF>3){
                        cout<<"extremely suspicious CS accepted as lesion ";
                        LesionToCode->LesionType=SCS;
                    }
                    //                else if(LesionToCode->ProportionCSF==0){
                    //                    cout<<" more than extremely CS suspicious but still accepted as lesion ";
                    //                    LesionToCode->LesionType=SCS;
                    //                }
                    else if(LesionToCode->DistanceAcceptedGM==-1 || LesionToCode->DistanceAcceptedGM >LesionToCode->DistanceGM){
                        cout<<"...reclassif as FP belonging to cortical sheet ";
                        LesionToCode->LesionType=CS;
                    }
                    cout<<endl;
                }
            }
            break;
            case 1115:{ // Quite close to the Out part but might be accepted nonetheless
                LesionToCode->LesionType=SCS2;
                if (LesionToCode->DistanceAcceptedGM<LesionToCode->DistanceOut && LesionToCode->ProportionWM>LesionToCode->ProportionCSF && LesionToCode->ProportionWM>0.25) {
                    cout<<"Suspicious cortical sheet lesion ";
                    LesionToCode->LesionType=SCS2;
                }
                else if(LesionToCode->ProportionCSF>LesionToCode->ProportionWM){
                    cout<<"Cortical sheet near out mask ";
                    LesionToCode->LesionType=CS;
                }
                else if(LesionToCode->ProportionOut>0.05){
                    cout<<" Certainly out ";
                    LesionToCode->LesionType=Out;
                }
            }
            break;
            case 1110:{ // Very probable cortical sheet close to out accepted only if WM proportion is high enough
                if (LesionToCode->ProportionWM>0.25) {
                    cout<<"Very suspicious lesion near cortical sheet ";
                    LesionToCode->LesionType=SCS;
                }
                else{
                    cout <<"Cortical sheet lesion near out ";
                    LesionToCode->LesionType=SCS2;
                }
            }
            break;
        default: {// All FP
            if (LesionToCode->ProportionWM>0.85 && LesionToCode->LesionCode<1000) {
                cout<<"Not considered but probably lesion WM ";
                LesionToCode->LesionType=SC2;
            }
            cout<<"Probably out ";
            LesionToCode->LesionType=Out;
        }
            break;
    }
}

int * CreateInsideFromBorder(bool * PotentialRing,bool *Centre, float * DistCentre, int *Dim,int *Shift,float * PixDim,bool flag_plane){
    int numel = Dim[0]*Dim[2]*Dim[1];
    int * OutIn = TranscribeArray<bool,int>(PotentialRing,numel);
    deque<int> ListPot;
    for(int i=0;i<numel;i++){
        if(OutIn[i]==0){
            OutIn[i]=-1;
        }
        if (PotentialRing[i]){
            OutIn[i]=0;
            float DistMax= DistCentre[i];
            vector<int> ToExplore= GetIndicesToExploreFloatDist(i,PixDim[0]+0.1,Dim,Shift,PixDim,1);
            int numb_expl=ToExplore.size();
            for(int n=0;n<numb_expl;n++){
                if(OutIn[ToExplore[n]]<0){
                    if (DistCentre[ToExplore[n]]<DistMax){
                        OutIn[ToExplore[n]]=1;
                        vector<int> Bis = GetIndicesToExploreFloatDist(ToExplore[n],PixDim[0]+0.1,Dim,Shift,PixDim,1);
                        int numb_b=Bis.size();
                        for(int nb=0;nb<numb_b;nb++){
                            if(abs(OutIn[ToExplore[n]]-OutIn[Bis[nb]])>1){
                                ListPot.push_back(Bis[nb]);
                            }
                        }
                    }
                    else{
                        OutIn[ToExplore[n]]=-1;
                    }
                }
            }
        }
    }
    while(ListPot.size()>0){
        int i=ListPot[0];
        float DistMax= GetDistanceSegToPoint(i,Centre,Dim,Shift,PixDim);
        vector<int> ToExplore= GetIndicesToExploreFloatDist(i,PixDim[0]+0.1,Dim,Shift,PixDim,1);
        int numb_expl=ToExplore.size();
        for(int n=0;n<numb_expl;n++){
            if(OutIn[ToExplore[n]]<0){
                if (DistCentre[ToExplore[n]]<DistMax){
                    OutIn[ToExplore[n]]=1;
                    vector<int> Bis = GetIndicesToExploreFloatDist(ToExplore[n],PixDim[0]+0.1,Dim,Shift,PixDim,1);
                    int numb_b = Bis.size();
                    for(int nb=0;nb<numb_b;nb++){
                        if(abs(OutIn[ToExplore[n]]-OutIn[Bis[nb]])>1){
                            ListPot.push_back(Bis[nb]);
                        }
                    }
                }
            }
        }
         ListPot.pop_front();
    }
    return OutIn;
}



// Determine list of all indices under certain MaxDist as float taking into account size of voxels (not problem for non isotropic images)
vector<int> GetIndicesToExploreFloatDist(int CentralIndex, float MaxDist, int * Dim, int * Shift, float * PixDim,bool flag_plane=1){
    //    int * MaxTransDim=new int[3];
    int MaxTransDim[3];
    vector<int> ToExploreIndices;
    int CorrespondingCoord[3];
    CorrespondingCoordinates_bis(CorrespondingCoord, CentralIndex, Dim, Shift);
    //    int * CorrespondingCoord=CorrespondingCoordinates(CentralIndex, Dim, Shift);
    for (int d=0; d<3; d++) {
        MaxTransDim[d]=(int)floorf(MaxDist/PixDim[d]);
    }
//    cout<<"PixDim is "<<PixDim[0]<<" "<<PixDim[1]<<" "<< PixDim[2]<<endl;
    if(flag_plane==1){
        MaxTransDim[2]=0;
    }
    for (int x=-MaxTransDim[0]; x<=MaxTransDim[0]; x++) {
        for (int y=-MaxTransDim[1]; y<=MaxTransDim[1]; y++) {
            float distXY=sqrtf(x*x*PixDim[0]*PixDim[0]+y*y*PixDim[1]*PixDim[1]);
            if (distXY>MaxDist) {
                continue;
            }
            else{
                for (int z=-MaxTransDim[2]; z<=MaxTransDim[2]; z++) {
                    if (abs(x)+abs(y)+abs(z)>0) { // we do not consider the central index as one to explore.
                        float distXYZ=sqrtf(x*x*PixDim[0]*PixDim[0]+y*y*PixDim[1]*PixDim[1]+z*z*PixDim[2]*PixDim[2]);
                        if (distXYZ>MaxDist) {
                            continue;
                        }
                        else{
                            int IndexFinal=0;
                            //                            int * newIndex=new int[3];
                            int newIndex[3];
                            newIndex[0]=CorrespondingCoord[0]+x;
                            newIndex[1]=CorrespondingCoord[1]+y;
                            newIndex[2]=CorrespondingCoord[2]+z;
                            bool flag_valid=ValidityCoordinates(newIndex, Dim);
                            if (flag_valid) {
                                for (int d=0; d<3; d++) {
                                    IndexFinal+=newIndex[d]*Shift[d];
                                }
                                ToExploreIndices.push_back(IndexFinal);
                            }
                        }
                    }
                }
            }
        }
    }
    return ToExploreIndices;
}

// Given an index generally at the border of the lesion, the radius of exploration and the information about the dimension of the image, gives the list of the indices, that are not classified as lesion that are exactly situated at that radius (counted in terms of number of voxels and not of actual distance : beware in case of non isotropic images).
vector<int> GetIndicesToExplore(int BorderLesionIndex, int * OrderedLabels, int Radius, int * Dim){
    vector<int> VectorExploreIndices;
    
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    
    
    //    int * CorrespondingIndex=new int[3];
    int CorrespondingIndex[3];
    int tmp=BorderLesionIndex;
    for(int i=2;i>=0;i--){
        CorrespondingIndex[i]=(int)tmp/Shift[i];
        tmp-=CorrespondingIndex[i]*Shift[i];
    }
    for(int x=-Radius;x<=Radius;x++){
        for(int y=(Radius-abs(x))*-1;y<=Radius-abs(x);y++){
            for(int z=(Radius-abs(x)-abs(y))*-1;z<=Radius-abs(x)-abs(y);z++){
                //                int * newIndex=new int [3];
                int newIndex[3];
                newIndex[0]=CorrespondingIndex[0]+x;
                newIndex[1]=CorrespondingIndex[1]+y;
                newIndex[2]=CorrespondingIndex[2]+z;
                int NewIndexGen=newIndex[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2];
                // Check if the newIndexGen is compatible with the given dimensions
                bool outborder=0;
                for(int d=0;d<3;d++){
                    if(newIndex[d]<0 || newIndex[d]>Dim[d]-1){
                        outborder=1;
                    }
                }
                if(!outborder && OrderedLabels[NewIndexGen]==0){
                    VectorExploreIndices.push_back(NewIndexGen);
                }
                //                delete [] newIndex;
                //                newIndex=NULL;
            }
        }
    }
    //    delete []  CorrespondingIndex;
    //    CorrespondingIndex=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    return VectorExploreIndices;
}



// Given the lesion segmentation, the corresponding image structure (dim,shift and pixdim), and the border type looked at returns the calculation of the surface area.
float GetSurfaceImage(int * OrderedLabel, nifti_image * ImageRef, int Label, int BorderType){
    int numel=ImageRef->nx*ImageRef->ny*ImageRef->nz;
    int maxLabel=GetMaxLabel(OrderedLabel, numel);
    if(Label <1 || Label > maxLabel){
        cout<<"Inconsistency in Label checking for surface"<<endl;
        return -1;
    }
    int Inside=-1;
    int Outside=-1;
    //    int * Dim=new int[3];
    int Dim[3];
    //    float * Face=new float[3];
    float Face[3];
    for(int d=0;d<3;d++){
        Dim[d]=ImageRef->dim[d+1];
        int qd1=(d+1)/3;
        int qd2=(d+2)/3;
        Face[d]=ImageRef->pixdim[d+1-qd1*3+1]*ImageRef->pixdim[d+2-qd2*3+1];
    }
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    
    switch (BorderType){
            case 1 : {// Corresponding to the inner border case
                Inside=Label;
                Outside=0;
            }
            break;
            case -1 : {// Corresponding to the outer border case
                Inside=0;
                Outside=Label;
            }
            break;
        default:{// Corresponding to the inner border case
            Inside=Label;
            Outside=0;
        }
            break;
    }
    
    //    int * CountFaces=new int[3];
    int CountFaces[3];
    for(int i=0;i<3;i++){
        CountFaces[i]=0;
    }
    for(int i=0;i<numel;i++){
        if(OrderedLabel[i]==Inside){
            //            int * FaceNeighbours=Get6Neighbours(i,Dim,Shift);
            int FaceNeighbours[6];
            GetListNeighbours_bis(FaceNeighbours, i, Dim, Shift, 6);
            //            int * FaceNeighbours=GetListNeighbours(i, Dim, Shift, 6);
            
            for(int n=0;n<6;n++){
                //                cout<<" "<<FaceNeighbours[n]<<" "<<OrderedLabel[FaceNeighbours[n]];
                if(OrderedLabel[FaceNeighbours[n]]==Outside){
                    //cout<<"bb ";
                    CountFaces[n/2]++;
                }
            }
        }
    }
    
    float SurfaceResult=0;
    for(int d=0;d<3;d++){
        SurfaceResult+=CountFaces[d]*Face[d];
    }
    
    return SurfaceResult;
}







// Given the lesion segmentation, the tree structure and the border type looked at returns the calculation of the surface area. Here the tree structure is only used to get the pixels dimensions in order to calculate the area of the faces
float GetSurface(int * OrderedLabel, TreeEM * TreeToAnalyse, int Label, int BorderType){
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabel, numel);
    if(Label <1 || Label > maxLabel){
        cout<<"Inconsistency in Label checking for surface"<<endl;
        return -1;
    }
    int Inside=-1;
    int Outside=-1;
    //    int * Dim=new int[3];
    int Dim[3];
    //    float * Face=new float[3];
    float Face[3];
    for(int d=0;d<3;d++){
        Dim[d]=TreeToAnalyse->GetDataImage()->dim[d+1];
        int qd1=(d+1)/3;
        int qd2=(d+2)/3;
        Face[d]=TreeToAnalyse->GetDataImage()->pixdim[d+1-qd1*3+1]*TreeToAnalyse->GetDataImage()->pixdim[d+2-qd2*3+1];
    }
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    
    switch (BorderType){
            case 1 : {// Corresponding to the inner border case
                Inside=Label;
                Outside=0;
            }
            break;
            case -1 : {// Corresponding to the outer border case
                Inside=0;
                Outside=Label;
            }
            break;
        default:{// Corresponding to the inner border case
            Inside=Label;
            Outside=0;
        }
            break;
    }
    
    //    int * CountFaces=new int[3];
    int CountFaces[3];
    for(int i=0;i<3;i++){
        CountFaces[i]=0;
    }
    for(int i=0;i<numel;i++){
        if(OrderedLabel[i]==Inside){
            //            int * FaceNeighbours=Get6Neighbours(i,Dim,Shift);
            int FaceNeighbours[6];
            GetListNeighbours_bis(FaceNeighbours, i, Dim, Shift, 6);
            //            int * FaceNeighbours=GetListNeighbours(i, Dim, Shift, 6);
            
            for(int n=0;n<6;n++){
                //                cout<<" "<<FaceNeighbours[n]<<" "<<OrderedLabel[FaceNeighbours[n]];
                if(OrderedLabel[FaceNeighbours[n]]==Outside){
                    //cout<<"bb ";
                    CountFaces[n/2]++;
                }
            }
            //            delete [] FaceNeighbours;
            //            FaceNeighbours=NULL;
            // cout<<endl;
        }
    }
    
    float SurfaceResult=0;
    for(int d=0;d<3;d++){
        SurfaceResult+=CountFaces[d]*Face[d];
    }
    
    //    delete [] CountFaces;
    //    CountFaces=NULL;
    //    delete [] Face;
    //    Face=NULL;
    //    delete [] Dim;
    //    Dim=NULL;
    
    return SurfaceResult;
}




// return the new lesion probabilistic map after refinement of too small lesions and correction for FP
nifti_image * CorrectionLesionFromClassif(nifti_image * ImageLesionClassif,nifti_image * SegToAnalyse){
    // First checking that new image can be output
    if(SegToAnalyse==NULL){
        return NULL;
    }
    if (ImageLesionClassif==NULL) {
        return CopyFloatNii(SegToAnalyse);
    }
    if (!(ImageLesionClassif->nx==SegToAnalyse->nx)*(ImageLesionClassif->ny==SegToAnalyse->ny)*(ImageLesionClassif->nz==SegToAnalyse->nz)) {
        cout<<"Incompatible dimensions "<<endl;
        return NULL;
    }
    nifti_image * ImageLesionCorr=nifti_copy_nim_info(SegToAnalyse);
    ImageLesionCorr->data=(void *)calloc(ImageLesionCorr->nvox, sizeof(float));
    float * ImageLesionCorr_PTR=static_cast<float*>(ImageLesionCorr->data);
    float * SegToAnalyse_PTR=static_cast<float*>(SegToAnalyse->data);
    float * ImageLesionClassif_PTR=static_cast<float *>(ImageLesionClassif->data);
    
    int numel = ImageLesionClassif->nvox;
    for (int i=0; i<numel; i++) {
        if (ImageLesionClassif_PTR[i]>0.5) {
            ImageLesionCorr_PTR[i]=SegToAnalyse_PTR[i];
        }
        else if (ImageLesionClassif_PTR[i]<-19){
            cout<<"Correction Non Contrast"<<endl;
           ImageLesionCorr_PTR[i]=SegToAnalyse_PTR[i]>0.99?1:0;
        }
        else {
            ImageLesionCorr_PTR[i]=0;
        }
    }
    return ImageLesionCorr;
}


// Average image intensities from vector
nifti_image * MakeMeanFromVectorImages(vector<nifti_image *> VectorImagesToMean,bool * Mask){
    //    First check that there is compatibility of images within vector
    if(! CheckCompatibilityVectorNii(VectorImagesToMean)){
        cout<<"Impossible to do average on incompatible vector"<<endl;
        return NULL;
    }
    //    Initialise result image if not NULL means that the vector is at least of size 1
    nifti_image * ResultMean=nifti_copy_nim_info(VectorImagesToMean[0]);
    ResultMean->data=(void *)calloc(ResultMean->nvox,sizeof(float));
    float * ResultMeanData=static_cast<float *>(ResultMean->data);
    int numelTot=ResultMean->nvox;
    int numel=ResultMean->nx*ResultMean->ny*ResultMean->nz;
    int numbmodal=ResultMean->nvox/numel;
    int numbimages=VectorImagesToMean.size();
    for(int i=0;i<numelTot;i++){
        ResultMeanData[i]=0;
    }
    int Dim[3];
    Dim[0]=ResultMean->dim[1];
    Dim[1]=ResultMean->dim[2];
    Dim[2]=ResultMean->dim[3];
    int * L2S=MakeL2S(Mask, Dim);
    vector<float *> VectorData;
    for(int n=0;n<numbimages;n++){
        if(VectorImagesToMean[n]!=NULL){
            VectorData.push_back(static_cast<float * >(VectorImagesToMean[n]->data));
        }
    }
    numbimages=VectorData.size(); // In case one of the image in the vector is NULL. Everything NULL should be treated in the CheckforCompatibility
    
    //     Adding the relevant information
    
    for(int i=0;i<numel;i++){
        if(L2S[i]>=0){
            for(int m=0;m<numbmodal;m++){
                for(int n=0;n<numbimages;n++){
                    ResultMeanData[i+m*numel]+=VectorData[n][i+m*numel];
                }
            }
        }
    }
    
    for(int i=0;i<numelTot;i++){
        ResultMeanData[i]/=numbimages;
    }
    
    //    Dividing by numbimages
    delete [] L2S;
    L2S=NULL;
    return ResultMean;
    
}


// Copy and returns a float nii image
nifti_image * CopyFloatNii(nifti_image * FloatNiiToCopy){
    if (FloatNiiToCopy==NULL || FloatNiiToCopy->nbyper!=4) {
        return NULL;
    }
    nifti_image * CopiedImage=nifti_copy_nim_info(FloatNiiToCopy);
    CopiedImage->data=(void *)calloc(CopiedImage->nvox, sizeof(float));
    float * CopiedImage_PTR=static_cast<float *>(CopiedImage->data);
    float * FloatNiiToCopy_PTR=static_cast<float *>(FloatNiiToCopy->data);
    int numel=CopiedImage->nvox;
    for (int i=0; i<numel; i++,CopiedImage_PTR++,FloatNiiToCopy_PTR++) {
        *CopiedImage_PTR=*FloatNiiToCopy_PTR;
    }
    //    nifti_set_filenames(CopiedImage, "/Users/Carole/Documents/PhD/MICCAI_MS/TempResults/TestStrangeCopy.nii.gz", 0, 0);
    //    nifti_set_filenames(FloatNiiToCopy, "/Users/Carole/Documents/PhD/MICCAI_MS/TempResults/TestStrangeCopy-init.nii.gz", 0, 0);
    //    nifti_image_write(CopiedImage);
    //    nifti_image_write(FloatNiiToCopy);
    return CopiedImage;
}

float * NormDistWithinLesionRidge(bool * Lesion, bool * Ridge,int numel, vector<int> DimVector, int* Dim, int* Shift, float* PixDim){


        float * TmpOut=TranscribeArray<bool, float>(Lesion, numel);
        float * DilatedOut=Erosion_bis(TmpOut, 3, DimVector, 0);
        delete [] TmpOut;

        TmpOut=NULL;
        bool * MaskDilOut=TranscribeArray<float, bool>(DilatedOut, numel);
        int * L2S_Out=MakeL2S(Lesion, Dim);
        int numelmaskedLapOut=0;
        int * S2L_Out=MakeS2L(Lesion, Dim, numelmaskedLapOut);
            int * LabelLaplace=CreateLaplaceLabelling(Ridge,Lesion,Dim);
 //                            SaveTmpResult(LabelLaplace, "/Users/Carole/Documents/PhD/MS_Laplace/TempLook/TestLabel.nii.gz", InImage);
            int numelmaskedbOut=0;
            int * L2SbOut=MakeL2S(MaskDilOut, Dim);
            int * S2LbOut=MakeS2L(MaskDilOut, Dim, numelmaskedbOut);
            if (MaskDilOut!=NULL) {
                delete [] MaskDilOut;
                MaskDilOut=NULL;
            }
            int * Label_s=CreateShort(LabelLaplace, S2LbOut, numelmaskedbOut);
            cout<<GetMax<int>(Label_s, numelmaskedbOut)<<endl;
            //            SaveTmpResult_short(Label_sPar, "/Users/Carole/Documents/PhD/SABRE_80/TempLook/187549I/TestLabelB.nii.gz", WMDGMSeg, L2SbPar);
            if (LabelLaplace!=NULL) {
                delete [] LabelLaplace;
                LabelLaplace=NULL;
            }
             nifti_image * InImage=NULL;

            float * LaplaceSol_short=SolvingLaplaceEquation(Label_s, Dim, Shift, PixDim, 5, L2SbOut, S2LbOut, numelmaskedbOut,InImage);
            float * LaplaceSol=CreateLong(LaplaceSol_short,L2SbOut,numel);

            bool * In_short=CreateShort(Ridge, S2L_Out, numelmaskedLapOut);
            bool * Out_short=CreateShort(Lesion, S2L_Out, numelmaskedLapOut);

            float * LaplaceSol_s=CreateShort(LaplaceSol, S2L_Out, numelmaskedLapOut);
            float * DistanceNormalisedLaplace_s=NormalisedLaplaceLength(LaplaceSol_s, In_short, Out_short, L2S_Out, S2L_Out, numelmaskedLapOut, PixDim, Dim, Shift,InImage);
            float * DistanceNormalisedLaplace=CreateLong(DistanceNormalisedLaplace_s,L2S_Out,numel);
            delete In_short;
            delete [] Out_short;
            delete [] LaplaceSol;
            delete [] LaplaceSol_short;
            delete [] L2S_Out;
            delete [] S2L_Out;
            delete [] L2SbOut;
            delete [] S2LbOut;
            delete [] DilatedOut;
            return DistanceNormalisedLaplace;
}

float * NormDistWithinLesion(bool * Lesion,int numel,vector<int> DimVector,int* Dim,int* Shift,float* PixDim,int dilationNumber,bool * maxMask,nifti_image* BasisImage){
   int CoG= GetCenterGravity(Lesion,Dim);
   if (Lesion[CoG]){
       cout << "easy lesion inside"<<endl;
       bool * InBool=new bool[numel];
       for (int i=0; i<numel; i++) {
           InBool[i]=0;
       }
       InBool[CoG]=1;

       float * TmpOut=TranscribeArray<bool, float>(maxMask, numel);
       cout << dilationNumber << endl;
//       float * ToUse=Erosion_bis(TmpOut,2*dilationNumber+1,DimVector,0);
//       bool * ToUseBool=TranscribeArray<float,bool>(ToUse,numel);
//       ANDOperationBool(ToUseBool,maxMask,ToUseBool,numel);
//       delete [] ToUse;
//       ToUse=NULL;
//       ToUse=TranscribeArray<bool,float>(ToUseBool,numel);
       float * DilatedOut=Erosion_bis(TmpOut, 3, DimVector, 0);
       delete [] TmpOut;

       TmpOut=NULL;
       bool * MaskDilOut=TranscribeArray<float, bool>(DilatedOut, numel);
       int * L2S_Out=MakeL2S(maxMask, Dim);
       int numelmaskedLapOut=0;
       int * S2L_Out=MakeS2L(maxMask, Dim, numelmaskedLapOut);
           int * LabelLaplace=CreateLaplaceLabelling(InBool,maxMask,Dim);
//                            SaveTmpResult(LabelLaplace, "/Users/Carole/Documents/PhD/MS_Laplace/TempLook/TestLabel.nii.gz", InImage);
           int numelmaskedbOut=0;
           int * L2SbOut=MakeL2S(MaskDilOut, Dim);
           int * S2LbOut=MakeS2L(MaskDilOut, Dim, numelmaskedbOut);
           if (MaskDilOut!=NULL) {
               delete [] MaskDilOut;
               MaskDilOut=NULL;
           }
           int * Label_s=CreateShort(LabelLaplace, S2LbOut, numelmaskedbOut);
           cout<<GetMax<int>(Label_s, numelmaskedbOut)<<endl;
           //            SaveTmpResult_short(Label_sPar, "/Users/Carole/Documents/PhD/SABRE_80/TempLook/187549I/TestLabelB.nii.gz", WMDGMSeg, L2SbPar);
           if (LabelLaplace!=NULL) {
               delete [] LabelLaplace;
               LabelLaplace=NULL;
           }
            nifti_image * InImage=NULL;

           float * LaplaceSol_short=SolvingLaplaceEquation(Label_s, Dim, Shift, PixDim, 5, L2SbOut, S2LbOut, numelmaskedbOut,InImage);
           float * LaplaceSol=CreateLong(LaplaceSol_short,L2SbOut,numel);

           bool * In_short=CreateShort(InBool, S2L_Out, numelmaskedLapOut);
           bool * Out_short=CreateShort(Lesion, S2L_Out, numelmaskedLapOut);

           float * LaplaceSol_s=CreateShort(LaplaceSol, S2L_Out, numelmaskedLapOut);
           float * DistanceNormalisedLaplace_s=NormalisedLaplaceLength(LaplaceSol_s, In_short, Out_short, L2S_Out, S2L_Out, numelmaskedLapOut, PixDim, Dim, Shift,InImage);
           float * DistanceNormalisedLaplace=CreateLong(DistanceNormalisedLaplace_s,L2S_Out,numel);
           delete In_short;
           delete [] Out_short;
           delete [] LaplaceSol;
           delete [] LaplaceSol_short;
           delete [] L2S_Out;
           delete [] S2L_Out;
           delete [] L2SbOut;
           delete [] S2LbOut;
           delete [] DilatedOut;
//           delete [] ToUse;
//           ToUse=NULL;
//           delete [] ToUseBool;
//           ToUseBool=NULL;
           return DistanceNormalisedLaplace;

   }
   else{
       // Need to first try to erode by one voxel the lesion. If more than one component, for each component, dilate by one, intersect with initial one, recursive run with lesion
        float * TmpOut=TranscribeArray<bool, float>(Lesion, numel);
        float * Eroded=Erosion_bis(TmpOut,3,DimVector,1);
        dilationNumber++;
        int * ConnectedLabel=ComponentLabeling(Eroded,6,Dim,Shift);
        int * OrderedLabel=OrderedVolumeLabel(ConnectedLabel,1,numel,1);
        int maxLabel=GetMaxLabel(OrderedLabel,numel);
        if(maxLabel==0){
            // Means that all elements are part of border
            int * LesionInt = TranscribeArray<bool, int>(Lesion, numel);
            vector<int> ListIndices=GetListIndicesLabel(LesionInt,Dim,1);
            float DistanceMin=1000;
            int ind_min = -1;
            int sLI=ListIndices.size();
            for(int ind=0;ind<sLI;ind++){
                float DistanceTemp=GetDistanceBetweenPoints(CoG,ListIndices[ind],Dim,PixDim);
                if (DistanceTemp<DistanceMin){
                    DistanceMin=DistanceTemp;
                    ind_min = ListIndices[ind];
                }
            }

            float * DistInside=NormDistInside(ind_min, Lesion, numel, maxMask,  DimVector, Dim,  Shift,  PixDim);
            delete [] ConnectedLabel;
            delete [] OrderedLabel;
            delete [] Eroded;
            delete [] LesionInt;
            delete [] TmpOut;
            return DistInside;

        }
//        nifti_image * LabelsFromErosion=CreateNiiFromArray(OrderedLabel,BasisImage,numel);
        SaveTmpResult(OrderedLabel,"/Users/csudre/Downloads/carole_example/TestEroded.nii.gz",BasisImage);
        vector<float*>VectorDistance;
        for(int l=0;l<maxLabel;l++){
            bool * LesionBool=CreateLesionBool(OrderedLabel,l+1,numel);
            float * DistanceMap=NormDistWithinLesion(LesionBool,numel,DimVector,Dim,Shift,PixDim,dilationNumber,maxMask,BasisImage);
            VectorDistance.push_back(DistanceMap);
            cout << "Comp vol "<< CountNonZero(LesionBool,numel)<<" "<<CountNonZero(DistanceMap,numel)<<" "<<CountNonZero(maxMask,numel)<<" "<<dilationNumber<<endl;
        }
        float * FinDistance=GetMinElementwise<float,bool>(VectorDistance,maxMask,numel);
        cout << "Compvol2"<<CountNonZero(FinDistance,numel)<<" "<<CountNonZero(maxMask,numel)<<endl;
        int Fsize=VectorDistance.size();
        for(int s=0;s<Fsize;s++){
            if(VectorDistance[s]!=NULL){
                delete [] VectorDistance[s];
                VectorDistance[s]=NULL;
            }
        }
        return FinDistance;
   }
}


// Create Norm dist when value inside
float * NormDistInside(int CoG,bool * Lesion, int numel, bool*maxMask, vector<int> DimVector, int* Dim, int* Shift, float* PixDim){
    bool * InBool=new bool[numel];
    for (int i=0; i<numel; i++) {
        InBool[i]=0;
    }
    InBool[CoG]=1;

    float * TmpOut=TranscribeArray<bool, float>(maxMask, numel);
//       float * ToUse=Erosion_bis(TmpOut,2*dilationNumber+1,DimVector,0);
//       bool * ToUseBool=TranscribeArray<float,bool>(ToUse,numel);
//       ANDOperationBool(ToUseBool,maxMask,ToUseBool,numel);
//       delete [] ToUse;
//       ToUse=NULL;
//       ToUse=TranscribeArray<bool,float>(ToUseBool,numel);
    float * DilatedOut=Erosion_bis(TmpOut, 3, DimVector, 0);
    delete [] TmpOut;

    TmpOut=NULL;
    bool * MaskDilOut=TranscribeArray<float, bool>(DilatedOut, numel);
    int * L2S_Out=MakeL2S(maxMask, Dim);
    int numelmaskedLapOut=0;
    int * S2L_Out=MakeS2L(maxMask, Dim, numelmaskedLapOut);
        int * LabelLaplace=CreateLaplaceLabelling(InBool,maxMask,Dim);
//                            SaveTmpResult(LabelLaplace, "/Users/Carole/Documents/PhD/MS_Laplace/TempLook/TestLabel.nii.gz", InImage);
        int numelmaskedbOut=0;
        int * L2SbOut=MakeL2S(MaskDilOut, Dim);
        int * S2LbOut=MakeS2L(MaskDilOut, Dim, numelmaskedbOut);
        if (MaskDilOut!=NULL) {
            delete [] MaskDilOut;
            MaskDilOut=NULL;
        }
        int * Label_s=CreateShort(LabelLaplace, S2LbOut, numelmaskedbOut);
        cout<<GetMax<int>(Label_s, numelmaskedbOut)<<endl;
        //            SaveTmpResult_short(Label_sPar, "/Users/Carole/Documents/PhD/SABRE_80/TempLook/187549I/TestLabelB.nii.gz", WMDGMSeg, L2SbPar);
        if (LabelLaplace!=NULL) {
            delete [] LabelLaplace;
            LabelLaplace=NULL;
        }
         nifti_image * InImage=NULL;

        float * LaplaceSol_short=SolvingLaplaceEquation(Label_s, Dim, Shift, PixDim, 5, L2SbOut, S2LbOut, numelmaskedbOut,InImage);
        float * LaplaceSol=CreateLong(LaplaceSol_short,L2SbOut,numel);

        bool * In_short=CreateShort(InBool, S2L_Out, numelmaskedLapOut);
        bool * Out_short=CreateShort(Lesion, S2L_Out, numelmaskedLapOut);

        float * LaplaceSol_s=CreateShort(LaplaceSol, S2L_Out, numelmaskedLapOut);
        float * DistanceNormalisedLaplace_s=NormalisedLaplaceLength(LaplaceSol_s, In_short, Out_short, L2S_Out, S2L_Out, numelmaskedLapOut, PixDim, Dim, Shift,InImage);
        float * DistanceNormalisedLaplace=CreateLong(DistanceNormalisedLaplace_s,L2S_Out,numel);
        delete In_short;
        delete [] Out_short;
        delete [] LaplaceSol;
        delete [] LaplaceSol_short;
        delete [] L2S_Out;
        delete [] S2L_Out;
        delete [] L2SbOut;
        delete [] S2LbOut;
        delete [] DilatedOut;
//           delete [] ToUse;
//           ToUse=NULL;
//           delete [] ToUseBool;
//           ToUseBool=NULL;
        return DistanceNormalisedLaplace;
}

float * EdginessBorderLesion(bool * LesionBool, float * Data, int* Dim,int*Shift, float*PixDim,int numel,int numbmodal ){
    bool * BorderLesion=CreateBorderFromBool(LesionBool,Dim,Shift);
//    float * Data=static_cast<float*>(DataNii->data);
    int ListNeighbour[6];
//    cout << numbmodal <<" "<< CountNonZero(BorderLesion,numel)<< " "<<numel<< endl;
    int allocation=numel*(numbmodal+1);
    float * EdginessBorderResult=new float[allocation];
//    cout << "Initiated "<< endl;
    for (int i=0;i<numel;i++){
//        cout << "Treating voxel "<<i<<endl;
        EdginessBorderResult[i]=0;
        if(BorderLesion[i]){
//            cout << "Treating voxel "<< i<<endl;
            float Value=0;
            int Numb=0;
            GetListNeighbours_bis(ListNeighbour,i,Dim,Shift,6);
            for(int n=0;n<6;n++){
                if(!LesionBool[ListNeighbour[n]]){
                    Numb++;
                    float Dist=GetDistanceBetweenPoints(i,ListNeighbour[n],Dim,PixDim);
                    for (int m=0;m<numbmodal;m++){
                        EdginessBorderResult[(m+1)*numel+i]=fabs(Data[m*numel+i]-Data[m*numel+ListNeighbour[n]])/Dist;
                        Value+=EdginessBorderResult[(m+1)*numel+i];
                    }

                }
                EdginessBorderResult[i]=Value/Numb;
                for(int m=0;m<numbmodal;m++){
                    EdginessBorderResult[(m+1)*numel+i]/=Numb;
                }

            }
    }
    }
    delete[] BorderLesion;
    return EdginessBorderResult;
}

float * CreateRidge(float * DistData, int numel, int *Dim, int*Shift, float*PixDim, int omitted_dir){
    int * L2S=new int[numel];
    int * S2L=new int[numel];
    float * PotRidge= new float[numel];
    for(int i=0;i<numel;i++){
        L2S[i]=i;
        S2L[i]=i;
        PotRidge[i]=0;
    }
    vector<float*>VecGrad;
    for(int d=0;d<3;d++){
        if (d!=omitted_dir){
            float * GradDistXa=GradientImage(DistData,d,1,Dim,Shift,PixDim,L2S,S2L,numel);
            float * GradDistXb=GradientImage(DistData,d,-1,Dim,Shift,PixDim,L2S,S2L,numel);
            float * GradDistXc=GradientImage(DistData,d,0,Dim,Shift,PixDim,L2S,S2L,numel);
            float * SubGrad = SubtractArray(GradDistXa,GradDistXb,numel);
            float * SignGrad = Sign(SubGrad,numel);
            VecGrad.push_back(GradDistXa);
            VecGrad.push_back(GradDistXb);
            float * AGradDistXa = Absolute(GradDistXa,numel);
            float * AGradDistXb = Absolute(GradDistXb,numel);
            float * AGradDistXc = Absolute(GradDistXc,numel);
            for (int i=0;i<numel;i++){
                if(AGradDistXa[i]+AGradDistXb[i]>AGradDistXc[i]+0.00001){
                    PotRidge[i]= SignGrad[i] * (AGradDistXa[i]+AGradDistXb[i]);
                }
            }
            delete AGradDistXa;
            delete [] AGradDistXb;
            delete [] AGradDistXc;
            delete[] SignGrad;
        }
    }

    float * GradDistXYpp = AddElementwise(VecGrad[0], VecGrad[2],numel);
    float * GradDistXYmm = AddElementwise(VecGrad[1], VecGrad[3],numel);
    float * GradDistXYpm = AddElementwise(VecGrad[0], VecGrad[3],numel);
    float * GradDistXYmp = AddElementwise(VecGrad[1], VecGrad[2],numel);
    float * GradDistXYpmmp = SubtractArray(GradDistXYpm, GradDistXYmp,numel);
    float * GradDistXYppmm = SubtractArray(GradDistXYpp, GradDistXYmm,numel);

    float * AGradDistXYpp = Absolute(GradDistXYpp,numel);
    float * AGradDistXYmm = Absolute(GradDistXYmm,numel);
    float * AGradDistXYpm = Absolute(GradDistXYpm,numel);
    float * AGradDistXYmp = Absolute(GradDistXYmp,numel);
    float * AGradDistXYpmmp = Absolute(GradDistXYpmmp,numel);
    float * AGradDistXYppmm = Absolute(GradDistXYppmm,numel);

    float * SignXYpp = Sign(GradDistXYppmm,numel);
    float * SignXYpm = Sign(GradDistXYpmmp,numel);
    for(int i=0;i<numel;i++){
        if(AGradDistXYmm[i]+AGradDistXYpp[i]>AGradDistXYppmm[i]+0.0001){
            PotRidge[i]+=SignXYpp[i]*(AGradDistXYmm[i]+AGradDistXYpp[i]);
        }
        if(AGradDistXYpm[i]+AGradDistXYmp[i]>AGradDistXYpmmp[i]+0.0001){
            PotRidge[i]+=SignXYpm[i]*(AGradDistXYpm[i]+AGradDistXYmp[i]);
        }
    }
    for (int i=0;i<VecGrad.size();i++){
        if (VecGrad[i]!=NULL){
        delete [] VecGrad[i];
        }
    }
    delete [] SignXYpp;
    delete [] SignXYpm;
    delete [] AGradDistXYpp;
    delete [] AGradDistXYpm;
    delete [] AGradDistXYpmmp;
    delete [] AGradDistXYppmm;
    delete [] GradDistXYppmm;
    delete [] GradDistXYpmmp;
    delete [] GradDistXYpm;
    delete [] GradDistXYmp;
    delete [] GradDistXYpp;
    delete [] GradDistXYmm;

    return PotRidge;
}

float * ExtractionSkeletonBis(bool * LesionBool, int numel, int* Dim, int* Shift, float* PixDim,nifti_image * BasisImage){
    bool * BorderLesion=CreateBorderFromBool(LesionBool,Dim,Shift);
    int numbNZ=0;
    int * L2S=MakeL2S(LesionBool,Dim);
    int * S2L=MakeS2L(LesionBool,Dim,numbNZ);
    nifti_image * MaskLesion=CreateNiiFromArray(LesionBool,BasisImage,numel);
    nifti_image * DistanceMap=EuclideanDistanceImage(BasisImage,BorderLesion,MaskLesion);
    if(DistanceMap==NULL){
        return NULL;
    }
    float * DistData=CreateShort(static_cast<float*>(DistanceMap->data),S2L,numbNZ);
    float * GradDistX=GradientImage(DistData,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradDistXb=GradientImage(DistData,0,-1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    SaveTmpResult_short(GradDistX,"/Users/csudre/Downloads/carole_example/GradDistX.nii.gz",BasisImage,L2S);
    SaveTmpResult_short(DistData,"/Users/csudre/Downloads/carole_example/DistanceMap.nii.gz",BasisImage,L2S);
    float * GradDistY=GradientImage(DistData,1,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradDistYb=GradientImage(DistData,1,-1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradDistZ=GradientImage(DistData,2,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradDistZb=GradientImage(DistData,2,-1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    nifti_image_free(DistanceMap);
    nifti_image_free(MaskLesion);
    float * SignX=Sign(GradDistX,numbNZ);
    float * SignXb=Sign(GradDistXb,numbNZ);
    vector<float*> SignXVec;
    SignXVec.push_back(SignX);
    SignXVec.push_back(SignXb);
    float * SumSignX=AddElementwise(SignXVec,numbNZ);
    float * SignY=Sign(GradDistY,numbNZ);
    float * SignYb=Sign(GradDistYb,numbNZ);
    vector<float*> SignYVec;
    SignYVec.push_back(SignY);
    SignYVec.push_back(SignYb);
    float * SumSignY=AddElementwise(SignYVec,numbNZ);
    float * SignZ=Sign(GradDistZ,numbNZ);
    float * SignZb=Sign(GradDistZb,numbNZ);
    vector<float*> SignZVec;
    SignZVec.push_back(SignZ);
    SignZVec.push_back(SignZb);
    float * SumSignZ=AddElementwise(SignZVec,numbNZ);
    SaveTmpResult_short(SumSignX,"/Users/csudre/Downloads/carole_example/SumGradDist.nii.gz",BasisImage,L2S);
    SaveTmpResult_short(SumSignY,"/Users/csudre/Downloads/carole_example/SumGradDistY.nii.gz",BasisImage,L2S);
    SaveTmpResult_short(SumSignZ,"/Users/csudre/Downloads/carole_example/SumGradDistZ.nii.gz",BasisImage,L2S);
    AbsoluteInPlace(SumSignX,numbNZ);
    AbsoluteInPlace(SumSignY,numbNZ);
    AbsoluteInPlace(SumSignZ,numbNZ);


    cout << "CountNonZero X is "<<CountNonZero(SignX,numbNZ)<<endl;
    float * SignX_long=CreateLong(SumSignX,L2S,numel);
    float * SignY_long=CreateLong(SumSignY,L2S,numel);
    float * SignZ_long=CreateLong(SumSignZ,L2S,numel);
    vector<float*> VecSign;
    VecSign.push_back(SignX_long);
    VecSign.push_back(SignY_long);
//    VecSign.push_back(SignZ_long);
    float * FinalMul=AddElementwise(VecSign,numel,LesionBool);
    AddConstantInPlace<float>(FinalMul,1,numel);
    bool * FinalBool = UpperThresholdArray<float,bool>(FinalMul,1.2,numel);
//    bool * FinalMulFin = OpposeBoolArray(FinalBool,numel);
    SaveTmpResult(FinalMul,"/Users/csudre/Downloads/carole_example/Attempt.nii.gz",BasisImage);

    ANDOperationBool(FinalBool,LesionBool,FinalBool,numel);
    SaveTmpResult(FinalBool,"/Users/csudre/Downloads/carole_example/Attempt.nii.gz",BasisImage);

    float * GradSignX=GradientImage(SignX,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradSignY=GradientImage(SignY,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradSignZ=GradientImage(SignZ,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradSignX_long=CreateLong(GradSignX,L2S,numel);
    float * GradSignY_long=CreateLong(GradSignY,L2S,numel);
    float * GradSignZ_long=CreateLong(GradSignZ,L2S,numel);
    vector<float*> VecGradSign;
    VecGradSign.push_back(GradSignX_long);
    VecGradSign.push_back(GradSignY_long);
    VecGradSign.push_back(GradSignZ_long);
    SaveTmpResult(VecGradSign,"/Users/csudre/Downloads/carole_example/TestSign.nii.gz",BasisImage);

//    float * FinalMul=MultiplyElementwise(VecGradSign,numel,LesionBool);
//    float * FinalMulFin=MultiplyElementwiseChoose<float,bool,float>(FinalMul,LesionBool,numel);
//    for(int i=0;i<numel;i++){
//        if(BorderLesion[i]){
//            FinalMulFin[i]=0;
//        }
//    }
    delete [] SignX;
    delete [] SignY;
    delete [] SignZ;
    delete [] GradSignX;
    delete [] GradSignY;
    delete [] GradSignZ;
    delete [] SignX_long;
    delete [] SignY_long;
    delete [] SignZ_long;
    delete [] GradSignX_long;
    delete [] GradSignY_long;
    delete [] GradSignZ_long;
    delete [] FinalMul;
    float * FinalMulFinFloat=TranscribeArray<bool,float>(FinalBool,numel);
    return FinalMulFinFloat;
}




float * ExtractionSkeleton(bool * LesionBool, int numel, int* Dim, int* Shift, float* PixDim,nifti_image * BasisImage){
    bool * BorderLesion=CreateBorderFromBool(LesionBool,Dim,Shift);
    int numbNZ=0;
    int * L2S=MakeL2S(LesionBool,Dim);
    int * S2L=MakeS2L(LesionBool,Dim,numbNZ);
    nifti_image * MaskLesion=CreateNiiFromArray(LesionBool,BasisImage,numel);
    nifti_image * DistanceMap=EuclideanDistanceImage(BasisImage,BorderLesion,MaskLesion);
    if(DistanceMap==NULL){
        return NULL;
    }
    float * DistData=CreateShort(static_cast<float*>(DistanceMap->data),S2L,numbNZ);
    float * GradDistX=GradientImage(DistData,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    SaveTmpResult_short(GradDistX,"/Users/csudre/Downloads/carole_example/GradDistX.nii.gz",BasisImage,L2S);
    SaveTmpResult_short(DistData,"/Users/csudre/Downloads/carole_example/DistanceMap.nii.gz",BasisImage,L2S);
    float * GradDistY=GradientImage(DistData,1,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradDistZ=GradientImage(DistData,2,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    nifti_image_free(DistanceMap);
    nifti_image_free(MaskLesion);
    float * SignX=Sign(GradDistX,numbNZ);
    cout << "CountNonZero X is "<<CountNonZero(SignX,numbNZ)<<endl;
    float * SignY=Sign(GradDistY,numbNZ);
    float * SignZ=Sign(GradDistZ,numbNZ);
    float * SignX_long=CreateLong(SignX,L2S,numel);
    float * SignY_long=CreateLong(SignY,L2S,numel);
    float * SignZ_long=CreateLong(SignZ,L2S,numel);
    vector<float*> VecSign;
    VecSign.push_back(SignX_long);
    VecSign.push_back(SignY_long);
    VecSign.push_back(SignZ_long);
        float * GradSignX=GradientImage(SignX,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradSignY=GradientImage(SignY,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradSignZ=GradientImage(SignZ,0,1,Dim,Shift,PixDim,L2S,S2L,numbNZ);
    float * GradSignX_long=CreateLong(GradSignX,L2S,numel);
    float * GradSignY_long=CreateLong(GradSignY,L2S,numel);
    float * GradSignZ_long=CreateLong(GradSignZ,L2S,numel);
    vector<float*> VecGradSign;
    VecGradSign.push_back(GradSignX_long);
    VecGradSign.push_back(GradSignY_long);
    VecGradSign.push_back(GradSignZ_long);
    SaveTmpResult(VecGradSign,"/Users/csudre/Downloads/carole_example/TestSign.nii.gz",BasisImage);

    float * FinalMul=MultiplyElementwise(VecGradSign,numel,LesionBool);
    float * FinalMulFin=MultiplyElementwiseChoose<float,bool,float>(FinalMul,LesionBool,numel);
    for(int i=0;i<numel;i++){
        if(BorderLesion[i]){
            FinalMulFin[i]=0;
        }
    }
    delete [] SignX;
    delete [] SignY;
    delete [] SignZ;
    delete [] GradSignX;
    delete [] GradSignY;
    delete [] GradSignZ;
    delete [] SignX_long;
    delete [] SignY_long;
    delete [] SignZ_long;
    delete [] GradSignX_long;
    delete [] GradSignY_long;
    delete [] GradSignZ_long;
    delete [] FinalMul;
    return FinalMulFin;
}

nifti_image * ImageOrderedVolumeLabel(nifti_image * SegToAnalyse, SEG_ANALYSIS * segment_analysis){
    if(segment_analysis->flag_connect==0){
        cout<<"No connecting labels asked for"<<endl;
        return NULL;
    }
    float thresh=0.5;
    int numel=SegToAnalyse->nvox;
    int * ComponentLabels=ComponentLabeling(SegToAnalyse,segment_analysis->Neigh,thresh);
    int maxLabel=GetMaxLabel(ComponentLabels, numel);
    int * VolumeLabels=GetVolumeLabels(ComponentLabels, numel);
    int * OrderedLabels=GetCorrespondanceOrderedVolume(VolumeLabels, maxLabel);
    int * NewComponentsOrderedLabel=new int[numel];
    for(int i=0;i<numel;i++){
        NewComponentsOrderedLabel[i]=ComponentLabels[i];
        NewComponentsOrderedLabel[i]=OrderedLabels[ComponentLabels[i]-1];
        if(ComponentLabels[i]>0 && VolumeLabels[OrderedLabels[ComponentLabels[i]-1]]<5){
            NewComponentsOrderedLabel[i]=0;
        }
    }
    nifti_image * ImageLabelsConnect=nifti_copy_nim_info(SegToAnalyse);
    ImageLabelsConnect->data=(void *)calloc(numel, sizeof(float));
    float * LabelsData_PTR=static_cast<float *>(ImageLabelsConnect->data);
    for(int i=0;i<numel;i++){
        LabelsData_PTR[i]=NewComponentsOrderedLabel[i];
    }
    delete [] ComponentLabels;
    ComponentLabels=NULL;
    delete [] NewComponentsOrderedLabel;
    NewComponentsOrderedLabel=NULL;
    delete [] OrderedLabels;
    OrderedLabels=NULL;
    delete [] VolumeLabels;
    VolumeLabels=NULL;
    return ImageLabelsConnect;
}

// Return value of the maximum label in the label
int GetMaxLabel(int * ComponentLabel, int numel){
    int maxLabel=-1;
    for(int i=0;i<numel;i++){
        if(ComponentLabel[i]>maxLabel){
            maxLabel=ComponentLabel[i];
        }
    }
    return maxLabel;
}

// Returns the image refined for mini size
nifti_image * ImageRefinedLabel(nifti_image * SegToAnalyse, SEG_ANALYSIS * segment_analysis){
    if(segment_analysis->flag_connect==0){
        cout<<"No connecting labels asked for"<<endl;
        return NULL;
    }
    MiniSize=segment_analysis->MiniSize;
    float thresh=0.5;
    int numel=SegToAnalyse->nvox;
    int * ComponentLabels=ComponentLabeling(SegToAnalyse,segment_analysis->Neigh, thresh);
    int maxLabel=GetMaxLabel(ComponentLabels, numel);
    int * CorrespondanceTrueLabel=new int[maxLabel];
    for(int l=0;l<maxLabel;l++){
        CorrespondanceTrueLabel[l]=l;
    }
    int * RefinedLabels=RefinedComponentLabel(ComponentLabels, MiniSize, numel, CorrespondanceTrueLabel, maxLabel);
    nifti_image * ImageLabelsConnect=nifti_copy_nim_info(SegToAnalyse);
    ImageLabelsConnect->data=(void *)calloc(numel, sizeof(float));
    float * LabelsData_PTR=static_cast<float *>(ImageLabelsConnect->data);
    for(int i=0;i<numel;i++){
        LabelsData_PTR[i]=RefinedLabels[i];
    }
    delete [] ComponentLabels;
    ComponentLabels=NULL;
    delete [] RefinedLabels;
    RefinedLabels=NULL;
    delete [] CorrespondanceTrueLabel;
    CorrespondanceTrueLabel=NULL;
    return ImageLabelsConnect;
}

int * RefinedComponentLabel(int * ComponentLabel, int MiniSize, int numel, int * CorrespondanceTrueLabel, int maxLabel){
    // Define maxLabel
    
    // for each label, determine if group considered can be classified as lesion
    int TrueLabel=1;
    if(maxLabel==0){
        return ComponentLabel;
    }
    int * VolumeLabels=GetVolumeLabels(ComponentLabel, numel);
    int CountLesionRejected=0;
    for(int l=1;l<=maxLabel;l++){
        //cout<< "Volume for label "<<l<<" is "<<VolumeLabels[l-1];
        if(VolumeLabels[l-1]>MiniSize){
            CorrespondanceTrueLabel[l]=TrueLabel;
            TrueLabel++;
        }
        else{
            CountLesionRejected++;
        }
    }
    cout<<CountLesionRejected<<" rejected lesion zones out of "<<maxLabel<<endl;
    // Initialise RefinedComponentLabel
    int * RefinedComponentLabel=new int [numel];
    for(int i=0;i<numel;i++){
        RefinedComponentLabel[i]=0;
    }
    // Rewrite Component Label into Refined Component Label according to Correspondance TrueLabel
    
    for(int i=0;i<numel;i++){
        if(ComponentLabel[i]!=0){
            RefinedComponentLabel[i]=CorrespondanceTrueLabel[ComponentLabel[i]-1];
        }
    }
    delete [] VolumeLabels;
    VolumeLabels=NULL;
    return RefinedComponentLabel;
}

// Given the volumes of the initial labels (i.e not reordered), find the label that corresponds to the maximum volume
int FindBiggestLesion(int * CorrespondanceTrueLabel,int * GetVolumeLabels, int maxLabel,int maxVolume){
    int indexMaxVolume=-1;
    for(int l=0;l<maxLabel;l++){
        if (GetVolumeLabels[l]>maxVolume){
            maxVolume=GetVolumeLabels[l];
            indexMaxVolume=l;
        }
    }
    return CorrespondanceTrueLabel[indexMaxVolume];
}

// Recursive function allowing for the building of connected components given the soft segmentation, binarised with thresh.
void RecurseCompLabel(float * Data, int * PositionTmp, int Label, int * ComponentsLabel,int Neigh,int * Dim,int * Shift, float thresh,int& Times){
    int numel=Dim[0]*Dim[1]*Dim[2];
    if(Times==1000){
        cout<<"Have to go out"<<endl;
        return;
    }
    else{
        for(int i=0;i<numel;i++){
            if(PositionTmp[i]==1 && Times<1000){
                //            int * NeighboursToLook=GetListNeighboursToLook(i, Dim,Shift);
                int * NeighboursToLook=GetListNeighbours(i, Dim, Shift, Neigh);
                int CountNeighboursBelongingToSame=0;
                for(int n=0;n<Neigh;n++){
                    if(Data[NeighboursToLook[n]]>=thresh && ComponentsLabel[NeighboursToLook[n]]==0){
                        PositionTmp[NeighboursToLook[n]]=1;
                        ComponentsLabel[NeighboursToLook[n]]=Label;
                        CountNeighboursBelongingToSame++;
                    }
                }
                // cout<<CountNeighboursBelongingToSame<<" neighbours in same lesion"<<endl;
                delete [] NeighboursToLook;
                NeighboursToLook=NULL;
                PositionTmp[i]=2;
                //Times++;
                //            RecurseCompLabel(Data, PositionTmp, Label, ComponentsLabel, Dim, Shift, thresh,Times);
            }
        }
        Times++;
    }
    //    cout<<"Times is "<<Times<<endl;
    bool flag_pos1=0;
    for (int i=0; i<numel; i++) {
        if (PositionTmp[i]==1) {
            flag_pos1=1;
            //            cout<<"Still something in Position...";
            break;
        }
    }
    
    //    Times=0;
    if (flag_pos1) { // Recursive call on RecurseCompLabel, given the updated positionTmp and ComponentsLabel. Performed if there is still one voxel that has to be considered but has not been treated.
        RecurseCompLabel(Data, PositionTmp, Label, ComponentsLabel,Neigh, Dim, Shift,thresh,Times);
    }
    return;
    //
}

// Given the current ComponentLabel integer array of labels for the connected components of lesion, modify the labelling so that there is no gap in the labeling (consecutive label integers). Note that discontinuity can occurr when suppressing lesion components due to incoherence or size limitation. Processed in a recursive way until no gap anymore
void RelabelComponents(int * ComponentsLabel, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int maxLabel=GetMaxLabel(ComponentsLabel, numel);
    bool flag_change=0;
    for (int l=0 ; l<maxLabel; l++) {
        int Size=GetLabelSize(l+1, ComponentsLabel, numel);
        if (Size==0) {
            flag_change=1;
            for (int i=0; i<numel; i++) {
                if (ComponentsLabel[i]>l+1) {
                    ComponentsLabel[i]--;
                }
            }
        }
    }
    if (flag_change) { // Recursive call to RelabelComponents.
        cout<<"Again change... "<<endl;
        RelabelComponents(ComponentsLabel, Dim);
    }
    
}

// Recursive functions on the labeling integer array making sure that it only one label is used for neighborhing regions. To avoid connected regions to be labelled differently.
void RepassComponentsLabel(int * ComponentsLabel, int Neigh,int * Dim,int * Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    //    int maxLabel=GetMaxLabel(ComponentsLabel, numel);
    int CountChange=0;
    for (int i=0; i<numel; i++) {
        if (ComponentsLabel[i]>0) {
            //            int * ListNeighboursToLook=GetListNeighboursToLook(i, Dim,Shift);
            int * ListNeighboursToLook=GetListNeighbours(i, Dim, Shift, Neigh);
            int LabelTmp=ComponentsLabel[i];
            for (int n=0; n<Neigh; n++) {
                int LabelNeigh=ComponentsLabel[ListNeighboursToLook[n]];
                if (LabelNeigh>0 && LabelNeigh!=LabelTmp) {
                    if (LabelTmp>LabelNeigh) {
                        ComponentsLabel[i]=LabelNeigh;
                    }
                    else{
                        ComponentsLabel[ListNeighboursToLook[n]]=LabelTmp;
                    }
                    CountChange ++;
                }
            }
            delete [] ListNeighboursToLook;
            ListNeighboursToLook=NULL;
        }
    }
    cout<<CountChange<<" changes after repass"<<endl;
    if(CountChange>0){ // Recursive call to RepassComponentsLabel
        RepassComponentsLabel(ComponentsLabel, Neigh,Dim,Shift);
    }
}



nifti_image * SummarisedSegDecoupled(nifti_image * SummarisedSeg, nifti_image * SegToAnalyse, int CorrespondingDecouplingIndex){
    if (SummarisedSeg==NULL) {
        return NULL;
    }
    if (SegToAnalyse==NULL) {
        return CopyFloatNii(SummarisedSeg);
    }
    nifti_image * DecoupledSummarisedSeg=nifti_copy_nim_info(SummarisedSeg);
    DecoupledSummarisedSeg->dim[4]++;
    nifti_update_dims_from_array(DecoupledSummarisedSeg);
    DecoupledSummarisedSeg->data=(void *)calloc(DecoupledSummarisedSeg->nvox, sizeof(float));
    float * DecoupledData=static_cast<float *>(DecoupledSummarisedSeg->data);
    float * SummarisedData=static_cast<float *>(SummarisedSeg->data);
    float * LesionData=static_cast<float *>(SegToAnalyse->data);
    int numbgen=SummarisedSeg->nu*SummarisedSeg->nt;
    int numel=DecoupledSummarisedSeg->nx*DecoupledSummarisedSeg->ny*DecoupledSummarisedSeg->nz;
    int nTot=(numbgen+1)*numel;
    //    Initialise with 0 value
    for (int i=0; i<nTot; i++) {
        DecoupledData[i]=0;
    }
    
    
    for (int g=0 ; g<numbgen; g++) {
        if (g!=CorrespondingDecouplingIndex) {
            for (int i=0; i<numel; i++) {
                DecoupledData[numel*g+i]+=SummarisedData[numel*g+i];
            }
        }
        else { // case where we have to make the decoupling
            for (int i=0; i<numel; i++) {
                DecoupledData[numel*g+i]=SummarisedData[numel*g+i]-LesionData[i];
                DecoupledData[numel*numbgen+i]=LesionData[i];
            }
        }
    }
    return DecoupledSummarisedSeg;
}


// From integer label array, ordered by decreasing lesion importance, using the initial image, build the lesion simple structure corresponding to each label
vector<LesionSimple *> GetVectorLesionSimple(int * OrderedLabels,nifti_image * InitialSeg){
    
    vector<LesionSimple *> LesionVector;
    int numel=InitialSeg->nx*InitialSeg->ny*InitialSeg->nz;
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    for (int l=0; l<maxLabel; l++) {
        cout<<"Label "<<l+1<<"...";
        LesionSimple * LesionToPush=BuildLesionSimpleFromConnectedLabels(OrderedLabels, InitialSeg, l+1,1);
        LesionVector.push_back(LesionToPush);
        cout<<"treated"<<endl;
    }
    
    return LesionVector;
}




// From integer label array, ordered by decreasing lesion importance, using the initial image, build the lesion simple structure corresponding to each label
vector<LesionIntensity *> GetVectorLesionIntensity(int * OrderedLabels, float* ParamWM,float * InvertCovarianceWM,nifti_image * DataCompImage,nifti_image * MahalDistImage){
    
    vector<LesionIntensity *> LesionVector;
    int numel=DataCompImage->nx*DataCompImage->ny*DataCompImage->nz;
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    for (int l=0; l<maxLabel; l++) {
        cout<<"Label "<<l+1<<"...";
        LesionIntensity * LesionToPush=BuildLesionIntensityFromConnectedLabel(OrderedLabels , l+1, ParamWM, InvertCovarianceWM, DataCompImage,MahalDistImage);
        LesionVector.push_back(LesionToPush);
        cout<<"treated"<<endl;
    }
    
    return LesionVector;
}


// From integer label array, ordered by decreasing lesion importance, using TreeToAnalyse to get the borders, build the lesion structure corresponding to each label and completing them with information from the rebuilt borders using the summarised segmentation that can be or not corrected for false positives. The summarised segmentation used must be the one for which the lesions are on a specific volume and not combined with the WM
vector<Lesion *> GetVectorLesion_bis(int * OrderedLabels,nifti_image * SummarisedSeg, TreeEM * TreeToAnalyse,SEG_ANALYSIS* segment_analysis,nifti_image * VentricleSeg){
    vector<Lesion *> LesionVector;
    nifti_image * Mask=TreeToAnalyse->GetMask();
    //    WARNING : we assume hereafter that the mask is non null
    bool * MaskData=static_cast<bool *>(Mask->data);
    int Dim[3];
    Dim[0]=SummarisedSeg->nx;
    Dim[1]=SummarisedSeg->ny;
    Dim[2]=SummarisedSeg->nz;
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    float PixDim[3];
    PixDim[0]=SummarisedSeg->pixdim[1];
    PixDim[1]=SummarisedSeg->pixdim[2];
    PixDim[2]=SummarisedSeg->pixdim[3];
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    int GravityIndex=GetCenterGravity(MaskData, Dim);
    bool * VentricleSegBool=NULL;
    if (VentricleSeg!=NULL) {
        float * VentricleSegData=static_cast<float *>(VentricleSeg->data);
        VentricleSegBool=TranscribeArray<float, bool>(VentricleSegData, numel);
    }
    
    //    int * CorrespondingCoordinatesGravity=CorrespondingCoordinates(GravityIndex,Dim,Shift);
    // defining borders needed to finish Lesion definition
    bool * BorderWMI=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 1);
    bool * BorderCSF=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 15);
    bool * BorderGMC=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 25);
    vector<int> OutIndexVector;
    OutIndexVector.push_back(-1);
    OutIndexVector.push_back(segment_analysis->IndexOut);
    bool * BorderSumOutMask=BorderExtractionThreshold(TreeToAnalyse,SummarisedSeg,OutIndexVector,0.2);
    
    nifti_image * HardSegSummarised=HardSegmentation_bis(SummarisedSeg, TreeToAnalyse->GetMask());
    bool * HardSegData=static_cast<bool *>(HardSegSummarised->data);
    
    for (int l=0; l<maxLabel; l++) {
        cout<<"Label "<<l+1<<"...";
        bool * LesionBool=CreateLesionBool(OrderedLabels, l+1, numel);
        Lesion * LesionToPush=BuildLesionFromConnectedLabels_bis(OrderedLabels, TreeToAnalyse, HardSegData, l+1, segment_analysis);
        cout<<"Lesion rebuilt...";
        bool NeighLesionWMI=IsLesionCloseToBorder(OrderedLabels, l+1, BorderWMI, Dim, Shift);
        bool NeighLesionCSF=IsLesionCloseToBorder(OrderedLabels, l+1, BorderCSF, Dim, Shift);
        bool NeighLesionGMC=IsLesionCloseToBorder(OrderedLabels, l+1, BorderGMC, Dim, Shift);
        bool NeighLesionOut=IsLesionCloseToBorder(OrderedLabels, l+1, BorderSumOutMask, Dim, Shift);
        LesionToPush->NeighbourCSF=NeighLesionCSF;
        LesionToPush->NeighbourGMC=NeighLesionGMC;
        LesionToPush->NeighbourWMI=NeighLesionWMI;
        LesionToPush->NeighbourOut=NeighLesionOut;
        
        if (VentricleSegBool!=NULL) {
            //            LesionToPush->DistanceVentricle=GetDistanceToSeg(OrderedLabels, l+1, TreeToAnalyse, VentricleSegBool);
            LesionToPush->DistanceVentricle=GetDistanceBetweenSeg(LesionBool, VentricleSegBool, Dim, Shift, PixDim);
            //            LesionToPush->DistanceExternalCSF=
        }
        float * ProportionNeighbour=ProportionNeighboursLesion(OrderedLabels, l+1, SummarisedSeg, segment_analysis);
        //        float * DistanceNeighbourGravity=DistanceNeighbourLesionGravity(OrderedLabels,l+1,SummarisedSeg,segment_analysis,CorrespondingCoordinatesGravity);
        int IndexCSF=segment_analysis->IndexCSF;
        int IndexGM=segment_analysis->IndexGM;
        int IndexWM=segment_analysis->IndexWM;
        int IndexOut=segment_analysis->IndexOut;
        LesionToPush->ProportionCSF=ProportionNeighbour[IndexCSF];
        LesionToPush->ProportionGM=ProportionNeighbour[IndexGM];
        LesionToPush->ProportionWM=ProportionNeighbour[IndexWM];
        LesionToPush->ProportionOut=ProportionNeighbour[IndexOut];
        if (ProportionNeighbour!=NULL) {
            delete [] ProportionNeighbour;
            ProportionNeighbour=NULL;
        }
        
        //        Check distance of Center of gravity and proportion of Path in CSF of WM inliers
        
        int IndexLesionGravCenter=GetCenterGravity(LesionBool, Dim);
        vector<int> IndicesPath=GetIndicesMinPath(GravityIndex,IndexLesionGravCenter,Dim,Shift,PixDim);
        //        int numbPath=IndicesPath.size();
        float * PropIndicesPath= ProportionIndicesSegmentation( IndicesPath, HardSegSummarised);
        LesionToPush->DistanceGrav=GetDistanceBetweenPoints(IndexLesionGravCenter, GravityIndex, Dim, PixDim);
        LesionToPush->ProportionGravCSF=PropIndicesPath[IndexCSF];
        LesionToPush->ProportionGravGM=PropIndicesPath[IndexGM];
        LesionToPush->ProportionGravWM=PropIndicesPath[IndexWM];
        LesionToPush->ProportionGravOut=PropIndicesPath[IndexOut];
        delete [] PropIndicesPath;
        delete [] LesionBool;
        
        LesionCode(LesionToPush);
        //        cout<<"Trying to push lesion"<<endl;
        LesionVector.push_back(LesionToPush);
        cout<<"treated"<<endl;
    }
    
    if (HardSegSummarised!=NULL) {
        nifti_image_free(HardSegSummarised);
        HardSegSummarised=NULL;
    }
    
    //    delete [] Dim;
    //    delete [] Shift;
    delete [] BorderCSF;
    delete [] BorderWMI;
    delete [] BorderGMC;
    delete [] BorderSumOutMask;
    
    //    Shift=NULL;
    //    Dim=NULL;
    BorderGMC=NULL;
    BorderCSF=NULL;
    BorderWMI=NULL;
    BorderSumOutMask=NULL;
    
    return LesionVector;
}





// From integer label array, ordered by decreasing lesion importance, using TreeToAnalyse to get the borders, build the lesion structure corresponding to each label and completing them with information from the rebuilt borders using the summarised segmentation that can be or not corrected for false positives. The summarised segmentation used must be the one for which the lesions are on a specific volume and not combined with the WM
vector<Lesion *> GetVectorLesion_ter(int * OrderedLabels,nifti_image * SummarisedSeg, TreeEM * TreeToAnalyse,SEG_ANALYSIS* segment_analysis,bool * VentricleBool, bool * DGMBool, bool * AcceptedGMBool, float * ICSFPriors, float * DGMPriors){
    vector<Lesion *> LesionVector;
    nifti_image * Mask=TreeToAnalyse->GetMask();
    //    WARNING : we assume hereafter that the mask is non null
    bool * MaskData=static_cast<bool *>(Mask->data);
    int Dim[3];
    Dim[0]=SummarisedSeg->nx;
    Dim[1]=SummarisedSeg->ny;
    Dim[2]=SummarisedSeg->nz;
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    float PixDim[3];
    PixDim[0]=SummarisedSeg->pixdim[1];
    PixDim[1]=SummarisedSeg->pixdim[2];
    PixDim[2]=SummarisedSeg->pixdim[3];
    float SumPixDim=PixDim[0]+PixDim[1]+PixDim[2];
    float SumDim=Dim[0]+Dim[1]+Dim[2];
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    int GravityIndex=GetCenterGravity(MaskData, Dim);
    
    vector<float *> ICSFDGMVector;
    float * ICSFDGM=NULL;
    if (ICSFPriors!=NULL && DGMPriors!=NULL) {
        ICSFDGMVector.push_back(ICSFPriors);
        ICSFDGMVector.push_back(DGMPriors);
        ICSFDGM=AddArray(ICSFDGMVector, numel);
    }
    
    
    
    int * CorrespondingCoordinatesGravity=CorrespondingCoordinates(GravityIndex,Dim,Shift);
    // defining borders needed to finish Lesion definition
    bool * BorderWMI=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 1);
    bool * BorderCSF=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 15);
    bool * BorderGMC=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 25);
    vector<int> OutIndexVector;
    OutIndexVector.push_back(-1);
    OutIndexVector.push_back(segment_analysis->IndexOut);
    bool * BorderSumOutMask=BorderExtractionThreshold(TreeToAnalyse,SummarisedSeg,OutIndexVector,0.2);
    nifti_image * HardSegSummarised=HardSegmentation_bis(SummarisedSeg, TreeToAnalyse->GetMask());
    bool * HardSegData=static_cast<bool *>(HardSegSummarised->data);
    
    for (int l=0; l<maxLabel; l++) {
        cout<<"Label "<<l+1<<"...";
        bool * LesionBool=CreateLesionBool(OrderedLabels, l+1, numel);
        Lesion * LesionToPush=BuildLesionFromConnectedLabels_bis(OrderedLabels, TreeToAnalyse, HardSegData, l+1, segment_analysis);
        cout<<"Lesion rebuilt...";
        bool NeighLesionWMI=IsLesionCloseToBorder(OrderedLabels, l+1, BorderWMI, Dim, Shift);
        bool NeighLesionCSF=IsLesionCloseToBorder(OrderedLabels, l+1, BorderCSF, Dim, Shift);
        bool NeighLesionGMC=IsLesionCloseToBorder(OrderedLabels, l+1, BorderGMC, Dim, Shift);
        bool NeighLesionOut=IsLesionCloseToBorder(OrderedLabels, l+1, BorderSumOutMask, Dim, Shift);
        LesionToPush->NeighbourCSF=NeighLesionCSF;
        if (LesionToPush->DistanceCSF>SumPixDim) {
            LesionToPush->NeighbourCSF=0;
        }
        LesionToPush->NeighbourGMC=NeighLesionGMC;
        LesionToPush->NeighbourWMI=NeighLesionWMI;
        LesionToPush->NeighbourOut=NeighLesionOut;
        
        if (ICSFDGM!=NULL) {
            LesionToPush->SPPotProp=GetProportionAbove<float,bool>(ICSFDGM, LesionBool, 0.45, numel);
        }
        if (ICSFPriors!=NULL) {
            LesionToPush->PropICSF=GetProportionAbove<float, bool>(ICSFPriors, LesionBool, 0.25, numel);
        }
        
        if (VentricleBool!=NULL) { // Check distance to ventricle
            //            LesionToPush->DistanceVentricle=GetDistanceToSeg(OrderedLabels, l+1, TreeToAnalyse, VentricleSegBool);
            LesionToPush->DistanceVentricle=GetDistanceBetweenSeg(LesionBool, VentricleBool, Dim, Shift, PixDim);
            //            LesionToPush->DistanceExternalCSF=
        }
        if (LesionToPush->DistanceVentricle<=SumPixDim) {
            LesionToPush->NeighbourVentricle=1;
        }
        float DistanceAcceptedGM=SumDim;
        if (AcceptedGMBool!=NULL && CountNonZero(AcceptedGMBool, numel)>0)  { // If any island of GM, check if neighbour to one of them
            DistanceAcceptedGM=GetDistanceBetweenSeg(LesionBool, AcceptedGMBool, Dim, Shift, PixDim);
            
        }
        LesionToPush->DistanceAcceptedGM=DistanceAcceptedGM;
        int CountIntersectDGM=0;
        if (DGMBool !=NULL) { // Check if part of the lesion is also part of the DGM bool region
            bool * IntersectDGMLesion=new bool[numel];
            ANDOperationBool(LesionBool, DGMBool, IntersectDGMLesion, numel);
            CountIntersectDGM=CountNonZero(IntersectDGMLesion, numel);
            delete [] IntersectDGMLesion;
            IntersectDGMLesion=NULL;
        }
        if (CountIntersectDGM>0) {
            LesionToPush->DGMBelonging=1;
        }
        float * ProportionNeighbour=ProportionNeighboursLesion(OrderedLabels, l+1, SummarisedSeg, segment_analysis);
        //        float * DistanceNeighbourGravity=DistanceNeighbourLesionGravity(OrderedLabels,l+1,SummarisedSeg,segment_analysis,CorrespondingCoordinatesGravity);
        int IndexCSF=segment_analysis->IndexCSF;
        int IndexGM=segment_analysis->IndexGM;
        int IndexWM=segment_analysis->IndexWM;
        int IndexOut=segment_analysis->IndexOut;
        LesionToPush->ProportionCSF=ProportionNeighbour[IndexCSF];
        LesionToPush->ProportionGM=ProportionNeighbour[IndexGM];
        LesionToPush->ProportionWM=ProportionNeighbour[IndexWM];
        LesionToPush->ProportionOut=ProportionNeighbour[IndexOut];
        if (ProportionNeighbour!=NULL) {
            delete [] ProportionNeighbour;
            ProportionNeighbour=NULL;
        }
        
        //        Check distance of Center of gravity and proportion of Path in CSF of WM inliers
        
        int IndexLesionGravCenter=GetCenterGravity(LesionBool, Dim);
        int * CorrespondingCoordGrav=CorrespondingCoordinates(IndexLesionGravCenter, Dim, Shift);
        for (int d=0; d<3; d++) {
            LesionToPush->CentreGravity.push_back(CorrespondingCoordGrav[d]);
        }
        
        vector<int> IndicesPath=GetIndicesMinPath(GravityIndex,IndexLesionGravCenter,Dim,Shift,PixDim);
        //        int numbPath=IndicesPath.size();
        float * PropIndicesPath= ProportionIndicesSegmentation( IndicesPath, HardSegSummarised);
        LesionToPush->DistanceGrav=GetDistanceBetweenPoints(IndexLesionGravCenter, GravityIndex, Dim, PixDim);
        for (int d=0; d<3; d++) {
            LesionToPush->VectorDiffGrav.push_back((CorrespondingCoordGrav[d]-CorrespondingCoordinatesGravity[d]));
        }
        
        LesionToPush->ProportionGravCSF=PropIndicesPath[IndexCSF];
        LesionToPush->ProportionGravGM=PropIndicesPath[IndexGM];
        LesionToPush->ProportionGravWM=PropIndicesPath[IndexWM];
        LesionToPush->ProportionGravOut=PropIndicesPath[IndexOut];
        delete [] PropIndicesPath;
        PropIndicesPath=NULL;
        delete [] LesionBool;
        LesionBool=NULL;
        delete [] CorrespondingCoordGrav;
        CorrespondingCoordGrav=NULL;
        if (segment_analysis->flag_correctionLevel==1) {
            LesionCodeImprovedT1T2(LesionToPush);
        }
        else{
            LesionCodeImproved(LesionToPush);
        }
        //        cout<<"Trying to push lesion"<<endl;
        LesionVector.push_back(LesionToPush);
        cout<<"treated"<<endl;
    }
    
    if (HardSegSummarised!=NULL) {
        nifti_image_free(HardSegSummarised);
        HardSegSummarised=NULL;
    }
    
    delete [] BorderCSF;
    delete [] BorderWMI;
    delete [] BorderGMC;
    delete [] BorderSumOutMask;
    delete [] CorrespondingCoordinatesGravity;
    CorrespondingCoordinatesGravity=NULL;
    BorderGMC=NULL;
    BorderCSF=NULL;
    BorderWMI=NULL;
    BorderSumOutMask=NULL;
    
    return LesionVector;
}

void CorrectOrderedLabels(int LabelBase, int LabelChange, int * OrderedLabelBase, int * OrderedLabelChange, nifti_image * SegBase, nifti_image * SegChange){
//    int numel=SegChange->nvox;
    int Dim[3];
    Dim[0]=SegChange->dim[1];
    Dim[1]=SegChange->dim[2];
    Dim[2]=SegChange->dim[3];
    vector<int> ListIndicesBase=GetListIndicesLabel(OrderedLabelBase, Dim, LabelBase);
    vector<int> ListIndicesChange=GetListIndicesLabel(OrderedLabelChange, Dim, LabelChange);
    int sizeLabelBase=ListIndicesBase.size();
    int sizeLabelChange=ListIndicesChange.size();
    float * SegBaseData=static_cast<float*>(SegBase->data);
    float * SegChangeData=static_cast<float*>(SegChange->data);
    for (int s=0; s<sizeLabelChange; s++) {
        OrderedLabelChange[ListIndicesChange[s]]=0;
        SegChangeData[ListIndicesChange[s]]=0;
    }
    for (int s=0; s<sizeLabelBase; s++) {
        OrderedLabelChange[ListIndicesBase[s]]=LabelChange;
        SegChangeData[ListIndicesBase[s]]=SegBaseData[ListIndicesBase[s]];
    }
}

//Return a vector of outliers structures done with both their normal and NIV version that are then compared
vector<Outlier *> GetVectorOutliers_NIVCorr(int * OrderedLabels, int * OrderedLabelsNIV, nifti_image * SegToAnalyse, nifti_image * SegToAnalyseNIV,TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis, float mult_modify){
    vector<Outlier *> OutlierVectorCorr;
    int numel=TreeToAnalyse->GetNumberElements();
    // Get the vectors for OrderedLabels and OrderedLabelsNIV
    vector<Outlier *> OutlierVector=GetVectorOutliers(OrderedLabels, TreeToAnalyse, segment_analysis,mult_modify);
    vector<Outlier *> OutlierVectorNIV=GetVectorOutliers(OrderedLabelsNIV, TreeToAnalyse, segment_analysis,mult_modify);
    int maxLabel=OutlierVector.size();
//    int maxLabelNIV=OutlierVectorNIV.size();
    for (int l=0; l<maxLabel; l++) {
        vector<int> ListLabelCorr=GetListCorrespondingLabels(l+1, OrderedLabelsNIV, OrderedLabels, numel);
        if (ListLabelCorr.size()!=1) {
            cout<<"Potential problem with NIV"<<endl;
        }
    }

//    for each of the elements in OutlierVector, check if correction needed or not.
    for (int l=0; l<maxLabel; l++) {
        vector<int> ListLabelCorr=GetListCorrespondingLabels(l+1, OrderedLabelsNIV, OrderedLabels, numel);
        int sizeTest=GetLabelSize(l+1, OrderedLabels, numel);
        if (ListLabelCorr.size()!=1) {
            cout<<"Potential problem with NIV"<<endl;
            
            if (sizeTest==0) {
                cout<<"Nothing left in label"<<l+1<<endl;
            }
            else if (ListLabelCorr.size()==0) {
                cout<<"Strangely nothing found in OrderedLabelsNIV"<<endl;
            }
            else{
                cout<<"There are "<<ListLabelCorr.size()<<"needed in OrderedLabelsNIV now"<<endl;
            }
        }
        if (ListLabelCorr.size()==0) {
            cout<<"Nothing matching between NIV and normal"<<endl;
            if (OutlierVector[l]!=NULL) {
                OutlierVectorCorr.push_back(OutlierVector[l]);
            }
        }
        else{
            int lniv=ListLabelCorr[0]-1;
        int SizeCurr=GetLabelSize(l+1, OrderedLabels, numel);
        int SizeCurrNIV=GetLabelSize(ListLabelCorr[0], OrderedLabelsNIV, numel);
        if(SizeCurr==0){
            delete OutlierVector[l];
            OutlierVector[l]=NULL;
            OutlierVectorCorr.push_back(NULL);
        }
        else if (OutlierVector[l]==NULL && OutlierVectorNIV[lniv]==NULL){
            cout<<"Both NULL"<<endl;
            OutlierVectorCorr.push_back(NULL);
        }
        else if(OutlierVector[l]==NULL){
            CorrectOrderedLabels(ListLabelCorr[0],l+1,OrderedLabelsNIV,OrderedLabels,SegToAnalyseNIV,SegToAnalyse);
            OutlierVectorCorr.push_back(OutlierVectorNIV[lniv]);
        }
        else if(OutlierVectorNIV[lniv]==NULL){
            OutlierVectorCorr.push_back(OutlierVector[l]);
        }
        else if(SizeCurr==SizeCurrNIV){
            delete OutlierVectorNIV[lniv];
            OutlierVectorNIV[lniv]=NULL;
            OutlierVectorCorr.push_back(OutlierVector[l]);
        }
        else if (OutlierVector[l]->OutlierClass>0 && OutlierVectorNIV[lniv]->OutlierClass>0){
            cout <<"Accepting correction NIV"<<endl;
            CorrectOrderedLabels(ListLabelCorr[0],l+1,OrderedLabelsNIV,OrderedLabels,SegToAnalyseNIV,SegToAnalyse);
            delete OutlierVector[l];
            OutlierVector[l]=NULL;
            OutlierVectorCorr.push_back(OutlierVectorNIV[lniv]);
        }
            else{
                cout<<"Change not accepted for NIV"<<endl;
                delete OutlierVectorNIV[lniv];
                OutlierVectorNIV[lniv]=NULL;
                OutlierVectorCorr.push_back(OutlierVector[l]);
            }
        }
    }
    int * VolumesLabels=GetVolumeLabels(OrderedLabels, numel);
    vector<Outlier *> FinalVectorCorr;
    int CountZeroTreated=0;
    for (int l=0; l<maxLabel; l++) {
        if (VolumesLabels[l]==0) {
            cout << "Labe "<<l+1<< " is void now !"<<endl;
            if(OutlierVectorCorr[l]!=NULL){
                delete OutlierVectorCorr[l];
                OutlierVectorCorr[l]=NULL;
            }
            for (int i=0; i<numel; i++) {
                if (OrderedLabels[i]>=l+1-CountZeroTreated) {
                    OrderedLabels[i]=OrderedLabels[i]-1;
                }
            }
            CountZeroTreated++;
        }
        else{
            FinalVectorCorr.push_back(OutlierVectorCorr[l]);
        }
    }
    cout <<CountZeroTreated <<" zero lesion volumes had to be treated "<<endl;
    delete [] VolumesLabels;
    VolumesLabels=NULL;
    return FinalVectorCorr;
}

// Returns the image of all voxels within the region of interest that would satisfy the intensity rules for being a PVS or a lacune
nifti_image * PVSExtraction(RuleCorr * Rule, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis, vector<float *> MahalVec){
//    First determine the zone in which one may expect these elements ie WM DGM and fill holes if any
//    Need PriorsWM PriorsDGM or SegWM
    nifti_image * PriorsDGM = ReadFromFilename(segment_analysis->filename_inPriorsDGM);
    nifti_image * PriorsWM = ReadFromFilename(segment_analysis->filename_inPriorsWM);
//    nifti_image * PriorsCGM=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
    nifti_image * Artefacts=ReadFromFilename(segment_analysis->filename_Artefact);
    int numel=TreeToAnalyse->GetNumberElements();
    vector<TreeEM *> WMSegVector;
    WMSegVector.push_back(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM));
    WMSegVector.push_back(TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexWM));
    float * DGMData= static_cast<float*>(PriorsDGM->data);
    float * WMData=static_cast<float*>(PriorsWM->data);
    float * ArtefactData=static_cast<float*>(Artefacts->data);
//    float * CGMData=static_cast<float*>(PriorsCGM->data);
    float * AddWM=AddNormResp(WMSegVector);
    float * ParcellationData=NULL;
    int Dim[3];
    int Shift[3];
    vector<int> DimVector;
    float PixDim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=PriorsDGM->dim[d+1];
        PixDim[d]=PriorsDGM->pixdim[d+1];
        if (d==0) {
            Shift[d]=1;
        }
        else{
            Shift[d]=Shift[d-1]*Dim[d-1];
        }
        DimVector.push_back(Dim[d]);
    }

    if (segment_analysis->flag_Parc){
        nifti_image* ParcellationNii=ReadFromFilename(segment_analysis->filename_Parc);
        ParcellationData=static_cast<float*>(ParcellationNii->data);
        int ListNeigh[6];
        for(int i=0;i<numel;i++){
            GetListNeighbours_bis(ListNeigh,i,Dim,Shift,6);
            bool flag_artefact=0;
            for (int n=0;n<6;n++){
                if((ParcellationData[ListNeigh[n]]>46.5 && ParcellationData[ListNeigh[n]]<53.5) || (ParcellationData[ListNeigh[n]]>4.5 && ParcellationData[ListNeigh[n]]<16.5 )) {
                    flag_artefact=1;
                    break;
                }
            ArtefactData[i]=0;
            }
        }
    }
    float * WMLong=CreateLong(AddWM, TreeToAnalyse->GetL2S(), numel);
    bool * ZonePotential=new bool[numel];
    int CountEqual=0;
    for(int i=0;i<numel;i++){
        ZonePotential[i]=0;
        if(WMLong[i]>0.3){
            ZonePotential[i]=1;
        }
        if(DGMData[i]+WMData[i]>0.2){
            ZonePotential[i]=1;
        }
//        if(CGMData[i]>0.25){
//            ZonePotential[i]=0;
//        }
        if(ArtefactData[i]){
            ZonePotential[i]=0;
        }
        if (MahalVec.size()>2){
            if (fabs(MahalVec[1][i]-MahalVec[2][i])<0.01) {
                CountEqual++;
            }
        }
    }
    
    nifti_image * MahalT1=CreateNiiFromArray(MahalVec[0], PriorsDGM, numel);
    nifti_image * MahalFLAIR=CreateNiiFromArray(MahalVec[1], PriorsDGM, numel);
    
    string FilenamePA=nifti_makebasename(segment_analysis->filename_InLes);
    int Index=FilenamePA.find_last_of('/');
    string FilenamePA_b=FilenamePA.substr(0,Index+1);
    if(segment_analysis->flag_outputDir){
        FilenamePA_b=segment_analysis->name_outputDir;
    }
    string FilenamePA_e=FilenamePA.substr(Index+1,FilenamePA.length());
    string FilenameSave=FilenamePA_b+"CorrWeightTot"+FilenamePA_e+".nii.gz";
    string FilenameSaveT1=FilenamePA_b+"MahalT1"+FilenamePA_e+".nii.gz";
    string FilenameSaveFLAIR=FilenamePA_b+"MahalFLAIR"+FilenamePA_e+".nii.gz";
    string FilenameSaveT2=FilenamePA_b+"MahalT2"+FilenamePA_e+".nii.gz";
    nifti_set_filenames(MahalT1, FilenameSaveT1.c_str(), 0, 0);
    nifti_image_write(MahalT1);
    nifti_image_free(MahalT1);
    nifti_set_filenames(MahalFLAIR, FilenameSaveFLAIR.c_str(), 0, 0);
    nifti_image_write(MahalFLAIR);
    nifti_image_free(MahalFLAIR);
    cout << "Count equal MahalFLAIR MahalT2 is "<< CountEqual<<endl;
    if (segment_analysis->vecModalities.size()>2) {
        nifti_image * MahalT2=CreateNiiFromArray(MahalVec[2], PriorsDGM, numel);
        nifti_set_filenames(MahalT2, FilenameSaveT2.c_str(), 0, 0);
        nifti_image_write(MahalT2);
        nifti_image_free(MahalT2);
    }
    
    
//    Then apply CorrSelection to the zone selected and threshold it
    int sizeModVec=segment_analysis->vecModalities.size();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    if (sizeModVec != numbmodal) {
        cout << "Impossible to do correction weighting due to modalities incompatibilities" << endl;
        return NULL;
    }

    int * CorrWeight=new int [numel];
    numbmodal=segment_analysis->vecModalities.size();
    
    //int ValueBuffer=numbmodal+1;
    for (int i=0; i<numel; i++) {
        CorrWeight[i]=0;
        if (ZonePotential[i]>0) {
            int ValueToAdd=0;
            for (int m=0; m<numbmodal; m++) {
                float ValueComp=MahalVec[m][i]*Rule->SignComparison[m];
                if(segment_analysis->vecModalities[m]==3 && ValueComp<-1*Rule->ZScoreComparisonMax[m]){
                    //float ValueMahal=MahalVec[m][i];
                    ValueToAdd=0;
                    break;
                }
                if(segment_analysis->vecModalities[m]==2 && ValueComp<-1*Rule->ZScoreComparisonBuffer[m]){
                    ValueToAdd=0;
                    break;
                }
                else if (ValueComp>Rule->ZScoreComparisonMax[m]) {
                    ValueToAdd+=2;
                }
                else if (ValueComp<-1*Rule->ZScoreComparisonBuffer[m]){
                    ValueToAdd+=-1;
                }
                else if (ValueComp<-1*Rule->ZScoreComparisonMax[m]){
                    ValueToAdd+=-2;
                }
                else if (ValueComp>Rule->ZScoreComparisonBuffer[m]){
                    ValueToAdd+=1;
                }
            }
            CorrWeight[i]+=ValueToAdd;
        }
    }
    int * FinalSelection=ThresholdArray<int, int>(CorrWeight, 2, numel);
    nifti_image * FinalNii=CreateNiiFromArray(FinalSelection, PriorsDGM, numel);
   
    nifti_image * CorrWeightNii=CreateNiiFromArray(CorrWeight, PriorsDGM, numel);
    nifti_image_free(PriorsDGM);
    nifti_image_free(PriorsWM);
    nifti_set_filenames(CorrWeightNii, FilenameSave.c_str(), 0, 0);
    nifti_image_write(CorrWeightNii);
    nifti_image_free(CorrWeightNii);
    
    delete [] CorrWeight;
    delete [] FinalSelection;
    delete [] ZonePotential;
    delete [] AddWM;
    delete [] WMLong;
    
    return FinalNii;
    
}


// Returns the image of other outliers in WM than those WMH
nifti_image * OutliersLac(SimpleRule * Rule, TreeEM* TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    //    Create Names For Files to save
    string FilenamePA=nifti_makebasename(segment_analysis->filename_SegTot);
    
    
    int Index=FilenamePA.find_last_of('/');
    string FilenamePA_b=FilenamePA.substr(0,Index+1);
    if(segment_analysis->flag_outputDir){
        FilenamePA_b=segment_analysis->name_outputDir;
    }
    string FilenamePA_e=FilenamePA.substr(Index+1,FilenamePA.length());
    string FilenameCodedOutliers=FilenamePA_b+"CodedOutliers_"+FilenamePA_e+".nii.gz";
    string FilenameAcceptedZone=FilenamePA_b+"AcceptedZone_"+FilenamePA_e+".nii.gz";
    
    string FilenameTreatedCSF=FilenamePA_b+"TreatedCSF_"+FilenamePA_e+".nii.gz";
    string FilenameTreatedGM=FilenamePA_b+"TreatedGM_"+FilenamePA_e+".nii.gz";
    string FilenameTreatedOut=FilenamePA_b+"TreatedGM_"+FilenamePA_e+".nii.gz";
    string FilenameTreatedPV=FilenamePA_b+"TreatedPV_"+FilenamePA_e+".nii.gz";
    string FilenameRejectedCSF=FilenamePA_b+"RejectedCSF_"+FilenamePA_e+".nii.gz";
    string FilenameRejectedGM=FilenamePA_b+"RejectedGM_"+FilenamePA_e+".nii.gz";
    string FilenameRejectedPV=FilenamePA_b+"RejectedPV_"+FilenamePA_e+".nii.gz";
    string FilenamePotential=FilenamePA_b+"PotentialInit_"+FilenamePA_e+".nii.gz";
    string FilenameFinal=FilenamePA_b+"FinalLC_"+FilenamePA_e+".nii.gz";
    string FilenameMahalGM=FilenamePA_b+"MahalGM_"+FilenamePA_e+".nii.gz";
    string FilenameMahalWM=FilenamePA_b+"MahalWM_"+FilenamePA_e+".nii.gz";
    string FilenameMahalCSF=FilenamePA_b+"MahalCSF_"+FilenamePA_e+".nii.gz";
    string FilenameRule=FilenamePA_b+"Rule_"+FilenamePA_e+".nii.gz";
    
    
    
    //    First get all the needed standard elements:
    nifti_image * ResultsCoded = CodedOutliers(TreeToAnalyse, segment_analysis);
    int numel=TreeToAnalyse->GetNumberElements();
    //    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int * L2S=TreeToAnalyse->GetL2S();
    //    int * S2L=TreeToAnalyse->GetS2L();
    int IndexGM=segment_analysis->IndexGM;
    int IndexWM=segment_analysis->IndexWM;
    int IndexCSF=segment_analysis->IndexCSF;
    int IndexOut=segment_analysis->IndexOut;
    nifti_image * DataCorrected=TreeToAnalyse->GetDataImage();
    nifti_image * Mask=TreeToAnalyse->GetMask();
    bool * MaskData=static_cast<bool *>(Mask->data);
    
    
    //    Then get all the inlier segmentations as needed
    float * OutlierNormResp=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    float * LongOutlierNormResp=CreateLong(OutlierNormResp, L2S, numel);
    bool * OutlierSeg=ThresholdArray<float, bool>(LongOutlierNormResp, 0.5, numel);
//    nifti_image * OutlierNii=CreateNiiFromArray(OutlierSeg, ResultsCoded, numel);
    nifti_image * MaskFloatNii=CreateNiiFromArray(MaskData, ResultsCoded, numel);
    nifti_image * SummarisedTemp=HardSegmentationTemp(TreeToAnalyse, OutlierSeg, 0, segment_analysis);
    bool * GMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexGM);
    nifti_image * GMINii=CreateNiiFromArray(GMIHardSeg, ResultsCoded, numel);
    bool * WMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexWM);
    nifti_image * WMINii=CreateNiiFromArray(WMIHardSeg, ResultsCoded, numel);
    bool * CSFIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexCSF);
    nifti_image * CSFINii=CreateNiiFromArray(CSFIHardSeg, ResultsCoded, numel);
    bool * OutIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexOut);
    nifti_image * OutINii=CreateNiiFromArray(OutIHardSeg, ResultsCoded, numel);
    
    
    nifti_image * MahalDistGM=MahalDistMaps(GMINii, MaskFloatNii, DataCorrected);
    nifti_image * MahalDistWM=MahalDistMaps(WMINii, MaskFloatNii, DataCorrected);
    nifti_image * MahalDistCSF=MahalDistMaps(CSFINii, MaskFloatNii, DataCorrected);
    
    nifti_set_filenames(MahalDistGM, FilenameMahalGM.c_str(), 0, 0);
    nifti_set_filenames(MahalDistWM, FilenameMahalWM.c_str(), 0, 0);
    nifti_set_filenames(MahalDistCSF, FilenameMahalCSF.c_str(), 0, 0);
    
    nifti_image_write(MahalDistCSF);
    nifti_image_write(MahalDistGM);
    nifti_image_write(MahalDistWM);
    
    vector<nifti_image *> MahalVector;
    MahalVector.reserve(3);
    cout<<MahalVector.size()<<endl;
    MahalVector.push_back(NULL);
    MahalVector.push_back(NULL);
    MahalVector.push_back(NULL);
    MahalVector[IndexGM]=MahalDistGM;
    MahalVector[IndexWM]=MahalDistWM;
    MahalVector[IndexCSF]=MahalDistCSF;
    
//  Read mask on which everything will be done
    nifti_image * MaskWork=ReadFromFilename(segment_analysis->filename_inLacMask);
//    Get the CSF within the mask
    bool * MaskWorkData=static_cast<bool*>(MaskWork->data);
    bool * CSFIncluded=new bool[numel];
    bool * OutlierIncluded=new bool[numel];
    ANDOperationBool(MaskWorkData, OutlierSeg, OutlierIncluded, numel);

    ANDOperationBool(MaskWorkData, CSFIHardSeg, CSFIncluded, numel);
    int OI=CountNonZero(OutlierIncluded, numel);
    int OS=CountNonZero(CSFIncluded, numel);
    int MS=CountNonZero(MaskWorkData, numel);
    cout << "OI "<<OI << " OS "<<OS << " MS "<<MS<< endl;
    nifti_image * OutlierPotNii=CreateNiiFromArray(OutlierIncluded, ResultsCoded, numel);
    nifti_image * CSFPotNii=CreateNiiFromArray(CSFIncluded, ResultsCoded, numel);
    nifti_set_filenames(OutlierPotNii, FilenameTreatedOut.c_str(), 0, 0);
    nifti_set_filenames(CSFPotNii, FilenameTreatedCSF.c_str(), 0, 0);
    nifti_image_write(OutlierPotNii);
    nifti_image_write(CSFPotNii);
    nifti_image_free(OutlierPotNii);
    nifti_image_free(CSFPotNii);
//    Get the PV within the mask
    //    Get images of PV or full inliers for each of the origins separately
    int sizeOrigin=Rule->Origins.size();
    cout << Rule->Origins.size()<<endl;
    vector<bool *> PotentialCluster;
    PotentialCluster.push_back(OutlierIncluded);
    PotentialCluster.push_back(CSFIncluded);
    for(int o=0;o<sizeOrigin;o++){
        cout<<"Treating Origin "<<Rule->Origins[o]<<endl;
        if (Rule->Origins[o]>=10){
            int PVClass1=Rule->Origins[o]/10;
            int PVClass2=Rule->Origins[o]-PVClass1*10;
            vector<TreeEM *> PVClasses=SelectionPVClasses(TreeToAnalyse, PVClass1, PVClass2);
            cout<<"Selected PV"<<endl;
            if (PVClasses.size()>0) {
                float * AddedNormResp=AddNormResp(PVClasses);
                cout<< "Added PV"<<endl;
                float * LongNormResp=CreateLong(AddedNormResp, L2S, numel);
                bool * ThresholdedPV=ThresholdArray<float, bool>(LongNormResp, 0.2, numel);
                bool * PVIncluded=new bool[numel];
                ANDOperationBool(ThresholdedPV, MaskWorkData, PVIncluded, numel);
                cout<<"ThresholdedPV " << CountNonZero(ThresholdedPV,numel)<<endl;
                delete [] AddedNormResp;
                delete [] LongNormResp;
                PotentialCluster.push_back(PVIncluded);
                AddedNormResp=NULL;
                LongNormResp=NULL;
                nifti_image * PVNii=CreateNiiFromArray(PVIncluded, ResultsCoded, numel);
                nifti_set_filenames(PVNii, FilenameTreatedPV.c_str(), 0, 0);
                nifti_image_write(PVNii);
                nifti_image_free(PVNii);
                delete [] ThresholdedPV;
                ThresholdedPV=NULL;
            }
            
        }
        
    }
    cout <<"PV treated for outlier selection "<<endl;
    bool * SumPotentialCluster=AddArray(PotentialCluster, numel);
    nifti_image * PotentialClustNii=CreateNiiFromArray(SumPotentialCluster, ResultsCoded, numel);
    nifti_set_filenames(PotentialClustNii, FilenamePotential.c_str(), 0, 0);
    nifti_image_write(PotentialClustNii);
    nifti_image_free(PotentialClustNii);
    //    Then applying the rules of acceptance of the selected voxels based on intensity comparison
    //    Create the vector of DataCorrected intensities that will need to be checked
    cout<<"Applying rules"<<endl;
    int * ModalityCorr=GetCorrespondingModality(segment_analysis->vecModalities, Rule->Modalities);
    int sizeMahal=MahalVector.size();
    int sizeMod=Rule->Modalities.size();
    vector<float *> MahalDataVector;
    float * DataCorrectedData=static_cast<float*>(DataCorrected->data);
    vector<float*> DataCorrVector;
    vector<vector<float*> > MahalDistVectorMod;
    for (int c=0; c<sizeMahal; c++) {
        float * MahalDataTmp=static_cast<float*>(MahalVector[c]->data);
        vector<float *> MahalData;
        for (int m=0; m<sizeMod; m++) {
            MahalData.push_back(&MahalDataTmp[(ModalityCorr[m]+1)*numel]);
        }
        MahalDistVectorMod.push_back(MahalData);
    }
    
    for (int m=0; m<sizeMod; m++) {
        DataCorrVector.push_back(&DataCorrectedData[ModalityCorr[m]*numel]);
    }
    
    
    //    Perform the intensity comparison based on the rules set up in ClassesComparison, ComparisonType and ZScoreComparison
    cout<<"Performing intensity comparison"<<endl;
    int sizeComp=Rule->ClassesComparison.size();
    int * SelectedOutlierCode=new int[numel];
    for (int i=0; i<numel; i++) {
        SelectedOutlierCode[i]=0;
    }
    for (int r=0; r<sizeComp; r++) {
        for (int i=0; i<numel; i++) {
            if (SumPotentialCluster[i]>0) { //Then need to check
                bool flag_accept=1;
                for (int m=0; m<sizeMod; m++) {
                    float * MahalComp= MahalDistVectorMod[Rule->ClassesComparison[r][m]][m];
                    if(Rule->ComparisonType[r][m]==0){
                        flag_accept*=1;
                    }
                    else{
                        flag_accept*=((MahalComp[i]-Rule->ZScoreComparison[r][m])*Rule->ComparisonType[r][m]>0);
                    }
                }
                if (SelectedOutlierCode[i]==0) {
                    SelectedOutlierCode[i]=r*flag_accept;
                }
            }
        }
    }
    
    nifti_image * FinalOutliersSelected=CreateNiiFromArray(SelectedOutlierCode, ResultsCoded, numel);
    
    nifti_set_filenames(FinalOutliersSelected, FilenameFinal.c_str(), 0, 0);
    nifti_image_write(FinalOutliersSelected);
    
    //    Clearing of memory
    delete [] SelectedOutlierCode;
    delete [] ModalityCorr;
    delete [] SumPotentialCluster;
    //    delete [] RejectedZoneBoolPV;
    //    delete [] CSFFirstBool;
    delete [] CSFIHardSeg;
    delete [] GMIHardSeg;
    delete [] WMIHardSeg;
    delete [] OutIHardSeg;
    SelectedOutlierCode=NULL;
    ModalityCorr=NULL;
    SumPotentialCluster=NULL;
    //    RejectedZoneBoolPV=NULL;
    //    CSFFirstBool=NULL;
    CSFIHardSeg=NULL;
    GMIHardSeg=NULL;
    WMIHardSeg=NULL;
    OutIHardSeg=NULL;
    int sizePot=PotentialCluster.size();
    for (int o=0; o<sizePot; o++) {
        delete [] PotentialCluster[o];
        PotentialCluster[o]=NULL;
    }
    nifti_image_free(GMINii);
    nifti_image_free(CSFINii);
    nifti_image_free(WMINii);
    nifti_image_free(OutINii);
    nifti_image_free(SummarisedTemp);
    nifti_image_free(ResultsCoded);
    nifti_image_free(MaskFloatNii);
    nifti_image_free(MahalDistCSF);
    nifti_image_free(MahalDistGM);
    nifti_image_free(MahalDistWM);
    GMINii=NULL;
    CSFINii=NULL;
    WMINii=NULL;
    OutINii=NULL;
    SummarisedTemp=NULL;
    ResultsCoded=NULL;
    MaskFloatNii=NULL;
    MahalDistCSF=NULL;
    MahalDistGM=NULL;
    MahalDistWM=NULL;
    
    
    return FinalOutliersSelected;

    
}



// Returns the image of selected outliers according to the set of rules specified in Rule. Each
nifti_image * OutlierSelected(SimpleRule * Rule, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis ){
//    Create Names For Files to save
    string FilenamePA=nifti_makebasename(segment_analysis->filename_SegTot);
    
    
    int Index=FilenamePA.find_last_of('/');
    string FilenamePA_b=FilenamePA.substr(0,Index+1);
    string FilenamePA_e=FilenamePA.substr(Index+1,FilenamePA.length());
    string FilenameCodedOutliers=FilenamePA_b+"CodedOutliers_"+FilenamePA_e+".nii.gz";
    string FilenameAcceptedZone=FilenamePA_b+"AcceptedZone_"+FilenamePA_e+".nii.gz";

    string FilenameTreatedCSF=FilenamePA_b+"TreatedCSF_"+FilenamePA_e+".nii.gz";
    string FilenameTreatedGM=FilenamePA_b+"TreatedGM_"+FilenamePA_e+".nii.gz";
    string FilenameTreatedOut=FilenamePA_b+"TreatedGM_"+FilenamePA_e+".nii.gz";
    string FilenameTreatedPV=FilenamePA_b+"TreatedPV_"+FilenamePA_e+".nii.gz";
    string FilenameRejectedCSF=FilenamePA_b+"RejectedCSF_"+FilenamePA_e+".nii.gz";
    string FilenameRejectedGM=FilenamePA_b+"RejectedGM_"+FilenamePA_e+".nii.gz";
    string FilenameRejectedPV=FilenamePA_b+"RejectedPV_"+FilenamePA_e+".nii.gz";
    string FilenamePotential=FilenamePA_b+"PotentialInit_"+FilenamePA_e+".nii.gz";
    string FilenameFinal=FilenamePA_b+"FinalLC_"+FilenamePA_e+".nii.gz";
    string FilenameMahalGM=FilenamePA_b+"MahalGM_"+FilenamePA_e+".nii.gz";
    string FilenameMahalWM=FilenamePA_b+"MahalWM_"+FilenamePA_e+".nii.gz";
    string FilenameMahalCSF=FilenamePA_b+"MahalCSF_"+FilenamePA_e+".nii.gz";
    string FilenameRule=FilenamePA_b+"Rule_"+FilenamePA_e+".nii.gz";
    
    
    
//    First get all the needed standard elements:
    nifti_image * ResultsCoded = CodedOutliers(TreeToAnalyse, segment_analysis);
    int numel=TreeToAnalyse->GetNumberElements();
//    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int * L2S=TreeToAnalyse->GetL2S();
//    int * S2L=TreeToAnalyse->GetS2L();
    int IndexGM=segment_analysis->IndexGM;
    int IndexWM=segment_analysis->IndexWM;
    int IndexCSF=segment_analysis->IndexCSF;
    int IndexOut=segment_analysis->IndexOut;
    nifti_image * DataCorrected=TreeToAnalyse->GetDataImage();
    nifti_image * Mask=TreeToAnalyse->GetMask();
    bool * MaskData=static_cast<bool *>(Mask->data);
    
    
    //    Then get all the inlier segmentations as needed
    float * OutlierNormResp=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    float * LongOutlierNormResp=CreateLong(OutlierNormResp, L2S, numel);
    bool * OutlierSeg=ThresholdArray<float, bool>(LongOutlierNormResp, 0.5, numel);
    //nifti_image * OutlierNii=CreateNiiFromArray(OutlierSeg, ResultsCoded, numel);
    nifti_image * MaskFloatNii=CreateNiiFromArray(MaskData, ResultsCoded, numel);
    nifti_image * SummarisedTemp=HardSegmentationTemp(TreeToAnalyse, OutlierSeg, 0, segment_analysis);
    bool * GMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexGM);
    nifti_image * GMINii=CreateNiiFromArray(GMIHardSeg, ResultsCoded, numel);
    bool * WMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexWM);
    nifti_image * WMINii=CreateNiiFromArray(WMIHardSeg, ResultsCoded, numel);
    bool * CSFIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexCSF);
    nifti_image * CSFINii=CreateNiiFromArray(CSFIHardSeg, ResultsCoded, numel);
    bool * OutIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, IndexOut);
    nifti_image * OutINii=CreateNiiFromArray(OutIHardSeg, ResultsCoded, numel);

    
    nifti_image * MahalDistGM=MahalDistMaps(GMINii, MaskFloatNii, DataCorrected);
    nifti_image * MahalDistWM=MahalDistMaps(WMINii, MaskFloatNii, DataCorrected);
    nifti_image * MahalDistCSF=MahalDistMaps(CSFINii, MaskFloatNii, DataCorrected);
    
    nifti_set_filenames(MahalDistGM, FilenameMahalGM.c_str(), 0, 0);
    nifti_set_filenames(MahalDistWM, FilenameMahalWM.c_str(), 0, 0);
    nifti_set_filenames(MahalDistCSF, FilenameMahalCSF.c_str(), 0, 0);
    
    nifti_image_write(MahalDistCSF);
    nifti_image_write(MahalDistGM);
    nifti_image_write(MahalDistWM);
    
    vector<nifti_image *> MahalVector;
    MahalVector.reserve(3);
    cout<<MahalVector.size()<<endl;
    MahalVector.push_back(NULL);
    MahalVector.push_back(NULL);
    MahalVector.push_back(NULL);
    MahalVector[IndexGM]=MahalDistGM;
    MahalVector[IndexWM]=MahalDistWM;
    MahalVector[IndexCSF]=MahalDistCSF;
//    nifti_set_filenames(ResultsCoded, FilenameCodedOutliers.c_str(), 0, 0);
//    nifti_image_write(ResultsCoded);
    
    float * RejectedZone=new float[numel];
    float * PotentialCSFOut=new float[numel];
    float * PotentialGMOut=new float[numel];
    int Dim[3];
    int Shift[3];
    for (int d=0; d<3; d++) {
        Dim[d]=ResultsCoded->dim[d+1];
        if (d!=0) {
            Shift[d]=Dim[d-1]*Shift[d-1];
        }
        else{
            Shift[d]=1;
        }
    }
    for (int i=0; i<numel; i++) {
        RejectedZone[i]=0;
        PotentialCSFOut[i]=0;
        if(L2S[i]<0){
            RejectedZone[i]=1;
            PotentialCSFOut[i]=1;
            PotentialGMOut[i]=1;
        }
    }
    
    float * SumExtPriors=NULL;
    float * SumCSFPriors=NULL;
//    float * SumOutPriors;
    
    if (segment_analysis->flag_inPriorsOut && segment_analysis->flag_inPriorsICSF && segment_analysis->flag_inPriorsECSF && segment_analysis->flag_inPriorsCGM) {
//        nifti_image * CGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
        nifti_image * ECSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsECSF);
        nifti_image * ICSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
        nifti_image * OutPriors=ReadFromFilename(segment_analysis->filename_inPriorsOut);
        vector<float *> PriorsVector;
        vector<float *> PriorsVectorCSF;
        vector<float *> PriorsVectorOut;
        PriorsVector.push_back(static_cast<float *>(ECSFPriors->data));
        PriorsVector.push_back(static_cast<float*>(ICSFPriors->data));
        PriorsVector.push_back(static_cast<float*>(OutPriors->data));
        PriorsVectorCSF.push_back(static_cast<float *>(ECSFPriors->data));
        PriorsVectorCSF.push_back(static_cast<float *>(ICSFPriors->data));
        PriorsVectorCSF.push_back(static_cast<float *>(OutPriors->data));
       SumExtPriors= AddArray(PriorsVector, numel);
        SumCSFPriors=AddArray(PriorsVectorCSF, numel);
        nifti_image_free(ECSFPriors);
        nifti_image_free(ICSFPriors);
        nifti_image_free(OutPriors);
        ECSFPriors=NULL;
        ICSFPriors=NULL;
        OutPriors=NULL;
    }
    
    bool * RejectedZoneBoolPre=ThresholdArray<float, bool>(SumExtPriors, 0.9, numel);
    if (SumExtPriors!=NULL) {
        delete [] SumExtPriors;
        SumExtPriors=NULL;
        
    }

    bool * RejectedZoneBool=new bool[numel];
    
    XOROperationBool(RejectedZoneBoolPre, WMIHardSeg, RejectedZoneBool, numel);
    //bool * AcceptedZoneTemp=OpposeBoolArray(RejectedZoneBool, numel);
    if(segment_analysis->flag_Parc){
        cout<<"Using Parcellation"<<endl;
        nifti_image * ParcellationImage=ReadFromFilename(segment_analysis->filename_Parc);
        float * ParcellationData=static_cast<float*>(ParcellationImage->data);
        bool * RejectedZoneParc=ThresholdArray<float, bool>(ParcellationData, 100, ParcellationImage->nvox);
        
        // Rejected out part of cerebellum
        float * RejectedCerTemp=ThresholdArray<float, float>(ParcellationData, 38.5, numel);
        bool * RejectedZoneParc3=UpperThresholdArray<float, bool>(RejectedCerTemp, 40.5, numel);
        delete [] RejectedCerTemp;
        
        float * RejectedZoneParc2F=UpperThresholdArray<float, float>(ParcellationData, 1.5, ParcellationImage->nvox);
        int * CLECSF=ComponentLabeling(RejectedZoneParc2F, 26, Dim, Shift);
        int * VolCLECSF=GetVolumeLabels(CLECSF, numel);
        int numbECSF=GetMaxLabel(CLECSF, numel);
        for (int l=0; l<numbECSF; l++) {
            if (VolCLECSF[l]<500) {
                vector<int> IndicesLabel=GetListIndicesLabel(CLECSF, Dim, l+1);
                int LabelSize=IndicesLabel.size();
                for (int s=0; s<LabelSize; s++) {
                    RejectedZoneParc2F[IndicesLabel[s]]=0;
                }
            }
        }
//        if (segment_analysis->filename_inPriorsDGM) {
//            nifti_image * PriorsDGM=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
//            float * DGMData=static_cast<float*>(PriorsDGM->data);
//            bool * UTDGM=ThresholdArray<float, bool>(DGMData, 0.15, numel);
//            XOROperationBool(RejectedZoneParc2, UTDGM, RejectedZoneParc2, numel);
//            delete [] UTDGM;
//            nifti_image_free(PriorsDGM);
//        }
        bool * RejectedZoneParc2=TranscribeArray<float, bool>(RejectedZoneParc2F, numel);
            delete [] VolCLECSF;
            delete [] CLECSF;
            delete [] RejectedZoneParc2F;
        OROperationBool(RejectedZoneParc, RejectedZoneParc2, RejectedZoneParc, ParcellationImage->nvox);
        OROperationBool(RejectedZoneBool, RejectedZoneParc, RejectedZoneBool, ParcellationImage->nvox);
        OROperationBool(RejectedZoneBool, RejectedZoneParc3, RejectedZoneBool, numel);
        
        float * RejectedZoneFloat=TranscribeArray<bool, float>(RejectedZoneBool, numel);
        int * ComponentLabelRejected=ComponentLabeling(RejectedZoneFloat, 6, Dim, Shift);
        int * VolumeComponents=GetVolumeLabels(ComponentLabelRejected, numel);
        int numbLab=GetMaxLabel(ComponentLabelRejected, numel);
        cout <<"Island possible"<<numbLab<<endl;
        for (int l=0; l<numbLab; l++) {
            if(VolumeComponents[l]<50){
                cout<<"Filling a hole..."<<endl;
                vector<int> IndicesLabel=GetListIndicesLabel(ComponentLabelRejected, Dim, l+1);
                int LabelSize=IndicesLabel.size();
                for (int s=0; s<LabelSize; s++) {
                    RejectedZoneBool[IndicesLabel[s]]=0;
                }
            }
        }
        delete [] VolumeComponents;
        delete [] RejectedZoneFloat;
        delete [] ComponentLabelRejected;
        
        // Rejecting 3rd 4th and 5th ventricles
        RejectedCerTemp=ThresholdArray<float, float>(ParcellationData, 1.5, numel);
        bool * RejectedZoneParc4=UpperThresholdArray<float, bool>(RejectedCerTemp, 16.5, numel);
        delete [] RejectedCerTemp;
        
        // Rejecting 3rd ventricle post
        RejectedCerTemp=ThresholdArray<float, float>(ParcellationData, 46.5, numel);
        //bool * RejectedZoneParc6=UpperThresholdArray<float, bool>(RejectedCerTemp, 47.5, numel);
        delete [] RejectedCerTemp;
        
        // Rejecting lateral ventricles
        RejectedCerTemp=ThresholdArray<float, float>(ParcellationData, 49.5, numel);
        bool * RejectedZoneParc5=UpperThresholdArray<float, bool>(RejectedCerTemp, 53.5, numel);
        delete [] RejectedCerTemp;
        


        OROperationBool(RejectedZoneBool, RejectedZoneParc4, RejectedZoneBool, numel);
        OROperationBool(RejectedZoneBool, RejectedZoneParc5, RejectedZoneBool, numel);
        OROperationBool(RejectedZoneBool, RejectedZoneParc5, RejectedZoneBool, numel);

        nifti_image_free(ParcellationImage);
        delete [] RejectedZoneParc;
        delete [] RejectedZoneParc2;
        delete [] RejectedZoneParc3;
        delete [] RejectedZoneParc4;
        delete [] RejectedZoneParc5;
    }
    
   // bool * AcceptedZone =CheckAndFillHoles(AcceptedZoneTemp, Dim, Shift);
    bool * AcceptedZone=OpposeBoolArray(RejectedZoneBool, numel);
    nifti_image * AcceptedNii=CreateNiiFromArray(AcceptedZone, ResultsCoded, numel);
    nifti_set_filenames(AcceptedNii, FilenameAcceptedZone.c_str(), 0, 0);
    nifti_image_write(AcceptedNii);
    nifti_image_free(AcceptedNii);
    
    vector<TreeEM*> LeavesCSF;
    LeavesCSF.push_back(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexCSF));
    LeavesCSF.push_back(TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF));
    float * AddedNormRespCSF=AddNormResp(LeavesCSF);
    float * LongAddedNormRespCSF=CreateLong(AddedNormRespCSF, L2S, numel);
    
    
    vector<TreeEM*> LeavesOut;
    LeavesOut.push_back(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexOut));
    LeavesOut.push_back(TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexOut));
    float * AddedNormRespOut=AddNormResp(LeavesOut);
    float * LongAddedNormRespOut=CreateLong(AddedNormRespOut, L2S, numel);
    for (int i=0; i<numel; i++) {
        PotentialCSFOut[i]+=LongAddedNormRespCSF[i]+LongAddedNormRespOut[i];
        PotentialGMOut[i]+=LongAddedNormRespCSF[i]+LongAddedNormRespOut[i];
    }
    if (segment_analysis->flag_inPriorsOut) {
        nifti_image * OutPriors=ReadFromFilename(segment_analysis->filename_inPriorsOut);
        float *OutData=static_cast<float *>(OutPriors->data);
        for (int i=0; i<numel; i++) {
            RejectedZone[i]+=(OutData[i]>0.9);
            PotentialCSFOut[i]+=(OutData[i]>0.9);
            PotentialGMOut[i]+=(OutData[i]>0.9);
        }
        nifti_image_free(OutPriors);
        OutPriors=NULL;
    }
    
    if (segment_analysis->flag_inPriorsCGM) {
        nifti_image * CGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
        float * CGMData=static_cast<float*>(CGMPriors->data);
        for (int i=0; i<numel; i++) {
            PotentialGMOut[i]+=(CGMData[i]>0.8)*GMIHardSeg[i];
        }
        nifti_image_free(CGMPriors);
        CGMPriors=NULL;
    }
    
    bool * ThresholdCSFPriors=ThresholdArray<float, bool>(SumCSFPriors, 0.2, numel);
    if (SumCSFPriors!=NULL) {
        delete [] SumCSFPriors;
        SumCSFPriors=NULL;
    }
    bool * AcceptedZoneCSF=OpposeBoolArray(ThresholdCSFPriors, numel);
    ANDOperationBool(AcceptedZone, AcceptedZoneCSF, AcceptedZoneCSF, numel);
    
//    float * TreatedCSFPreFloat=MultiplyElementwiseChoose<float, bool, float>(PotentialCSFOut, AcceptedZoneCSF, numel);
    bool * TreatedCSFBool=ThresholdArray<float, bool>(PotentialCSFOut, 0.2, numel);
    int * TreatedCSFPre=TranscribeArray<bool, int>(TreatedCSFBool, numel);
    nifti_image * CSFNiiFirst=CreateNiiFromArray(TreatedCSFPre, ResultsCoded, numel);
//    bool * RejectedZoneBool=ThresholdArray<float, bool>(RejectedZone, 0.2, numel);
    bool * RejectedZoneBoolGM=ThresholdArray<float, bool>(PotentialGMOut, 0.2, numel);
    
            nifti_set_filenames(CSFNiiFirst, FilenameTreatedCSF.c_str(), 0, 0);
            nifti_image_write(CSFNiiFirst);
    nifti_image * GMNiiFirst=CreateNiiFromArray(PotentialGMOut, ResultsCoded, numel);
    nifti_set_filenames(GMNiiFirst, FilenameRejectedGM.c_str(), 0, 0);
    nifti_image_write(GMNiiFirst);
//    int * TreatedCSFPre=NULL;
    int * TreatedGMPre=NULL;
    int * TreatedOutPre=NULL;
    
    if (!segment_analysis->flag_CSFPre) {
        int * CSFFirst_CC=ComponentLabeling(CSFNiiFirst, 6);
        if (!segment_analysis->flag_Parc) {
            vector<int> LabelDiscardOutCSF=LabelToDiscard(CSFFirst_CC, RejectedZoneBoolPre, Dim, Shift);
            TreatedCSFPre=TreatingLabelFromSetDiscard(CSFFirst_CC, LabelDiscardOutCSF, numel);
            delete [] CSFFirst_CC;
            CSFFirst_CC=NULL;
        }
        MultiplyElementwiseChange(TreatedCSFPre, AcceptedZone, numel);

        nifti_image_free(CSFNiiFirst);
        CSFNiiFirst=CreateNiiFromArray(TreatedCSFPre, ResultsCoded, numel);
            nifti_set_filenames(CSFNiiFirst, FilenameTreatedCSF.c_str(), 0, 0);
            nifti_image_write(CSFNiiFirst);
        nifti_image_free(CSFNiiFirst);
        CSFNiiFirst=NULL;
    }
    else{
        nifti_image * TreatedCSFNii=ReadFromFilename(segment_analysis->filename_CSFPre);
        float * TreatedCSFFloat=static_cast<float*>(TreatedCSFNii->data);
        TreatedCSFPre=TranscribeArray<float, int>(TreatedCSFFloat, numel);
        nifti_image_free(TreatedCSFNii);
        TreatedCSFNii=NULL;
    }
    
    bool * TreatedCSFPreBool=TranscribeArray<int, bool>(TreatedCSFPre, numel);
    bool * RejectedZoneBoolNew=SubtractArray(RejectedZoneBool, TreatedCSFPreBool, numel);
    
    nifti_image * TreatedCSFNii=CreateNiiFromArray(TreatedCSFPre, ResultsCoded, numel);
    
    nifti_set_filenames(TreatedCSFNii, FilenameTreatedCSF.c_str(), 0, 0);
    nifti_image_write(TreatedCSFNii);
    cout <<"CSF treated for Outlier selection"<<endl;

    if (!segment_analysis->flag_GMPre && segment_analysis->flag_inPriorsCGM) {
        nifti_image * CGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
        float * CGMData=static_cast<float*>(CGMPriors->data);
        bool * CGMDataThresh=UpperThresholdArray<float,bool>(CGMData,0.2,numel);
        bool * GMPotential=MultiplyElementwiseChoose<bool, bool, bool>(CGMDataThresh, GMIHardSeg, numel);
        nifti_image * GMPot=CreateNiiFromArray(GMPotential, ResultsCoded, numel);
        int * GMFirst_CC=ComponentLabeling(GMPot, 6);
        TreatedGMPre=CopyArray(GMFirst_CC, numel);
        if (!segment_analysis->flag_Parc) {
            vector<int> LabelDiscardOutGM=LabelToDiscard(GMFirst_CC, RejectedZoneBool, Dim, Shift);
            TreatedGMPre=TreatingLabelFromSetDiscard(GMFirst_CC, LabelDiscardOutGM, numel);
        }
        
        MultiplyElementwiseChange(TreatedGMPre, AcceptedZone, numel);
        nifti_image * TreatedGMNii=CreateNiiFromArray(TreatedGMPre, ResultsCoded, numel);
        nifti_set_filenames(TreatedGMNii, FilenameTreatedGM.c_str(), 0, 0);
        nifti_image_write(TreatedGMNii);
        nifti_image_free(TreatedGMNii);
        TreatedGMNii=NULL;
        nifti_image_free(GMPot);
        GMPot=NULL;
        nifti_image_free(CGMPriors);
        CGMPriors=NULL;
        delete [] GMPotential;
        GMPotential=NULL;
        delete [] GMFirst_CC;
        GMFirst_CC=NULL;
        delete [] CGMDataThresh;
        CGMDataThresh=NULL;
    }
    else {
        nifti_image * TreatedGMNii=ReadFromFilename(segment_analysis->filename_GMPre);
        float * TreatedGMFloat=static_cast<float*>(TreatedGMNii->data);
        TreatedGMPre=TranscribeArray<float, int>(TreatedGMFloat, numel);
        nifti_image_free(TreatedGMNii);
        TreatedGMNii=NULL;
    }
    cout <<"GM treated for outlier selection"<<endl;
    
//    bool * RejectedZoneBoolPV=new bool[numel];
//    bool * RejectedZoneBoolPVPre=new bool [numel];
//    float * SumPriorsExt=NULL;
//    if (segment_analysis->flag_inPriorsCGM && segment_analysis->flag_inPriorsECSF && segment_analysis->flag_inPriorsOut) {
//        nifti_image * CGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
//        nifti_image * OutPriors=ReadFromFilename(segment_analysis->filename_inPriorsOut);
//        nifti_image * ECSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsECSF);
//        vector<float *> PriorsToSum;
//        PriorsToSum.push_back(static_cast<float*>(CGMPriors->data));
//        PriorsToSum.push_back(static_cast<float*>(ECSFPriors->data));
//        PriorsToSum.push_back(static_cast<float*>(OutPriors->data));
//        SumPriorsExt=AddArray(PriorsToSum, numel);
//        nifti_image_free(CGMPriors);
//        nifti_image_free(ECSFPriors);
//        nifti_image_free(OutPriors);
//        
//    }
//    bool * UpperThreshWM=ThresholdArray<float, bool>(SumPriorsExt, 0.9, numel);
//    bool * TreatedCSFBool=TranscribeArray<int, bool>(TreatedCSFPre, numel);
//    bool * CSFFirstBool=ThresholdArray<float, bool>(PotentialCSFOut,0.2, numel);
//    XOROperationBool(CSFFirstBool, TreatedCSFBool, RejectedZoneBoolPVPre, numel);
//    XOROperationBool(RejectedZoneBoolPVPre, UpperThreshWM, RejectedZoneBoolPV, numel);
    
//    nifti_image * RejectedPVNii=CreateNiiFromArray(RejectedZoneBoolPV, ResultsCoded, numel);
//    nifti_set_filenames(RejectedPVNii, FilenameRejectedPV.c_str(), 0, 0);
//    nifti_image_write(RejectedPVNii);
    
//    int * OutlierFirst_CC=ComponentLabeling(OutlierNii, 6);
//    vector<int> LabelDiscardOutOut=LabelToDiscard(OutlierFirst_CC, RejectedZoneBoolPV, Dim, Shift);
//    TreatedOutPre=TreatingLabelFromSetDiscard(OutlierFirst_CC, LabelDiscardOutOut, numel);
//    delete [] OutlierFirst_CC;
//    OutlierFirst_CC=NULL;
    cout << "Just before OutMultiplication "<< endl;
    TreatedOutPre=MultiplyElementwiseChoose<bool, bool, int>(OutlierSeg, AcceptedZoneCSF, numel);
    MultiplyElementwiseChange(TreatedOutPre, AcceptedZone, numel);
    cout << "Multiplication for out done "<<endl;
    nifti_image * TreatedOutNii=CreateNiiFromArray(TreatedOutPre, ResultsCoded, numel);
    nifti_set_filenames(TreatedOutNii, FilenameTreatedOut.c_str(), 0, 0);
    nifti_image_write(TreatedOutNii);
    nifti_image_free(TreatedOutNii);
    TreatedOutNii=NULL;
    
    cout <<"Out treated for outlier selection"<<endl;

    
//    if (segment_analysis->flag_inPriorsECSF) {
//        nifti_image *ECSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsECSF);
//        float *ECSFData=static_cast<float *>(ECSFPriors->data);
//        for (int i=0; i<numel; i++) {
//            RejectedZone[i]+=(ECSFData[i]>0.1)*LongAddedNormRespCSF[i];
//        }
//        nifti_image_free(ECSFPriors);
//        ECSFPriors=NULL;
//    }
    
//    AcceptedZoneWM=ThresholdArray<float, bool>(WMPriorsData, 0.1, numel);
//    AcceptedZoneMahalWM=ThresholdArray<float, bool>(<#T1 *ArrayToThreshold#>, <#T1 Threshold#>, <#int numel#>)
//    int * DirectWMI=TranscribeArray<bool, int>(WMIHardSeg, numel);
    
    
//    Get images of PV or full inliers for each of the origins separately
    int sizeOrigin=Rule->Origins.size();
    cout << Rule->Origins.size()<<endl;
    vector<int *> PotentialCluster;
    for(int o=0;o<sizeOrigin;o++){
        cout<<"Treating Origin "<<Rule->Origins[o]<<endl;
        if (Rule->Origins[o]==IndexCSF) {
            PotentialCluster.push_back(TreatedGMPre);
            cout<<"Cluster GMpre"<<endl;
        }
        else if (Rule->Origins[o]==IndexGM) {
            PotentialCluster.push_back(TreatedCSFPre);
            cout<<"Cluster CSFpre"<<endl;
        }
        else if(Rule->Origins[o]==-1){
            PotentialCluster.push_back(TreatedOutPre);
            cout<<"Cluster Outpre"<<endl;
        }
//        else if(Rule->Origins[o]==IndexWM){
//            PotentialCluster.push_back(DirectWMI);
//        }
        else{
            int PVClass1=Rule->Origins[o]/10;
            int PVClass2=Rule->Origins[o]-PVClass1*10;
            vector<TreeEM *> PVClasses=SelectionPVClasses(TreeToAnalyse, PVClass1, PVClass2);
            cout<<"Selected PV"<<endl;
            if (PVClasses.size()>0) {
                float * AddedNormResp=AddNormResp(PVClasses);
                cout<< "Added PV"<<endl;
                float * LongNormResp=CreateLong(AddedNormResp, L2S, numel);
                bool * ThresholdedPV=ThresholdArray<float, bool>(LongNormResp, 0.2, numel);
                cout<<"ThresholdedPV"<<endl;
                int * ThresholdedPVInt=MultiplyElementwiseChoose<bool, bool, int>(ThresholdedPV, AcceptedZone, numel);
                delete [] AddedNormResp;
                delete [] LongNormResp;
                PotentialCluster.push_back(ThresholdedPVInt);
                AddedNormResp=NULL;
                LongNormResp=NULL;
                nifti_image * PVNii=CreateNiiFromArray(ThresholdedPVInt, ResultsCoded, numel);
                nifti_set_filenames(PVNii, FilenameTreatedPV.c_str(), 0, 0);
                nifti_image_write(PVNii);
                nifti_image_free(PVNii);
                delete [] ThresholdedPV;
                ThresholdedPV=NULL;
            }

        }

    }
    
    cout <<"PV treated for outlier selection "<<endl;
    int * SumPotentialCluster=AddArray(PotentialCluster, numel);

    nifti_image * PotentialInit=CreateNiiFromArray(SumPotentialCluster, ResultsCoded, numel);
    nifti_set_filenames(PotentialInit, FilenamePotential.c_str(), 0, 0);
    nifti_image_write(PotentialInit);
    nifti_image_free(PotentialInit);
    PotentialInit=NULL;
    
//    Then applying the rules of acceptance of the selected voxels based on intensity comparison
//    Create the vector of DataCorrected intensities that will need to be checked
    cout<<"Applying rules"<<endl;
    int * ModalityCorr=GetCorrespondingModality(segment_analysis->vecModalities, Rule->Modalities);
    int sizeMahal=MahalVector.size();
    int sizeMod=Rule->Modalities.size();
    vector<float *> MahalDataVector;
    float * DataCorrectedData=static_cast<float*>(DataCorrected->data);
    vector<float*> DataCorrVector;
    vector<vector<float*> > MahalDistVectorMod;
    for (int c=0; c<sizeMahal; c++) {
        float * MahalDataTmp=static_cast<float*>(MahalVector[c]->data);
        vector<float *> MahalData;
        for (int m=0; m<sizeMod; m++) {
            MahalData.push_back(&MahalDataTmp[(ModalityCorr[m]+1)*numel]);
        }
        MahalDistVectorMod.push_back(MahalData);
    }

    for (int m=0; m<sizeMod; m++) {
        DataCorrVector.push_back(&DataCorrectedData[ModalityCorr[m]*numel]);
    }

//    Perform the intensity comparison based on the rules set up in ClassesComparison, ComparisonType and ZScoreComparison
    cout<<"Performing intensity comparison"<<endl;
    int sizeComp=Rule->ClassesComparison.size();
    int * SelectedOutlierCode=new int[numel];
    for (int i=0; i<numel; i++) {
        SelectedOutlierCode[i]=0;
    }
    for (int r=0; r<sizeComp; r++) {
        for (int i=0; i<numel; i++) {
           if (SumPotentialCluster[i]>0) { //Then need to check
               bool flag_accept=1;
               for (int m=0; m<sizeMod; m++) {
                  float * MahalComp= MahalDistVectorMod[Rule->ClassesComparison[r][m]][m];
                   if(Rule->ComparisonType[r][m]==0){
                       flag_accept*=1;
                   }
                   else{
                   flag_accept*=((MahalComp[i]-Rule->ZScoreComparison[r][m])*Rule->ComparisonType[r][m]>0);
                   }
               }
               if (SelectedOutlierCode[i]==0) {
                   SelectedOutlierCode[i]=r*flag_accept;
               }
            }
        }
    }
    
//    Then for each of the connected components (either individually on PV only or collectively), apply the Label to discard system
    cout<<"Test on final "<< endl;
        nifti_image * FinalResultTmp=CreateNiiFromArray(SelectedOutlierCode, ResultsCoded, numel);
    nifti_set_filenames(FinalResultTmp, FilenameRule.c_str(), 0, 0);
    nifti_image_write(FinalResultTmp);
    int * TreatedCCPre=NULL;
    if (segment_analysis->Opt_JointLC) { // Analysis jointly
        int * CC_Selected=ComponentLabeling(FinalResultTmp, 26);
        TreatedCCPre=CopyArray(CC_Selected, numel);
        if (!segment_analysis->flag_Parc) {
            
            vector<int> LabelDiscardOutCC=LabelToDiscard(CC_Selected, RejectedZoneBool, Dim, Shift);
            TreatedCCPre=TreatingLabelFromSetDiscard(CC_Selected, LabelDiscardOutCC, numel);
            
        }
        delete [] CC_Selected;

    }
    else {
        cout<<"No joint analysis"<<endl;
        vector<int *> TreatedCCPreVector;
        for (int o=0; o<PotentialCluster.size(); o++) {
            if (Rule->Origins[o]<10 ) { // If plain class, then already treated, can be included as it is
                int * TemporaryMult=MultiplyElementwiseChoose<int,int,int>(SelectedOutlierCode, PotentialCluster[o],numel);
                TreatedCCPreVector.push_back(TemporaryMult);
            }
            else {
                int * TemporaryMult=MultiplyElementwiseChoose<int,int,int>(SelectedOutlierCode,PotentialCluster[o], numel);
                nifti_image * TemporaryNii=CreateNiiFromArray(TemporaryMult, ResultsCoded, numel);
                int * TreatedCCPreTemp=NULL;
                if (!segment_analysis->flag_Parc) {
                    int * CCTemporary=ComponentLabeling(TemporaryNii, 6);
                    vector<int> LabelDiscardOutCCTemp=LabelToDiscard(CCTemporary, RejectedZoneBoolNew, Dim, Shift);
                    TreatedCCPreTemp =TreatingLabelFromSetDiscard(CCTemporary, LabelDiscardOutCCTemp, numel);
                                   delete [] CCTemporary;
                                    CCTemporary=NULL;
                }
                else{
                    TreatedCCPreTemp=CopyArray(TemporaryMult, numel);
                }
                
                MultiplyElementwiseChange(TreatedCCPreTemp, AcceptedZone, numel);
                TreatedCCPreVector.push_back(TreatedCCPreTemp);
 
                delete [] TemporaryMult;
                nifti_image_free(TemporaryNii);

                TemporaryNii=NULL;
                TemporaryMult=NULL;
            }
        }
        TreatedCCPre=AddArray(TreatedCCPreVector, numel);
        for (int o=0; o<sizeOrigin; o++) {
            delete [] TreatedCCPreVector[o];
            TreatedCCPreVector[o]=NULL;
        }
    }
    bool * AcceptedVoxels=TranscribeArray<int, bool>(TreatedCCPre, numel);
    int * FinalRule=MultiplyElementwiseChoose<bool,int,int>(AcceptedVoxels, SelectedOutlierCode, numel);
    nifti_image * FinalOutliersSelected=CreateNiiFromArray(FinalRule, ResultsCoded, numel);
    
    nifti_set_filenames(FinalOutliersSelected, FilenameFinal.c_str(), 0, 0);
    nifti_image_write(FinalOutliersSelected);

//    Clearing of memory
    delete [] SelectedOutlierCode;
    delete [] FinalRule;
    delete [] AcceptedVoxels;
    delete [] ModalityCorr;
    delete [] SumPotentialCluster;
    delete [] PotentialCSFOut;
    delete [] PotentialGMOut;
    delete [] RejectedZone;
    delete [] RejectedZoneBool;
//    delete [] RejectedZoneBoolPV;
    delete [] RejectedZoneBoolGM;
    delete [] TreatedCSFBool;
    delete [] TreatedCCPre;
//    delete [] CSFFirstBool;
    delete [] CSFIHardSeg;
    delete [] GMIHardSeg;
    delete [] WMIHardSeg;
    delete [] OutIHardSeg;
    delete [] LongAddedNormRespCSF;
    delete [] LongAddedNormRespOut;
    SelectedOutlierCode=NULL;
    FinalRule=NULL;
    AcceptedVoxels=NULL;
    ModalityCorr=NULL;
    SumPotentialCluster=NULL;
    PotentialCSFOut=NULL;
    PotentialGMOut=NULL;
    RejectedZone=NULL;
    RejectedZoneBool=NULL;
//    RejectedZoneBoolPV=NULL;
    RejectedZoneBoolGM=NULL;
    TreatedCSFBool=NULL;
    TreatedCCPre=NULL;
//    CSFFirstBool=NULL;
    CSFIHardSeg=NULL;
    GMIHardSeg=NULL;
    WMIHardSeg=NULL;
    OutIHardSeg=NULL;
    LongAddedNormRespOut=NULL;
    LongAddedNormRespCSF=NULL;
    for (int o=0; o<sizeOrigin; o++) {
        delete [] PotentialCluster[o];
        PotentialCluster[o]=NULL;
    }
    nifti_image_free(GMINii);
    nifti_image_free(CSFINii);
    nifti_image_free(WMINii);
    nifti_image_free(OutINii);
    nifti_image_free(SummarisedTemp);
    nifti_image_free(ResultsCoded);
    nifti_image_free(MaskFloatNii);
    nifti_image_free(MahalDistCSF);
    nifti_image_free(MahalDistGM);
    nifti_image_free(MahalDistWM);
    GMINii=NULL;
    CSFINii=NULL;
    WMINii=NULL;
    OutINii=NULL;
    SummarisedTemp=NULL;
    ResultsCoded=NULL;
    MaskFloatNii=NULL;
    MahalDistCSF=NULL;
    MahalDistGM=NULL;
    MahalDistWM=NULL;
    
    
    return FinalOutliersSelected;
}



//    
//    
//    bool * RejectedZoneDoubtfulIron=ThresholdArray<float,bool>(RejectedZone,0.15, numel);
//    bool * RejectedZoneDoubtfulLacunes=ThresholdArray<float,bool>(RejectedZone, 0.15,numel);
//    bool * AcceptedDGM=new bool[numel];
//    for (int i=0; i<numel; i++) {
//        AcceptedDGM[i]=0;
//    }
//    if (segment_analysis->flag_inPriorsDGM) {
//        nifti_image * DGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
//        float *DGMData=static_cast<float *>(DGMPriors->data);
//        for (int i=0; i<numel; i++) {
//            AcceptedDGM[i]=DGMData[i]>0.15?1:0;
//        }
//        nifti_image_free(DGMPriors);
//        DGMPriors=NULL;
//    }
//    bool * NonAcceptedDGM=OpposeBoolArray(AcceptedDGM, numel);
//    bool * RejectedZoneThr=ThresholdArray<float,bool>(RejectedZone,0.15,numel);
//    OROperationBool(RejectedZoneBoolPV, NonAcceptedDGM, RejectedZoneDoubtfulIron, numel);
//    OROperationBool(RejectedZoneBoolPV, AcceptedDGM, RejectedZoneDoubtfulLacunes, numel);
//    
//    
//    //        OROperationBool(RejectedZoneThr, NonAcceptedDGM, RejectedZoneDoubtfulIron, numel);
//    //        OROperationBool(RejectedZoneThr, AcceptedDGM, RejectedZoneDoubtfulLacunes, numel);
//    
//    //        Creation of the code selection vectors according to intensities
//    vector<float> OriginSelection;
//    vector<float> CodeSelectionIron;
//    vector<float> CodeSelectionLacunes;
//    vector<float> CodeSelectionWMH;
//    vector<float> CodeSelectionDoubtfulIL;
//    vector<float> CodeSelectionLacunesNotEnough;
//    OriginSelection.push_back(0);
//    OriginSelection.push_back(1);
//    OriginSelection.push_back(2);
//    
//    CodeSelectionDoubtfulIL.push_back(13);
//    CodeSelectionDoubtfulIL.push_back(23);
//    
//    CodeSelectionIron.push_back(14);
//    CodeSelectionIron.push_back(24);
//    
//    
//    
//    CodeSelectionLacunes.push_back(21);
//    CodeSelectionLacunes.push_back(12);
//    CodeSelectionLacunes.push_back(11);
//    
//    CodeSelectionLacunesNotEnough.push_back(22);
//    
//    CodeSelectionWMH.push_back(43);
//    CodeSelectionWMH.push_back(42);
//    CodeSelectionWMH.push_back(41);
//    CodeSelectionWMH.push_back(44);
//    CodeSelectionWMH.push_back(33);
//    CodeSelectionWMH.push_back(34);
//    CodeSelectionWMH.push_back(32);
//    CodeSelectionWMH.push_back(31);
//    
//    vector<TreeEM*> PVVectorGMCSF=SelectionPVClasses( TreeToAnalyse, segment_analysis->IndexGM, segment_analysis->IndexCSF);
//    
//    float * AddedNormResp=AddNormResp(PVVectorGMCSF);
//    float * LongNormResp=CreateLong(AddedNormResp, L2S, numel);
//    bool * ThresholdedPV=ThresholdArray<float, bool>(LongNormResp, 0.2, numel);
//    
//    nifti_image * PVNii=CreateNiiFromArray(ThresholdedPV, ResultsCoded, numel);
//    
//    
//    float * PotentialWMH=OutlierSelection(TreeToAnalyse, OutliersCode, OutliersOrigin, CodeSelectionWMH,  OriginSelection, RejectedZoneThr);
//    float * PotentialIron=OutlierSelection(TreeToAnalyse, OutliersCode, OutliersOrigin, CodeSelectionIron, OriginSelection, RejectedZoneDoubtfulIron);
//    float * PotentialLacunes=OutlierSelection(TreeToAnalyse, OutliersCode, OutliersOrigin, CodeSelectionLacunes, OriginSelection, RejectedZoneBoolPV);
//    float * PotentialLacunesNotEnough=OutlierSelection(TreeToAnalyse, OutliersCode, OutliersOrigin, CodeSelectionLacunesNotEnough, OriginSelection, RejectedZoneBoolPV);
//    float * PotentialDoubtfulLacunes=OutlierSelection(TreeToAnalyse, OutliersCode, OutliersOrigin, CodeSelectionDoubtfulIL, OriginSelection, RejectedZoneDoubtfulLacunes);
//    float * PotentialDoubtfulIron=OutlierSelection(TreeToAnalyse, OutliersCode, OutliersOrigin, CodeSelectionDoubtfulIL, OriginSelection, RejectedZoneDoubtfulIron);
//    float * PotentialLacunesB1=AddElementwise(PotentialDoubtfulLacunes, PotentialLacunes, numel);
//    float * PotentialIronB=AddElementwise(PotentialDoubtfulIron, PotentialIron, numel);
//    
//    nifti_image * LacunesNii=CreateNiiFromArray(PotentialLacunesB1, ResultsOrigin, numel);
//    nifti_image * IronNii=CreateNiiFromArray(PotentialIronB, ResultsOrigin, numel);
//    nifti_image * WMHNii=CreateNiiFromArray(PotentialWMH, ResultsOrigin, numel);
//    
//    
//    //        Performing the correction of the Iron deposition among the possible lacunes Correction done only on PV
//    
//    bool * PotentialIronBool=ThresholdArray<float, bool>(PotentialIronB, 0.2, numel);
//    //        nifti_image * PotIronRejNii=CreateNiiFromArray(PotentialIronBool, ResultsCoded, numel);
//    //        nifti_set_filenames(PotIronRejNii, "/Users/Carole/Documents/PhD/SABRE_80/TestIronRej.nii.gz", 0, 0);
//    //        nifti_image_write(PotIronRejNii);
//    //
//    //        nifti_image_free(PotIronRejNii);
//    
//    bool * DoubtfulLacunesBool=ThresholdArray<float, bool>(PotentialLacunesNotEnough, 0.2, numel);
//    nifti_image * DoubtfulLacunesNii=CreateNiiFromArray(DoubtfulLacunesBool, ResultsCoded, numel);
//    int * DoubtfulLacunes_CC=ComponentLabeling(DoubtfulLacunesNii, 6);
//    vector<int> LabelsDiscardedIron=LabelToDiscard(DoubtfulLacunes_CC, PotentialIronBool, Dim, Shift);
//    int * TreatedPVIronCorrected=TreatingLabelFromSetDiscard(DoubtfulLacunes_CC, LabelsDiscardedIron, numel);
//    //        nifti_image * TreatedIronCorrectedNii=CreateNiiFromArray(TreatedPVIronCorrected, ResultsCoded, numel);
//    //        nifti_set_filenames(TreatedIronCorrectedNii, "/Users/Carole/Documents/PhD/SABRE_80/TestPVIronCorrected.nii.gz", 0, 0);
//    float * TreatedPVIronCorrectedFloat=TranscribeArray<int, float>(TreatedPVIronCorrected, numel);
//    float * PotentialLacunesB=AddElementwise(TreatedPVIronCorrectedFloat, PotentialLacunesB1, numel);
//    nifti_image * LacunesNiiB=CreateNiiFromArray(PotentialLacunesB1, ResultsOrigin, numel);
//    
//    nifti_set_filenames(LacunesNii, FilenamePotLacunes.c_str(), 0, 0);
//    nifti_set_filenames(LacunesNiiB, FilenamePotLacunesB.c_str(), 0, 0);
//    nifti_set_filenames(WMHNii, FilenamePotWMH.c_str(), 0, 0);
//    nifti_set_filenames(IronNii, FilenamePotIron.c_str(), 0, 0);
//    
//    nifti_image_write(LacunesNii);
//    nifti_image_write(LacunesNiiB);
//    nifti_image_write(WMHNii);
//    nifti_image_write(IronNii);
//    
//    //        Building refuse zone for lacunes
//    
//    bool * RejectedZonePV=CopyArray(RejectedZoneBoolPV, numel);
//    //        bool * VentricleBool = VentricleSegmentationDirect(TreeToAnalyse,segment_analysis);
//    //        bool * RejectedZonePV=new bool[numel];
//    //        OROperationBool(RejectedZoneThr, VentricleBool, RejectedZonePV, numel);
//    nifti_image * RejectedPVNii=CreateNiiFromArray(RejectedZonePV, ResultsCoded, numel);
//    nifti_set_filenames(RejectedPVNii, FilenameRejected.c_str(), 0, 0);
//    nifti_image_write(RejectedPVNii);
//    nifti_image_free(RejectedPVNii);
//    RejectedPVNii=NULL;
//    
//    bool * BorderExtRejected=CreateBorderExtFromBool(RejectedZonePV, Dim, Shift, NULL);
//    nifti_image * RejectedPVNiiB=CreateNiiFromArray(BorderExtRejected, ResultsCoded, numel);
//    nifti_set_filenames(RejectedPVNiiB, FilenameRejectedBorder.c_str(), 0, 0);
//    nifti_image_write(RejectedPVNiiB);
//    nifti_image_free(RejectedPVNiiB);
//    RejectedPVNiiB=NULL;
//    
//    
//    float * LacunePV=AddElementwise(PotentialLacunesB, LongNormResp, numel);
//    bool * LacunePVB=ThresholdArray<float, bool>(LacunePV, 0.2, numel);
//    nifti_image * LacunePVNii=CreateNiiFromArray(LacunePVB, ResultsCoded, numel);
//    int * ComponentPV=ComponentLabeling(LacunePVNii, 6);
//    vector<int> LabelsLacPVDiscarded=LabelToDiscard(ComponentPV, RejectedZonePV, Dim, Shift);
//    int * TreatedPV=TreatingLabelFromSetDiscard(ComponentPV, LabelsLacPVDiscarded, numel);
//    delete [] ComponentPV;
//    delete [] LacunePVB;
//    delete [] LacunePV;
//    //        int * TreatedPV=TreatingPreLabel(ComponentPV,RejectedZonePV,Dim,Shift);
//    nifti_image * PVCCNii=CreateNiiFromArray(TreatedPV, ResultsCoded, numel);
//    nifti_set_filenames(PVCCNii, FilenamePVCC.c_str(), 0, 0);
//    nifti_set_filenames(LacunePVNii, FilenameLacunePV.c_str(), 0, 0);
//    nifti_image_write(LacunePVNii);
//    nifti_image_write(PVCCNii);
//    delete [] LongNormResp;
//    delete [] AddedNormResp;
//    delete [] ThresholdedPV;
//    delete [] PotentialLacunesB;
//    nifti_image_free(LacunePVNii);
//    nifti_image_free(PVCCNii);
//    
//    
//    //        nifti_image_write(TreatedIronCorrectedNii);
//    //        nifti_image_free(TreatedIronCorrectedNii);
//    int * TreatedTotLac=AddElementwiseInt(TreatedCSFPre, TreatedPV, numel);
//    
//    nifti_image * TreatedTotNii=CreateNiiFromArray(TreatedTotLac, ResultsCoded, numel);
//    //        nifti_set_filenames(TreatedTotNii, "/Users/Carole/Documents/PhD/SABRE_80/TestFinalPre.nii.gz", 0, 0);
//    //        nifti_image_write(TreatedTotNii);
//    int * ComponentLacTot=ComponentLabeling(TreatedTotNii, 6);
//    nifti_image * FinalLacNii=CreateNiiFromArray(ComponentLacTot, ResultsCoded, numel);
//    nifti_image_free(TreatedTotNii);
//    nifti_set_filenames(FinalLacNii, FilenameFinalLac.c_str(), 0, 0);
//    nifti_image_write(FinalLacNii);
//    
//    nifti_image_free(ResultsCoded);
//    nifti_image_free(ResultsOrigin);
//    nifti_image_free(LacunesNii);
//    nifti_image_free(WMHNii);
//    nifti_image_free(IronNii);
//    delete [] RejectedZoneThr;
//    delete [] RejectedZone;
//    delete [] ComponentLacTot;
//    delete [] TreatedTotLac;
//}


nifti_image * HolesJuxta(TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    if (!segment_analysis->flag_inPriorsDGM || !segment_analysis->flag_inPriorsCGM) {
        return NULL;
    }
    float * GMI=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
    float * WMI=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
    nifti_image * PriorsDGM=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
    nifti_image * PriorsCGM=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
    float * DGMData=static_cast<float*>(PriorsDGM->data);
    float * CGMData=static_cast<float*>(PriorsCGM->data);
    int numelmasked = TreeToAnalyse->GetNumberMaskedElements();
    int numel=TreeToAnalyse->GetNumberElements();
    int * L2S=TreeToAnalyse->GetL2S();
    
    bool * GMISeg=ThresholdArray<float, bool>(GMI, 0.8, numelmasked);
    bool * WMISeg=ThresholdArray<float, bool>(WMI, 0.5, numelmasked);
    bool * GMILong=CreateLong(GMISeg, L2S, numel);
    bool * WMILong=CreateLong(WMISeg, L2S, numel);
    bool * FinalIsland=new bool[numel];
    for (int i=0; i<numel; i++) {
        if (CGMData[i]<=0.1 || DGMData[i] ==0) {
            GMILong[i]=0;
        }
        FinalIsland[i]=0;
    }
    nifti_image * GMISegNii=CreateNiiFromArray(GMILong, PriorsDGM, numel);
    
    nifti_image * DistanceWM=EuclideanDistanceImage(PriorsDGM, WMILong, TreeToAnalyse->GetMask());
    float * DistWMData=static_cast<float*>(DistanceWM->data);
    int * GMIComp=ComponentLabeling(GMISegNii, 6);
    float VolumeVox=GMISegNii->pixdim[1]*GMISegNii->pixdim[2]*GMISegNii->pixdim[3];
    int * GMICompOrdered=OrderedVolumeLabel(GMIComp, 1, numel,VolumeVox);
    int numbLabels=GetMaxLabel(GMICompOrdered, numel);
    for (int l=0; l<numbLabels; l++) {
        bool * CompBool=CreateLesionBool(GMICompOrdered, l+1, numel);
        float MinDist=GetMin(DistWMData, CompBool, numel);
        int Size=GetLabelSize(l+1, GMICompOrdered, numel);
        if (Size<50&&MinDist<1.5) {
            OROperationBool(CompBool, FinalIsland, FinalIsland, numel);
        }
        delete [] CompBool;
    }
    nifti_image * ResultsIslands=CreateNiiFromArray(FinalIsland, PriorsDGM, numel);
    delete [] GMICompOrdered;
    delete [] GMIComp;
    delete [] WMISeg;
    delete [] WMILong;
    delete [] WMI;
    delete [] GMI;
    delete [] GMISeg;
    delete [] GMILong;
    nifti_image_free(DistanceWM);
    nifti_image_free(GMISegNii);
    nifti_image_free(PriorsDGM);
    nifti_image_free(PriorsCGM);
    return ResultsIslands;
}

void CreateInterfaceGMCSF(nifti_image * GIFParcellation, bool * Interface){
    float * ParcData = static_cast<float *>(GIFParcellation->data);
    vector<int> DimVector;
    for (int d =0;d<3;d++){
        DimVector.push_back(GIFParcellation->dim[d+1]);
    }
    int numel = GIFParcellation->nvox;
    float * CGM = new float[numel];
    float * ECSF = new float[numel];
    for (int i=0; i<numel; i++){
        CGM[i] = ParcData[i]>100?1:0;
        ECSF[i] = ParcData[i]<10?1:0;
    }
    float * DilECSF = Erosion_bis(ECSF, 3, DimVector, 0);
    for(int i=0;i<numel;i++){
        Interface[i] = DilECSF[i]*CGM[i]>0?1:0;
    }
    delete [] ECSF;
    delete [] CGM;
    delete [] DilECSF;
    return;
}

//From integer label array, ordered by decreasing size, build the features for each lesion (mainly to be used for lacunes)
vector<Outlier *> GetVectorOutliers(int * OrderedLabels,TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis, float mult_modify){
    int numel=TreeToAnalyse->GetNumberElements();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    int * L2S=TreeToAnalyse->GetL2S();
    int * S2L=TreeToAnalyse->GetS2L();
    bool * MaskLabel=TranscribeArray<int, bool>(OrderedLabels, numel);
    bool * MaskLabelShort=CreateShort(MaskLabel, S2L, numelmasked);
    nifti_image * CodedOutliersNii=CodedOutliersMask(TreeToAnalyse,MaskLabelShort, segment_analysis);
    delete [] MaskLabel;
    delete [] MaskLabelShort;
    MaskLabelShort=NULL;
    MaskLabel=NULL;
    float * CodedOutliersData=static_cast<float *>(CodedOutliersNii->data);
    vector<Outlier *> ResultVector;



//    nifti_image * DataImage=TreeToAnalyse->GetDataImage();
    float * DataCorr=CreateLongPaddingMulti<float>(TreeToAnalyse->GetDataBFCorrected(), 0, TreeToAnalyse->GetL2S(), numel, numbmodal);
    nifti_image * DataImage=CreateNiiFromArray(DataCorr, TreeToAnalyse->GetDataImage(), numel*numbmodal);
    float * DataCorrectedImage=static_cast<float*>(DataImage->data);
    nifti_image * DGMPriors = NULL;
    nifti_image * ICSFPriors = NULL;
    int Dim[3];
    int Shift[3];
    float PixDim[3];
    float VolumeVox=1;
    vector<int> DimVec;
    for (int d=0; d<3; d++) {
        Dim[d]=DataImage->dim[d+1];
        DimVec.push_back(Dim[d]);
        PixDim[d]=DataImage->pixdim[d+1];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
        VolumeVox*=PixDim[d];
    }
    if ( ! segment_analysis->flag_sc){
        cout << "Reading priors "<<endl;
    DGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
    ICSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
    }
    nifti_image * ECSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsECSF);
    nifti_image * CGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
    nifti_image * OutliersSeg=CreateNiiFromArray(OrderedLabels,CGMPriors, numel);
    nifti_image * MaskImage=TreeToAnalyse->GetMask();
    bool * GIFBoolCorr=new bool[numel];
    bool * GMECSF_interface = new bool[numel];
    bool * GMCer = new bool[numel];
    bool * GMCerEro = NULL;
    for (int i=0; i<numel; i++) {
        GIFBoolCorr[i]=0;
        GMECSF_interface[i]=0;
        GMCer[i]=0;
    }
    if (segment_analysis->flag_Parc) {
       nifti_image * GIFParcellation=ReadFromFilename(segment_analysis->filename_Parc);
        float * GIFData=static_cast<float*>(GIFParcellation->data);
        for (int i=0; i<numel; i++) {
            GIFBoolCorr[i]=0;
            if (GIFData[i]>100.5 && GIFData[i]<102.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>138.5 && GIFData[i]<140.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>166.5 && GIFData[i]<168.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>184.5 && GIFData[i]<188.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>200.5 && GIFData[i]<208.5){
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>38 && GIFData[i] < 41){
                GMCer[i] = 1;
            }
        }
        CreateInterfaceGMCSF(GIFParcellation, GMECSF_interface);
        nifti_image_free(GIFParcellation);
        GIFParcellation=NULL;
        GMCerEro = ErosionTemplate(GMCer, 3, DimVec, 1);

    }
    else if (segment_analysis->flag_inArtefact){
        nifti_image * GIFArtefacts=ReadFromFilename(segment_analysis->filename_Artefact);
        float * GIFArtData=static_cast<float*>(GIFArtefacts->data);
        for (int i=0; i<numel; i++) {
            if (GIFArtData[i]> 0.4) {
                GIFBoolCorr[i]=1;
            }
        }
        nifti_image_free(GIFArtefacts);
        GIFArtefacts=NULL;
    }
    else{
        cout << "No indication for artefacts"<<endl;

    }
    bool * MaskData=static_cast<bool*>(MaskImage->data);
    int maxLabel=GetMaxLabel(OrderedLabels, numel);


    bool * BorderMaskInB=NULL;
    if(segment_analysis->flag_RuleCorr && segment_analysis->flag_inLes){
        nifti_image * MaskExtent=ReadFromFilename(segment_analysis->filename_InLes);
        bool * MaskExtentData=TranscribeArray<float,bool>(static_cast<float*>(MaskExtent->data),MaskExtent->nvox);
        BorderMaskInB=CreateBorderFromBool(MaskExtentData,Dim,Shift);
        delete MaskExtentData;
//        nifti_image * BorderNii=CreateNiiFromArray(BorderMaskInB,MaskExtent,numel);
//        nifti_set_filenames(BorderNii,"/Users/csudre/Documents/Temp/TestSABRE/BorderTest.nii.gz",0,0);
//        nifti_image_write(BorderNii);
    }
    else if(segment_analysis->flag_GIFPriors){
        nifti_image * GIFPriors=ReadFromFilename(segment_analysis->filename_GIFPriors);
        float * GIFData=static_cast<float*>(GIFPriors->data);
        bool * MaskGM=ThresholdArray<float,bool>(&GIFData[2*numel],0.5,numel);
        bool * MaskGMOppose=OpposeBoolArray(MaskGM,numel);
        BorderMaskInB=CreateBorderFromBool(MaskGMOppose,Dim,Shift);

        nifti_image_free(GIFPriors);
        delete [] MaskGM;
        delete [] MaskGMOppose;
    }
    bool * OutliersBool=TranscribeArray<int, bool>(OrderedLabels, numel);
    bool * InliersBool=OpposeBoolArray(OutliersBool, numel);
    nifti_image * SummarisedTemp=HardSegmentationTemp(TreeToAnalyse,OutliersBool, 0, segment_analysis);
//    nifti_set_filenames(SummarisedTemp, "/Users/Carole/Documents/PhD/BAMBI_ADNI/TestSumm.nii.gz", 0, 0);
//    nifti_image_write(SummarisedTemp);
    bool * WMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, segment_analysis->IndexWM);
    bool * GMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, segment_analysis->IndexGM);
    bool * CSFIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, segment_analysis->IndexCSF);
    bool * OutIHardSegPre=ExtractTPFromNii<bool>(SummarisedTemp, segment_analysis->IndexOut);
    bool * OutIHardSeg=new bool[numel];
    bool * OppMask=OpposeBoolArray(MaskData, numel);
    OROperationBool(OppMask, OutIHardSegPre, OutIHardSeg, numel);
    delete [] OppMask;
    OppMask=NULL;
    bool * OutliersHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, 4);
    vector<bool *> VectorHardSeg;
    VectorHardSeg.push_back(GMIHardSeg);
    VectorHardSeg.push_back(WMIHardSeg);
    VectorHardSeg.push_back(CSFIHardSeg);
    VectorHardSeg.push_back(OutIHardSeg);
    VectorHardSeg.push_back(OutliersHardSeg);
    
    nifti_image * SummarisedTempOutliers=HardSegmentationTemp(TreeToAnalyse, InliersBool, 1, segment_analysis);
    bool * WMOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 1);
    bool * GMOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 0);
    bool * CSFOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 2);
    bool * OutOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 3);
    bool * InliersHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 4);
    vector<bool*> VectorHardSegO;
    VectorHardSegO.push_back(GMOHardSeg);
    VectorHardSegO.push_back(WMOHardSeg);
    VectorHardSegO.push_back(CSFOHardSeg);
    VectorHardSegO.push_back(OutOHardSeg);
    VectorHardSegO.push_back(InliersHardSeg);

    float * WMNormResp=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
    float * WMNormResp_copied = CopyArray<float>(WMNormResp, numelmasked);
    cout << "WM original weight is "<< GetSum(WMNormResp, numelmasked) << endl;
    if (segment_analysis->flag_checkInliers || segment_analysis->flag_FLAIRonly){
        vector<TreeEM*> LeavesToRemove = FindLesionClassesInliersFLAIRonly(TreeToAnalyse,segment_analysis->vecModalities,segment_analysis);
        for(int l=0;l<LeavesToRemove.size();l++){
            float*NormCorr = LeavesToRemove[l]->GetNormResp();
            for(int i=0;i<numelmasked;i++){
                WMNormResp_copied[i] -= NormCorr[i];
            }
        }
    }
    cout << "WM real weeight is "<< GetSum(WMNormResp_copied, numelmasked) << endl;
    bool * WMBool=ThresholdArray<float, bool>(WMNormResp_copied, 0.5, numelmasked);
    bool * WMBoolLong=CreateLong(WMBool, L2S, numel);
    nifti_image * WMSeg=CreateNiiFromArray(WMBoolLong, CGMPriors, numel);
    nifti_image * MahalDistance=MahalDistMaps(WMSeg, OutliersSeg, DataImage);
    nifti_image * MaskFloat=CreateNiiFromArray(MaskData, WMSeg, numel);
    nifti_image * MahalDistanceElse=MahalDistMaps(WMSeg, MaskFloat, DataImage);
    nifti_image_free(MaskFloat);
//    nifti_set_filenames(MahalDistanceElse, "/Users/Carole/Documents/PhD/SABRE_80/TestMahalDist", 0, 0);
//    nifti_image_write(MahalDistanceElse);
    //float * MahalData=static_cast<float*>(MahalDistance->data);
    float * MahalDataElse=static_cast<float*>(MahalDistanceElse->data);
    bool * PotentialOutliersSeg=TranscribeArray<int, bool>(OrderedLabels, numel);
    bool * OpposedPotOutSeg=OpposeBoolArray(PotentialOutliersSeg, numel);
    bool * BorderExt=CreateBorderFromBool(OpposedPotOutSeg, Dim, Shift);
    bool * BorderInt=CreateBorderExtFromBool(OpposedPotOutSeg, Dim, Shift, NULL);
    int GravityMaskIndex=GetCenterGravity(MaskData, Dim);
    int * GravityMaskCoord=CorrespondingCoordinates(GravityMaskIndex, Dim, Shift);
    
    bool * DilatedMask=ErosionTemplate(MaskData, 3, DimVec, 0);
    nifti_image * DilatedNii=CreateNiiFromArray(DilatedMask, WMSeg, numel);
    nifti_image * DistanceOutNii=EuclideanDistanceImage(SummarisedTemp, OutIHardSeg, DilatedNii);
//    nifti_set_filenames(DistanceOutNii, "/Users/Carole/Documents/PhD/SABRE_80/TestOutDistance.nii.gz", 0, 0);
//    nifti_image_write(DistanceOutNii);
    nifti_image_free(DilatedNii);
    nifti_image * DistanceGMNii=EuclideanDistanceImage(SummarisedTemp, GMIHardSeg, MaskImage);
    nifti_image * DistanceWMNii=EuclideanDistanceImage(SummarisedTemp, WMIHardSeg, MaskImage);
    nifti_image * DistanceCSFNii=EuclideanDistanceImage(SummarisedTemp, CSFIHardSeg, MaskImage);
    delete [] DilatedMask;
    DilatedMask=NULL;
    
    float * DistanceGM=static_cast<float *>(DistanceGMNii->data);
    float * DistanceWM=static_cast<float *>(DistanceWMNii->data);
    float * DistanceCSF=static_cast<float *>(DistanceCSFNii->data);
    float * DistanceOut=static_cast<float *>(DistanceOutNii->data);
    
//    Get the bool corresponding needed and corresponding to the available priors
    float * DGMData = NULL;
    float * ICSFData=NULL;
    if (!segment_analysis->flag_sc){
    DGMData=static_cast<float *>(DGMPriors->data);
    ICSFData=static_cast<float*>(ICSFPriors->data);
    }
    float * ECSFData=static_cast<float*>(ECSFPriors->data);
    float * CGMData=static_cast<float*>(CGMPriors->data);
    if (segment_analysis->flag_GIFPriors){
        nifti_image* GIFPriors = ReadFromFilename(segment_analysis->filename_GIFPriors);
        float * GIFData= static_cast<float*>(GIFPriors->data);
        float * GIFWM = & GIFData[3*numel];
        for(int i=0;i<numel;i++){
            CGMData[i]=GIFWM[i]>0.5?0:CGMData[i];
        }
        nifti_image_free(GIFPriors);
    }
    bool * SPBool = NULL;
    nifti_image * DistanceSPNii=NULL;
    float * DistanceSP=NULL;
    bool * VentricleBool=NULL;
    float * DGMICSFData = NULL;
    float* DistanceVentricle=NULL;
    bool * DGMBool = NULL;
    nifti_image * DistanceVentriclesNii = NULL;
    if (! segment_analysis->flag_sc){
    DGMBool=TranscribeArray<float, bool>(DGMData, numel);
    DGMICSFData=AddElementwise(DGMData, ICSFData, numel);
    SPBool=ThresholdArray<float, bool>(DGMICSFData, 0.25, numel);

    cout << "Creation Ventricles "<<endl;
    if (segment_analysis->flag_VentrSeg==0){
         VentricleBool=VentricleSegmentationDirect(TreeToAnalyse, segment_analysis);
    }
    else{
        VentricleBool=VentricleSegmentationFromParc(TreeToAnalyse,segment_analysis);
    }
    DistanceVentriclesNii=EuclideanDistanceImage(SummarisedTemp, VentricleBool, MaskImage);
     DistanceVentricle=static_cast<float*>(DistanceVentriclesNii->data);
    }

    if (segment_analysis->flag_MNITemplate && segment_analysis->flag_MNITransform) {
        nifti_image * QuadrantResult= CreateQuadrantResult(ICSFPriors, segment_analysis,TreeToAnalyse);
        bool * CGMBool=ThresholdArray<float, bool>(CGMData, 0.5, numel);
        bool * SPRegion=PotentialSPRegion(QuadrantResult, VentricleBool, CGMBool, segment_analysis->ThresholdSP, MaskImage);
        DistanceSPNii=EuclideanDistanceImage(QuadrantResult, SPRegion, MaskImage);
        DistanceSP=static_cast<float*>(DistanceSPNii->data);
        delete [] SPRegion;
        delete [] CGMBool;
    }
    
//    Creating the needed pointers to have everything ready for the texture descriptors creation
    
    vector<float *> DataCorrectedVector;
    vector<vector<float *> > DataTotalShiftVector;
    float * DataCorrected=TreeToAnalyse->GetDataBFCorrected();
    float * Data=CreateLongPaddingMulti<float>(DataCorrected,0,TreeToAnalyse->GetL2S(),numel,numbmodal);
    float  PixDimShift[6];
    for (int m=0; m<numbmodal; m++) {
        vector<float *> DataShiftVector;
        DataCorrectedVector.push_back(&DataCorrected[numelmasked*m]);
        
        for (int d=0; d<3; d++) {
            if (m==0) {
                PixDimShift[2*d]=PixDim[d];
                PixDimShift[2*d+1]=PixDim[d];
            }
            int Trans [3];
            for (int d1=0; d1<3; d1++) {
                Trans[d1]=0;
            }
            Trans[d]=1;
            DataShiftVector.push_back(ShiftedVersion(&DataCorrected[numelmasked*m], Trans, Dim, Shift, L2S, S2L, numelmasked));
            for (int d1=0; d1<3; d1++) {
                Trans[d1]=0;
            }
            Trans[d]=-1;
            DataShiftVector.push_back(ShiftedVersion(&DataCorrected[numelmasked*m], Trans, Dim, Shift, L2S, S2L, numelmasked));
        }
        DataTotalShiftVector.push_back(DataShiftVector);
    }
    
    vector<float> QuantilisationValues;
    QuantilisationValues.push_back(0.1);
    QuantilisationValues.push_back(0.5);
    QuantilisationValues.push_back(0.9);
    
//    Once everything has been created to be used in a general manner, look into each cluster of voxels.
//    maxLabel=50; // Temp to activate for tests
    for (int l=0; l<maxLabel; l++) {
        cout<<"Treating label "<<l+1<<"...";
        Outlier* OutlierToPush=new Outlier();
        bool * LesionBool = CreateLesionBool(OrderedLabels, l+1, numel);
        if (CountNonZero(LesionBool,numel)==0){
            cout << "Problem with the selected label"<<endl;
            continue;
        }
//        cout << "Lesion created"<<endl;
        bool * LesionBoolShort=CreateShort(LesionBool, S2L, numelmasked);
//        cout << "Short lesion created"<<endl;
        float * Edginess=EdginessBorderLesion(LesionBool,&MahalDataElse[numel],Dim,Shift,PixDim,numel,numbmodal);
//        cout << "Edginess created"<<endl;
        bool * BorderIntLes=MultiplyElementwiseChoose<bool,bool,bool>(LesionBool,BorderInt,numel);
//        cout << "BorderIntLes created"<<endl;
        for (int m=0;m<numbmodal+1;m++){
            float * EdgStats=GetStatisticData(&Edginess[m*numel],BorderIntLes,numel);
//            cout << CountNonZero(BorderIntLes,numel)<<" non zero in Border"<<endl;
//            float * TempEdginess=new float[9];
//            for (int d=0; d<9; d++) {
//                TempEdginess[d]=EdgStats[d];
//            }
//            delete [] EdgStats;
            OutlierToPush->Edginess.push_back(EdgStats);
        }

//        cout << "Edginess done "<< endl;

        delete [] Edginess;
        delete [] BorderIntLes;
        if (GIFBoolCorr!=NULL) {
            OutlierToPush->PropArtefact=GetProportionAbove<bool,bool>(GIFBoolCorr, LesionBool, 0, numel);
        }
        if(GMCerEro != NULL){
            OutlierToPush->PropCer=GetProportionAbove<bool,bool>(GMCer, LesionBool, 0, numel);
            OutlierToPush->PropCerEro = GetProportionAbove<bool, bool>(GMCerEro, LesionBool, 0,numel);
        }
        if(GMECSF_interface!=NULL){
            OutlierToPush->PropInterface=GetProportionAbove<bool,bool>(GMECSF_interface, LesionBool, 0, numel);
            cout << "PropInterface is "<< OutlierToPush->PropInterface << "for label "<< l+1 << endl;
        }
//        cout << "Prop artefact done if there"<<endl;
        if(BorderMaskInB!=NULL){
            OutlierToPush->PropBorderExtent=GetProportionAbove<bool,bool>(BorderMaskInB,LesionBool,0,numel);
        }
        float MeanOC=GetMeanData(CodedOutliersData, LesionBool, numel);
        OutlierToPush->MeanOC=MeanOC;
        int SizeLesion=CountNonZero(LesionBool, numel);
        OutlierToPush->Volume=CountNonZero(LesionBool, numel)*VolumeVox;
        int GravityLesIndex=GetCenterGravity(LesionBool, Dim);
        int * GravityLesCoord=CorrespondingCoordinates(GravityLesIndex, Dim, Shift);
//        Taking care of measures related to centre of gravity
        float DistGrav=0;
        for (int d=0; d<3; d++) {
            OutlierToPush->CentreGravity.push_back(GravityLesCoord[d]);
            OutlierToPush->VectorDiffGrav.push_back(-1*(GravityMaskCoord[d]-GravityLesCoord[d])*PixDim[d]);
            DistGrav+=pow_int(OutlierToPush->VectorDiffGrav[d],2);
        }
        OutlierToPush->DistanceGrav=sqrtf(DistGrav);
        delete [] GravityLesCoord;
        GravityLesCoord=NULL;
        log_verb(LOG_DEBUG, "Gravity calculation done", segment_analysis->verbose_level);
        
//        Taking care of measures relative to proportion of belonging to tissues segmented referring to priors (DGMBelonging, SPPotProp, PropICSF)
        bool * DGMandLesion=new bool[numel];
        bool * SPandLesion=new bool [numel];
        ANDOperationBool(DGMBool, LesionBool, DGMandLesion, numel);
        ANDOperationBool(SPBool, LesionBool, SPandLesion, numel);
        int DGMBoolBelongingNumber=CountNonZero(DGMandLesion, numel);
        int SPandLesionCount=CountNonZero(SPandLesion, numel);
        OutlierToPush->DGMBelonging=(bool)DGMBoolBelongingNumber;
        OutlierToPush->SPPotProp=(float)SPandLesionCount/SizeLesion;
        OutlierToPush->PropICSF=GetProportionAbove<float, bool>(ICSFData, LesionBool, 0.25, numel);
        OutlierToPush->PropCGM=GetProportionAbove<float,bool>(CGMData, LesionBool, 0.4, numel);
        OutlierToPush->PropDGM=GetProportionAbove<float,bool>(DGMData, LesionBool, 0.4, numel);
        OutlierToPush->PropECSF=GetProportionAbove<float,bool>(ECSFData, LesionBool, 0.25, numel);
        log_verb(LOG_DEBUG, "Proportion DGM ICSF ECSF CGM done", segment_analysis->verbose_level);
        delete [] DGMandLesion;
        delete [] SPandLesion;
        DGMandLesion=NULL;
        SPandLesion=NULL;
        

        
//        Taking care of what is related to the BoundingBox
        int LabelSize=CountNonZero(LesionBool, numel);
        int * BoundingBox=FindBoundingBox(LesionBool, Dim, Shift);

        int * ListCoordinates=ListCoordinatesBoolSeg(LesionBool, Dim, Shift);
        float * ListCoordF=ListCoordinatesTransformed(ListCoordinates, LabelSize, PixDim);
        float * ListCoordF_demeaned = DemeanListCoordinates(ListCoordF, LabelSize, 3, segment_analysis->verbose_level);
        stringstream ss;
        ss << LabelSize;
        log_verb(LOG_DEBUG, "Demeaning of indices done"+ss.str(), segment_analysis->verbose_level);
//        float * Test=TreeToAnalyse->TransposeMatrix(ListCoordF, LabelSize, 3);
        SVD ResultSVD=SVD(ListCoordF_demeaned, LabelSize, 3);
        log_verb(LOG_DEBUG, "SVD demeaned done", segment_analysis->verbose_level);
//        SVD ResultSVDTest=SVD(Test,3,LabelSize);
//        SVD TestStrange=SVD(ListCoordF,3,LabelSize);
        delete [] ListCoordinates;
        delete [] ListCoordF_demeaned;
        delete [] ListCoordF;
        ListCoordF_demeaned=NULL;
        ListCoordF=NULL;
        ListCoordinates=NULL;
        OutlierToPush->SVDEigen=new float[3];
        for (int d=0; d<3; d++) {
            OutlierToPush->SVDEigen[d]=ResultSVD.getSingularValues()[d];
        }
//        delete [] Test;
        float * ExtentBB=new float[3];
        float * ExtentVolumeBB=new float[3];
        for (int d=0; d<3; d++) {
            ExtentBB[d]=PixDim[d]*abs(BoundingBox[d*2]-BoundingBox[d*2+1]);
            ExtentVolumeBB[d]=ExtentBB[d]/OutlierToPush->Volume;
        }
        OutlierToPush->ExtentBB=ExtentBB;
        OutlierToPush->ExtentVolumeBB=ExtentVolumeBB;
        OutlierToPush->BoundingBox=BoundingBox;
        log_verb(LOG_DEBUG, "BB calculation done", segment_analysis->verbose_level);
        bool * BoundingBoxBool=CreateBoolBoundingBox(BoundingBox, Dim);
        bool * BorderAndBBInt=new bool[numel];
        ANDOperationBool(BoundingBoxBool, BorderInt, BorderAndBBInt, numel);
        OutlierToPush->Surface=CountNonZero(BorderAndBBInt, numel)*VolumeVox;
        OutlierToPush->SAV=OutlierToPush->Surface/(1.0*OutlierToPush->Volume);
        OutlierToPush->Compactness=pow_int(OutlierToPush->Surface, 3)/pow_int(OutlierToPush->Volume, 2);
        bool * DilatedBB=ErosionTemplate(BoundingBoxBool,3,DimVec,0);
        bool * BorderAndBBExt=new bool[numel];
        ANDOperationBool(DilatedBB, BorderExt, BorderAndBBExt, numel);
        log_verb(LOG_DEBUG, "SAV Compactness calculation done", segment_analysis->verbose_level);
        if(GIFBoolCorr!=NULL){

            OutlierToPush->ProportionNeighbourArtefact=GetProportionAbove<bool,bool>(BorderAndBBExt,GIFBoolCorr,0,numel);
        }
        float * ProportionBorder=ProportionFromBoolVec(BorderAndBBExt,VectorHardSeg,numel);
        float PropWMHNeigh=GetProportionAbove<float,bool>(&MahalDataElse[min(numbmodal,2)*numel], BorderAndBBExt, 3, numel);
        OutlierToPush->PropWMHNeigh=PropWMHNeigh;
        OutlierToPush->ProportionNeighbour=ProportionBorder;
        log_verb(LOG_DEBUG, "Proportion neighbour calculation done", segment_analysis->verbose_level);
        float * RatioBoundingBox=ProportionFromBoolVec(BoundingBoxBool, VectorHardSeg, numel);
        OutlierToPush->RatioBoundingBox=RatioBoundingBox;
        float * ProportionOrigin=ProportionFromBoolVec(LesionBool, VectorHardSegO, numel);
        OutlierToPush->ProportionOrigin=ProportionOrigin;
        delete [] BoundingBoxBool;
        delete [] BorderAndBBExt;
        delete [] BorderAndBBInt;
        delete [] DilatedBB;
        DilatedBB=NULL;
        BoundingBoxBool=NULL;
        BorderAndBBInt=NULL;
        BorderAndBBExt=NULL;
//        cout << "Bounding Box done "<<endl;
//        Taking care of the measures related to intensities and Mahalanobis distance;
        float * MeanMahal=GetMeanDataMulti(MahalDataElse, LesionBool, numel,numbmodal+1);
        float * MinMahal=GetMinDataMulti(MahalDataElse,LesionBool,numel,numbmodal+1);
        float * MaxMahal=GetMaxDataMulti(MahalDataElse,LesionBool,numel,numbmodal+1);
        
        float * MeanLesion=GetMeanDataMulti<float,bool>(DataCorrectedImage, LesionBool, numel,numbmodal);
        float * VarianceLesion=GetVarianceDataMulti<float,bool>(DataCorrectedImage, LesionBool, numel,numbmodal);
        
        vector<float *> MahalQuantVector=GetQuantilesMulti(MahalDataElse, LesionBool, numel, numbmodal+1, QuantilisationValues);
        
        OutlierToPush->Variance=VarianceLesion;
        OutlierToPush->Mean=MeanLesion;
        OutlierToPush->MahalVec.push_back(MinMahal);
        OutlierToPush->MahalVec.push_back(MeanMahal);
        OutlierToPush->MahalVec.push_back(MaxMahal);
        for (int m=0; m<numbmodal+1; m++) {
             OutlierToPush->MahalVecQuant.push_back(MahalQuantVector[m]);
        }
       log_verb(LOG_DEBUG, "Mahal Vec calculation done", segment_analysis->verbose_level);
        float MinDistSP=-1;
        float MaxDistSP=-1;
        float MeanDistSP=-1;
        
//        Getting all the data for distance to inliers
//        First Min
        float MinDistVentricle=GetMin(DistanceVentricle, LesionBool, numel);
        float MinDistGM=GetMin(DistanceGM,LesionBool,numel);
        float MinDistWM=GetMin(DistanceWM,LesionBool,numel);
        float MinDistCSF=GetMin(DistanceCSF,LesionBool, numel);
        float MinDistOut=GetMin(DistanceOut,LesionBool, numel);
        if (DistanceSP !=NULL) {
             MinDistSP=GetMin(DistanceSP, LesionBool, numel);
        }
//        Then Mean
        float MeanDistVentricle=GetMeanData(DistanceVentricle, LesionBool, numel);
        float MeanDistGM=GetMeanData(DistanceGM, LesionBool, numel);
        float MeanDistWM=GetMeanData(DistanceWM, LesionBool, numel);
        float MeanDistCSF=GetMeanData(DistanceCSF, LesionBool, numel);
        float MeanDistOut=GetMeanData(DistanceOut, LesionBool, numel);
        if (DistanceSP !=NULL) {
            MeanDistSP=GetMeanData(DistanceSP, LesionBool, numel);
        }
//        Finally Max
        float MaxDistVentricle=GetMaxArrayMasked(DistanceVentricle, LesionBool, numel);
        float MaxDistGM=GetMaxArrayMasked(DistanceGM,LesionBool,numel);
        float MaxDistWM=GetMaxArrayMasked(DistanceWM, LesionBool, numel);
        float MaxDistCSF=GetMaxArrayMasked(DistanceCSF, LesionBool, numel);
        float MaxDistOut=GetMaxArrayMasked(DistanceOut, LesionBool, numel);
        if (DistanceSP !=NULL) {
             MaxDistSP=GetMaxArrayMasked(DistanceSP, LesionBool, numel);
        }
//        Putting everything in the relevant vectors:
        OutlierToPush->DistanceVentricle.push_back(MinDistVentricle);
        OutlierToPush->DistanceVentricle.push_back(MeanDistVentricle);
        OutlierToPush->DistanceVentricle.push_back(MaxDistVentricle);
        
        OutlierToPush->DistanceGMI.push_back(MinDistGM);
        OutlierToPush->DistanceGMI.push_back(MeanDistGM);
        OutlierToPush->DistanceGMI.push_back(MaxDistGM);
        
        OutlierToPush->DistanceWMI.push_back(MinDistWM);
        OutlierToPush->DistanceWMI.push_back(MeanDistWM);
        OutlierToPush->DistanceWMI.push_back(MaxDistWM);
        
        OutlierToPush->DistanceCSFI.push_back(MinDistCSF);
        OutlierToPush->DistanceCSFI.push_back(MeanDistCSF);
        OutlierToPush->DistanceCSFI.push_back(MaxDistCSF);
        
        OutlierToPush->DistanceOutI.push_back(MinDistOut);
        OutlierToPush->DistanceOutI.push_back(MeanDistOut);
        OutlierToPush->DistanceOutI.push_back(MaxDistOut);
        
        OutlierToPush->DistanceSP.push_back(MinDistSP);
        OutlierToPush->DistanceSP.push_back(MeanDistSP);
        OutlierToPush->DistanceSP.push_back(MaxDistSP);
        log_verb(LOG_DEBUG, "distances calculation done", segment_analysis->verbose_level);
//        cout << "Distance done "<< endl;
//        Taking care of Texture elements
        for (int m=0; m<numbmodal; m++) {
            TextureDescriptors * TextureOutlier=CreateTextureDescriptors(LesionBoolShort, DataCorrectedVector[m], DataTotalShiftVector[m], PixDimShift, TreeToAnalyse);
            OutlierToPush->Texture.push_back(TextureOutlier);
            TextureDescriptors1 * TextureOutlier1=CreateTextureDescriptors1(LesionBoolShort, DataCorrectedVector[m], TreeToAnalyse);
            OutlierToPush->Texture1.push_back(TextureOutlier1);
        }
        log_verb(LOG_DEBUG, "texture calculation done", segment_analysis->verbose_level);
        if(segment_analysis->flag_sc){
            OutlierToPush->OutlierClass=OutlierTypePreliminary(OutlierToPush,segment_analysis, mult_modify);
            OutlierToPush->LesionType=OutlierRefinement(OutlierToPush,segment_analysis);
        }
//        cout<<"Texture done "<< endl;
        OutlierToPush->OutlierClass=OutlierTypePreliminary(OutlierToPush,segment_analysis, mult_modify);
//        cout <<"PreliminaryType done "<< endl;
        log_verb(LOG_DEBUG, "outlier class "
                            " done", segment_analysis->verbose_level);
        OutlierToPush->LesionType=OutlierRefinement(OutlierToPush, segment_analysis);
//        cout << "Lesion Type done "<< endl;
        log_verb(LOG_DEBUG, "lesion type  done", segment_analysis->verbose_level);
        if(segment_analysis->flag_infarcts){
            int IndexWM=segment_analysis->IndexWM;
            if ((OutlierToPush->OutlierClass == -5 || OutlierToPush->LesionType==-14) && OutlierToPush->Volume>2000 && OutlierToPush->ProportionNeighbour[IndexWM]>0.2){
                OutlierToPush->LesionType=InfarctLesion;
                OutlierToPush->OutlierClass=Infarct;
                cout <<"Potential non lesion infarct for label "<< l+1<<endl;
            }
             if(OutlierToPush->Volume>2000 && OutlierToPush->PropCGM>0.2 && (OutlierToPush->DistanceVentricle[0]>OutlierToPush->DistanceGMI[0] || (OutlierToPush->DistanceGMI[0]<=OutlierToPush->DistanceVentricle[0]+0.5 && OutlierToPush->PropWMHNeigh>0.04)) && OutlierToPush->ProportionNeighbour[segment_analysis->IndexOut]<0.05){
                 OutlierToPush->LesionType=InfarctLesion;
                 OutlierToPush->OutlierClass=Infarct;
                 cout <<"Potential lesion infarct for label "<< l+1<<endl;
             }
             if(OutlierToPush->Volume>500 && OutlierToPush->PropCGM>0.15 &&  ( (OutlierToPush->DistanceGMI[0]<=OutlierToPush->DistanceVentricle[0]+0.5)) && OutlierToPush->PropWMHNeigh*OutlierToPush->Volume>75 && OutlierToPush->ProportionNeighbour[segment_analysis->IndexOut]<0.05 && OutlierToPush->MahalVecQuant[1][0]<-3){
                 if(OutlierToPush->PropWMHNeigh>0.3){
                     if(OutlierToPush->PropCGM>0.5 || OutlierToPush->PropECSF>0.1){
                         OutlierToPush->LesionType=InfarctLesion;
                         OutlierToPush->OutlierClass=Infarct;
                         cout <<"Potential lesion infarct for label "<< l+1<<endl;
                     }
                 }
                 else{
                     OutlierToPush->LesionType=InfarctLesion;
                     OutlierToPush->OutlierClass=Infarct;
                     cout <<"Potential lesion infarct for label "<< l+1<<endl;
                 }

             }
        }
        if(OutlierToPush->LesionType>0 && segment_analysis->flag_correctionLevel==3){
            bool FPDGM=CheckForFPDGM(OutlierToPush->PropDGM, OutlierToPush->MahalVec, numbmodal);
            OutlierToPush->LesionType=FPDGM==1?NonLesion:OutlierToPush->LesionType;
            OutlierToPush->OutlierClass=FPDGM==1?SuspIron:OutlierToPush->OutlierClass;
        }
//        cout << "Clearing for new "<< endl;
        delete [] LesionBool;
        delete [] LesionBoolShort;
        LesionBool=NULL;
        LesionBoolShort=NULL;
        ResultVector.push_back(OutlierToPush);
        cout<<"treated !"<<endl;
    }
    
//    Clearing and deleting all that has been calculated once for everything
    if(! segment_analysis->flag_sc){
        nifti_image_free(DistanceVentriclesNii);
        nifti_image_free(ICSFPriors);
        nifti_image_free(DGMPriors);
        delete [] VentricleBool;
        delete [] DGMBool;
        delete [] SPBool;
        delete [] DGMICSFData;
    }
    nifti_image_free(OutliersSeg);
    nifti_image_free(ECSFPriors);
    nifti_image_free(DistanceCSFNii);
    nifti_image_free(DistanceGMNii);
    nifti_image_free(DistanceWMNii);
    nifti_image_free(DistanceOutNii);
    nifti_image_free(MahalDistance);
    nifti_image_free(MahalDistanceElse);
    nifti_image_free(WMSeg);
    nifti_image_free(SummarisedTempOutliers);
    nifti_image_free(SummarisedTemp);
    delete[] Data;
    if (DistanceSPNii!=NULL) {
        nifti_image_free(DistanceSPNii);
        DistanceSPNii=NULL;
    }
    OutliersSeg=NULL;
    ICSFPriors=NULL;
    DGMPriors=NULL;
    ECSFPriors=NULL;
    DistanceGMNii=NULL;
    DistanceCSFNii=NULL;
    DistanceWMNii=NULL;
    DistanceOutNii=NULL;
    DistanceVentriclesNii=NULL;
    MahalDistance=NULL;
    WMSeg=NULL;
    SummarisedTemp=NULL;
    SummarisedTempOutliers=NULL;
    
    for (int m=0; m<numbmodal; m++) {
        for (int d=0; d<6; d++) {
            delete [] DataTotalShiftVector[m][d];
            DataTotalShiftVector[m][d]=NULL;
        }
    }
    if (GIFBoolCorr!=NULL) {
        delete [] GIFBoolCorr;
        GIFBoolCorr=NULL;
    }
    if(GMCerEro !=NULL){
        delete [] GMCerEro;
        GMCerEro=NULL;
    }
    delete [] GMCer;
    delete [] GravityMaskCoord;
    delete [] WMOHardSeg;
    delete [] WMIHardSeg;
    delete [] GMOHardSeg;
    delete [] GMIHardSeg;
    delete [] CSFOHardSeg;
    delete [] CSFIHardSeg;
    delete [] OutOHardSeg;
    delete [] OutIHardSeg;
    delete [] OutliersHardSeg;
    delete [] InliersHardSeg;
    delete [] BorderExt;
    delete [] BorderInt;
    delete [] OpposedPotOutSeg;
    delete [] PotentialOutliersSeg;
    delete [] WMBool;
    delete [] WMBoolLong;
    delete [] OutIHardSegPre;
    delete [] GMECSF_interface;
    OutIHardSegPre=NULL;
    GMCer = NULL;
    WMBoolLong=NULL;
    WMBool=NULL;
    PotentialOutliersSeg=NULL;
    OpposedPotOutSeg=NULL;
    VentricleBool=NULL;
    DGMBool=NULL;
    SPBool=NULL;
    DGMICSFData=NULL;
    GravityMaskCoord=NULL;
    WMOHardSeg=NULL;
    WMIHardSeg=NULL;
    GMIHardSeg=NULL;
    GMOHardSeg=NULL;
    CSFOHardSeg=NULL;
    CSFIHardSeg=NULL;
    OutOHardSeg=NULL;
    OutIHardSeg=NULL;
    OutliersHardSeg=NULL;
    InliersHardSeg=NULL;
    BorderInt=NULL;
    BorderExt=NULL;
    return ResultVector;
}






vector<vector<Outlier*> > GetVectorOutliersMultiType(float* MultiDataValue, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis, float mult_modify){
    int numel=TreeToAnalyse->GetNumberElements();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    int * L2S=TreeToAnalyse->GetL2S();
    int * S2L=TreeToAnalyse->GetS2L();
    bool * MaskLabel=TranscribeArray<float, bool>(MultiDataValue, numel);
    bool * MaskLabelShort=CreateShort(MaskLabel, S2L, numelmasked);
    nifti_image * CodedOutliersNii=CodedOutliersMask(TreeToAnalyse,MaskLabelShort, segment_analysis);
    delete [] MaskLabel;
    delete [] MaskLabelShort;
    MaskLabelShort=NULL;
    MaskLabel=NULL;
    float * CodedOutliersData=static_cast<float *>(CodedOutliersNii->data);
    vector<vector<Outlier *> > ResultVector;
//    nifti_image * DataImage=TreeToAnalyse->GetDataImage();
    float * DataCorr=CreateLongPaddingMulti<float>(TreeToAnalyse->GetDataBFCorrected(), 0, TreeToAnalyse->GetL2S(), numel, numbmodal);
    nifti_image * DataImage=CreateNiiFromArray(DataCorr, TreeToAnalyse->GetDataImage(), numel*numbmodal);
    int Dim[3];
    int Shift[3];
    float PixDim[3];
    float VolumeVox=1;
    vector<int> DimVec;
    for (int d=0; d<3; d++) {
        Dim[d]=DataImage->dim[d+1];
        DimVec.push_back(Dim[d]);
        PixDim[d]=DataImage->pixdim[d+1];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
        VolumeVox*=PixDim[d];
    }
    float * DataCorrectedImage=static_cast<float*>(DataImage->data);
    nifti_image * DGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
    nifti_image * ICSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
    nifti_image * ECSFPriors=ReadFromFilename(segment_analysis->filename_inPriorsECSF);
    nifti_image * CGMPriors=ReadFromFilename(segment_analysis->filename_inPriorsCGM);
    
    nifti_image * MaskImage=TreeToAnalyse->GetMask();
    cout << "All images read" << endl;
    bool * GIFBoolCorr=new bool[numel];
    bool * GMECSF_interface = new bool[numel];
    bool * GMCer = new bool[numel];
    bool * GMCerEro = NULL;
    for (int i=0; i<numel; i++) {
        GIFBoolCorr[i]=0;
        GMECSF_interface[i]=0;
        GMCer[i]=0;
    }
    if (segment_analysis->flag_Parc) {
       nifti_image * GIFParcellation=ReadFromFilename(segment_analysis->filename_Parc);
        float * GIFData=static_cast<float*>(GIFParcellation->data);
        for (int i=0; i<numel; i++) {
            GIFBoolCorr[i]=0;
            if (GIFData[i]>100.5 && GIFData[i]<102.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>138.5 && GIFData[i]<140.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>166.5 && GIFData[i]<168.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>184.5 && GIFData[i]<188.5) {
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>200.5 && GIFData[i]<208.5){
                GIFBoolCorr[i]=1;
            }
            if (GIFData[i]>38 && GIFData[i] < 41){
                GMCer[i] = 1;
            }
        }
        CreateInterfaceGMCSF(GIFParcellation, GMECSF_interface);
        nifti_image_free(GIFParcellation);
        GIFParcellation=NULL;
        GMCerEro = ErosionTemplate(GMCer, 3, DimVec, 1);

    }
    else if (segment_analysis->flag_inArtefact){
        nifti_image * GIFArtefacts=ReadFromFilename(segment_analysis->filename_Artefact);
        float * GIFArtData=static_cast<float*>(GIFArtefacts->data);
        for (int i=0; i<numel; i++) {
//            GIFBoolCorr[i]=0;
            if (GIFArtData[i]> 0.4) {
                GIFBoolCorr[i]=1;
            }
        }
        nifti_image_free(GIFArtefacts);
        GIFArtefacts=NULL;
    }
    bool * MaskData=static_cast<bool*>(MaskImage->data);
//    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    vector<int> ValuesToAnalyse=GetListValues<float,int>(MultiDataValue,numel);

//    bool * OutliersBool=TranscribeArray<int, bool>(OrderedLabels, numel);
//    bool * InliersBool=OpposeBoolArray(OutliersBool, numel);
//    float * OutliersFloat=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    bool * ShortOutlierBool=ThresholdArray<float, bool>(TreeToAnalyse->GetNodeOutlier()->GetNormResp(), 0.5, numelmasked);
    bool * OutliersBool=CreateLong(ShortOutlierBool, L2S, numel);
    nifti_image * OutliersSeg=CreateNiiFromArray(OutliersBool,DGMPriors, numel);
    nifti_image * SummarisedTemp=HardSegmentationTemp(TreeToAnalyse,OutliersBool, 0, segment_analysis);
    bool * InliersBool=OpposeBoolArray(OutliersBool, numel);
//    nifti_set_filenames(SummarisedTemp, "/Users/Carole/Documents/PhD/BAMBI_ADNI/TestSumm.nii.gz", 0, 0);
//    nifti_image_write(SummarisedTemp);
    bool * WMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, 1);
    bool * GMIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, 0);
    bool * CSFIHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, 2);
    bool * OutIHardSegPre=ExtractTPFromNii<bool>(SummarisedTemp, 3);
    bool * OutIHardSeg=new bool[numel];
    bool * OppMask=OpposeBoolArray(MaskData, numel);
    OROperationBool(OppMask, OutIHardSegPre, OutIHardSeg, numel);
    delete [] OppMask;
    OppMask=NULL;
    bool * OutliersHardSeg=ExtractTPFromNii<bool>(SummarisedTemp, 4);
    vector<bool *> VectorHardSeg;
    VectorHardSeg.push_back(GMIHardSeg);
    VectorHardSeg.push_back(WMIHardSeg);
    VectorHardSeg.push_back(CSFIHardSeg);
    VectorHardSeg.push_back(OutIHardSeg);
    VectorHardSeg.push_back(OutliersHardSeg);
    
    nifti_image * SummarisedTempOutliers=HardSegmentationTemp(TreeToAnalyse, InliersBool, 1, segment_analysis);
    bool * WMOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 1);
    bool * GMOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 0);
    bool * CSFOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 2);
    bool * OutOHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 3);
    bool * InliersHardSeg=ExtractTPFromNii<bool>(SummarisedTempOutliers, 4);
    vector<bool*> VectorHardSegO;
    VectorHardSegO.push_back(GMOHardSeg);
    VectorHardSegO.push_back(WMOHardSeg);
    VectorHardSegO.push_back(CSFOHardSeg);
    VectorHardSegO.push_back(OutOHardSeg);
    VectorHardSegO.push_back(InliersHardSeg);
    
    float * WMNormResp=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
    float * WMNormResp_copied = CopyArray<float>(WMNormResp, numelmasked);
    cout << "WM original weight is "<< GetSum(WMNormResp, numelmasked) << endl;
    if (segment_analysis->flag_checkInliers || segment_analysis->flag_FLAIRonly){
        vector<TreeEM*> LeavesToRemove = FindLesionClassesInliersFLAIRonly(TreeToAnalyse,segment_analysis->vecModalities,segment_analysis);
        for(int l=0;l<LeavesToRemove.size();l++){
            float*NormCorr = LeavesToRemove[l]->GetNormResp();
            for(int i=0;i<numelmasked;i++){
                WMNormResp_copied[i] -= NormCorr[i];
            }
        }
    }
    cout << "WM real weeight is "<< GetSum(WMNormResp_copied, numelmasked) << endl;
    bool * WMBool=ThresholdArray<float, bool>(WMNormResp_copied, 0.5, numelmasked);
    bool * WMBoolLong=CreateLong(WMBool, L2S, numel);
    nifti_image * WMSeg=CreateNiiFromArray(WMBoolLong, DGMPriors, numel);
    nifti_image * MahalDistance=MahalDistMaps(WMSeg, OutliersSeg, DataImage);
    nifti_image * MaskFloat=CreateNiiFromArray(MaskData, WMSeg, numel);
    nifti_image * MahalDistanceElse=MahalDistMaps(WMSeg, MaskFloat, DataImage);
    nifti_image_free(MaskFloat);
//    nifti_set_filenames(MahalDistanceElse, "/Users/Carole/Documents/PhD/SABRE_80/TestMahalDist", 0, 0);
//    nifti_image_write(MahalDistanceElse);
    //float * MahalData=static_cast<float*>(MahalDistance->data);
    float * MahalDataElse=static_cast<float*>(MahalDistanceElse->data);
    bool * PotentialOutliersSeg=TranscribeArray<float, bool>(MultiDataValue, numel);
    bool * OpposedPotOutSeg=OpposeBoolArray(PotentialOutliersSeg, numel);
    bool * BorderExt=CreateBorderFromBool(OpposedPotOutSeg, Dim, Shift);
    bool * BorderInt=CreateBorderExtFromBool(OpposedPotOutSeg, Dim, Shift, NULL);
    int GravityMaskIndex=GetCenterGravity(MaskData, Dim);
    int * GravityMaskCoord=CorrespondingCoordinates(GravityMaskIndex, Dim, Shift);
    
    bool * DilatedMask=ErosionTemplate(MaskData, 3, DimVec, 0);
    nifti_image * DilatedNii=CreateNiiFromArray(DilatedMask, WMSeg, numel);
    nifti_image * DistanceOutNii=EuclideanDistanceImage(SummarisedTemp, OutIHardSeg, DilatedNii);
//    nifti_set_filenames(DistanceOutNii, "/Users/Carole/Documents/PhD/SABRE_80/TestOutDistance.nii.gz", 0, 0);
//    nifti_image_write(DistanceOutNii);
    nifti_image_free(DilatedNii);
    nifti_image * DistanceGMNii=EuclideanDistanceImage(SummarisedTemp, GMIHardSeg, MaskImage);
    nifti_image * DistanceWMNii=EuclideanDistanceImage(SummarisedTemp, WMIHardSeg, MaskImage);
    nifti_image * DistanceCSFNii=EuclideanDistanceImage(SummarisedTemp, CSFIHardSeg, MaskImage);
    delete [] DilatedMask;
    DilatedMask=NULL;

    
    float * DistanceGM=static_cast<float *>(DistanceGMNii->data);
    float * DistanceWM=static_cast<float *>(DistanceWMNii->data);
    float * DistanceCSF=static_cast<float *>(DistanceCSFNii->data);
    float * DistanceOut=static_cast<float *>(DistanceOutNii->data);
    
    //    Get the bool corresponding needed and corresponding to the available priors
    
    float * DGMData=static_cast<float *>(DGMPriors->data);
    float * ICSFData=static_cast<float*>(ICSFPriors->data);
    float * ECSFData=static_cast<float*>(ECSFPriors->data);
    float * CGMData=static_cast<float*>(CGMPriors->data);
    bool * DGMBool=TranscribeArray<float, bool>(DGMData, numel);
    float * DGMICSFData=AddElementwise(DGMData, ICSFData, numel);
    bool * SPBool=ThresholdArray<float, bool>(DGMICSFData, 0.25, numel);
    bool * VentricleBool=NULL;
    if (segment_analysis->flag_VentrSeg==0){
         VentricleBool=VentricleSegmentationDirect(TreeToAnalyse, segment_analysis);
    }
    else{
        VentricleBool=VentricleSegmentationFromParc(TreeToAnalyse,segment_analysis);
    }
    nifti_image * DistanceVentriclesNii=EuclideanDistanceImage(SummarisedTemp, VentricleBool, MaskImage);

    nifti_set_filenames(DistanceVentriclesNii,"/Users/csudre/Documents/Test.nii.gz",0,0);
    nifti_image_write(DistanceVentriclesNii);
    nifti_image * DistanceSPNii=NULL;
    float * DistanceSP=NULL;
    float * DistanceVentricle=static_cast<float*>(DistanceVentriclesNii->data);
    if (segment_analysis->flag_MNITemplate && segment_analysis->flag_MNITransform) {
        nifti_image * QuadrantResult= CreateQuadrantResult(ICSFPriors, segment_analysis,TreeToAnalyse);
        bool * CGMBool=ThresholdArray<float, bool>(CGMData, 0.5, numel);
        bool * SPRegion=PotentialSPRegion(QuadrantResult, VentricleBool, CGMBool, segment_analysis->ThresholdSP, MaskImage);
        DistanceSPNii=EuclideanDistanceImage(QuadrantResult, SPRegion, MaskImage);
        DistanceSP=static_cast<float*>(DistanceSPNii->data);
        delete [] SPRegion;
        delete [] CGMBool;
    }
    
    //    Creating the needed pointers to have everything ready for the texture descriptors creation
    
    vector<float *> DataCorrectedVector;
    vector<vector<float *> > DataTotalShiftVector;
    float * DataCorrected=TreeToAnalyse->GetDataBFCorrected();
    float  PixDimShift[6];
    for (int m=0; m<numbmodal; m++) {
        vector<float *> DataShiftVector;
        DataCorrectedVector.push_back(&DataCorrected[numelmasked*m]);
        
        for (int d=0; d<3; d++) {
            if (m==0) {
                PixDimShift[2*d]=PixDim[d];
                PixDimShift[2*d+1]=PixDim[d];
            }
            int Trans [3];
            for (int d1=0; d1<3; d1++) {
                Trans[d1]=0;
            }
            Trans[d]=1;
            DataShiftVector.push_back(ShiftedVersion(&DataCorrected[numelmasked*m], Trans, Dim, Shift, L2S, S2L, numelmasked));
            for (int d1=0; d1<3; d1++) {
                Trans[d1]=0;
            }
            Trans[d]=-1;
            DataShiftVector.push_back(ShiftedVersion(&DataCorrected[numelmasked*m], Trans, Dim, Shift, L2S, S2L, numelmasked));
        }
        DataTotalShiftVector.push_back(DataShiftVector);
    }
    
    vector<float> QuantilisationValues;
    QuantilisationValues.push_back(0.1);
    QuantilisationValues.push_back(0.5);
    QuantilisationValues.push_back(0.9);
    
    //    Once everything has been created to be used in a general manner, look into each cluster of voxels.
    int numbvalues=ValuesToAnalyse.size();
    for (int v=0; v<numbvalues; v++) {
        vector<Outlier*> NewVectorToPush;
        stringstream val;
        val << v;
        string FilenamePA=nifti_makebasename(segment_analysis->filename_inToAnalyse);
        int Index=FilenamePA.find_last_of('/');
        string FilenamePA_b=FilenamePA.substr(0,Index+1);
        if(segment_analysis->flag_outputDir){
            FilenamePA_b=segment_analysis->name_outputDir;
        }
        string FilenamePA_e=FilenamePA.substr(Index+1,FilenamePA.length());
        string FilenameSaveClassif=FilenamePA_b+"ClassifLes_"+val.str() + "_"+FilenamePA_e+".nii.gz";
        string FilenameSaveConnect=FilenamePA_b+"ConnectLes_"+val.str()+"_"+FilenamePA_e+".nii.gz";
        float * ValuesChosen=EqualArray<float, float>(MultiDataValue, (float)ValuesToAnalyse[v], numel);
        int * ComponentValues=ComponentLabeling(ValuesChosen, segment_analysis->Neigh, Dim, Shift);
                int * ResultClassif=new int[2*numel];
        for(int i=0;i<2*numel;i++){
            ResultClassif[i]=0;
        }
        int * OrderedLabels=OrderedVolumeLabel(ComponentValues, 0, numel);
        nifti_image * ComponentValueNii=CreateNiiFromArray(OrderedLabels,ECSFPriors,numel);

        int maxLabel=GetMaxLabel(OrderedLabels, numel);
    
            for (int l=0; l<maxLabel; l++) {
        cout<<"Treating label "<<l+1<<"...";

        Outlier* OutlierToPush=new Outlier();
        bool * LesionBool = CreateLesionBool(OrderedLabels, l+1, numel);
        bool * LesionBoolShort=CreateShort(LesionBool, S2L, numelmasked);
        if (GIFBoolCorr!=NULL) {
            OutlierToPush->PropArtefact=GetProportionAbove<bool,bool>(GIFBoolCorr, LesionBool, 0.5, numel);
        }
        if(GMECSF_interface!=NULL){
            OutlierToPush->PropInterface=GetProportionAbove<bool,bool>(GMECSF_interface, LesionBool, 0, numel);
            cout << "PropInterface is "<< OutlierToPush->PropInterface << "for label "<< l+1 << endl;
        }
        if(GMCerEro != NULL){
            OutlierToPush->PropCer=GetProportionAbove<bool,bool>(GMCer, LesionBool, 0, numel);
            OutlierToPush->PropCerEro = GetProportionAbove<bool, bool>(GMCerEro, LesionBool, 0,numel);
        }
        float MeanOC=GetMeanData(CodedOutliersData, LesionBool, numel);
        OutlierToPush->MeanOC=MeanOC;
        int SizeLesion=CountNonZero(LesionBool, numel);
        OutlierToPush->Volume=CountNonZero(LesionBool, numel)*VolumeVox;
        int GravityLesIndex=GetCenterGravity(LesionBool, Dim);
        int * GravityLesCoord=CorrespondingCoordinates(GravityLesIndex, Dim, Shift);
        //        Taking care of measures related to centre of gravity
        float DistGrav=0;
        for (int d=0; d<3; d++) {
            OutlierToPush->CentreGravity.push_back(GravityLesCoord[d]);
            OutlierToPush->VectorDiffGrav.push_back(-1*(GravityMaskCoord[d]-GravityLesCoord[d])*PixDim[d]);
            DistGrav+=pow_int(OutlierToPush->VectorDiffGrav[d],2);
        }
        OutlierToPush->DistanceGrav=sqrtf(DistGrav);
        delete [] GravityLesCoord;
        GravityLesCoord=NULL;

        float * Edginess=EdginessBorderLesion(LesionBool,&MahalDataElse[numel],Dim,Shift,PixDim,numel,numbmodal);
//        cout << "Edginess created"<<endl;
        bool * BorderIntLes=MultiplyElementwiseChoose<bool,bool,bool>(LesionBool,BorderInt,numel);
//        cout << "BorderIntLes created"<<endl;
        for (int m=0;m<numbmodal+1;m++){
            float * EdgStats=GetStatisticData(&Edginess[m*numel],BorderIntLes,numel);
//            cout << CountNonZero(BorderIntLes,numel)<<" non zero in Border"<<endl;
//            float * TempEdginess=new float[9];
//            for (int d=0; d<9; d++) {
//                TempEdginess[d]=EdgStats[d];
//            }
//            delete [] EdgStats;
            OutlierToPush->Edginess.push_back(EdgStats);
        }
        
        //        Taking care of measures relative to proportion of belonging to tissues segmented referring to priors (DGMBelonging, SPPotProp, PropICSF)
        bool * DGMandLesion=new bool[numel];
        bool * SPandLesion=new bool [numel];
        ANDOperationBool(DGMBool, LesionBool, DGMandLesion, numel);
        ANDOperationBool(SPBool, LesionBool, SPandLesion, numel);
        int DGMBoolBelongingNumber=CountNonZero(DGMandLesion, numel);
        int SPandLesionCount=CountNonZero(SPandLesion, numel);
        OutlierToPush->DGMBelonging=(bool)DGMBoolBelongingNumber;
        OutlierToPush->SPPotProp=(float)SPandLesionCount/SizeLesion;
        OutlierToPush->PropICSF=GetProportionAbove<float, bool>(ICSFData, LesionBool, 0.25, numel);
        OutlierToPush->PropCGM=GetProportionAbove<float,bool>(CGMData, LesionBool, 0.4, numel);
        OutlierToPush->PropDGM=GetProportionAbove<float,bool>(DGMData, LesionBool, 0.4, numel);
        OutlierToPush->PropECSF=GetProportionAbove<float,bool>(ECSFData, LesionBool, 0.25, numel);
        delete [] DGMandLesion;
        delete [] SPandLesion;
        DGMandLesion=NULL;
        SPandLesion=NULL;
        
        
        
        //        Taking care of what is related to the BoundingBox
        
        int * BoundingBox=FindBoundingBox(LesionBool, Dim, Shift);
        int LabelSize=CountNonZero(LesionBool, numel);
        int * ListCoordinates=ListCoordinatesBoolSeg(LesionBool, Dim, Shift);
        float * ListCoordF=ListCoordinatesTransformed(ListCoordinates, LabelSize, PixDim);
        float * ListCoordFDeMeaned = DemeanListCoordinates(ListCoordF, LabelSize, 3);
        //        float * Test=TreeToAnalyse->TransposeMatrix(ListCoordF, LabelSize, 3);
        SVD ResultSVD=SVD(ListCoordFDeMeaned, LabelSize, 3);
        //        SVD ResultSVDTest=SVD(Test,3,LabelSize);
        //        SVD TestStrange=SVD(ListCoordF,3,LabelSize);
        delete [] ListCoordinates;
        delete [] ListCoordF;
        ListCoordF=NULL;
        ListCoordinates=NULL;
        OutlierToPush->SVDEigen=new float[3];
        for (int d=0; d<3; d++) {
            OutlierToPush->SVDEigen[d]=ResultSVD.getSingularValues()[d];
        }
        //        delete [] Test;
        float * ExtentBB=new float[3];
        float * ExtentVolumeBB=new float[3];
        for (int d=0; d<3; d++) {
            ExtentBB[d]=PixDim[d]*abs(BoundingBox[d*2]-BoundingBox[d*2+1]);
            ExtentVolumeBB[d]=ExtentBB[d]/OutlierToPush->Volume;
        }
        OutlierToPush->ExtentBB=ExtentBB;
        OutlierToPush->ExtentVolumeBB=ExtentVolumeBB;
        OutlierToPush->BoundingBox=BoundingBox;
        bool * BoundingBoxBool=CreateBoolBoundingBox(BoundingBox, Dim);
        bool * BorderAndBBInt=new bool[numel];
        ANDOperationBool(BoundingBoxBool, BorderInt, BorderAndBBInt, numel);
        OutlierToPush->Surface=CountNonZero(BorderAndBBInt, numel)*VolumeVox;
        OutlierToPush->SAV=OutlierToPush->Surface/(1.0*OutlierToPush->Volume);
        OutlierToPush->Compactness=pow_int(OutlierToPush->Surface, 3)/pow_int(OutlierToPush->Volume, 2);
        bool * DilatedBB=ErosionTemplate(BoundingBoxBool,3,DimVec,0);
        bool * BorderAndBBExt=new bool[numel];
        bool * WMAndOutlier=new bool[numel];
        OROperationBool(OutliersBool, WMIHardSeg, WMAndOutlier, numel);
        ANDOperationBool(DilatedBB, BorderExt, BorderAndBBExt, numel);
                ANDOperationBool(WMAndOutlier, BorderAndBBExt, BorderAndBBExt, numel);
        float * ProportionBorder=ProportionFromBoolVec(BorderAndBBExt,VectorHardSeg,numel);
        float PropWMHNeigh=GetProportionAbove<float,bool>(&MahalDataElse[min(numbmodal,2)*numel], BorderAndBBExt, 3, numel);
        OutlierToPush->PropWMHNeigh=PropWMHNeigh;
        OutlierToPush->ProportionNeighbour=ProportionBorder;
        float * RatioBoundingBox=ProportionFromBoolVec(BoundingBoxBool, VectorHardSeg, numel);
        OutlierToPush->RatioBoundingBox=RatioBoundingBox;
        float * ProportionOrigin=ProportionFromBoolVec(LesionBool, VectorHardSegO, numel);
        OutlierToPush->ProportionOrigin=ProportionOrigin;
        delete [] BoundingBoxBool;
        delete [] BorderAndBBExt;
        delete [] BorderAndBBInt;
        delete [] DilatedBB;
        DilatedBB=NULL;
        BoundingBoxBool=NULL;
        BorderAndBBInt=NULL;
        BorderAndBBExt=NULL;
        
        //        Taking care of the measures related to intensities and Mahalanobis distance;
        float * MeanMahal=GetMeanDataMulti(MahalDataElse, LesionBool, numel,numbmodal+1);
        float * MinMahal=GetMinDataMulti(MahalDataElse,LesionBool,numel,numbmodal+1);
        float * MaxMahal=GetMaxDataMulti(MahalDataElse,LesionBool,numel,numbmodal+1);
        
        float * MeanLesion=GetMeanDataMulti<float,bool>(DataCorrectedImage, LesionBool, numel,numbmodal);
        float * VarianceLesion=GetVarianceDataMulti<float,bool>(DataCorrectedImage, LesionBool, numel,numbmodal);
        
        vector<float *> MahalQuantVector=GetQuantilesMulti(MahalDataElse, LesionBool, numel, numbmodal+1, QuantilisationValues);
        
        OutlierToPush->Variance=VarianceLesion;
        OutlierToPush->Mean=MeanLesion;
        OutlierToPush->MahalVec.push_back(MinMahal);
        OutlierToPush->MahalVec.push_back(MeanMahal);
        OutlierToPush->MahalVec.push_back(MaxMahal);
        for (int m=0; m<numbmodal+1; m++) {
            OutlierToPush->MahalVecQuant.push_back(MahalQuantVector[m]);
        }
        
        float MinDistSP=-1;
        float MaxDistSP=-1;
        float MeanDistSP=-1;
        
        //        Getting all the data for distance to inliers
        //        First Min
        float MinDistVentricle=GetMin(DistanceVentricle, LesionBool, numel);
        float MinDistGM=GetMin(DistanceGM,LesionBool,numel);
        float MinDistWM=GetMin(DistanceWM,LesionBool,numel);
        float MinDistCSF=GetMin(DistanceCSF,LesionBool, numel);
        float MinDistOut=GetMin(DistanceOut,LesionBool, numel);
        if (DistanceSP !=NULL) {
            MinDistSP=GetMin(DistanceSP, LesionBool, numel);
        }
        //        Then Mean
        float MeanDistVentricle=GetMeanData(DistanceVentricle, LesionBool, numel);
        float MeanDistGM=GetMeanData(DistanceGM, LesionBool, numel);
        float MeanDistWM=GetMeanData(DistanceWM, LesionBool, numel);
        float MeanDistCSF=GetMeanData(DistanceCSF, LesionBool, numel);
        float MeanDistOut=GetMeanData(DistanceOut, LesionBool, numel);
        if (DistanceSP !=NULL) {
            MeanDistSP=GetMeanData(DistanceSP, LesionBool, numel);
        }
        //        Finally Max
        float MaxDistVentricle=GetMaxArrayMasked(DistanceVentricle, LesionBool, numel);
        float MaxDistGM=GetMaxArrayMasked(DistanceGM,LesionBool,numel);
        float MaxDistWM=GetMaxArrayMasked(DistanceWM, LesionBool, numel);
        float MaxDistCSF=GetMaxArrayMasked(DistanceCSF, LesionBool, numel);
        float MaxDistOut=GetMaxArrayMasked(DistanceOut, LesionBool, numel);
        if (DistanceSP !=NULL) {
            MaxDistSP=GetMaxArrayMasked(DistanceSP, LesionBool, numel);
        }
        //        Putting everything in the relevant vectors:
        OutlierToPush->DistanceVentricle.push_back(MinDistVentricle);
        OutlierToPush->DistanceVentricle.push_back(MeanDistVentricle);
        OutlierToPush->DistanceVentricle.push_back(MaxDistVentricle);
        
        OutlierToPush->DistanceGMI.push_back(MinDistGM);
        OutlierToPush->DistanceGMI.push_back(MeanDistGM);
        OutlierToPush->DistanceGMI.push_back(MaxDistGM);
        
        OutlierToPush->DistanceWMI.push_back(MinDistWM);
        OutlierToPush->DistanceWMI.push_back(MeanDistWM);
        OutlierToPush->DistanceWMI.push_back(MaxDistWM);
        
        OutlierToPush->DistanceCSFI.push_back(MinDistCSF);
        OutlierToPush->DistanceCSFI.push_back(MeanDistCSF);
        OutlierToPush->DistanceCSFI.push_back(MaxDistCSF);
        
        OutlierToPush->DistanceOutI.push_back(MinDistOut);
        OutlierToPush->DistanceOutI.push_back(MeanDistOut);
        OutlierToPush->DistanceOutI.push_back(MaxDistOut);
        
        OutlierToPush->DistanceSP.push_back(MinDistSP);
        OutlierToPush->DistanceSP.push_back(MeanDistSP);
        OutlierToPush->DistanceSP.push_back(MaxDistSP);
        
        //        Taking care of Texture elements
        for (int m=0; m<numbmodal; m++) {
            TextureDescriptors * TextureOutlier=CreateTextureDescriptors(LesionBoolShort, DataCorrectedVector[m], DataTotalShiftVector[m], PixDimShift, TreeToAnalyse);
            OutlierToPush->Texture.push_back(TextureOutlier);
            TextureDescriptors1 * TextureOutlier1=CreateTextureDescriptors1(LesionBoolShort, DataCorrectedVector[m], TreeToAnalyse);
            OutlierToPush->Texture1.push_back(TextureOutlier1);
        }
        OutlierToPush->OutlierClass=OutlierTypePreliminary(OutlierToPush,segment_analysis, mult_modify);
                OutlierToPush->LesionType=(LesionSubcategories)ValuesToAnalyse[v];
        OutlierToPush->LesionType=OutlierRefinement(OutlierToPush, segment_analysis);
        if(OutlierToPush->LesionType>0 && segment_analysis->flag_correctionLevel==3){
            bool FPDGM=CheckForFPDGM(OutlierToPush->PropDGM, OutlierToPush->MahalVec, numbmodal);
            OutlierToPush->LesionType=FPDGM==1?NonLesion:OutlierToPush->LesionType;
            OutlierToPush->OutlierClass=FPDGM==1?SuspIron:OutlierToPush->OutlierClass;
        }
        for(int i=0;i<numel;i++){
            if(LesionBool[i]){
            ResultClassif[i]=OutlierToPush->LesionType;
            ResultClassif[i+numel]=OutlierToPush->OutlierClass;
            }
        }


        delete [] LesionBool;
        delete [] LesionBoolShort;
                delete [] WMAndOutlier;
                WMAndOutlier=NULL;
        LesionBool=NULL;
        LesionBoolShort=NULL;
        NewVectorToPush.push_back(OutlierToPush);
        cout<<"treated !"<<endl;
        }
            nifti_image * ClassifNii=CreateNiiFromArray(ResultClassif,ECSFPriors,2*numel);
            nifti_set_filenames(ClassifNii,FilenameSaveClassif.c_str(),0,0);
            nifti_set_filenames(ComponentValueNii,FilenameSaveConnect.c_str(),0,0);
            nifti_image_write(ClassifNii);
            nifti_image_write(ComponentValueNii);
            nifti_image_free(ClassifNii);
            nifti_image_free(ComponentValueNii);
        delete [] OrderedLabels;
        delete [] ComponentValues;
        delete [] ValuesChosen;
        ResultVector.push_back(NewVectorToPush);
    }
    
        //    Clearing and deleting all that has been calculated once for everything
        nifti_image_free(OutliersSeg);
        nifti_image_free(ICSFPriors);
        nifti_image_free(DGMPriors);
        nifti_image_free(ECSFPriors);
        nifti_image_free(DistanceCSFNii);
        nifti_image_free(DistanceGMNii);
        nifti_image_free(DistanceVentriclesNii);
        nifti_image_free(DistanceWMNii);
        nifti_image_free(DistanceOutNii);
        nifti_image_free(MahalDistance);
        nifti_image_free(MahalDistanceElse);
        nifti_image_free(WMSeg);
        nifti_image_free(SummarisedTempOutliers);
        nifti_image_free(SummarisedTemp);
        if (DistanceSPNii!=NULL) {
            nifti_image_free(DistanceSPNii);
            DistanceSPNii=NULL;
        }
        OutliersSeg=NULL;
        ICSFPriors=NULL;
        DGMPriors=NULL;
        ECSFPriors=NULL;
        DistanceGMNii=NULL;
        DistanceCSFNii=NULL;
        DistanceWMNii=NULL;
        DistanceOutNii=NULL;
        DistanceVentriclesNii=NULL;
        MahalDistance=NULL;
        WMSeg=NULL;
        SummarisedTemp=NULL;
        SummarisedTempOutliers=NULL;
        
        for (int m=0; m<numbmodal; m++) {
            for (int d=0; d<6; d++) {
                delete [] DataTotalShiftVector[m][d];
                DataTotalShiftVector[m][d]=NULL;
            }
        }
        if (GIFBoolCorr!=NULL) {
            delete [] GIFBoolCorr;
            GIFBoolCorr=NULL;
        }

        delete [] VentricleBool;
        delete [] DGMBool;
        delete [] SPBool;
        delete [] DGMICSFData;
        delete [] GravityMaskCoord;
        delete [] WMOHardSeg;
        delete [] WMIHardSeg;
        delete [] GMOHardSeg;
        delete [] GMIHardSeg;
        delete [] CSFOHardSeg;
        delete [] CSFIHardSeg;
        delete [] OutOHardSeg;
        delete [] OutIHardSeg;
        delete [] OutliersHardSeg;
        delete [] InliersHardSeg;
        delete [] BorderExt;
        delete [] BorderInt;
        delete [] OpposedPotOutSeg;
        delete [] PotentialOutliersSeg;
        delete [] WMBoolLong;
        delete [] OutIHardSegPre;
        delete [] GMECSF_interface;
        delete [] GMCer;
        if (GMCerEro != NULL){
            delete [] GMCerEro;
        }
        GMCer = NULL;
        GMCerEro = NULL;
        OutIHardSegPre=NULL;
        WMBoolLong=NULL;
        PotentialOutliersSeg=NULL;
        OpposedPotOutSeg=NULL;
        VentricleBool=NULL;
        DGMBool=NULL;
        SPBool=NULL;
        DGMICSFData=NULL;
        GravityMaskCoord=NULL;
        WMOHardSeg=NULL;
        WMIHardSeg=NULL;
        GMIHardSeg=NULL;
        GMOHardSeg=NULL;
        CSFOHardSeg=NULL;
        CSFIHardSeg=NULL;
        OutOHardSeg=NULL;
        OutIHardSeg=NULL;
        OutliersHardSeg=NULL;
        InliersHardSeg=NULL;
        BorderInt=NULL;
        BorderExt=NULL;
    delete [] DataCorr;
    nifti_image_free(DataImage);
        return ResultVector;
        }

OutlierType OutlierTypePreliminary(Outlier * OutlierToClassify,SEG_ANALYSIS * segment_analysis, float mult_modify){
    OutlierType OutlierTypeResult=Lacune;
    int numbmodal=segment_analysis->vecModalities.size();
    if(segment_analysis->flag_sc){
        OutlierTypeResult=ClassifyOutlierSC(OutlierToClassify,segment_analysis);
        return OutlierTypeResult;
    }
//  Applying classification system for
    cout << segment_analysis->vecModalities[numbmodal-1] << " 2nd modality " << numbmodal << " Nbr modalities"<<endl;
    if ((OutlierToClassify->MeanOC>29.5*mult_modify && OutlierToClassify->MahalVecQuant[min(numbmodal,2)][2]>mult_modify) || (segment_analysis->vecModalities[numbmodal-1]==2 && numbmodal==2)){
        cout << "Classifying WMH"<< endl;
        OutlierTypeResult=ClassifyOutlierWMH(OutlierToClassify,segment_analysis, mult_modify);
        cout << "Type of Outlier is "<< OutlierTypeResult;
    }
    else   {
        cout << "Lacune refinement "<< OutlierToClassify->MeanOC << " " << OutlierToClassify->MahalVecQuant[min(numbmodal,2)][2] << endl;
        OutlierTypeResult=ClassifyOutlierLacune(OutlierToClassify,segment_analysis);
    }
    return OutlierTypeResult;
}

// Check for potential problems in the lesions of the DGM by looking at the level of outlierness in the relevant modality
bool CheckForFPDGM(float PropDGM, vector<float *> MahalVec, int numbmodal){
    bool FPDGM=0;
    if (PropDGM>0.2 && MahalVec[1][min(numbmodal,2)]<3 && MahalVec[2][min(numbmodal,2)]<4.5) {
        FPDGM=1;
    }
    return FPDGM;
}

LesionSubcategories OutlierRefinement(Outlier * OutlierInit, SEG_ANALYSIS * segment_analysis){
    int IndexWM=segment_analysis->IndexWM;
    int * ModalitiesCorresp=GetCorrespondingModality(segment_analysis->vecModalities, segment_analysis->vecCheckModalities);
    float MaxRatioExtent=0;
    float PotMaxRatio=0;
    for (int d=0; d<3; d++) {
        if (OutlierInit->ExtentBB[d]!=0) {
            for (int d2=0; d2<3; d2++) {
                if (d2!=d) {
                    PotMaxRatio=OutlierInit->ExtentBB[d2]/OutlierInit->ExtentBB[d];
                }
                if (PotMaxRatio>MaxRatioExtent) {
                    MaxRatioExtent=PotMaxRatio;
                }
            }
        }

    }
    LesionSubcategories LesionCategory=NonLesion;
    if (static_cast<int>(OutlierInit->OutlierClass)<0) {
        return NonLesion;
    }
    else if(OutlierInit->MahalVecQuant[ModalitiesCorresp[0]+1][0]<0 && OutlierInit->MahalVecQuant[ModalitiesCorresp[1]+1][0]<0 && OutlierInit->MeanOC<29){ // Hypointensity on both T1 and FLAIR
        if (OutlierInit->PropWMHNeigh>0.1) { // Potential Lacune
            if (OutlierInit->PropDGM>0.1) { // Lacune of BG Type
                if (MaxRatioExtent>1.5) { // Elongated type
                    return Lacunes_BGE;
                }
                else {
                    return Lacunes_BGR;
                }
            }
            else if(OutlierInit->PropDGM==0 && OutlierInit->DistanceVentricle[0]>5){ // Lacune of SC type
                if (MaxRatioExtent>1.5) { // Elongated type
                    return Lacunes_SCE;
                }
                else {
                    return Lacunes_SCR;
                }
            }
            else {
                if (MaxRatioExtent>1.5) { // Elongated type
                    return Lacunes_PVE;
                }
                else {
                    return Lacunes_PVR;
                }
            }
        }
        else { // Most probably PVS
            if (OutlierInit->PropDGM>0.1) { // PVS of BG Type
                if (MaxRatioExtent>1.5) { // Elongated type
                    return PVS_BGE;
                }
                else {
                    return PVS_BGR;
                }
            }
            else if(OutlierInit->PropDGM==0 && OutlierInit->DistanceVentricle[0]>5){ // PVS of SC type
                if (MaxRatioExtent>1.5) { // Elongated type
                    return PVS_SCE;
                }
                else {
                    return PVS_SCR;
                }
            }
            else {
                if (MaxRatioExtent>1.5) { // Elongated type
                    return PVS_E;
                }
                else {
                    return PVS_R;
                }
            }
        }
    }
    else if ( OutlierInit->MahalVecQuant[ModalitiesCorresp[1]+1][0]>1){
        if (OutlierInit->ProportionNeighbour[IndexWM]==0) { // Pure WM Cases
            if (OutlierInit->DistanceVentricle[0]<=OutlierInit->DistanceCSFI[0]) {
                return PVWMH_PureWM;
            }
            else {
                return DWMH_PureWM;
            }
        }
        else{
            if (OutlierInit->PropDGM>0) {
                return PVWMH_BG;
            }
            else if(OutlierInit->DistanceVentricle[0]<=OutlierInit->DistanceCSFI[0]){
                return DWMH_Mixed;
            }
            else{
                cout << "WMH reclassification "<< OutlierInit->MahalVecQuant[ModalitiesCorresp[1]+1][0]<<endl;
                OutlierInit->OutlierClass= ClassifyOutlierWMH(OutlierInit, segment_analysis);
                return WMH;
            }
        }
    }
    else {
        if ((OutlierInit->MahalVecQuant[ModalitiesCorresp[0]+1][0]+OutlierInit->MahalVecQuant[ModalitiesCorresp[1]+1][0]<-7 || OutlierInit->MahalVecQuant[ModalitiesCorresp[0]+1][0]<-5 || OutlierInit->MahalVecQuant[ModalitiesCorresp[1]+1][0]<-5 || OutlierInit->MahalVec[1][ModalitiesCorresp[0]+1]<-0.5) && OutlierInit->MeanOC<33) {
            if (OutlierInit->PropDGM>0.1) { // PVS of BG Type
                if (MaxRatioExtent>1.5) { // Elongated type
                    return PVS_BGE;
                }
                else {
                    return PVS_BGR;
                }
            }
            else if(OutlierInit->PropDGM==0 && OutlierInit->DistanceVentricle[0]>5){ // PVS of SC type
                if (MaxRatioExtent>1.5) { // Elongated type
                    return PVS_SCE;
                }
                else {
                    return PVS_SCR;
                }
            }
            else {
                if (MaxRatioExtent>1.5) { // Elongated type
                    return PVS_E;
                }
                else {
                    return PVS_R;
                }
            }
        }
        else if (OutlierInit->MahalVecQuant[ModalitiesCorresp[0]+1][1]<-0.5 && OutlierInit->MahalVec[1][ModalitiesCorresp[1]+1]<2){
            return PVSLacSusp;
        }
        else if (OutlierInit->DGMBelonging) {
            return IronDeposit;
        }
        return NonLesion;
    }
    return LesionCategory;
}

// If the outlier is classified as FP, check if there are any symmetric lesions (with respect to centre of gravity) according to a specific direction that are classified as full lesions
vector<int > SymmetryLabelsFP(vector<Outlier*> VectorOutlier, int Label, int * OrderedLabels, int* Dim, int Direction){
    Outlier * OutlierToSymmetrise = VectorOutlier[Label-1];
    if (OutlierToSymmetrise->LesionCode>0) {
        vector<int> SymmetricalNFPLabels;
        return SymmetricalNFPLabels;
    }
//    First generate Bounding Box corresponding to symmetric
    int NewBB[6];
    for (int i=0; i<6; i++) {
        NewBB[i]=OutlierToSymmetrise->BoundingBox[i];
    }
    for (int i=0; i<2; i++) {
        NewBB[i+2*Direction]-=OutlierToSymmetrise->VectorDiffGrav[Direction];
    }
//    Then creating the bool array corresponding to the NewBB
    bool * NewBBBool=CreateBoolBoundingBox(NewBB, Dim);
//    Then adding to a set (in order to have unique elements) the labels in OrderedLabels that are not classified as FP...
    int numel=Dim[0]*Dim[1]*Dim[2];
    set<int> LabelsToCheck;
    for (int i=0; i<numel; i++) {
        if (NewBBBool[i]) {
            if (OrderedLabels[i]>0) {
                if (VectorOutlier[OrderedLabels[i]-1]->LesionCode>0){
                    LabelsToCheck.insert(OrderedLabels[i]-1);
                }
            }
        }
    }
    int sizeCheck=LabelsToCheck.size();
    cout << "Number of labels to check is "<<sizeCheck<<endl;
    std::vector<int> SymmetricalNFPLabels(sizeCheck);
    std::copy(LabelsToCheck.begin(), LabelsToCheck.end(), SymmetricalNFPLabels.begin());
    delete [] NewBBBool;
    NewBBBool=NULL;
    return SymmetricalNFPLabels;
}


void CorrectionCST(TreeEM* TreeToAnalyse, nifti_image * SegToAnalyse, SEG_ANALYSIS* segment_analysis){
    if (! segment_analysis->flag_CST){
        return;
    }
    nifti_image * CSTPrior=ReadFromFilename(segment_analysis->filename_inCST);
    float * DataBF=TreeToAnalyse->GetDataBFCorrected();
    int CountChange=0;
    int * L2S=TreeToAnalyse->GetL2S();
    int numel=TreeToAnalyse->GetNumberElements();
    int numbmodal= TreeToAnalyse->GetNumberModalities();
    float * DataBFLong=CreateLongPaddingMulti<float>(DataBF,0,L2S,numel,numbmodal);
    float * WMData=CreateLong(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp(),L2S,numel);
    bool * MaskTractsLesion=new bool[numel];
    float * SegData=static_cast<float*>(SegToAnalyse->data);
    float * CSTData=static_cast<float*>(CSTPrior->data);
    for(int i=0;i<numel;i++){
        MaskTractsLesion[i]=0;
        if ((SegData[i]>0||WMData[i]>0.4) && CSTData[i]>0){
            MaskTractsLesion[i]=1;
        }
    }
    cout << "Mask bool created"<<endl;
    nifti_image* MaskNii=CreateNiiFromArray(MaskTractsLesion,CSTPrior,numel);
    nifti_image* DataNii=CreateNiiFromArray(DataBFLong,TreeToAnalyse->GetDataImage(),numel*numbmodal);
    nifti_image* MahalNii=MahalDistMaps(MaskNii,MaskNii,DataNii);
    cout << "Tot images CST created"<<endl;
    float * MahalData=static_cast<float*>(MahalNii->data);
    for(int i=0;i<numel;i++){
        if(CSTData[i]>0.1 && MaskTractsLesion[i]==1 && MahalData[min(numbmodal,2)*numel+i]<3){
            SegData[i]=0;
            CountChange++;
        }
    }

    cout <<"Correction due to CST "<<CountChange<<endl;
    delete [] MaskTractsLesion;
    nifti_image_free(DataNii);
    nifti_image_free(MahalNii);
    nifti_image_free(MaskNii);
    delete [] DataBFLong;
}

// Reclassification of some missing labels classified as TP whereas symmetrical ones are classified as FP. Looks only at symmetry in a specified direction within a certain range of the midline and concerns only lesions that are close to symmetrical.
void CorrectionForSymmetry(vector<Outlier*> VectorOutliers, int Direction, float ThresholdDifference, float Range, int * OrderedLabels, int * Dim){
    int MaxLabel=VectorOutliers.size();
    for (int l=0 ; l<MaxLabel; l++) {
        if (VectorOutliers[l]->LesionCode<0) {
            if (fabs(VectorOutliers[l]->VectorDiffGrav[Direction])<Range) {
                vector<int> LabelsToCheck=SymmetryLabelsFP(VectorOutliers, l+1, OrderedLabels, Dim, Direction);
                int numbChecks=LabelsToCheck.size();
                for (int c=0; c<numbChecks; c++) {
                    if (fabs(VectorOutliers[LabelsToCheck[c]]->VectorDiffGrav[Direction]-VectorOutliers[l]->VectorDiffGrav[Direction])<ThresholdDifference) {
                        VectorOutliers[LabelsToCheck[c]]->LesionCode=-15;
                    }
                }
            }
        }
    }
}

OutlierType ClassifyOutlierSC(Outlier * OutlierToClassify, SEG_ANALYSIS * segment_analysis){
    OutlierType OutlierTypeResult=PeriV;
//    int IndexOut=segment_analysis->IndexOut;
    int IndexCSF=segment_analysis->IndexCSF;
    int IndexGM=segment_analysis->IndexGM;
    int IndexWM=segment_analysis->IndexWM;
    if( OutlierToClassify->SAV > 1.2 && OutlierToClassify->ProportionNeighbour[IndexWM] > OutlierToClassify->ProportionNeighbour[IndexGM] && OutlierToClassify->ProportionNeighbour[IndexWM]<0.65 && OutlierToClassify->ProportionNeighbour[IndexCSF]>0.05){
        return OutlierTypeResult=OutWMH;
    }
    if ((OutlierToClassify->ExtentBB[0]==0 || OutlierToClassify->ExtentBB[1]==0) && OutlierToClassify->ProportionNeighbour[IndexCSF]>=OutlierToClassify->ProportionNeighbour[IndexGM]){
        return OutlierTypeResult=OutWMH;
    }
    return OutlierTypeResult;
}

OutlierType ClassifyOutlierWMH(Outlier * OutlierToClassify, SEG_ANALYSIS * segment_analysis, float mult_modify){
    OutlierType OutlierTypeResult=NonClassified;
    int IndexOut=segment_analysis->IndexOut;
    int IndexCSF=segment_analysis->IndexCSF;
    int IndexGM=segment_analysis->IndexGM;
    int IndexWM=segment_analysis->IndexWM;
    int numbmodal = segment_analysis->vecModalities.size();
//    Check for gigantic lesion
    if(OutlierToClassify->DistanceVentricle[0]<4 && OutlierToClassify->Volume>15000&& segment_analysis->vecModalities[min(numbmodal-1,1)]==3 ){
        return OutlierTypeResult=PeriV;
    }
    // Check for non contrast
//    cout << "Checking contrast "<<endl;
//    cout << OutlierToClassify->Edginess[0][0] <<endl;
//    cout << OutlierToClassify->ProportionNeighbourArtefact<<endl;
    if(OutlierToClassify->Edginess[0][0]<segment_analysis->EdginessThreshold && OutlierToClassify->MahalVec[1][min(numbmodal,2)] < 3 *mult_modify  && OutlierToClassify->ProportionNeighbour[0]>0.01){
        return OutlierTypeResult=ReclassifNonContrast;
        cout << "Reclassif no contrast"<<endl;
    }
    if(OutlierToClassify->Edginess[0][0]<segment_analysis->EdginessThreshold+1 && OutlierToClassify->MahalVec[1][min(numbmodal,2)] < 3 *mult_modify&& OutlierToClassify->ProportionNeighbourArtefact>0){
        return OutlierTypeResult=ReclassifNonContrast;
        cout << "Reclassif no contrast"<<endl;
    }
    if(segment_analysis->flag_FLAIRonly && OutlierToClassify->DistanceGMI[1] <= OutlierToClassify->DistanceWMI[1] + 0.1 && OutlierToClassify->PropCerEro>0){
        return OutlierTypeResult=CerebellumSuspect;
    }
//    First check for probable out
    if (((OutlierToClassify->ProportionNeighbour[IndexOut]*OutlierToClassify->Volume>3 && OutlierToClassify->Volume<1000) || OutlierToClassify->ProportionNeighbour[IndexOut] > 0.05) && OutlierToClassify->DistanceVentricle[0]>4.5) {
        cout << "Out 1"<<endl;
        return OutlierTypeResult=OutWMH;
    }
    if ((OutlierToClassify->ExtentBB[0]==0 || OutlierToClassify->ExtentBB[1]==0 || OutlierToClassify->ExtentBB[2]==0) && OutlierToClassify->DistanceVentricle[0]>10){
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->RatioBoundingBox[IndexOut]>0.05 && OutlierToClassify->ProportionNeighbour[IndexCSF]>0 && OutlierToClassify->DistanceVentricle[0]>4.5) {
        cout << "Out 2"<<endl;
        return OutlierTypeResult=OutWMH;
    }
    if(((OutlierToClassify->ProportionNeighbour[IndexOut]*OutlierToClassify->Volume>3 && OutlierToClassify->Volume<1000) || OutlierToClassify->ProportionNeighbour[IndexOut] > 0.05) && OutlierToClassify->PropDGM==0 && OutlierToClassify->PropICSF==0 && OutlierToClassify->ProportionNeighbour[IndexWM]<0.65 && OutlierToClassify->DistanceVentricle[0]>2.5){
        cout << "Out 3"<<endl;
        return OutlierTypeResult=OutWMH;
    }
    if ((OutlierToClassify->DistanceVentricle[0]>3.5 && OutlierToClassify->ProportionNeighbour[IndexOut]*OutlierToClassify->Volume>2 && OutlierToClassify->Volume<1000) || (OutlierToClassify->ProportionNeighbour[IndexOut] > 0.05 && OutlierToClassify->DistanceOutI[0]<3 && (OutlierToClassify->Volume<10000))) {
        cout << "Out 4"<<endl;
        return OutlierTypeResult=OutWMH;
    }
    // Check for JC MS
    if(segment_analysis->flag_acceptJCMS && OutlierToClassify->Volume>50 && OutlierToClassify->MahalVec[1][min(numbmodal,2)] > 4.5 && OutlierToClassify->SVDEigen[0]/OutlierToClassify->SVDEigen[1]<2 && OutlierToClassify->ProportionNeighbour[IndexWM]>0.05 && OutlierToClassify->PropCGM>0.5){
        cout << "JuxtaCorr MS"<<endl;
        return OutlierTypeResult=JuxtaCorrMS;

    }
//    Check for IV
    if (OutlierToClassify->DistanceVentricle[0]==0 && OutlierToClassify->DistanceCSFI[0]==0 && OutlierToClassify->ProportionOrigin[IndexWM]<OutlierToClassify->ProportionOrigin[IndexCSF]) {
        return OutlierTypeResult=IntV;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<0.1 && OutlierToClassify->ProportionNeighbour[IndexGM]<OutlierToClassify->ProportionNeighbour[IndexCSF]&&OutlierToClassify->DistanceCSFI[0]>=OutlierToClassify->DistanceVentricle[0]){
        return OutlierTypeResult=IntV;
    }
    if(OutlierToClassify->ProportionNeighbour[IndexWM]<0.1 && OutlierToClassify->PropICSF>0.45){
        return OutlierTypeResult=IntV;
    }
    if (OutlierToClassify->PropICSF>0.45 && OutlierToClassify->ProportionNeighbour[IndexCSF]>OutlierToClassify->ProportionNeighbour[IndexWM] && OutlierToClassify->ProportionNeighbour[IndexCSF]>OutlierToClassify->ProportionNeighbour[IndexGM]) {
        return OutlierTypeResult=IntV;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<OutlierToClassify->ProportionNeighbour[IndexGM] && OutlierToClassify->ProportionNeighbour[IndexWM]<OutlierToClassify->ProportionNeighbour[IndexCSF] && OutlierToClassify->PropICSF>0.45  && OutlierToClassify->DistanceWMI[1]>5) {
        return OutlierTypeResult=IntV;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]==0&&!OutlierToClassify->DGMBelonging && OutlierToClassify->DistanceVentricle[0]<3) {
        return OutlierTypeResult=IntV;
    }
    
//    Check for Cortical sheet
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<0.1 && OutlierToClassify->ProportionNeighbour[IndexCSF]>0 && OutlierToClassify->ProportionNeighbour[IndexGM]>0 && OutlierToClassify->DistanceCSFI[0]<OutlierToClassify->DistanceVentricle[0]) {
        cout << "CS 1" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<0.1 && OutlierToClassify->ProportionNeighbour[IndexGM]>0 && OutlierToClassify->DistanceCSFI[0]<OutlierToClassify->DistanceVentricle[0] && OutlierToClassify->PropCGM>0.8) {
        cout << "CS 2" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<0.12 && OutlierToClassify->ProportionNeighbour[IndexGM]>0 && OutlierToClassify->DistanceCSFI[0]<OutlierToClassify->DistanceVentricle[0] && OutlierToClassify->PropCGM>0.8 && OutlierToClassify->DGMBelonging) {
        cout << "CS 2b" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<0.15 && OutlierToClassify->ProportionNeighbour[IndexGM]>0.5 && OutlierToClassify->DistanceCSFI[0]<OutlierToClassify->DistanceVentricle[0] && OutlierToClassify->PropCGM>0.8 && OutlierToClassify->DGMBelonging && OutlierToClassify->DistanceWMI[0]>OutlierToClassify->DistanceGMI[0]) {
        cout << "CS 2c" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if(OutlierToClassify->ProportionNeighbour[IndexWM]<0.1 && OutlierToClassify->ProportionNeighbour[IndexGM]>0.6 && OutlierToClassify->PropDGM<0.2 && OutlierToClassify->VectorDiffGrav[1]>25){
        cout << "CS 3" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]+OutlierToClassify->PropWMHNeigh<0.2 && OutlierToClassify->ProportionNeighbour[IndexCSF]>0 && OutlierToClassify->ProportionNeighbour[IndexGM]>0 && OutlierToClassify->DistanceCSFI[0]<OutlierToClassify->DistanceVentricle[0] && OutlierToClassify->PropDGM<0.2 && (OutlierToClassify->DistanceVentricle[0]>1.5 || OutlierToClassify->Volume<1000)) {
        cout << "CS 4" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexGM]>0&&OutlierToClassify->ProportionNeighbour[IndexCSF]>0.02 &&!OutlierToClassify->DGMBelonging && OutlierToClassify->ProportionNeighbour[IndexWM]<0.7 && OutlierToClassify->DistanceVentricle[0]>3.5 && OutlierToClassify->PropECSF + OutlierToClassify->PropCGM > 0.5) {
        cout << "CS 5" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexGM]>0.6 &&OutlierToClassify->DGMBelonging==0 && OutlierToClassify->ProportionNeighbour[IndexWM]<0.25 && OutlierToClassify->DistanceVentricle[0]>5 && OutlierToClassify->PropECSF + OutlierToClassify->PropCGM > 0.7 && fabs(OutlierToClassify->VectorDiffGrav[0])<10) {
        cout << "CS 5" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]==0 && OutlierToClassify->ProportionNeighbour[IndexCSF]>0 && OutlierToClassify->DistanceVentricle[0]>3) {
        cout << "CS 6" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]==0 && OutlierToClassify->ProportionNeighbour[IndexCSF]==0 && ! OutlierToClassify->DGMBelonging && OutlierToClassify->SPPotProp==0) {
        cout << "CS 7" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->PropArtefact>0.1) {
        if( OutlierToClassify->ProportionNeighbour[IndexWM]<0.3 && OutlierToClassify->DistanceVentricle[0]>=OutlierToClassify->DistanceGMI[0]+1){
            cout << "CS 8" << endl;
            return OutlierTypeResult=CorticalSheet;
        }
        if (OutlierToClassify->PropInterface>0.1){
            cout << "CS 8bis" <<endl;
            return OutlierTypeResult=CorticalSheet;
        }
    }


    if (OutlierToClassify->PropBorderExtent>0.7 && OutlierToClassify->Volume>4){
        cout << "CS 9" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->PropInterface>0.1 && OutlierToClassify->PropECSF>0.1 && OutlierToClassify->PropCGM>0 && OutlierToClassify->ProportionNeighbour[IndexWM]<0.5){
        cout << "CS 12"<< endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexGM]>0.55 && OutlierToClassify->PropCGM>0.7 && OutlierToClassify->PropICSF<0.05 && OutlierToClassify->VectorDiffGrav[1]>35 && OutlierToClassify->PropECSF>0 && fabs(OutlierToClassify->VectorDiffGrav[2])<10 && OutlierToClassify->DistanceVentricle[0]>1.5){
        cout << "CS 10" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexGM]+OutlierToClassify->ProportionNeighbour[4]>0.85 && OutlierToClassify->PropCGM>0.9 && OutlierToClassify->PropICSF==0 && !OutlierToClassify->DGMBelonging && OutlierToClassify->ProportionNeighbour[IndexWM]<0.4){
        cout << "CS 11" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if ((OutlierToClassify->ExtentBB[0]==0 || OutlierToClassify->ExtentBB[1]==0 || OutlierToClassify->ExtentBB[2]==0) && OutlierToClassify->DistanceVentricle[0]>10){
        cout << "CS 13 Flat line" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    if (OutlierToClassify->PropInterface>0 && OutlierToClassify->ProportionNeighbour[IndexWM]<(OutlierToClassify->ProportionNeighbour[IndexGM]+OutlierToClassify->ProportionNeighbour[IndexCSF]) && OutlierToClassify->DistanceVentricle[0]>10){
        cout << "CS 14 Cortical sheet follow" << endl;
        return OutlierTypeResult=CorticalSheet;
    }
    
//  Check for third ventricle
    if (OutlierToClassify->ProportionNeighbour[IndexCSF]>0&&OutlierToClassify->ProportionNeighbour[IndexWM]<0.1 && OutlierToClassify->ProportionNeighbour[IndexGM]>0 && fabs(OutlierToClassify->VectorDiffGrav[0])<=3) {
        if (OutlierToClassify->VectorDiffGrav[2]<0) {
            return OutlierTypeResult=ThirdV;
        }
    }
    if (OutlierToClassify->ProportionNeighbour[IndexGM]<0.55 && OutlierToClassify->ProportionNeighbour[IndexWM]<0.55) {
        if (fabs(OutlierToClassify->VectorDiffGrav[0])<=5) {
            if (OutlierToClassify->VectorDiffGrav[2]<0 && OutlierToClassify->VectorDiffGrav[1]<15) {
                if (OutlierToClassify->Volume<5000 && OutlierToClassify->ExtentBB[0]<50 &&OutlierToClassify->ExtentBB[1]<50 ) {
                    return OutlierTypeResult=ThirdV;
                }
                
            }
        }
    }
    if (OutlierToClassify->ProportionNeighbour[IndexCSF]>0 && OutlierToClassify->ProportionNeighbour[IndexWM]<OutlierToClassify->ProportionNeighbour[IndexGM]) {
        if (fabs(OutlierToClassify->VectorDiffGrav[0])<=6 && OutlierToClassify->ExtentBB[0]<50) {
            if (OutlierToClassify->VectorDiffGrav[2]<0 && OutlierToClassify->VectorDiffGrav[1]<15) {
                return OutlierTypeResult=ThirdV;
            }
        }
    }
    
//    Check for Septum pellucidum
    if(!segment_analysis->flag_SPCorrection){
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<0.1 && OutlierToClassify->DistanceGrav<20 && fabs(OutlierToClassify->VectorDiffGrav[0])<10) {
        return OutlierTypeResult=SeptPell;
    }
    if(OutlierToClassify->ProportionNeighbour[IndexWM]<0.55 && OutlierToClassify->ProportionNeighbour[IndexGM]<0.55){
            cout <<"Possible need to reclassify as SP";
            if (fabs(OutlierToClassify->VectorDiffGrav[0])<4*OutlierToClassify->DistanceVentricle[0] || fabs(OutlierToClassify->VectorDiffGrav[0])<5){
                if( OutlierToClassify->SPPotProp>0.3 && OutlierToClassify->DistanceGrav <30 && OutlierToClassify->ExtentBB[1]<25) {
                    cout<<"...change effective";
                    return OutlierTypeResult=SeptPell;
                }
                if (OutlierToClassify->SPPotProp>=0.5 && OutlierToClassify->DistanceSP[2]<10) {
                    cout<<"... change effective";
                    return OutlierTypeResult=SeptPell;
                }
                if(OutlierToClassify->DistanceGrav<15){
                    cout<<"... change effective";
                    return OutlierTypeResult=SeptPell;
                }
            }
    }
    if(OutlierToClassify->ProportionNeighbour[IndexWM]<OutlierToClassify->ProportionNeighbour[IndexGM]){
        if(fabs(OutlierToClassify->VectorDiffGrav[0])<=4 && fabs(OutlierToClassify->VectorDiffGrav[1])<=6 && fabs(OutlierToClassify->VectorDiffGrav[2])<=6){
            return OutlierTypeResult=SeptPell;
        }
        if (fabs(OutlierToClassify->VectorDiffGrav[0])<3 && fabs(OutlierToClassify->ProportionNeighbour[IndexCSF]-OutlierToClassify->ProportionNeighbour[IndexWM])<=0.03) {
            cout<<"Certainly SP";
            return OutlierTypeResult=SeptPell;
        }
        if (fabs(OutlierToClassify->VectorDiffGrav[0])+fabs(OutlierToClassify->VectorDiffGrav[1])<=5 && OutlierToClassify->SPPotProp>0.1) {
            cout<<"In enlarged SP";
            return OutlierTypeResult=SeptPell;
        }
    }
    
    if(OutlierToClassify->ProportionNeighbour[IndexWM]<0.75){
        if (fabs(OutlierToClassify->VectorDiffGrav[0])+fabs(OutlierToClassify->VectorDiffGrav[2])<=5 && OutlierToClassify->SPPotProp>0.25) {
//            cout<<"In enlarged SP";
            return OutlierTypeResult=SeptPell;
        }
        if (fabs(OutlierToClassify->VectorDiffGrav[0])+fabs(OutlierToClassify->VectorDiffGrav[1])<=5 && OutlierToClassify->ProportionNeighbour[IndexWM]<OutlierToClassify->ProportionNeighbour[IndexGM] && OutlierToClassify->SPPotProp>0.1) {
//            cout<<"In enlarged SP";
            return OutlierTypeResult=SeptPell;
        }
    }
    if (OutlierToClassify->ProportionNeighbour[IndexGM] < 0.55 && OutlierToClassify->ProportionNeighbour[IndexWM]<0.55 && OutlierToClassify->DistanceGrav <20) {
        cout <<" Need perhaps to reclassify as SP";
        if (fabs(OutlierToClassify->VectorDiffGrav[0])<4*OutlierToClassify->DistanceVentricle[1] && OutlierToClassify->SPPotProp>0.5) {
//            cout<<"...changed effective";
            return OutlierTypeResult=SeptPell;
        }
        
    }
    }
    
//    Check for Fourth ventricle
    if (OutlierToClassify->ProportionNeighbour[IndexWM]<OutlierToClassify->ProportionNeighbour[IndexGM] && OutlierToClassify->ProportionNeighbour[IndexCSF]>0 && OutlierToClassify->DistanceVentricle[1]>OutlierToClassify->DistanceCSFI[1] && OutlierToClassify->PropECSF>0) {
        if(OutlierToClassify->VectorDiffGrav[2]<0&& fabs(OutlierToClassify->VectorDiffGrav[0])<10){
            if(OutlierToClassify->BoundingBox[3]-OutlierToClassify->BoundingBox[2]<50 && OutlierToClassify->BoundingBox[3]<OutlierToClassify->CentreGravity[1]+10){
            return OutlierTypeResult=FourthV;
            }
        }
    }
//    Check for very suspicious subcortical
//    Periventricular
    if (OutlierToClassify->ProportionNeighbour[IndexGM]==0&&OutlierToClassify->ProportionNeighbour[IndexCSF]>0 && OutlierToClassify->DistanceVentricle[0]<=OutlierToClassify->DistanceCSFI[0]) {
        return OutlierTypeResult=PeriVNGM;
    }
    
    if (OutlierToClassify->ProportionNeighbour[IndexGM]==0 && OutlierToClassify->DistanceVentricle[0]<5) {
        return OutlierTypeResult=PeriV;
    }
    
    if (OutlierToClassify->ProportionNeighbour[IndexWM]==0 && OutlierToClassify->DGMBelonging) {
        return OutlierTypeResult=PeriVD;
    }
// Subcortical
    if (OutlierToClassify->ProportionNeighbour[IndexWM]==1) {
        return OutlierTypeResult=SubCort1;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexWM]>0.7) {
        return OutlierTypeResult=SubCort2;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexCSF]==0 && OutlierToClassify->ProportionNeighbour[IndexWM]>OutlierToClassify->ProportionNeighbour[IndexGM]) {
        return OutlierTypeResult=SubCort2;
    }
    if (OutlierToClassify->ProportionNeighbour[IndexCSF]==0 && OutlierToClassify->ProportionNeighbour[IndexWM]>0.15) {
        return OutlierTypeResult=SuspCS;
    }
//    Check for almost not lesion
    if (OutlierToClassify->Volume<10000 && OutlierToClassify->VectorDiffGrav[2]<-10 && OutlierToClassify->MahalVecQuant[min(numbmodal,2)][2]<2.9 *mult_modify ) {
        return FalseWMH;
    }
    if (OutlierToClassify->Volume<10000 &&  OutlierToClassify->PropDGM>0 && OutlierToClassify->MahalVecQuant[min(numbmodal,2)][2]<2.9 *mult_modify) {
        return FalseWMH;
    }
//    Default otherwise is out
    if (OutlierToClassify->ProportionNeighbour[IndexOut]>0.05 && OutlierToClassify->DistanceVentricle[0]>3) {
        cout<< "Out is def"<<endl;
        return OutlierTypeResult=OutWMH;
    }
    return OutlierTypeResult;
}


OutlierType ClassifyOutlierLacune(Outlier * OutlierToClassify,SEG_ANALYSIS * segment_analysis){
    OutlierType OutlierTypeResult=Lacune;
    float minExtentBox=10000;
    int numbmodal = segment_analysis->vecModalities.size();
    for (int d=0; d<3; d++) {
        if (minExtentBox>OutlierToClassify->ExtentBB[d]) {
            minExtentBox=OutlierToClassify->ExtentBB[d];
        }
    }
    if (OutlierToClassify->PropBorderExtent>0.75 && OutlierToClassify->Volume>4 && OutlierToClassify->PropWMHNeigh<0.1){
        return OutlierTypeResult=OutLac;
    }
    if (OutlierToClassify->PropBorderExtent>0.9 && OutlierToClassify->Volume>2){
        return OutlierTypeResult=OutLac;
    }
    
    if ((OutlierToClassify->DistanceOutI[0]<3 && OutlierToClassify->PropCGM>0.75)){
        return OutLac;
    }
    if (OutlierToClassify->DistanceOutI[0]<3 && OutlierToClassify->ProportionNeighbour[2]>0.25 && OutlierToClassify->PropECSF+OutlierToClassify->PropCGM>0.3)  {
        return OutLac;
    }
//    First case: Remaining iron deposition: characterised by no hypointensity in the mean T1 Mahalanobis distance
    if (numbmodal>1){
    if ((OutlierToClassify->MahalVecQuant[1][1]>0 || OutlierToClassify->MahalVecQuant[2][min(numbmodal,2)]<0) && (OutlierToClassify->MahalVecQuant[1][0]>-0.5 && OutlierToClassify->MahalVecQuant[1][min(numbmodal,2)]>1.5)) {
        return Iron;
    }
    if ((OutlierToClassify->MahalVecQuant[1][1]>0 || OutlierToClassify->MahalVecQuant[2][2]<0) && OutlierToClassify->DGMBelonging && (OutlierToClassify->MahalVecQuant[1][0]>-0.5) && OutlierToClassify->MahalVecQuant[1][2]>1 && OutlierToClassify->ProportionNeighbour[1]<OutlierToClassify->ProportionNeighbour[0] && OutlierToClassify->PropWMHNeigh<0.05 ) {
        return Iron;
    }
    }
//    Potential remaining blobs of ICSF
    if (OutlierToClassify->PropICSF>0.1 && !segment_analysis->flag_RuleCorr) {
        return ICSF;
    }
    if (OutlierToClassify->DistanceVentricle[0]==0 && OutlierToClassify->DistanceVentricle[1]<0.9 && !segment_analysis->flag_RuleCorr) {
        return ICSF;
    }
    if  (OutlierToClassify->DistanceVentricle[0]==0 && OutlierToClassify->DistanceVentricle[2]<3 && OutlierToClassify->ProportionOrigin[0] ==0 && OutlierToClassify->ProportionOrigin[1]==0){
        return ICSF;
    }
    if (OutlierToClassify->DistanceVentricle[2]<2 && OutlierToClassify->PropWMHNeigh==0) {
        return VentricleBorder;
    }
    if (OutlierToClassify->DistanceVentricle[2]<2 && minExtentBox<1.5) {
        return VentricleBorder;
    }
//    Then take care of those that are only flat
    bool flag_Flat=0;
    for (int d=0; d<3; d++) {
        if (OutlierToClassify->BoundingBox[2*d]-OutlierToClassify->BoundingBox[2*d+1]<=0.01) {
            flag_Flat=1;
            break;
        }
    }
    if (flag_Flat && OutlierToClassify->ProportionNeighbour[1]<0.5 && OutlierToClassify->PropDGM==0 && OutlierToClassify->Volume<2.5) {
        return NoiseFlat;
    }
    if (flag_Flat && OutlierToClassify->DistanceOutI[0]<3 && OutlierToClassify->ProportionNeighbour[1]<0.75 && OutlierToClassify->ProportionNeighbour[2]>0.2 ){
        return NoiseFlat;
    }
//    Then the most obvious almost gray matter only but with nothing much in hypointensity FLAIR
    if(numbmodal>1){
    if (OutlierToClassify->ProportionNeighbour[0]>OutlierToClassify->ProportionNeighbour[1] && OutlierToClassify->MahalVec[1][2]>-0.2  && OutlierToClassify->MahalVecQuant[2][2]>2 && OutlierToClassify->MahalVecQuant[1][2]>0) {
        return CorticalSheet;
    }
}

    if (!segment_analysis->flag_Parc && !segment_analysis->flag_RuleCorr) {
            if (OutlierToClassify->PropCGM>OutlierToClassify->PropDGM && OutlierToClassify->ProportionNeighbour[0]>OutlierToClassify->ProportionNeighbour[1] && OutlierToClassify->ProportionNeighbour[1]<0.25) {
                return CorticalSheet;
            }
            if (OutlierToClassify->PropCGM>OutlierToClassify->PropDGM && OutlierToClassify->ProportionNeighbour[0]>=OutlierToClassify->ProportionNeighbour[1] && OutlierToClassify->ProportionNeighbour[1]<0.35 && OutlierToClassify->PropCGM>=0.75) {
                return CorticalSheet;
            }
            if (OutlierToClassify->PropECSF > 0 && fabs(OutlierToClassify->VectorDiffGrav[2])<5) {
                return CorticalSheet;
            }
            if (OutlierToClassify->PropCGM >= 0.75 && (OutlierToClassify->ProportionNeighbour[0]+OutlierToClassify->ProportionNeighbour[2])>OutlierToClassify->ProportionNeighbour[1] && fabs(OutlierToClassify->VectorDiffGrav[2])<5 ) {
                return CorticalSheet;
            }
            if ( fabs(OutlierToClassify->VectorDiffGrav[2])<5 && OutlierToClassify->PropCGM>0 && OutlierToClassify->ProportionNeighbour[0]+OutlierToClassify->ProportionNeighbour[2]>0.3) {
                return CorticalSheet;
            }
            if (OutlierToClassify->ProportionNeighbour[0]>0.95 && OutlierToClassify->DGMBelonging==0 && OutlierToClassify->DistanceCSFI[0]<OutlierToClassify->DistanceVentricle[0]) {
                return CorticalSheet;
            }
            if (OutlierToClassify->ProportionNeighbour[0]>0.95 && OutlierToClassify->ProportionNeighbour[2]>0 && OutlierToClassify->DistanceCSFI[0]<OutlierToClassify->DistanceVentricle[0]) {
                return CorticalSheet;
            }
        //    ECSF
            if (OutlierToClassify->ProportionNeighbour[1]<OutlierToClassify->ProportionNeighbour[0] && OutlierToClassify->ProportionNeighbour[2]>0 && OutlierToClassify->DGMBelonging==0) {
                return ECSFRemain;
            }
            if (OutlierToClassify->ProportionNeighbour[1]<OutlierToClassify->ProportionNeighbour[0] && OutlierToClassify->ProportionNeighbour[2]>0 && OutlierToClassify->PropDGM==0 && OutlierToClassify->PropCGM>0.5 && OutlierToClassify->PropECSF>0) {
                return ECSFRemain;
            }
            //    ECSF PV
            if (OutlierToClassify->ProportionNeighbour[1]<0.05 && OutlierToClassify->DistanceWMI[0]>=OutlierToClassify->DistanceCSFI[0] && OutlierToClassify->DGMBelonging==0) {
                return ECSFRemain;
            }
            if (OutlierToClassify->ProportionNeighbour[3]>0) {
                return OutLac;
            }
            if (OutlierToClassify->ProportionNeighbour[2]>OutlierToClassify->ProportionNeighbour[1]&&!OutlierToClassify->DGMBelonging && OutlierToClassify->PropECSF>0.1) {
                return ECSFRemain;
            }
            if (OutlierToClassify->PropECSF>0.5 && OutlierToClassify->ProportionNeighbour[2]>0.4) {
                return ECSFRemain;
            }
            if((OutlierToClassify->ProportionNeighbour[0]>0.5 && OutlierToClassify->ProportionNeighbour[2]>0 && OutlierToClassify->DistanceVentricle[0]>OutlierToClassify->DistanceCSFI[0] && OutlierToClassify->PropCGM>=OutlierToClassify->PropDGM)){
                return SuspECSF;
            }
            if (OutlierToClassify->ProportionNeighbour[1]<OutlierToClassify->ProportionNeighbour[0] && OutlierToClassify->PropECSF>0.2 && OutlierToClassify->PropCGM>=OutlierToClassify->PropDGM && OutlierToClassify->ProportionNeighbour[1]<0.25) {
                return SuspECSF;
            }

    }
//    DGMLacunes
    if (OutlierToClassify->ProportionNeighbour[0]>0.9 && OutlierToClassify->DGMBelonging) {
        return DGMLacune;
    }
//    WMDGMLacunes
    if (OutlierToClassify->ProportionNeighbour[2]<0.1 && OutlierToClassify->ProportionNeighbour[0]<0.9 && OutlierToClassify->DGMBelonging) {
        return WMDGMLacune;
    }
//    WMLacunes
    if (OutlierToClassify->ProportionNeighbour[1]>0.7 && OutlierToClassify->DGMBelonging==0) {
        return WMLacune;
    }

    if(numbmodal>1){
    if ((OutlierToClassify->MahalVecQuant[1][2]>0 || OutlierToClassify->MahalVecQuant[2][2]>0) && OutlierToClassify->DGMBelonging) {
        return SuspIron;
    }
    if ((OutlierToClassify->MahalVecQuant[1][2]>0 || OutlierToClassify->MahalVecQuant[2][2]>0) &&(OutlierToClassify->MahalVecQuant[1][0]>-3 || OutlierToClassify->MahalVecQuant[2][0]>-3)) {
        return SuspLacune;
    }
}

    return OutlierTypeResult;
}


// From integer label array, ordered by decreasing lesion importance, using TreeToAnalyse to get the borders, build the lesion structure corresponding to each label and completing them with information from the rebuilt borders using the summarised segmentation that can be or not corrected for false positives. The summarised segmentation used must be the one for which the lesions are on a specific volume and not combined with the WM
vector<Lesion *> GetVectorLesion_quat(int * OrderedLabels,nifti_image * SummarisedSeg, TreeEM * TreeToAnalyse,SEG_ANALYSIS* segment_analysis,bool * VentricleBool, bool * DGMBool, bool * AcceptedGMBool, bool* SPRegion, float * ICSFPriors, float * DGMPriors,int * OrderedLabelsNIV, nifti_image * SegToAnalyse, nifti_image * SegToAnalyseNIV){
    vector<Lesion *> LesionVector;
    nifti_image * Mask=TreeToAnalyse->GetMask();
    //    WARNING : we assume hereafter that the mask is non null
    bool * MaskData=static_cast<bool *>(Mask->data);
    int Dim[3];
    Dim[0]=SummarisedSeg->nx;
    Dim[1]=SummarisedSeg->ny;
    Dim[2]=SummarisedSeg->nz;
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    float PixDim[3];
    PixDim[0]=SummarisedSeg->pixdim[1];
    PixDim[1]=SummarisedSeg->pixdim[2];
    PixDim[2]=SummarisedSeg->pixdim[3];
    float SumPixDim=PixDim[0]+PixDim[1]+PixDim[2];
    float SumDim=Dim[0]+Dim[1]+Dim[2];
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    int GravityIndex=GetCenterGravity(MaskData, Dim);
    
    vector<float *> ICSFDGMVector;
    float * ICSFDGM=NULL;
    if (ICSFPriors!=NULL && DGMPriors!=NULL) {
        ICSFDGMVector.push_back(ICSFPriors);
        ICSFDGMVector.push_back(DGMPriors);
        ICSFDGM=AddArray(ICSFDGMVector, numel);
    }
    int * L2S=TreeToAnalyse->GetL2S();
    int * S2L=TreeToAnalyse->GetS2L();
    int numbmodal=TreeToAnalyse->GetNumberModalities();
//    Creation of DataShifted according to different modalities to create corresponding TextureFeatures
    vector<float *> DataCorrectedVector;
    vector<vector<float *> > DataTotalShiftVector;
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    float * DataCorrected=TreeToAnalyse->GetDataBFCorrected();
    float * PixDimShift=new float[6];
    for (int m=0; m<numbmodal; m++) {
        vector<float *> DataShiftVector;
        DataCorrectedVector.push_back(&DataCorrected[numelmasked*m]);

        for (int d=0; d<3; d++) {
            if (m==0) {
                PixDimShift[2*d]=PixDim[d];
                PixDimShift[2*d+1]=PixDim[d];
            }
            int Trans [3];
            for (int d1=0; d1<3; d1++) {
                Trans[d1]=0;
            }
            Trans[d]=1;
            DataShiftVector.push_back(ShiftedVersion(&DataCorrected[numelmasked*m], Trans, Dim, Shift, L2S, S2L, numelmasked));
            for (int d1=0; d1<3; d1++) {
                Trans[d1]=0;
            }
            Trans[d]=-1;
            DataShiftVector.push_back(ShiftedVersion(&DataCorrected[numelmasked*m], Trans, Dim, Shift, L2S, S2L, numelmasked));
        }
        DataTotalShiftVector.push_back(DataShiftVector);
    }
    
    float * GMOShort=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
    float * GMOLong=CreateLong(GMOShort, L2S, numel);
    float * WMOShort=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexWM)->GetNormResp();
    float * WMOLong=CreateLong(WMOShort, L2S, numel);
    float * CSFOShort=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF)->GetNormResp();
    float * CSFOLong=CreateLong(CSFOShort, L2S, numel);
    float * OutOShort=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexOut)->GetNormResp();
    float * OutOLong=CreateLong(OutOShort, L2S, numel);
    nifti_image * HardSegGMI=HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp(), TreeToAnalyse,0.5);
    nifti_image * HardSegWMI=HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp(),TreeToAnalyse,0.5);
    nifti_image * HardSegCSFI=HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexCSF)->GetNormResp(), TreeToAnalyse, 0.5);
    nifti_image * HardSegOutI=HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexOut)->GetNormResp(), TreeToAnalyse, 0.5);
    nifti_image * HardSegOutO=HardSegmentationThresholdFromNormResp(TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexOut)->GetNormResp(), TreeToAnalyse, 0.5);
    float * SegWMI=static_cast<float *>(HardSegWMI->data);
    float * SegGMI=static_cast<float *>(HardSegGMI->data);
    float * SegCSFI=static_cast<float *>(HardSegCSFI->data);
    float * SegOutI=static_cast<float *>(HardSegOutI->data);
    float * SegOutO=static_cast<float *>(HardSegOutO->data);
    bool * GMIBool=TranscribeArray<float, bool>(SegGMI, numel);
    bool * WMIBool=TranscribeArray<float, bool>(SegWMI, numel);
    bool * CSFIBool=TranscribeArray<float, bool>(SegCSFI, numel);
    bool * OutIBool=TranscribeArray<float, bool>(SegOutI, numel);
    bool * OutOBool=TranscribeArray<float, bool>(SegOutO, numel);
    bool * OppMask=OpposeBoolArray(MaskData, numel);
    OROperationBool(OutIBool, OutOBool, OutOBool, numel);
    OROperationBool(OppMask, OutOBool, OutOBool, numel);
    nifti_image * DistanceGM=EuclideanDistanceImage(HardSegGMI, GMIBool, TreeToAnalyse->GetMask());
    nifti_image * DistanceWM=EuclideanDistanceImage(HardSegWMI, WMIBool, TreeToAnalyse->GetMask());
    nifti_image * DistanceCSF=EuclideanDistanceImage(HardSegCSFI, CSFIBool, TreeToAnalyse->GetMask());
    nifti_image * DistanceOut=EuclideanDistanceImage(HardSegOutI, OutOBool, NULL);
    nifti_image * DistanceSP=NULL;
    if (SPRegion!=NULL) {
        DistanceSP=EuclideanDistanceImage(HardSegCSFI, SPRegion, TreeToAnalyse->GetMask());
    }
//    nifti_set_filenames(DistanceGM, "/Users/Carole/Documents/PhD/POPPY/TestDistanceGM.nii.gz", 0, 0);
//    nifti_set_filenames(DistanceWM, "/Users/Carole/Documents/PhD/POPPY/TestDistanceWM.nii.gz", 0, 0);
//    nifti_set_filenames(DistanceCSF, "/Users/Carole/Documents/PhD/POPPY/TestDistanceCSF.nii.gz", 0, 0);
//    nifti_set_filenames(DistanceOut, "/Users/Carole/Documents/PhD/POPPY/TestDistanceOut.nii.gz", 0, 0);
//    nifti_image_write(DistanceWM);
//    nifti_image_write(DistanceGM);
//    nifti_image_write(DistanceOut);
//    nifti_image_write(DistanceCSF);
    
    float * DistanceGMI=static_cast<float *>(DistanceGM->data);
    float * DistanceWMI=static_cast<float *>(DistanceWM->data);
    float * DistanceCSFI=static_cast<float *>(DistanceCSF->data);
    float * DistanceOutI=NULL;
    float * DistanceSPI=NULL;
    if (DistanceOut!=NULL) {
        DistanceOutI=static_cast<float *>(DistanceOut->data);
    }
    if (DistanceSP!=NULL) {
        DistanceSPI=static_cast<float*>(DistanceSP->data);
    }
    
    
    
    int * CorrespondingCoordinatesGravity=CorrespondingCoordinates(GravityIndex,Dim,Shift);
    // defining borders needed to finish Lesion definition
    bool * BorderWMI=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 1);
    bool * BorderCSF=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 15);
    bool * BorderGMC=BorderExtraction_bis(TreeToAnalyse, SummarisedSeg, segment_analysis, 25);
    vector<int> OutIndexVector;
    OutIndexVector.push_back(-1);
    OutIndexVector.push_back(segment_analysis->IndexOut);
    bool * BorderSumOutMask=BorderExtractionThreshold(TreeToAnalyse,SummarisedSeg,OutIndexVector,0.2);
    nifti_image * HardSegSummarised=HardSegmentation_bis(SummarisedSeg, TreeToAnalyse->GetMask());
    bool * HardSegData=static_cast<bool *>(HardSegSummarised->data);
    
    for (int l=0; l<maxLabel; l++) {
        cout<<"Label "<<l+1<<"...";
        
        // Check the lesion for the NIV correspondance and creation of the bool lesion NIV
        vector<int> LNIV=GetListCorrespondingLabels(l+1, OrderedLabelsNIV, OrderedLabels, numel);
        int SizeNormal=GetLabelSize(l+1, OrderedLabels, numel);
        if (SizeNormal>0) {
            
            int SizeNIV=0;
            int numbLNIV=LNIV.size();
            for (int lniv=0; lniv<numbLNIV; lniv++) {
                SizeNIV+=GetLabelSize(LNIV[lniv], OrderedLabelsNIV, numel);
            }
            bool * LesionBoolNIV=NULL;
            bool * LesionBoolNIVTemp=NULL;
            Lesion * LesionNIVToPush=NULL;
            int * LesionBoolInt=NULL;
            float * ProportionNeighbourNIV=NULL;
            bool * LesionBool=NULL;
            int * LesionBoolIntNIV=NULL;
            
            if (SizeNIV!=SizeNormal && SizeNIV>0) {
                for (int lniv=0; lniv<numbLNIV; lniv++) {
                    LesionBoolNIVTemp=CreateLesionBool(OrderedLabelsNIV, LNIV[lniv], numel);
                    if (LesionBoolNIV==NULL) {
                        LesionBoolNIV=CopyArray(LesionBoolNIVTemp, numel);
                    }
                    else{
                        OROperationBool(LesionBoolNIVTemp, LesionBoolNIV, LesionBoolNIV, numel);
                    }
                    if (LesionBoolNIVTemp!=NULL) {
                        delete [] LesionBoolNIVTemp;
                        LesionBoolNIVTemp=NULL;
                    }
                }
                LesionBoolIntNIV=TranscribeArray<bool, int>(LesionBoolNIV, numel);
                bool * LesionBoolShortNIV=CreateShort(LesionBoolNIV, S2L, numelmasked);
                vector<TextureDescriptors*> DescriptorsLesionNIV;
                vector<TextureDescriptors1 *> DescriptorsLesionNIV1;
//                vector<vector<float *> > TestVector;
//                TestVector.push_back(DataCorrectedVector);
                for (int m=0; m<numbmodal; m++) {
//                    TextureDescriptors * TextTempTest=CreateTextureDescriptors(LesionBoolShort, DataCorrectedVector[m], TestVector[0], PixDimShift, TreeToAnalyse);
                    TextureDescriptors * TextTemp=CreateTextureDescriptors(LesionBoolShortNIV, DataCorrectedVector[m], DataTotalShiftVector[m], PixDimShift, TreeToAnalyse);
                    if (fabs(TextTemp->Correlation)>1) {
                        cout<<"Pb for correlation of TextTemp"<<endl;
                    }
                    TextureDescriptors1 * TextTemp1=CreateTextureDescriptors1(LesionBoolShortNIV, DataCorrectedVector[m], TreeToAnalyse);
                    DescriptorsLesionNIV.push_back(TextTemp);
                    DescriptorsLesionNIV1.push_back(TextTemp1);
                }
//                cout<<"Texture NIV done..."<<endl;

                LesionNIVToPush=BuildLesionFromConnectedLabels_bis(LesionBoolIntNIV, TreeToAnalyse, HardSegData, 1, segment_analysis);
//                cout<<"Lesion NIV built..."<<endl;
                LesionNIVToPush->Texture=DescriptorsLesionNIV;
                LesionNIVToPush->Texture1=DescriptorsLesionNIV1;
                float WeightGMOniv=SumOverMask<float,bool>(GMOLong, LesionBoolNIV, 0, numel);
                float WeightWMOniv=SumOverMask<float,bool>(WMOLong, LesionBoolNIV, 0, numel);
                float WeightCSFOniv=SumOverMask<float, bool>(CSFOLong, LesionBoolNIV, 0, numel);
                float WeightOutOniv=SumOverMask<float,bool>(OutOLong, LesionBoolNIV, 0, numel);
                float SumWeightniv=WeightGMOniv+WeightWMOniv+WeightCSFOniv+WeightOutOniv;
                if (SumWeightniv>0) {
                    LesionNIVToPush->ProportionOrigin=new float[4];
                    LesionNIVToPush->ProportionOrigin[0]=WeightGMOniv/SumWeightniv;
                    LesionNIVToPush->ProportionOrigin[1]=WeightWMOniv/SumWeightniv;
                    LesionNIVToPush->ProportionOrigin[2]=WeightCSFOniv/SumWeightniv;
                    LesionNIVToPush->ProportionOrigin[3]=WeightOutOniv/SumWeightniv;
                }
                
                if (LesionNIVToPush->BoundingBox!=NULL) {
//                    cout<<"Doing BoundingBox"<<endl;
                    LesionNIVToPush->RatioBoundingBox=new float [5];
                    bool * BoundingBoxBoolNIV=CreateBoolBoundingBox(LesionNIVToPush->BoundingBox, Dim);
//                    cout<<"BoundingBox created..."<<endl;
                    float RatioLesion=GetProportionAbove<bool, bool>(LesionBoolNIV, BoundingBoxBoolNIV, 0, numel);
                    float RatioGMI=GetProportionAbove<bool, bool>(GMIBool, BoundingBoxBoolNIV, 0, numel);
                    float RatioWMI=GetProportionAbove<bool,bool>(WMIBool, BoundingBoxBoolNIV, 0, numel);
                    float RatioCSFI=GetProportionAbove<bool,bool>(CSFIBool, BoundingBoxBoolNIV, 0, numel);
                    float RatioOutI=GetProportionAbove<bool, bool>(OutIBool, BoundingBoxBoolNIV, 0, numel);
//                    cout<<"Proportion above gotten !"<<endl;
                    LesionNIVToPush->RatioBoundingBox[0]=RatioGMI;
                    LesionNIVToPush->RatioBoundingBox[1]=RatioWMI;
                    LesionNIVToPush->RatioBoundingBox[2]=RatioCSFI;
                    LesionNIVToPush->RatioBoundingBox[3]=RatioOutI;
                    LesionNIVToPush->RatioBoundingBox[4]=RatioLesion;
                    if (BoundingBoxBoolNIV!=NULL) {
                        delete [] BoundingBoxBoolNIV;
                        BoundingBoxBoolNIV=NULL;
                    }
//                   cout<<" clearing of BoundingBoxBoolNIV done"<<endl;
                }
                bool NeighLesionWMI_niv=IsLesionCloseToBorder(LesionBoolIntNIV, 1, BorderWMI, Dim, Shift);
                bool NeighLesionCSF_niv=IsLesionCloseToBorder(LesionBoolIntNIV, 1, BorderCSF, Dim, Shift);
                bool NeighLesionGMC_niv=IsLesionCloseToBorder(LesionBoolIntNIV, 1, BorderGMC, Dim, Shift);
                bool NeighLesionOut_niv=IsLesionCloseToBorder(LesionBoolIntNIV, 1, BorderSumOutMask, Dim, Shift);
                LesionNIVToPush->NeighbourCSF=NeighLesionCSF_niv;
                if (LesionNIVToPush->DistanceCSF>SumPixDim) {
                    LesionNIVToPush->NeighbourCSF=0;
                }
                LesionNIVToPush->NeighbourGMC=NeighLesionGMC_niv;
                LesionNIVToPush->NeighbourWMI=NeighLesionWMI_niv;
                LesionNIVToPush->NeighbourOut=NeighLesionOut_niv;
                if (LesionBoolShortNIV!=NULL) {
                    delete [] LesionBoolShortNIV;
                    LesionBoolShortNIV=NULL;
                }
//                cout<<"Clearing of BoolShortNIV done"<<endl;
            }
            
            LesionBool=CreateLesionBool(OrderedLabels, l+1, numel);
            bool * LesionBoolShort=CreateShort(LesionBool, S2L, numelmasked);
            Lesion * LesionToPush=BuildLesionFromConnectedLabels_bis(OrderedLabels, TreeToAnalyse, HardSegData, l+1, segment_analysis);
//            cout<<"Lesion init built..."<<endl;
            vector<TextureDescriptors*> DescriptorsLesion;
            vector<TextureDescriptors1 *> DescriptorsLesion1;
//            vector<vector<float *> > TestVector;
//            TestVector.push_back(DataCorrectedVector);
            for (int m=0; m<numbmodal; m++) {
//                TextureDescriptors * TextTempTest=CreateTextureDescriptors(LesionBoolShort, DataCorrectedVector[m], TestVector[0], PixDimShift, TreeToAnalyse);
                TextureDescriptors * TextTemp=CreateTextureDescriptors(LesionBoolShort, DataCorrectedVector[m], DataTotalShiftVector[m], PixDimShift, TreeToAnalyse);
                if (fabs(TextTemp->Correlation)>1) {
//                    cout<<"Pb for correlation of TextTemp"<<endl;
                }
                TextureDescriptors1 * TextTemp1=CreateTextureDescriptors1(LesionBoolShort, DataCorrectedVector[m], TreeToAnalyse);
                DescriptorsLesion.push_back(TextTemp);
                DescriptorsLesion1.push_back(TextTemp1);
            }
//            cout<<"Texture descriptors done..."<<endl;
            LesionToPush->Texture=DescriptorsLesion;
            LesionToPush->Texture1=DescriptorsLesion1;
            if (LesionBoolShort!=NULL) {
                delete [] LesionBoolShort;
                LesionBoolShort=NULL;
            }
//            cout<<"LesionBoolShort cleared"<<endl;
            if (LesionToPush->BoundingBox!=NULL) {
                LesionToPush->RatioBoundingBox=new float [5];
                bool * BoundingBoxBool=CreateBoolBoundingBox(LesionToPush->BoundingBox, Dim);
//                cout<<"BoundingBox created"<<endl;
                float RatioLesion=GetProportionAbove<bool, bool>(LesionBool, BoundingBoxBool, 0, numel);
                float RatioGMI=GetProportionAbove<bool, bool>(GMIBool, BoundingBoxBool, 0, numel);
                float RatioWMI=GetProportionAbove<bool,bool>(WMIBool, BoundingBoxBool, 0, numel);
                float RatioCSFI=GetProportionAbove<bool,bool>(CSFIBool, BoundingBoxBool, 0, numel);
                float RatioOutI=GetProportionAbove<bool, bool>(OutIBool, BoundingBoxBool, 0, numel);
                LesionToPush->RatioBoundingBox[0]=RatioGMI;
                LesionToPush->RatioBoundingBox[1]=RatioWMI;
                LesionToPush->RatioBoundingBox[2]=RatioCSFI;
                LesionToPush->RatioBoundingBox[3]=RatioOutI;
                LesionToPush->RatioBoundingBox[4]=RatioLesion;
                if (BoundingBoxBool!=NULL) {
                    delete [] BoundingBoxBool;
                    BoundingBoxBool=NULL;
                }
//                cout<<"BoundingBoxBool cleared"<<endl;
            }
            float WeightGMO=SumOverMask<float,bool>(GMOLong, LesionBool, 0, numel);
            float WeightWMO=SumOverMask<float,bool>(WMOLong, LesionBool, 0, numel);
            float WeightCSFO=SumOverMask<float, bool>(CSFOLong, LesionBool, 0, numel);
            float WeightOutO=SumOverMask<float,bool>(OutOLong, LesionBool, 0, numel);
            float SumWeight=WeightGMO+WeightWMO+WeightCSFO+WeightOutO;
            if (SumWeight>0) {
                LesionToPush->ProportionOrigin=new float[4];
                LesionToPush->ProportionOrigin[0]=WeightGMO/SumWeight;
                LesionToPush->ProportionOrigin[1]=WeightWMO/SumWeight;
                LesionToPush->ProportionOrigin[2]=WeightCSFO/SumWeight;
                LesionToPush->ProportionOrigin[3]=WeightOutO/SumWeight;
            }
//            cout<<"Lesion rebuilt..."<<endl;
            bool NeighLesionWMI=IsLesionCloseToBorder(OrderedLabels, l+1, BorderWMI, Dim, Shift);
            bool NeighLesionCSF=IsLesionCloseToBorder(OrderedLabels, l+1, BorderCSF, Dim, Shift);
            bool NeighLesionGMC=IsLesionCloseToBorder(OrderedLabels, l+1, BorderGMC, Dim, Shift);
            bool NeighLesionOut=IsLesionCloseToBorder(OrderedLabels, l+1, BorderSumOutMask, Dim, Shift);
            LesionToPush->NeighbourCSF=NeighLesionCSF;
            if (LesionToPush->DistanceCSF>SumPixDim) {
                LesionToPush->NeighbourCSF=0;
            }
            LesionToPush->NeighbourGMC=NeighLesionGMC;
            LesionToPush->NeighbourWMI=NeighLesionWMI;
            LesionToPush->NeighbourOut=NeighLesionOut;
            
            if (ICSFDGM!=NULL) {
                LesionToPush->SPPotProp=GetProportionAbove<float,bool>(ICSFDGM, LesionBool, 0.45, numel);
                if (LesionNIVToPush!=NULL) {
                    LesionNIVToPush->SPPotProp=GetProportionAbove<float,bool>(ICSFDGM, LesionBoolNIV, 0.45, numel);
                }
            }
            
            if (ICSFPriors!=NULL) {
                LesionToPush->PropICSF=GetProportionAbove<float, bool>(ICSFPriors, LesionBool, 0.25, numel);
                if (LesionNIVToPush!=NULL) {
                    LesionNIVToPush->PropICSF=GetProportionAbove<float,bool>(ICSFPriors, LesionBoolNIV, 0.45, numel);
                }
            }
            
            if (DGMPriors!=NULL){
                LesionToPush->PropDGM=GetProportionAbove<float,bool>(DGMPriors, LesionBool, 0.4, numel);
                if (LesionNIVToPush!=NULL) {
                    LesionNIVToPush->PropDGM=GetProportionAbove<float,bool>(DGMPriors, LesionBoolNIV, 0.45, numel);
                }
            }
//            cout<<"ICSF for Prop done..."<<endl;
            if (VentricleBool!=NULL) { // Check distance to ventricle
                //            LesionToPush->DistanceVentricle=GetDistanceToSeg(OrderedLabels, l+1, TreeToAnalyse, VentricleSegBool);
                LesionToPush->DistanceVentricle=GetDistanceBetweenSeg(LesionBool, VentricleBool, Dim, Shift, PixDim);
                //            LesionToPush->DistanceExternalCSF=
                if (LesionNIVToPush!=NULL) {
                    LesionNIVToPush->DistanceVentricle=GetDistanceBetweenSeg(LesionBoolNIV, VentricleBool, Dim, Shift, PixDim);
                }
            }
//            cout<<"Ventricle Bool done"<<endl;
            if (LesionToPush->DistanceVentricle<=SumPixDim) {
                LesionToPush->NeighbourVentricle=1;
            }
            if (LesionNIVToPush!=NULL) {
                if (LesionNIVToPush->DistanceVentricle<=SumPixDim) {
                    LesionNIVToPush->NeighbourVentricle=1;
                }
            }
            float DistanceAcceptedGM=SumDim;
            float DistanceAcceptedNIVGM=SumDim;
            if (AcceptedGMBool!=NULL && CountNonZero(AcceptedGMBool, numel)>0)  { // If any island of GM, check if neighbour to one of them
                DistanceAcceptedGM=GetDistanceBetweenSeg(LesionBool, AcceptedGMBool, Dim, Shift, PixDim);
            }
            LesionToPush->DistanceAcceptedGM=DistanceAcceptedGM;
            
            if (LesionNIVToPush!=NULL) {
                if (AcceptedGMBool!=NULL && CountNonZero(AcceptedGMBool, numel)>0)  { // If any island of GM, check if neighbour to one of them
                    DistanceAcceptedNIVGM=GetDistanceBetweenSeg(LesionBoolNIV, AcceptedGMBool, Dim, Shift, PixDim);
                }
                LesionNIVToPush->DistanceAcceptedGM=DistanceAcceptedNIVGM;
                int CountIntersectNIVDGM=0;
                if (DGMBool !=NULL) { // Check if part of the lesion is also part of the DGM bool region
                    bool * IntersectDGMLesionNIV=new bool[numel];
                    ANDOperationBool(LesionBoolNIV, DGMBool, IntersectDGMLesionNIV, numel);
                    CountIntersectNIVDGM=CountNonZero(IntersectDGMLesionNIV, numel);
                    delete [] IntersectDGMLesionNIV;
                    IntersectDGMLesionNIV=NULL;
                }
                if (CountIntersectNIVDGM>0) {
                    LesionNIVToPush->DGMBelonging=1;
                }
                ProportionNeighbourNIV=ProportionNeighboursLesion(LesionBoolIntNIV, 1, SummarisedSeg, segment_analysis);

            }
            
            int CountIntersectDGM=0;
            if (DGMBool !=NULL) { // Check if part of the lesion is also part of the DGM bool region
                bool * IntersectDGMLesion=new bool[numel];
                ANDOperationBool(LesionBool, DGMBool, IntersectDGMLesion, numel);
                CountIntersectDGM=CountNonZero(IntersectDGMLesion, numel);
                delete [] IntersectDGMLesion;
                IntersectDGMLesion=NULL;
            }
            if (CountIntersectDGM>0) {
                LesionToPush->DGMBelonging=1;
            }
            float * ProportionNeighbour=ProportionNeighboursLesion(OrderedLabels, l+1, SummarisedSeg, segment_analysis);
            //        float * DistanceNeighbourGravity=DistanceNeighbourLesionGravity(OrderedLabels,l+1,SummarisedSeg,segment_analysis,CorrespondingCoordinatesGravity);
            int IndexCSF=segment_analysis->IndexCSF;
            int IndexGM=segment_analysis->IndexGM;
            int IndexWM=segment_analysis->IndexWM;
            int IndexOut=segment_analysis->IndexOut;
            LesionToPush->ProportionCSF=ProportionNeighbour[IndexCSF];
            LesionToPush->ProportionGM=ProportionNeighbour[IndexGM];
            LesionToPush->ProportionWM=ProportionNeighbour[IndexWM];
            LesionToPush->ProportionOut=ProportionNeighbour[IndexOut];
            
            LesionToPush->DistanceGMI.push_back(GetMin(DistanceGMI,LesionBool,numel));
            LesionToPush->DistanceGMI.push_back(GetMeanData(DistanceGMI, LesionBool, numel));
            LesionToPush->DistanceGMI.push_back(GetMaxArrayMasked(DistanceGMI, LesionBool, numel));
            
            LesionToPush->DistanceWMI.push_back(GetMin(DistanceWMI,LesionBool,numel));
            LesionToPush->DistanceWMI.push_back(GetMeanData(DistanceWMI, LesionBool, numel));
            LesionToPush->DistanceWMI.push_back(GetMaxArrayMasked(DistanceWMI, LesionBool, numel));
            
            LesionToPush->DistanceCSFI.push_back(GetMin(DistanceCSFI,LesionBool,numel));
            LesionToPush->DistanceCSFI.push_back(GetMeanData(DistanceCSFI, LesionBool, numel));
            LesionToPush->DistanceCSFI.push_back(GetMaxArrayMasked(DistanceCSFI, LesionBool, numel));
            
            LesionToPush->DistanceOutI.push_back(GetMin(DistanceOutI,LesionBool,numel));
            LesionToPush->DistanceOutI.push_back(GetMeanData(DistanceOutI, LesionBool, numel));
            LesionToPush->DistanceOutI.push_back(GetMaxArrayMasked(DistanceOutI, LesionBool, numel));
            
            if (DistanceSPI!=NULL) {
                LesionToPush->DistanceSP.push_back(GetMin(DistanceSPI, LesionBool,numel));
                LesionToPush->DistanceSP.push_back(GetMeanData(DistanceSPI, LesionBool, numel));
                LesionToPush->DistanceSP.push_back(GetMaxArrayMasked(DistanceSPI, LesionBool, numel));
            }
            else{
                LesionToPush->DistanceSP.push_back(-1);
                LesionToPush->DistanceSP.push_back(-1);
                LesionToPush->DistanceSP.push_back(-1);
            }

            
            if (ProportionNeighbour!=NULL) {
                delete [] ProportionNeighbour;
                ProportionNeighbour=NULL;
            }
//            cout<<"Proportion neighbour done"<<endl;
            
            //        Same for Lesion NIV
            if (LesionNIVToPush!=NULL) {
                LesionNIVToPush->ProportionCSF=ProportionNeighbourNIV[IndexCSF];
                LesionNIVToPush->ProportionGM=ProportionNeighbourNIV[IndexGM];
                LesionNIVToPush->ProportionWM=ProportionNeighbourNIV[IndexWM];
                LesionNIVToPush->ProportionOut=ProportionNeighbourNIV[IndexOut];
                if (ProportionNeighbourNIV!=NULL) {
                    delete [] ProportionNeighbourNIV;
                    ProportionNeighbourNIV=NULL;
                }
            }
            
            if (LesionNIVToPush!=NULL) {
                LesionNIVToPush->DistanceGMI.push_back(GetMin(DistanceGMI,LesionBoolNIV,numel));
                LesionNIVToPush->DistanceGMI.push_back(GetMeanData(DistanceGMI, LesionBoolNIV, numel));
                LesionNIVToPush->DistanceGMI.push_back(GetMaxArrayMasked(DistanceGMI, LesionBoolNIV, numel));
                
                LesionNIVToPush->DistanceWMI.push_back(GetMin(DistanceWMI,LesionBoolNIV,numel));
                LesionNIVToPush->DistanceWMI.push_back(GetMeanData(DistanceWMI, LesionBoolNIV, numel));
                LesionNIVToPush->DistanceWMI.push_back(GetMaxArrayMasked(DistanceWMI, LesionBoolNIV, numel));
                
                LesionNIVToPush->DistanceCSFI.push_back(GetMin(DistanceCSFI,LesionBoolNIV,numel));
                LesionNIVToPush->DistanceCSFI.push_back(GetMeanData(DistanceCSFI, LesionBoolNIV, numel));
                LesionNIVToPush->DistanceCSFI.push_back(GetMaxArrayMasked(DistanceCSFI, LesionBoolNIV, numel));
                
                LesionNIVToPush->DistanceOutI.push_back(GetMin(DistanceOutI,LesionBoolNIV,numel));
                LesionNIVToPush->DistanceOutI.push_back(GetMeanData(DistanceOutI, LesionBoolNIV, numel));
                LesionNIVToPush->DistanceOutI.push_back(GetMaxArrayMasked(DistanceOutI, LesionBoolNIV, numel));
                
                if (DistanceSPI!=NULL) {
                    LesionNIVToPush->DistanceSP.push_back(GetMin(DistanceSPI, LesionBool,numel));
                    LesionNIVToPush->DistanceSP.push_back(GetMeanData(DistanceSPI, LesionBool, numel));
                    LesionNIVToPush->DistanceSP.push_back(GetMaxArrayMasked(DistanceSPI, LesionBool, numel));
                }
                else{
                    LesionNIVToPush->DistanceSP.push_back(-1);
                    LesionNIVToPush->DistanceSP.push_back(-1);
                    LesionNIVToPush->DistanceSP.push_back(-1);
                }
                                                       
            }
//            cout<<"DistanceINIV done..."<<endl;
            
            //        Centre of gravity checking for Lesion NIV if exists
            if (LesionNIVToPush!=NULL) {
                int IndexLesionGravCenterNIV=GetCenterGravity(LesionBoolNIV, Dim);
                int * CorrespondingCoordGravNIV=CorrespondingCoordinates(IndexLesionGravCenterNIV, Dim, Shift);
                for (int d=0; d<3; d++) {
                    LesionNIVToPush->CentreGravity.push_back(CorrespondingCoordGravNIV[d]);
                }
                
                vector<int> IndicesPathNIV=GetIndicesMinPath(GravityIndex,IndexLesionGravCenterNIV,Dim,Shift,PixDim);
                //            int numbPath=IndicesPathNIV.size();
                float * PropIndicesPathNIV= ProportionIndicesSegmentation( IndicesPathNIV, HardSegSummarised);
                LesionNIVToPush->DistanceGrav=GetDistanceBetweenPoints(IndexLesionGravCenterNIV, GravityIndex, Dim, PixDim);
                for (int d=0; d<3; d++) {
                    LesionNIVToPush->VectorDiffGrav.push_back((CorrespondingCoordGravNIV[d]-CorrespondingCoordinatesGravity[d]));
                }
                
                LesionNIVToPush->ProportionGravCSF=PropIndicesPathNIV[IndexCSF];
                LesionNIVToPush->ProportionGravGM=PropIndicesPathNIV[IndexGM];
                LesionNIVToPush->ProportionGravWM=PropIndicesPathNIV[IndexWM];
                LesionNIVToPush->ProportionGravOut=PropIndicesPathNIV[IndexOut];
                if (PropIndicesPathNIV!=NULL) {
                    delete [] PropIndicesPathNIV;
                    PropIndicesPathNIV=NULL;
                }
                if (LesionBoolNIV!=NULL) {
                    delete [] LesionBoolNIV;
                    LesionBoolNIV=NULL;
                }
                if (CorrespondingCoordGravNIV!=NULL) {
                    delete [] CorrespondingCoordGravNIV;
                    CorrespondingCoordGravNIV=NULL;
                }
//                cout<<"Clearing of NIV done"<<endl;
            }
            
            //        Check distance of Center of gravity and proportion of Path in CSF of WM inliers
            
            int IndexLesionGravCenter=GetCenterGravity(LesionBool, Dim);
            int * CorrespondingCoordGrav=CorrespondingCoordinates(IndexLesionGravCenter, Dim, Shift);
            for (int d=0; d<3; d++) {
                LesionToPush->CentreGravity.push_back(CorrespondingCoordGrav[d]);
            }
            
            vector<int> IndicesPath=GetIndicesMinPath(GravityIndex,IndexLesionGravCenter,Dim,Shift,PixDim);
            //        int numbPath=IndicesPath.size();
            float * PropIndicesPath= ProportionIndicesSegmentation( IndicesPath, HardSegSummarised);
            LesionToPush->DistanceGrav=GetDistanceBetweenPoints(IndexLesionGravCenter, GravityIndex, Dim, PixDim);
            for (int d=0; d<3; d++) {
                LesionToPush->VectorDiffGrav.push_back((CorrespondingCoordGrav[d]-CorrespondingCoordinatesGravity[d]));
            }
            
            LesionToPush->ProportionGravCSF=PropIndicesPath[IndexCSF];
            LesionToPush->ProportionGravGM=PropIndicesPath[IndexGM];
            LesionToPush->ProportionGravWM=PropIndicesPath[IndexWM];
            LesionToPush->ProportionGravOut=PropIndicesPath[IndexOut];
            if (PropIndicesPath!=NULL) {
                delete [] PropIndicesPath;
                PropIndicesPath=NULL;
            }
            if (LesionBool!=NULL) {
                delete [] LesionBool;
                LesionBool=NULL;
            }
            if (CorrespondingCoordGrav!=NULL) {
                delete [] CorrespondingCoordGrav;
                CorrespondingCoordGrav=NULL;
            }

            if (segment_analysis->flag_correctionLevel==1) {
                LesionCodeImprovedT1T2(LesionToPush);
                if (LesionNIVToPush!=NULL) {
                    LesionCodeImprovedT1T2(LesionNIVToPush);
                }
            }

            else{
                LesionCodeImproved(LesionToPush);
                if (LesionNIVToPush!=NULL) {
                    LesionCodeImproved(LesionNIVToPush);
                }
            }
//            if (segment_analysis->flag_correctionLevel==3) {
//                bool FPDGM=CheckForFPDGM(LesionToPush->PropDGM, LesionToPush->MahalVec, LesionToPush->MahalVecQuant);
//                LesionToPush->LesionType=FPDGM==1?NL:LesionToPush->LesionType;
//                if (LesionNIVToPush!=NULL) {
//                    bool FPDGMNIV=CheckForFPDGM(LesionToPush->PropDGM, LesionToPush->MahalVec, LesionToPush->MahalVecQuant);
//                    LesionNIVToPush->LesionType=FPDGMNIV==1?NL:LesionNIVToPush->LesionType;
//                }
//                
//            }
            //        If there is a LesionNIVToPush and the codes are the same, then include the difference in the label and push the corresponding lesion + Alter SegAnalysis, OrderedLabels...
            if (LesionNIVToPush!=NULL) {
                if (LesionNIVToPush->LesionType>0 && LesionToPush->LesionType>0) {
                    cout<<"Changing to NIV with older size "<<LesionToPush->Volume<<" and new size "<<LesionNIVToPush->Volume<<endl;
                    // Add again to ordered labels the missing voxels and put them back as well in SegToAnalyse
                    vector<int> IndicesLesionNIV=GetListIndicesLabel(LesionBoolIntNIV, Dim, 1);
                    cout<<"size LesionNIV is "<<IndicesLesionNIV.size()<<endl;
                    
                    float * SegToAnalyseData=static_cast<float *>(SegToAnalyse->data);
                    float * SegToAnalyseDataNIV=static_cast<float *>(SegToAnalyseNIV->data);
                    int sizeNIV=IndicesLesionNIV.size();
                    for (int s=0; s<sizeNIV; s++) {
                        OrderedLabels[IndicesLesionNIV[s]]=l+1;
                        SegToAnalyseData[IndicesLesionNIV[s]]=SegToAnalyseDataNIV[IndicesLesionNIV[s]];
                    }
                    LesionVector.push_back(LesionNIVToPush);
                    for (int m=0; m<numbmodal; m++) {
                        if (fabs(LesionNIVToPush->Texture[m]->Correlation)>1) {
                            cout<<"Pb in correlation when LesionNIVToPush"<<endl;
                        }
                    }
                    delete LesionToPush;
                    cout<<"Change to LesionNIV"<<endl;
                }
                else{
                    delete LesionNIVToPush;
                    LesionVector.push_back(LesionToPush);
                    for (int m=0; m<numbmodal; m++) {
                        if (fabs(LesionToPush->Texture[m]->Correlation)>1) {
                            cout<<"Pb in correlation when LesionToPush"<<endl;
                        }
                    }
                    cout<<"No need of change between Lesion and LesionNIV"<<endl;
                }
                if (LesionBoolIntNIV!=NULL) {
                    delete [] LesionBoolIntNIV;
                    LesionBoolIntNIV=NULL;
                }
//                cout<<"Clearing of BoolIntNIV done"<<endl;
            }
            else{
                //        cout<<"Trying to push lesion"<<endl;
                if (LesionToPush->Volume>0) {
                    LesionVector.push_back(LesionToPush);
                    cout<<"treated"<<endl;
                }
                else{
                    cout<<"Lesion "<<l+1<<" is void... "<<endl;
                }
            }
            if(LesionBool!=NULL){
                delete [] LesionBool;
                LesionBool=NULL;
            }
            if(LesionBoolInt!=NULL){
                delete [] LesionBoolInt;
                LesionBoolInt=NULL;
            }
            if(LesionBoolNIV!=NULL){
                delete [] LesionBoolNIV;
                LesionBoolNIV=NULL;
            }
//            cout<<"Final clearing done "<<endl;
        }
        else{
            cout<<"Nothing in this lesion anymore of label "<<l+1<<endl;
        }
        
    }
    
    cout<<"All labels treated for creation of vector "<<endl;
    
    if (HardSegSummarised!=NULL) {
        nifti_image_free(HardSegSummarised);
        HardSegSummarised=NULL;
    }
    cout<<"Cleared HardSeg"<<endl;
    
    if(ICSFDGM!=NULL){
        delete [] ICSFDGM;
        ICSFDGM=NULL;
    }
    cout<<"Cleared ICSFDGM"<<endl;
    
    if (DistanceOut!=NULL) {
        nifti_image_free(DistanceOut);
        DistanceOut=NULL;
    }
    cout<<"Cleared DistanceOut"<<endl;
    if (DistanceCSF!=NULL) {
        nifti_image_free(DistanceCSF);
        DistanceCSF=NULL;
    }
    cout<<"Cleared DistanceCSF"<<endl;
    if (DistanceWM!=NULL) {
        nifti_image_free(DistanceWM);
        DistanceWM=NULL;
    }
    cout<<"Cleared DistanceWM"<<endl;
    if (DistanceGM!=NULL) {
        nifti_image_free(DistanceGM);
        DistanceGM=NULL;
    }
    cout<<"Cleared DistanceGM"<<endl;
    if (DistanceSP!=NULL) {
        nifti_image_free(DistanceSP);
        DistanceSP=NULL;
    }
    cout<<"Cleared DistanceSP"<<endl;
    if (HardSegCSFI!=NULL) {
        nifti_image_free(HardSegCSFI);
        HardSegCSFI=NULL;
    }
    cout<<"Cleared HardCSFI"<<endl;
    if (HardSegWMI!=NULL) {
        nifti_image_free(HardSegWMI);
        HardSegWMI=NULL;
    }
    cout<<"Cleared HardSegWMI"<<endl;
    if (HardSegGMI!=NULL) {
        nifti_image_free(HardSegGMI);
        HardSegGMI=NULL;
    }
    cout<<"Cleared HardSegGMI"<<endl;
    if (HardSegOutI!=NULL) {
        nifti_image_free(HardSegOutI);
        HardSegOutI=NULL;
    }
    cout<<"Cleared HardSegOutI"<<endl;
    if(GMOLong!=NULL){
        delete [] GMOLong;
        GMOLong=NULL;
    }
    cout<<"Cleared GMOLong"<<endl;
    if(WMOLong!=NULL){
        delete [] WMOLong;
        WMOLong=NULL;
    }
    cout<<"Cleared WMOLong"<<endl;
    if(CSFOLong!=NULL){
        delete [] CSFOLong;
        CSFOLong=NULL;
    }
    cout<<"Cleared CSFOLong"<<endl;
    if(OutOLong!=NULL){
        delete [] OutOLong;
        OutOLong=NULL;
    }
    cout<<"Cleared OutOLong"<<endl;
    for (int m=0; m<numbmodal; m++) {
        for (int s=0; s<6; s++) {
            if (DataTotalShiftVector[m][s]!=NULL) {
                delete [] DataTotalShiftVector[m][s];
                DataTotalShiftVector[m][s]=NULL;
            }
        }
    }
    cout<<"Cleared DataShift"<<endl;
    
    
    if (BorderCSF!=NULL) {
         delete [] BorderCSF;
        BorderCSF=NULL;
    }
    if (BorderWMI!=NULL) {
        delete [] BorderWMI;
        BorderWMI=NULL;
    }
    if (BorderGMC!=NULL) {
        delete [] BorderGMC;
        BorderGMC=NULL;
    }
    if (BorderSumOutMask!=NULL) {
        delete [] BorderSumOutMask;
        BorderSumOutMask=NULL;
    }
    if (CorrespondingCoordinatesGravity!=NULL) {
        delete [] CorrespondingCoordinatesGravity;
        CorrespondingCoordinatesGravity=NULL;
    }
    cout << " Returning lesion vector "<<endl;
    return LesionVector;
}




// From integer label array, ordered by decreasing lesion importance, using TreeToAnalyse to get the borders, build the lesion structure corresponding to each label and completing them with information from the rebuilt borders
vector<Lesion *> GetVectorLesion(int * OrderedLabels,TreeEM * TreeToAnalyse,SEG_ANALYSIS* segment_analysis){
    vector<Lesion *> LesionVector;
    int numel=TreeToAnalyse->GetNumberElements();
    int maxLabel=GetMaxLabel(OrderedLabels, numel);
    
    // defining borders needed to finish Lesion definition
    bool * BorderWMI=BorderExtraction(TreeToAnalyse, segment_analysis, 1);
    bool * BorderCSF=BorderExtraction(TreeToAnalyse, segment_analysis, 15);
    bool * BorderGMC=BorderExtraction(TreeToAnalyse, segment_analysis, 25);
    
    //    int * Dim=new int[3];
    int Dim[3];
    //    int * Shift=new int [3];
    int Shift[3];
    for (int i=0; i<3; i++) {
        Dim[i]=TreeToAnalyse->GetDataImage()->dim[i+1];
    }
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    
    for (int l=0; l<maxLabel; l++) {
        cout<<"Label "<<l+1<<"...";
        Lesion * LesionToPush=BuildLesionFromConnectedLabels(OrderedLabels, TreeToAnalyse, l+1, segment_analysis);
        cout<<"Lesion rebuilt"<<endl;
        bool NeighLesionWMI=IsLesionCloseToBorder(OrderedLabels, l+1, BorderWMI, Dim, Shift);
        bool NeighLesionCSF=IsLesionCloseToBorder(OrderedLabels, l+1, BorderCSF, Dim, Shift);
        bool NeighLesionGMC=IsLesionCloseToBorder(OrderedLabels, l+1, BorderGMC, Dim, Shift);
        LesionToPush->NeighbourCSF=NeighLesionCSF;
        LesionToPush->NeighbourGMC=NeighLesionGMC;
        LesionToPush->NeighbourWMI=NeighLesionWMI;
        LesionCode(LesionToPush);
        //        cout<<"Trying to push lesion"<<endl;
        LesionVector.push_back(LesionToPush);
        cout<<"treated"<<endl;
    }
    
    //    delete [] Dim;
    //    delete [] Shift;
    delete [] BorderCSF;
    delete [] BorderWMI;
    delete [] BorderGMC;
    
    //    Shift=NULL;
    //    Dim=NULL;
    BorderGMC=NULL;
    BorderCSF=NULL;
    BorderWMI=NULL;
    
    return LesionVector;
}






// Print on TxtFileLesion the count of lesions and corresponding volume calculated per LesionType according to CountperType and VolumeperType
void PrintCountVolperType(int * CountperType,float * VolumeperType,ostream& TxtFileLesion){
    string Subtypes[]={"FP", "CloseCSF1","CloseCSF2","Subcortical1","Subcortical2"};
    for (int t=0; t<5; t++) {
        TxtFileLesion<<"LesionSubtype "<<Subtypes[t]<<" "<<CountperType[t]<<" "<<VolumeperType[t]<<endl;
    }
}

// Select and put in array the intensities of DataImage at modality Modal that are contained in NBBPrint but avoiding direction DirectionAvoid
float * PrintData(nifti_image * DataImage,int Modal, int * NBBToPrint,int DirectionAvoid){
    // First determine size of resulting array.
    vector<int> VectSize;
    int PlaneIndex;
    int sizeTot=1;
    int NewNBB[6];
    int Dim[3];
    int Shift[3];
    for (int d=0; d<3; d++) {
        Dim[d]=DataImage->dim[d+1];
        Shift[d]=d>0?Dim[d-1]*Shift[d-1]:1;
        if (d!=DirectionAvoid) {
            VectSize.push_back(abs(NBBToPrint[2*d]-NBBToPrint[2*d+1]));
            sizeTot*=abs(NBBToPrint[2*d]-NBBToPrint[2*d+1]);
            NewNBB[2*d]=NBBToPrint[2*d];
            NewNBB[2*d+1]=NBBToPrint[2*d+1];
        }
        else{
            PlaneIndex=0.5*(NBBToPrint[2*d]+NBBToPrint[2*d+1]);
            NewNBB[2*d]=PlaneIndex;
            NewNBB[2*d+1]=PlaneIndex+1;
        }
    }
    float * Result=new float[sizeTot];
    int i=0;
    // Select data that is relevant
    float * DataImageData=static_cast<float*>(DataImage->data);
    int numel=DataImage->nx*DataImage->ny*DataImage->nz;
    float * ModalInterest=&DataImageData[Modal*numel];
    // Find the plane of interest given the direction that should not change and the NBB to print and copy it somewhere.
    for (int x=NewNBB[0]; x<NewNBB[1]; x++) {
        x=x<0?0:x;
        x=x>=Dim[0]?Dim[0]-1:x;
        for (int y=NewNBB[2]; y<NewNBB[3]; y++) {
            y=y<0?0:y;
            y=y>=Dim[1]?Dim[1]-1:y;
            for (int z=NewNBB[4]; z<NewNBB[5]; z++) {
                z=z<0?0:z;
                z=z>=Dim[2]?Dim[2]-1:z;
                Result[i]=ModalInterest[x+y*Shift[1]+z*Shift[2]];
                i++;
            }
        }
    }
    return Result;
    
}


// Print the LesionRefIntensity in TextFile with first the characterisation, then the volume, the true working volume, the DSC, the Mean, the Min and the Max of TPMahal the FNMahal and the FPMahal followed by the number of invalid FP

//Print the global LesionIntensityRef vector in the txtFile
void PrintAnalysisPerRefIntensityConnected(vector<LesionRefIntensity *>VectorLesionIntensity, ostream & TxtFileLesionIntensity){
    TxtFileLesionIntensity<<"Char Volume TVol DSC TP FP FN Ref Seg MeanTP MeanFP MeanFN MeanRef MeanSeg MinTP MinFP MinFN MinRef MinSeg MaxTP MaxFP MaxFN MaxRef MaxSeg QuantMinTP QuantMinFP QuantMinFN QuantMinRef QuantMinSeg QuantMedTP QuantMedFP QuandMedFN QuantMedRef QuantMedSeg QuantMaxTP QuantMaxFP QuantMaxFN QuantMaxRef QuantMaxSeg TPNotAgree FPNotAgree FNNotAgree RefNotAgree SegNotAgree PVTP PVFP PVFN PVRef PVSeg"<<endl;
    int numbLesions= VectorLesionIntensity.size();
    for (int l=0; l<numbLesions; l++) {
        PrintLesionRefIntensity(VectorLesionIntensity[l], TxtFileLesionIntensity);
        TxtFileLesionIntensity<<endl;
    }
}


void PrintAnalysisPerRefIntensityConnectedMahalProp(vector<LesionRefIntensity *>VectorLesionIntensity, int Index, ostream & TxtFileLesionIntensity){
    TxtFileLesionIntensity<<"Char Volume TVol DSC TP FP FN Ref Seg PropTP PropFP PropFN PropRef PropSeg"<<endl;
    int numbLesions= VectorLesionIntensity.size();
    for (int l=0; l<numbLesions; l++) {
        PrintLesionRefIntensityMahalProp(VectorLesionIntensity[l],Index, TxtFileLesionIntensity);
        TxtFileLesionIntensity<<endl;
    }
}



//Print on TxtFileRef all the analysis per reference lesion using AnalysisPerRefConnected
void PrintAnalysisPerRefConnected(int * ResultAnalysisRefConnected, int MaxLabel,ostream & TxtResRefConnected){
    for (int l=0; l<MaxLabel; l++) {
        for (int t=0; t<6; t++) {
            TxtResRefConnected<<ResultAnalysisRefConnected[l*6+t]<<" ";
        }
        TxtResRefConnected<<2.0*ResultAnalysisRefConnected[l*6+2]/(2.0*ResultAnalysisRefConnected[l*6+2]+ResultAnalysisRefConnected[l*6+3]+ResultAnalysisRefConnected[l*6+4])<<endl;
    }
}

// Print on TxtNormDistFile the results for the NormDistStudy
void PrintNormDistResult(float * ProportionLesVolDist, int * ExtentLesion, float * LayerIntensity, int MaxLabel, int numbmodal, ostream & TxtNormDistFile,SEG_ANALYSIS* segment_analysis){
    int numbLaminae=segment_analysis->numbLaminae[0];
    if (ProportionLesVolDist!=NULL) { // First if not NULL print the volume and proportion in each lamina
        for (int l=0; l<numbLaminae; l++) {
            TxtNormDistFile<<"Lamina "<<l<<" Volume "<<ProportionLesVolDist[4*l+1]<<" PercentageLes "<< ProportionLesVolDist[4*l]*100<< " PercentageLayer "<<ProportionLesVolDist[4*l+2]*100<<" PercentageRatio "<<ProportionLesVolDist[4*l+3]*100<<endl;
        }
    }
    TxtNormDistFile<<endl;
    
    //    Printing Intensity ratio for each layer for lesion against healthy WM (as of date, healthy WM considered globally 10th september 2014)
    int sizeResultModal=3*numbLaminae;
    if (LayerIntensity!=NULL) {
        for (int m=0; m<numbmodal; m++) {
            TxtNormDistFile<<"Modality "<< m<<endl;
            for(int l=0;l<numbLaminae;l++){
                TxtNormDistFile<<"Lamina "<<l<<" MinRatio "<<LayerIntensity[m*sizeResultModal+3*l]<<" MeanRatio "<<LayerIntensity[m*sizeResultModal+3*l+1]<<" MaxRatio "<<LayerIntensity[m*sizeResultModal+3*l+2]<<endl;
            }
        }
        TxtNormDistFile<<endl;
    }
    
    
    
    if (ExtentLesion!=NULL) { // Then for all remaining Labels (checking that the extent is in the right order) print result of extent
        for (int l=0; l<MaxLabel; l++) {
            if (ExtentLesion[3*l+1]<=ExtentLesion[3*l+2]) { // Checking that the extent is in the logical way (otherwise means that this lesion has been corrected and is not part of the final LesionSegmentation)
                TxtNormDistFile<<"Lesion "<<ExtentLesion[3*l]<<" minLamina "<<ExtentLesion[3*l+1]<<" maxLamina "<<ExtentLesion[3*l+2]<<endl;
            }
        }
    }
}

// Returns an upper bound of the minimum radius of extension needed to coalesce with an other label. The maximum radius by default is 15 voxels. The AuthorisedRegion in a boolean array of same size as OrderedLabels specifies if the element can be accepted when performing the dilation. Allows for a correction and therefore never going through ventricles and GM for example.
//WARNING : WILL ONLY BE MEANINGFUL FOR ISOTROPIC IMAGES : SOLVED BY USING ANISOTROPIC MORPHOLOGICAL CHANGE
float RadiusLesionCoalescence(int * OrderedLabels, int Label, bool * AuthorisedRegion, nifti_image * BasisImage, float & Radius, int & MetLabel, int maxRadius=15){
    //    bool flag_otherLabelReached=0;
    int numel=BasisImage->nx*BasisImage->ny*BasisImage->nz;
    vector<int> DimVector;
    float * PixDim=new float[3];
    for (int d=0; d<3; d++) {
        DimVector.push_back(BasisImage->dim[d+1]);
        PixDim[d]=BasisImage->pixdim[d+1];
    }
    float MinPixDim=GetMin(PixDim, 3);
    //    Check if label is available in OrderedLabels
    bool flag_oklabel=IsLabelPresent(Label, OrderedLabels, numel);
    if (!flag_oklabel) {
        cout<<"Label "<<Label<<" not available for growing"<<endl;
        return -1;
    }
    float * RegionToGrow=new float[numel];
    for (int i=0; i<numel; i++) {
        RegionToGrow[i]=0;
        if (OrderedLabels[i]==Label) {
            RegionToGrow[i]=1;
        }
    }
    int ks=1;
    float * RegionToGrowNew=NULL;
    while (!flag_oklabel && ks<=maxRadius) {
        //        Dilation of the lesion according to kernel of semi size ks
        RegionToGrowNew=AnisotropicMorphologicalChange(RegionToGrow, 3, DimVector, 0, PixDim);
        //        Correction for any voxel that would not be in the accepted region and
        for (int i=0; i<numel; i++) {
            if (RegionToGrowNew[i]>0.9) {
                if (AuthorisedRegion[i]==0) {
                    RegionToGrowNew[i]=0;
                }
                //                Check if another label is in the grown region
                if (RegionToGrowNew[i]>0.9) {
                    if (OrderedLabels[i]!=0 && OrderedLabels[i]!=Label) {
                        flag_oklabel=1;
                        MetLabel=OrderedLabels[i];
                        break;
                    }
                }
                
            }
        }
        if(!flag_oklabel){ // meaning that we have still not reached another lesion
            ks++;
            //            Reinitialisation for new dilation
            delete [] RegionToGrow;
            RegionToGrow=NULL;
            RegionToGrow=RegionToGrowNew;
        }
    }
    if (RegionToGrowNew!=NULL) {
        delete [] RegionToGrowNew;
        RegionToGrowNew=NULL;
    }
    if (RegionToGrow!=NULL) {
        delete [] RegionToGrow;
        RegionToGrow=NULL;
    }
    Radius=ks*MinPixDim;
    return ks;
    
}



// Print the LesionRefIntensity in TextFile with first the characterisation, then the volume, the true working volume, the DSC, the Mean, the Min and the Max of TPMahal the FNMahal and the FPMahal followed by the number of invalid FP
void PrintLesionRefIntensity(LesionRefIntensity * LesionToPrint, ostream & TxtFileLesion){
    TxtFileLesion<<LesionToPrint->FlagTypeConnectedComponent<<" ";
    TxtFileLesion<<LesionToPrint->Volume<<" ";
    TxtFileLesion<<LesionToPrint->TrueWorkingVolume<<" ";
    TxtFileLesion<<LesionToPrint->DSC<<" ";
    TxtFileLesion<<LesionToPrint->TPl<<" ";
    TxtFileLesion<<LesionToPrint->FPl<<" ";
    TxtFileLesion<<LesionToPrint->FNl<<" ";
    TxtFileLesion<<LesionToPrint->Refl<<" ";
    TxtFileLesion<<LesionToPrint->Segl<<" ";
    for (int i=0; i<6; i++) {
        TxtFileLesion<<LesionToPrint->TPMahal[i]<<" ";
        TxtFileLesion<<LesionToPrint->FPMahal[i]<<" ";
        TxtFileLesion<<LesionToPrint->FNMahal[i]<<" ";
        TxtFileLesion<<LesionToPrint->RefMahal[i]<<" ";
        TxtFileLesion<<LesionToPrint->SegMahal[i]<<" ";
    }
    TxtFileLesion<<LesionToPrint->TPNotAgree<<" ";
    TxtFileLesion<<LesionToPrint->FPNotAgree<<" ";
    TxtFileLesion<<LesionToPrint->FNNotAgree<<" ";
    TxtFileLesion<<LesionToPrint->RefNotAgree<<" ";
    TxtFileLesion<<LesionToPrint->SegNotAgree<<" ";
    for (int i=0; i<5; i++) {
        TxtFileLesion<<LesionToPrint->ProportionCloseVentricle[i]<<" ";
    }
}


// Print the LesionRefIntensity in TextFile with first the characterisation, then the volume, the true working volume, the DSC, the Mean, the Min and the Max of TPMahal the FNMahal and the FPMahal followed by the number of invalid FP
void PrintLesionRefIntensityMahalProp(LesionRefIntensity * LesionToPrint, int Index, ostream & TxtFileLesion){
    Index=Index>=10?10:Index;
    Index=Index<0?0:Index;
    TxtFileLesion<<LesionToPrint->FlagTypeConnectedComponent<<" ";
    TxtFileLesion<<LesionToPrint->Volume<<" ";
    TxtFileLesion<<LesionToPrint->TrueWorkingVolume<<" ";
    TxtFileLesion<<LesionToPrint->DSC<<" ";
    TxtFileLesion<<LesionToPrint->TPl<<" ";
    TxtFileLesion<<LesionToPrint->FPl<<" ";
    TxtFileLesion<<LesionToPrint->FNl<<" ";
    TxtFileLesion<<LesionToPrint->Refl<<" ";
    TxtFileLesion<<LesionToPrint->Segl<<" ";
    TxtFileLesion<<LesionToPrint->PropMahalTP[Index]<<" ";
    TxtFileLesion<<LesionToPrint->PropMahalFP[Index]<<" ";
    TxtFileLesion<<LesionToPrint->PropMahalFN[Index]<<" ";
    TxtFileLesion<<LesionToPrint->PropMahalRef[Index]<<" ";
    TxtFileLesion<<LesionToPrint->PropMahalSeg[Index]<<" ";
}

float * QuantiliseMask(bool * BinToQuantilise, nifti_image * MahalDistImage){
    if (BinToQuantilise==NULL || MahalDistImage ==NULL) {
        return NULL;
    }
    int numel=MahalDistImage->nx*MahalDistImage->ny*MahalDistImage->nz;
    int numbmodal=MahalDistImage->nu*MahalDistImage->nt;
    int numbNonZero=CountNonZero(BinToQuantilise, numel);
    if(numbNonZero <=0){
        return NULL;
    }
    
    int IndexMinQuant=(int)roundf(float(numbNonZero)/4.0);
    int IndexMaxQuant=(int)roundf(numbNonZero*3.0/4.0);
    int IndexMedQuant=(int)roundf(numbNonZero/2.0);
    if (numbNonZero==1) {
        IndexMinQuant=0;
        IndexMaxQuant=0;
        IndexMedQuant=0;
    }
    float * ImageData=static_cast<float *>(MahalDistImage->data);
    float * ResultQuantilisation=new float[3*numbmodal];
    for (int i=0; i<numbmodal*3; i++) {
        ResultQuantilisation[i]=0;
    }
    //    Creation of temporary Copy of the image to quantilise 1 for each modality of the image
    for (int m=0; m<numbmodal; m++) {
        float * tmpCopyToSort=new float[numbNonZero];
        int j=0;
        float * DataTmp_PTR=&ImageData[m*numel];
        for (int i=0; i<numel; i++) {
            if (BinToQuantilise[i]) {
                tmpCopyToSort[j]=DataTmp_PTR[i];
                j++;
            }
        }
        HeapSort(tmpCopyToSort, numbNonZero-1);
        ResultQuantilisation[m*3]=tmpCopyToSort[IndexMinQuant];
        ResultQuantilisation[m*3+1]=tmpCopyToSort[IndexMedQuant];
        ResultQuantilisation[m*3+2]=tmpCopyToSort[IndexMaxQuant];
        delete [] tmpCopyToSort;
        tmpCopyToSort=NULL;
    }
    return ResultQuantilisation;
}


// Print all characteristics / fields of lesion on specified TxtFile
void PrintLesionSimple(LesionSimple * PrintedLesion, ostream& TxtFileLesion){
    //TxtFileLesion<<endl;
    TxtFileLesion<<"Volume "<<PrintedLesion->Volume<<endl;
    TxtFileLesion<<"Surface "<<PrintedLesion->Surface<<endl;
    TxtFileLesion<<"SAV "<<PrintedLesion->SAV<<endl;
}

void PrintLesionIntensity(LesionIntensity * LesionToPrint, ostream & TxtFileLesion){
    TxtFileLesion<< LesionToPrint->Volume<< " ";
    int numbmodal=LesionToPrint->MeanRatio.size();
    for (int m=0; m<numbmodal; m++) {
        TxtFileLesion<< LesionToPrint->Param[m]<<" ";
    }
    for (int m=0; m<numbmodal; m++) {
        TxtFileLesion<< LesionToPrint->MeanRatio[m]<<" ";
    }
    TxtFileLesion<<LesionToPrint->MahalDistance[0]<<" ";
    for (int m=0; m<numbmodal; m++) {
        TxtFileLesion<<LesionToPrint->MahalDistance[m+1]<<" ";
    }
    TxtFileLesion<<LesionToPrint->ExtremaMahal[0]<<" ";
    TxtFileLesion<<LesionToPrint->ExtremaMahal[1]<<" ";
    TxtFileLesion<<LesionToPrint->Quantilisation[0]<<" ";
    TxtFileLesion<<LesionToPrint->Quantilisation[1]<<" ";
    TxtFileLesion<<LesionToPrint->Quantilisation[2]<<" ";
    int sizeProp=LesionToPrint->ProportionMahal.size();
    for (int i=0; i<sizeProp; i++) {
        TxtFileLesion<<LesionToPrint->ProportionMahal[i]<<" ";
    }
    TxtFileLesion<<endl;
}

void PrintThreshRange(float * Results, vector<float> VecThresh, ostream & TxtFile){
    if(VecThresh.size()<3){
        return;
    }
    else{
        int sizeResults=(int)VecThresh[2]+1;
        for (int s=0; s<sizeResults; s++) {
            TxtFile << Results[s]<<",";
        }
        TxtFile<< endl;
    }
    return;
}

void PrintEvalReport(EvaluationReport * Eval, ostream & TxtFile){
    TxtFile << Eval->VolumeRef<<",";
    TxtFile << Eval->VolumeSeg<<",";
    TxtFile << Eval->LabelRef<<",";
    TxtFile << Eval->LabelSeg<<",";
    TxtFile<<Eval->FP<<",";
    TxtFile<<Eval->FN<<",";
    TxtFile<<Eval->TP<<",";
    TxtFile << Eval->DSC<<",";
    TxtFile << Eval->AvDist<<",";
    TxtFile<< Eval->DE<<",";
    TxtFile<<Eval->DEFP<<",";
    TxtFile<<Eval->DEFN<<",";
    TxtFile<<Eval->OEFP<<",";
    TxtFile<<Eval->OEFN<<",";
    TxtFile<< Eval->OER<<",";
    TxtFile<< Eval->VD<<",";
    TxtFile<< Eval->TPR<<",";
    TxtFile<< Eval->FPR<<",";
    TxtFile<< Eval->TPR_card<<",";
    TxtFile<< Eval->FPR_card<<",";
    TxtFile<< Eval->FNR_card<<",";
    TxtFile<<endl;
}






void PrintOutlierCharacteristics(Outlier * PrintedOutlier,ostream& TxtFileLesion,int numbmodal, int * GravImage, float * PixDim, SEG_ANALYSIS * segment_analysis){
    //TxtFileLesion<<endl;
//    TxtFileLesion<<"LesionCode "<<PrintedOutlier->LesionCode<<endl;
    TxtFileLesion<<"OutlierType "<<PrintedOutlier->OutlierClass<<endl;
    TxtFileLesion<<"LesionSub "<<PrintedOutlier->LesionType<<endl;
    TxtFileLesion<<"MeanCode "<<PrintedOutlier->MeanOC<<endl;
    TxtFileLesion<<"Volume "<<PrintedOutlier->Volume<<endl;
    TxtFileLesion<<"Surface "<<PrintedOutlier->Surface<<endl;
    TxtFileLesion<<"SAV "<<PrintedOutlier->SAV<<endl;
    TxtFileLesion<<"Edginess " <<endl;
    for(int m=0;m<numbmodal+1;m++){
        for(int s=0;s<9;s++){
            TxtFileLesion <<PrintedOutlier->Edginess[m][s]<<" ";
        }
        TxtFileLesion<<endl;
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"Compactness "<<PrintedOutlier->Compactness<<endl;
    TxtFileLesion << "MahalVecQuant "<<endl;
    for (int m=0; m<numbmodal+1; m++) {
        for (int s=0; s<3; s++) {
            TxtFileLesion<<PrintedOutlier->MahalVecQuant[m][s]<<" ";
        }
        TxtFileLesion<<endl;
    }
//    int sizeMahalVec=PrintedOutlier->MahalVec.size();
    TxtFileLesion<<"MahalVecMin ";
    if (PrintedOutlier->MahalVec[0] !=NULL) {
        for (int m=0 ; m<=numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->MahalVec[0][m]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"MahalVecMean ";
    if (PrintedOutlier->MahalVec[1] !=NULL) {
        for (int m=0 ; m<=numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->MahalVec[1][m]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"MahalVecMax ";
    if (PrintedOutlier->MahalVec[2] !=NULL) {
        for (int m=0 ; m<=numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->MahalVec[2][m]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"MeanLesion ";
    if (PrintedOutlier->Mean !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->Mean[m]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"VarianceLesion ";
    if (PrintedOutlier->Variance !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->Variance[m]<<" ";
        }
    }
    TxtFileLesion<<endl;
//    TxtFileLesion<<"Variance "<<endl;
//    for (int m1=0; m1<numbmodal; m1++) {
//        for (int m2=0; m2<numbmodal; m2++) {
//            TxtFileLesion<<PrintedLesion->Variance[m1+m2*numbmodal]<<" ";
//        }
//        TxtFileLesion<<endl;
//    }

    TxtFileLesion<<"DistanceToCentreGrav "<<PrintedOutlier->DistanceGrav<<endl;
    TxtFileLesion<<"ProportionNeighWM "<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexWM]<<endl;
    TxtFileLesion<<"ProportionNeighGM "<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexGM]<<endl;
    TxtFileLesion<<"ProportionNeighCSF "<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexCSF]<<endl;
    TxtFileLesion<<"ProportionNeighNB "<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexOut]<<endl;
    TxtFileLesion<<"ProportionNeighOut "<<PrintedOutlier->ProportionNeighbour[4]<<endl;
    TxtFileLesion<<"CentreGravity ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->CentreGravity[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DiffCentreGravity ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->VectorDiffGrav[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DGMBelonging "<<PrintedOutlier->DGMBelonging<<endl;
    TxtFileLesion<<"SPPotProp "<<PrintedOutlier->SPPotProp<<endl;
    TxtFileLesion<<"PropICSF "<<PrintedOutlier->PropICSF<<endl;
    TxtFileLesion<<"PropECSF "<<PrintedOutlier->PropECSF<<endl;
    TxtFileLesion<<"PropCGM "<<PrintedOutlier->PropCGM<<endl;
    TxtFileLesion<<"PropDGM "<<PrintedOutlier->PropDGM<<endl;
    TxtFileLesion<<"PropWMH "<<PrintedOutlier->PropWMHNeigh<<endl;
    TxtFileLesion<<"PropArtefact "<<PrintedOutlier->PropArtefact<<endl;
    TxtFileLesion << "PropInterface " << PrintedOutlier->PropInterface << endl;
    TxtFileLesion<<"PropNeighbourArtefact "<<PrintedOutlier->ProportionNeighbourArtefact<<endl;
    TxtFileLesion<<"PropBorderExtent "<<PrintedOutlier->PropBorderExtent<<endl;
    TxtFileLesion<<"PropCer "<<PrintedOutlier->PropCer<<endl;
    TxtFileLesion<<"PropCerEro "<<PrintedOutlier->PropCerEro<<endl;
    TxtFileLesion<<"DistanceVentricle ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceVentricle[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceGMI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceGMI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceWMI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceWMI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceCSFI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceCSFI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceOutI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceOutI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceSP ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceSP[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"RatioBB ";
    if (PrintedOutlier->RatioBoundingBox!=NULL) {
        for (int i=0; i<5; i++) {
            TxtFileLesion<<PrintedOutlier->RatioBoundingBox[i]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"BoundingBoxRelGrav ";
    if (PrintedOutlier->BoundingBox!=NULL) {
        for (int d=0; d<3; d++) {
            float minDir=(PrintedOutlier->BoundingBox[2*d]-GravImage[d])*PixDim[d];
            float maxDir=(PrintedOutlier->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
            TxtFileLesion << minDir <<" " << maxDir <<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"ExtentBox ";
    if (PrintedOutlier->ExtentBB!=NULL) {
        for (int d=0; d<3; d++) {
            TxtFileLesion << PrintedOutlier->ExtentBB[d] <<" ";
        }
    }
//    if (PrintedOutlier->BoundingBox!=NULL) {
//        for (int d=0; d<3; d++) {
//            float minDir=(PrintedOutlier->BoundingBox[2*d]-GravImage[d])*PixDim[d];
//            float maxDir=(PrintedOutlier->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
//            TxtFileLesion << maxDir-minDir <<" ";
//        }
//    }
    TxtFileLesion <<endl;
    TxtFileLesion << "RatioExtentVolume ";
    if (PrintedOutlier->ExtentVolumeBB!=NULL) {
        for (int d=0; d<3; d++) {
            TxtFileLesion << PrintedOutlier->ExtentVolumeBB[d] <<" ";
        }
    }
    TxtFileLesion << endl;
    TxtFileLesion<< "EigenValues ";
    if (PrintedOutlier->SVDEigen!=NULL) {
        for (int d=0; d<3; d++) {
            TxtFileLesion << PrintedOutlier->SVDEigen[d] <<" ";
        }
        TxtFileLesion<<endl;
        TxtFileLesion<< "RatioEigen ";
        TxtFileLesion<< PrintedOutlier->SVDEigen[0]/PrintedOutlier->SVDEigen[2]<<" ";
        TxtFileLesion<< PrintedOutlier->SVDEigen[0]/PrintedOutlier->SVDEigen[1]<<" ";
        TxtFileLesion<< PrintedOutlier->SVDEigen[1]/PrintedOutlier->SVDEigen[2]<<endl;
    }
    
    TxtFileLesion<< "ProportionOrigin ";
    if (PrintedOutlier->ProportionOrigin!=NULL) {
        for (int c=0; c<4; c++) {
            TxtFileLesion<< PrintedOutlier->ProportionOrigin[c]<<" ";
        }
    }
    TxtFileLesion<<endl;
    int sizeText=PrintedOutlier->Texture.size();
    for (int s=0; s<sizeText; s++) {
        TextureDescriptors * TextureToPrint=PrintedOutlier->Texture[s];
        TxtFileLesion << "TextureDescriptors " <<s <<" "<< TextureToPrint->Contrast<<" "<< TextureToPrint->Homogeneity<<" "<< TextureToPrint->Energy<<" "<<TextureToPrint->Entropy<<" " << TextureToPrint->Correlation<<endl;
    }
    for (int s=0; s<sizeText; s++) {
        if (fabs(PrintedOutlier->Texture[s]->Correlation)>1) {
            cout<<"Pb in correlation when PrintedLesion"<<endl;
        }
    }
    int sizeText1=PrintedOutlier->Texture1.size();
    for (int s=0; s<sizeText1; s++) {
        TextureDescriptors1 * TextureToPrint=PrintedOutlier->Texture1[s];
        TxtFileLesion << "TextureDescriptors1 " <<s <<" "<< TextureToPrint->Mean<<" "<< TextureToPrint->Variance<<" "<< TextureToPrint->Skewness<<" "<<TextureToPrint->Kurtosis<<endl;
    }
    
    }

void PrintOutlierCharacteristicsForFile(Outlier * PrintedOutlier,ostream& TxtFileLesion,int numbmodal, int * GravImage, float * PixDim, SEG_ANALYSIS * segment_analysis){
    //TxtFileLesion<<endl;
    //    TxtFileLesion<<"LesionCode "<<PrintedOutlier->LesionCode<<endl;
    TxtFileLesion<<PrintedOutlier->OutlierClass<<" ";
    TxtFileLesion<<PrintedOutlier->Volume<<" ";
    TxtFileLesion<<PrintedOutlier->Surface<<" ";
    TxtFileLesion<<PrintedOutlier->SAV<<" ";
    TxtFileLesion<<PrintedOutlier->Compactness<<" ";
    for (int m=0; m<numbmodal+1; m++) {
        for (int s=0; s<3; s++) {
            TxtFileLesion<<PrintedOutlier->MahalVecQuant[m][s]<<" ";
        }
    }
//    int sizeMahalVec=PrintedOutlier->MahalVec.size();
    if (PrintedOutlier->MahalVec[0] !=NULL) {
        for (int m=0 ; m<=numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->MahalVec[0][m]<<" ";
        }
    }
    if (PrintedOutlier->MahalVec[1] !=NULL) {
        for (int m=0 ; m<=numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->MahalVec[1][m]<<" ";
        }
    }
    if (PrintedOutlier->MahalVec[2] !=NULL) {
        for (int m=0 ; m<=numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->MahalVec[2][m]<<" ";
        }
    }
    if (PrintedOutlier->Mean !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->Mean[m]<<" ";
        }
    }
    if (PrintedOutlier->Variance !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedOutlier->Variance[m]<<" ";
        }
    }
    
    TxtFileLesion<<PrintedOutlier->DistanceGrav<<" ";
    TxtFileLesion<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexWM]<<" ";
    TxtFileLesion<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexGM]<<" ";
    TxtFileLesion<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexCSF]<<" ";
    TxtFileLesion<<PrintedOutlier->ProportionNeighbour[segment_analysis->IndexOut]<< " ";
    TxtFileLesion<<PrintedOutlier->ProportionNeighbour[4]<<" ";
    
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->CentreGravity[d]<<" ";
    }

    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->VectorDiffGrav[d]<<" ";
    }
    TxtFileLesion<<PrintedOutlier->DGMBelonging<<" ";
    TxtFileLesion<<PrintedOutlier->SPPotProp<<" ";
    TxtFileLesion<<PrintedOutlier->PropICSF<<" ";
    TxtFileLesion<<PrintedOutlier->PropECSF<<" ";
    TxtFileLesion<<PrintedOutlier->PropCGM<< " ";
    TxtFileLesion<< PrintedOutlier->PropDGM<<" ";
    TxtFileLesion<<PrintedOutlier->PropWMHNeigh<<" ";
    TxtFileLesion<<PrintedOutlier->PropArtefact<<" ";
    TxtFileLesion<< PrintedOutlier->PropInterface<<" ";
    TxtFileLesion<<PrintedOutlier->ProportionNeighbourArtefact<<" ";
    TxtFileLesion<<PrintedOutlier->PropBorderExtent<<" ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceVentricle[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceGMI[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceWMI[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceCSFI[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceOutI[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedOutlier->DistanceSP[d]<<" ";
    }
    if (PrintedOutlier->RatioBoundingBox!=NULL) {
        for (int i=0; i<5; i++) {
            TxtFileLesion<<PrintedOutlier->RatioBoundingBox[i]<<" ";
        }
    }
    if (PrintedOutlier->BoundingBox!=NULL) {
        for (int d=0; d<3; d++) {
            float minDir=(PrintedOutlier->BoundingBox[2*d]-GravImage[d])*PixDim[d];
            float maxDir=(PrintedOutlier->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
            TxtFileLesion << minDir <<" " << maxDir <<" ";
        }
    }
    if (PrintedOutlier->BoundingBox!=NULL) {
        for (int d=0; d<3; d++) {
            float minDir=(PrintedOutlier->BoundingBox[2*d]-GravImage[d])*PixDim[d];
            float maxDir=(PrintedOutlier->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
            TxtFileLesion << maxDir-minDir <<" ";
        }
    }
    if (PrintedOutlier->ExtentVolumeBB!=NULL) {
        for (int d=0; d<3; d++) {
            TxtFileLesion << PrintedOutlier->ExtentVolumeBB[d] <<" ";
        }
    }
    if (PrintedOutlier->SVDEigen!=NULL) {
        for (int d=0; d<3; d++) {
            TxtFileLesion << PrintedOutlier->SVDEigen[d] <<" ";
        }
        TxtFileLesion<< PrintedOutlier->SVDEigen[0]/PrintedOutlier->SVDEigen[2]<<" ";
        TxtFileLesion<< PrintedOutlier->SVDEigen[0]/PrintedOutlier->SVDEigen[1]<<" ";
        TxtFileLesion<< PrintedOutlier->SVDEigen[1]/PrintedOutlier->SVDEigen[2]<<" ";
    }

    
    if (PrintedOutlier->ProportionOrigin!=NULL) {
        for (int c=0; c<4; c++) {
            TxtFileLesion<< PrintedOutlier->ProportionOrigin[c]<<" ";
        }
    }
    int sizeText=PrintedOutlier->Texture.size();
    for (int s=0; s<sizeText; s++) {
        TextureDescriptors * TextureToPrint=PrintedOutlier->Texture[s];
        TxtFileLesion << TextureToPrint->Contrast<<" "<< TextureToPrint->Homogeneity<<" "<< TextureToPrint->Energy<<" "<<TextureToPrint->Entropy<<" " << TextureToPrint->Correlation<<" ";
    }
    for (int s=0; s<sizeText; s++) {
        if (fabs(PrintedOutlier->Texture[s]->Correlation)>1) {
            cout<<"Pb in correlation when PrintedLesion"<<endl;
        }
    }
    int sizeText1=PrintedOutlier->Texture1.size();
    for (int s=0; s<sizeText1; s++) {
        TextureDescriptors1 * TextureToPrint=PrintedOutlier->Texture1[s];
        TxtFileLesion << TextureToPrint->Mean<<" "<< TextureToPrint->Variance<<" "<< TextureToPrint->Skewness<<" "<<TextureToPrint->Kurtosis<<" ";
    }
    for (int m=0;m<numbmodal+1;m++){
        for(int s=0;s<9;s++){
            TxtFileLesion <<PrintedOutlier->Edginess[m][s]<<" ";
        }
    }
}




// Print all characteristics / fields of lesion on specified TxtFile
void PrintLesion(Lesion * PrintedLesion, ostream& TxtFileLesion,int numbmodal, int * GravImage, float * PixDim){
    //TxtFileLesion<<endl;
    TxtFileLesion<<"LesionCode "<<PrintedLesion->LesionCode<<endl;
    TxtFileLesion<<"LesionType "<<PrintedLesion->LesionType<<endl;
    TxtFileLesion<<"Volume "<<PrintedLesion->Volume<<endl;
    TxtFileLesion<<"Surface "<<PrintedLesion->Surface<<endl;
    TxtFileLesion<<"SAV "<<PrintedLesion->SAV<<endl;
    TxtFileLesion<<"Compactness "<<PrintedLesion->Compactness<<endl;
    TxtFileLesion<<"NormRatio ";
    if (PrintedLesion->RatioToNormal !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedLesion->RatioToNormal[m]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"MeanLesion ";
    if (PrintedLesion->Mean !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedLesion->Mean[m]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"Variance "<<endl;
    for (int m1=0; m1<numbmodal; m1++) {
        for (int m2=0; m2<numbmodal; m2++) {
            TxtFileLesion<<PrintedLesion->Variance[m1+m2*numbmodal]<<" ";
        }
        TxtFileLesion<<endl;
    }
    TxtFileLesion<<"DistanceToNormalGM "<<PrintedLesion->DistanceGM<<endl;
    TxtFileLesion<<"DistanceToNormalCSF "<<PrintedLesion->DistanceCSF<<endl;
    TxtFileLesion<<"DistanceToNormalWM "<<PrintedLesion->DistanceWM<<endl;
    TxtFileLesion<<"DistanceToNormalOut "<<PrintedLesion->DistanceOut<<endl;
    TxtFileLesion<<"DistanceToCentreGrav "<<PrintedLesion->DistanceGrav<<endl;
    TxtFileLesion<<"NeighbourWMI "<<PrintedLesion->NeighbourWMI<<endl;
    TxtFileLesion<<"NeighbourCSF "<<PrintedLesion->NeighbourCSF<<endl;
    TxtFileLesion<<"NeighbourGMC "<<PrintedLesion->NeighbourGMC<<endl;
    TxtFileLesion<<"ProportionNeighWM "<<PrintedLesion->ProportionWM<<endl;
    TxtFileLesion<<"ProportionNeighGM "<<PrintedLesion->ProportionGM<<endl;
    TxtFileLesion<<"ProportionNeighCSF "<<PrintedLesion->ProportionCSF<<endl;
    TxtFileLesion<<"ProportionNeighOut "<<PrintedLesion->ProportionOut<<endl;
    TxtFileLesion<<"ProportionPathGravWM "<<PrintedLesion->ProportionGravWM<<endl;
    TxtFileLesion<<"ProportionPathGravGM "<<PrintedLesion->ProportionGravGM<<endl;
    TxtFileLesion<<"ProportionPathGravCSF "<<PrintedLesion->ProportionGravCSF<<endl;
    TxtFileLesion<<"ProportionPathGravOut "<<PrintedLesion->ProportionGravOut<<endl;
    TxtFileLesion<<"DistanceVentricle "<<PrintedLesion->DistanceVentricle <<endl;
    TxtFileLesion<<"CentreGravity ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->CentreGravity[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DiffCentreGravity ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->VectorDiffGrav[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceAcceptedGM "<<PrintedLesion->DistanceAcceptedGM<<endl;
    TxtFileLesion<<"DGMBelonging "<<PrintedLesion->DGMBelonging<<endl;
    TxtFileLesion<<"SPPotProp "<<PrintedLesion->SPPotProp<<endl;
    TxtFileLesion<<"PropICSF "<<PrintedLesion->PropICSF<<endl;
    TxtFileLesion<<"DistanceGMI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceGMI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceWMI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceWMI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceCSFI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceCSFI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceOutI ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceOutI[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"DistanceSP ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceSP[d]<<" ";
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"RatioBB ";
    if (PrintedLesion->RatioBoundingBox!=NULL) {
        for (int i=0; i<5; i++) {
            TxtFileLesion<<PrintedLesion->RatioBoundingBox[i]<<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"BoundingBoxRelGrav ";
    if (PrintedLesion->BoundingBox!=NULL) {
        for (int d=0; d<3; d++) {
            float minDir=(PrintedLesion->BoundingBox[2*d]-GravImage[d])*PixDim[d];
            float maxDir=(PrintedLesion->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
            TxtFileLesion << minDir <<" " << maxDir <<" ";
        }
    }
    TxtFileLesion<<endl;
    TxtFileLesion<<"ExtentBox ";
    if (PrintedLesion->BoundingBox!=NULL) {
        for (int d=0; d<3; d++) {
            float minDir=(PrintedLesion->BoundingBox[2*d]-GravImage[d])*PixDim[d];
            float maxDir=(PrintedLesion->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
            TxtFileLesion << maxDir-minDir <<" ";
        }
    }
    TxtFileLesion <<endl;
    TxtFileLesion<< "ProportionOrigin ";
    if (PrintedLesion->ProportionOrigin!=NULL) {
        for (int c=0; c<4; c++) {
            TxtFileLesion<< PrintedLesion->ProportionOrigin[c]<<" ";
        }
    }
    TxtFileLesion<<endl;
    int sizeText=PrintedLesion->Texture.size();
    for (int s=0; s<sizeText; s++) {
        TextureDescriptors * TextureToPrint=PrintedLesion->Texture[s];
        TxtFileLesion << "TextureDescriptors " <<s <<" "<< TextureToPrint->Contrast<<" "<< TextureToPrint->Homogeneity<<" "<< TextureToPrint->Energy<<" "<<TextureToPrint->Entropy<<" " << TextureToPrint->Correlation<<endl;
    }
    for (int s=0; s<sizeText; s++) {
        if (fabs(PrintedLesion->Texture[s]->Correlation)>1) {
            cout<<"Pb in correlation when PrintedLesion"<<endl;
        }
    }
    int sizeText1=PrintedLesion->Texture1.size();
    for (int s=0; s<sizeText1; s++) {
        TextureDescriptors1 * TextureToPrint=PrintedLesion->Texture1[s];
        TxtFileLesion << "TextureDescriptors1 " <<s <<" "<< TextureToPrint->Mean<<" "<< TextureToPrint->Variance<<" "<< TextureToPrint->Skewness<<" "<<TextureToPrint->Kurtosis<<endl;
    }

}



// Print all characteristics / fields of lesion on specified TxtFile
void PrintLesionForFile(Lesion * PrintedLesion, ostream& TxtFileLesion,int numbmodal, int * GravImage, float * PixDim){
    //TxtFileLesion<<endl;
    TxtFileLesion<<PrintedLesion->LesionType<< " ";
    TxtFileLesion<<PrintedLesion->LesionCode<< " ";
    TxtFileLesion<<PrintedLesion->Volume<< " ";
    TxtFileLesion<<PrintedLesion->Surface<<" ";
    TxtFileLesion<<PrintedLesion->SAV<<" ";
    TxtFileLesion<<PrintedLesion->Compactness<<" ";
    if (PrintedLesion->RatioToNormal !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedLesion->RatioToNormal[m]<<" ";
        }
    }
    if (PrintedLesion->Mean !=NULL) {
        for (int m=0 ; m<numbmodal; m++) {
            TxtFileLesion<<PrintedLesion->Mean[m]<<" ";
        }
    }
    for (int m1=0; m1<numbmodal; m1++) {
        for (int m2=0; m2<numbmodal; m2++) {
            TxtFileLesion<<PrintedLesion->Variance[m1+m2*numbmodal]<<" ";
        }
    }
    TxtFileLesion<<PrintedLesion->DistanceGM<<" ";
    TxtFileLesion<<PrintedLesion->DistanceCSF<<" ";
    TxtFileLesion<<PrintedLesion->DistanceWM<<" ";
    TxtFileLesion<<PrintedLesion->DistanceOut<<" ";
    TxtFileLesion<<PrintedLesion->DistanceGrav<<" ";
    TxtFileLesion<<PrintedLesion->NeighbourWMI<<" ";
    TxtFileLesion<<PrintedLesion->NeighbourCSF<<" ";
    TxtFileLesion<<PrintedLesion->NeighbourGMC<<" ";
    TxtFileLesion<<PrintedLesion->ProportionWM<<" ";
    TxtFileLesion<<PrintedLesion->ProportionGM<<" ";
    TxtFileLesion<<PrintedLesion->ProportionCSF<<" ";
    TxtFileLesion<<PrintedLesion->ProportionOut<<" ";
    TxtFileLesion<<PrintedLesion->ProportionGravWM<<" ";
    TxtFileLesion<<PrintedLesion->ProportionGravGM<<" ";
    TxtFileLesion<<PrintedLesion->ProportionGravCSF<<" ";
    TxtFileLesion<<PrintedLesion->ProportionGravOut<<" ";
    TxtFileLesion<<PrintedLesion->DistanceVentricle <<" ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->CentreGravity[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->VectorDiffGrav[d]<<" ";
    }
    TxtFileLesion<<PrintedLesion->DistanceAcceptedGM<<" ";
    TxtFileLesion<<PrintedLesion->DGMBelonging<<" ";
    TxtFileLesion<<PrintedLesion->SPPotProp<<" ";
    TxtFileLesion<<PrintedLesion->PropICSF<<" ";
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceGMI[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceWMI[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceCSFI[d]<<" ";
    }
    for (int d=0; d<3; d++) {
        TxtFileLesion<<PrintedLesion->DistanceOutI[d]<<" ";
    }
    if (PrintedLesion->RatioBoundingBox!=NULL) {
        for (int i=0; i<5; i++) {
            TxtFileLesion<<PrintedLesion->RatioBoundingBox[i]<<" ";
        }
    }
    if (PrintedLesion->BoundingBox!=NULL) {
        for (int d=0; d<3; d++) {
            float minDir=(PrintedLesion->BoundingBox[2*d]-GravImage[d])*PixDim[d];
            float maxDir=(PrintedLesion->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
            TxtFileLesion << minDir <<" " << maxDir <<" ";
        }
    }
    if (PrintedLesion->BoundingBox!=NULL) {
        for (int d=0; d<3; d++) {
            float minDir=(PrintedLesion->BoundingBox[2*d]-GravImage[d])*PixDim[d];
            float maxDir=(PrintedLesion->BoundingBox[2*d+1]-GravImage[d])*PixDim[d];
            TxtFileLesion << maxDir-minDir <<" ";
        }
    }
    if (PrintedLesion->ProportionOrigin!=NULL) {
        for (int c=0; c<4; c++) {
            TxtFileLesion<< PrintedLesion->ProportionOrigin[c]<<" ";
        }
    }
    int sizeText=PrintedLesion->Texture.size();
    for (int s=0; s<sizeText; s++) {
        TextureDescriptors * TextureToPrint=PrintedLesion->Texture[s];
        TxtFileLesion << s <<" "<< TextureToPrint->Contrast<<" "<< TextureToPrint->Homogeneity<<" "<< TextureToPrint->Energy<<" "<<TextureToPrint->Entropy<<" " << TextureToPrint->Correlation<<" ";
    }
    for (int s=0; s<sizeText; s++) {
        if (fabs(PrintedLesion->Texture[s]->Correlation)>1) {
            cout<<"Pb in correlation when PrintedLesion"<<endl;
        }
    }
    int sizeText1=PrintedLesion->Texture1.size();
    for (int s=0; s<sizeText1; s++) {
        TextureDescriptors1 * TextureToPrint=PrintedLesion->Texture1[s];
        TxtFileLesion << s <<" "<< TextureToPrint->Mean<<" "<< TextureToPrint->Variance<<" "<< TextureToPrint->Skewness<<" "<<TextureToPrint->Kurtosis<<" ";
    }
    
}




// Print all characteristics / fields of lesion on specified TxtFile
void PrintLeafID(LeafID * LeafToPrint, ostream& TxtFileLeaf,int numbmodal){
    //TxtFileLesion<<endl;
    int sizeHierarchy=LeafToPrint->HierarchyVector.size();
    TxtFileLeaf<<" Threshold "<<LeafToPrint->Threshold;
    TxtFileLeaf<<"Hierarchy ";
    for(int h=0;h<sizeHierarchy;h++){
        TxtFileLeaf<<LeafToPrint->HierarchyVector[h];
    }TxtFileLeaf<<endl;
    TxtFileLeaf<<"Inside PropInsideContribution";
    TxtFileLeaf<<LeafToPrint->PropInsideContribution<< " PropInsideClassified "<<LeafToPrint->RatioInside<<" PropNeighbourInsideClassified "<<LeafToPrint->NeighInside<<endl;
    TxtFileLeaf<<"GM ";
    TxtFileLeaf<<" PropGMClassified "<<LeafToPrint->RatioGM<<" PropNeighbourGMClassified "<<LeafToPrint->NeighGM<<endl;
    TxtFileLeaf<<"WM ";
    TxtFileLeaf<<" PropWMClassified "<<LeafToPrint->RatioWM<<" PropNeighbourWMClassified "<<LeafToPrint->NeighWM<<endl;
    TxtFileLeaf<<"CSF ";
    TxtFileLeaf<<" PropCSFClassified "<<LeafToPrint->RatioCSF<<" PropNeighbourCSFClassified "<<LeafToPrint->NeighCSF<<endl;
    TxtFileLeaf<<"Out ";
    TxtFileLeaf<<" PropOutClassified "<<LeafToPrint->RatioOut<<" PropNeighbourOutClassified "<<LeafToPrint->NeighOut<<endl;
    
}

// Returns the border to a specific accumulation of tissue according to a certain threshold. The vector of int indicates the combined tissues. Value -1 is relative to the mask.
bool * BorderExtractionThreshold(TreeEM * TreeToAnalyse, nifti_image * SummarisedSeg,vector<int> OutIndexVector,float Threshold){
    //    Initialisation of the result and the needed values
    int numel=TreeToAnalyse->GetNumberElements();
    int numbIndex=OutIndexVector.size();
    int numbTissues=SummarisedSeg->nu*SummarisedSeg->nt;
    float * SummarisedSegData=static_cast<float *>(SummarisedSeg->data);
    int * L2S=TreeToAnalyse->GetL2S();
    bool * BorderExtracted=new bool[numel];
    bool * TempBinarySeg=new bool[numel];
    float * TempCombination=new float[numel];
    for (int i=0; i<numel; i++) {
        
        TempCombination[i]=0;
        BorderExtracted[i]=0;
    }
    int Dim[3];
    int Shift[3];
    Dim[0]=SummarisedSeg->nx;
    Dim[1]=SummarisedSeg->ny;
    Dim[2]=SummarisedSeg->nz;
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    
    
    //    Combining tissues according to SummarisedSeg
    for (int t=0 ; t<numbIndex; t++) {
        if (OutIndexVector[t]<0) {
            cout << "Mask considered as tissue border"<<endl;
            
            for (int i=0; i<numel; i++) {
                if (L2S[i]<0) {
                    TempCombination[i]+=1;
                }
            }
        }
        else if (OutIndexVector[t]>=numbTissues) {
            cout<<"Impossible tissue asked for with index "<<OutIndexVector[t];
        }
        else{
            float * SummarisedSegDataLooked=&SummarisedSegData[OutIndexVector[t]*numel];
            for (int i=0; i<numel; i++) {
                TempCombination[i]+=SummarisedSegDataLooked[i];
            }
        }
    }
    
    //    Binarising according to threshold
    for (int i=0; i<numel; i++) {
        if (TempCombination[i]>Threshold) {
            TempBinarySeg[i]=1;
        }
    }
    
    //    Create the border according to the temporary binary segmentation obtained
    for (int i=0; i<numel; i++) {
        if (L2S[i]>=0) { // we only consider voxels within the mask to be able to belong to the border
            int ListNeighbours[18];
            GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 18);
            for (int n=0; n<18; n++) {
                if (TempBinarySeg[ListNeighbours[n]]==1) {
                    BorderExtracted[i]=1;
                    break;
                }
            }
        }
    }
    
    //    Clearing before returning
    if (TempBinarySeg!=NULL) {
        delete [] TempBinarySeg;
        TempBinarySeg=NULL;
    }
    if (TempCombination!=NULL) {
        delete [] TempCombination;
        TempCombination=NULL;
    }
    
    return BorderExtracted;
}



// Extraction of the border of one tissue, the lesion probability maps retrieved from the WM tissue. It uses SummarisedSegDec if possible
bool * BorderExtraction_bis(TreeEM * TreeToAnalyse, nifti_image * SummarisedSeg, SEG_ANALYSIS * segment_analysis, int TissueType){
    //Initialisation and obtention of variables needed in all cases :
    //    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int numel=TreeToAnalyse->GetNumberElements();
    float * SummarisedSegData=static_cast<float *>(SummarisedSeg->data);
    vector<TreeEM*> GeneralClassesVector=TreeToAnalyse->GetGeneralClassesVector();
    float * NormRespExtracted=new float [numel];
    for (int i=0; i<numel; i++) {
        NormRespExtracted[i]=0;
    }
    float * NormRespTmp_PTR=NULL;
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    //    int * Dim=new int[3];
    int Dim[3];
    Dim[0]=TreeToAnalyse->GetDataImage()->dim[1];
    Dim[1]=TreeToAnalyse->GetDataImage()->dim[2];
    Dim[2]=TreeToAnalyse->GetDataImage()->dim[3];
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    int IndexToUse=0;
    int numbgen=SummarisedSeg->nu*SummarisedSeg->nt;
    // First establishment of segmentation result on which to extract the border based on TissueType, TreeToAnalyse and segment_analysis
    switch (TissueType) {
            case 0:{ // Extraction of GM (Inliers + Outliers)
                IndexToUse=segment_analysis->IndexGM;
                float * SummarisedDataToLook=&SummarisedSegData[numel*IndexToUse];
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=SummarisedDataToLook[i];
                    }
                }
                
            }
            break;
            case 10:{ // Extraction of WM (Inliers + Outliers)
                //                Correspond to WM (global) + Lesions
                float * NormRespWM=&SummarisedSegData[numel*segment_analysis->IndexWM];
                float * NormRespLes=&SummarisedSegData[numel*(numbgen-1)];
                //                TreeEM * TreeWM=GeneralClassesVector[segment_analysis->IndexWM];
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=NormRespWM[i]+NormRespLes[i];
                    }
                }
                
            }
            break;
            case 1:{ // extraction of WM Inliers Only / modified to WM global minus lesions
                //                TreeEM * TreeWM=GeneralClassesVector[segment_analysis->IndexWM];
                //                NormRespTmp_PTR=TreeWM->GetNormResp();
                //                for (int i=0; i<numel; i++) {
                //                    if (L2S_PTR[i]>=0) {
                //                        NormRespExtracted[i]=*NormRespTmp_PTR;
                //                        NormRespTmp_PTR++;
                //                    }
                //                }
                float * NormRespWM=&SummarisedSegData[numel*segment_analysis->IndexWM];
                for (int i=0; i<numel; i++) {
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]=NormRespWM[i];
                    }
                }
            }
            break;
            case 2:{ // extraction of CSF
                TreeEM * TreeCSF=GeneralClassesVector[segment_analysis->IndexCSF];
                NormRespTmp_PTR=TreeCSF->GetNormResp();
                for (int i=0; i<numel; i++) {
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]=*NormRespTmp_PTR;
                        NormRespTmp_PTR++;
                    }
                }
            }
            break;
            case 20:{ // extraction of CSF containing also CSF outliers
                float * NormRespCSF=&SummarisedSegData[numel*segment_analysis->IndexCSF];
                
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=NormRespCSF[i];
                    }
                }
            }
            break;
            case 30:{ // Extraction of GM (Inliers + Outliers)
                TreeEM * TreeOut=GeneralClassesVector[segment_analysis->IndexOut];
                float * NormRespInliers=TreeOut->GetNormResp();
                float * NormRespOutliers=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeOutOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexOut);
                    NormRespOutliers=TreeOutOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliers;
                        NormRespInliers++;
                        if (NormRespOutliers!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliers;
                            NormRespOutliers++;
                        }
                    }
                }
                
            }
            break;
            case 15 :{ // case where we consider the parenchyma (GM+WM) Inliers and Outliers
                float * NormRespGM=&SummarisedSegData[numel*segment_analysis->IndexGM];
                float * NormRespWM=&SummarisedSegData[numel*segment_analysis->IndexWM];
                float * NormRespLes=&SummarisedSegData[numel*(numbgen-1)];
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=NormRespGM[i]+NormRespWM[i]+NormRespLes[i];
                    }
                }
                
            }
            break;
            case 35 :{ // case where we consider the CSF + Out Inliers and Outliers
                float * NormRespCSF=&SummarisedSegData[numel*segment_analysis->IndexCSF];
                float * NormRespOut=&SummarisedSegData[numel*segment_analysis->IndexOut];
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=NormRespCSF[i]+NormRespOut[i];
                    }
                }
                
            }
            break;
            case 40:{ // case where we consider the Out part totally
                float * NormRespOut=&SummarisedSegData[numel*segment_analysis->IndexOut];
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=NormRespOut[i];
                    }
                }
                
            }
            break;
            case 25 :{ // case where we consider the CSF + GM Inliers and Outliers // Compared to what was used before do not take into account lesion classified as GM
                float * NormRespCSF=&SummarisedSegData[numel*segment_analysis->IndexCSF];
                float * NormRespGM=&SummarisedSegData[numel*segment_analysis->IndexGM];
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=NormRespCSF[i]+NormRespGM[i];
                    }
                }
            }
            break;
        default:
            break;
    }
    
    // Then test if border for all voxels on which it has to be tested. Difficult to separate GM and WM so maybe use parenchyma as whole ??
    //    int j=0;
    bool * Border=new bool[numel];
    for (int i=0; i<numel; i++) {
        Border[i]=0;
    }
    for (int i=0; i<numel; i++) {
        if (NormRespExtracted[i]>=0.5) {
            //                int * ListNeighboursToLook=Get6Neighbours(i, Dim,Shift);
            int ListNeighboursToLook[6];
            GetListNeighbours_bis(ListNeighboursToLook, i, Dim, Shift, 6);
            //            int * ListNeighboursToLook=GetListNeighbours(i, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (NormRespExtracted[ListNeighboursToLook[n]]<0.5) {
                    //                        Border[ListNeighboursToLook[n]]=1;
                    Border[i]=1;
                    break;
                    
                }
            }
            //            delete [] ListNeighboursToLook;
            //            ListNeighboursToLook=NULL;
        }
    }
    
    // Clearing memory and returning result
    delete [] NormRespExtracted;
    NormRespExtracted=NULL;
    //    delete [] Dim;
    //    Dim=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    return Border;
}









// Extraction of the border of one tissue
bool * BorderExtraction(TreeEM * TreeToAnalyse,SEG_ANALYSIS * segment_analysis, int TissueType){
    //Initialisation and obtention of variables needed in all cases :
    //    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int numel=TreeToAnalyse->GetNumberElements();
    vector<TreeEM*> GeneralClassesVector=TreeToAnalyse->GetGeneralClassesVector();
    float * NormRespExtracted=new float [numel];
    for (int i=0; i<numel; i++) {
        NormRespExtracted[i]=0;
    }
    float * NormRespTmp_PTR=NULL;
    int * L2S_PTR=TreeToAnalyse->GetL2S();
    //    int * Dim=new int[3];
    int Dim[3];
    Dim[0]=TreeToAnalyse->GetDataImage()->dim[1];
    Dim[1]=TreeToAnalyse->GetDataImage()->dim[2];
    Dim[2]=TreeToAnalyse->GetDataImage()->dim[3];
    //    int * Shift = new int[3];
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[0]*Dim[1];
    // First establishment of segmentation result on which to extract the border based on TissueType, TreeToAnalyse and segment_analysis
    switch (TissueType) {
            case 0:{ // Extraction of GM (Inliers + Outliers)
                TreeEM * TreeGM=GeneralClassesVector[segment_analysis->IndexGM];
                float * NormRespInliers=TreeGM->GetNormResp();
                float * NormRespOutliers=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeGMOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexGM);
                    NormRespOutliers=TreeGMOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliers;
                        NormRespInliers++;
                        if (NormRespOutliers!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliers;
                            NormRespOutliers++;
                        }
                    }
                }
                
            }
            break;
            case 10:{ // Extraction of WM (Inliers + Outliers)
                TreeEM * TreeWM=GeneralClassesVector[segment_analysis->IndexWM];
                float * NormRespInliers=TreeWM->GetNormResp();
                float * NormRespOutliers=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeWMOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexWM);
                    NormRespOutliers=TreeWMOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliers;
                        NormRespInliers++;
                        if (NormRespOutliers!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliers;
                            NormRespOutliers++;
                        }
                    }
                }
                
            }
            break;
            case 1:{ // extraction of WM Inliers
                TreeEM * TreeWM=GeneralClassesVector[segment_analysis->IndexWM];
                NormRespTmp_PTR=TreeWM->GetNormResp();
                for (int i=0; i<numel; i++) {
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]=*NormRespTmp_PTR;
                        NormRespTmp_PTR++;
                    }
                }
            }
            break;
            case 2:{ // extraction of CSF
                TreeEM * TreeCSF=GeneralClassesVector[segment_analysis->IndexCSF];
                NormRespTmp_PTR=TreeCSF->GetNormResp();
                for (int i=0; i<numel; i++) {
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]=*NormRespTmp_PTR;
                        NormRespTmp_PTR++;
                    }
                }
            }
            break;
            case 20:{ // extraction of CSF containing also CSF outliers
                TreeEM * TreeCSF=GeneralClassesVector[segment_analysis->IndexCSF];
                float * NormRespInliers=TreeCSF->GetNormResp();
                float * NormRespOutliers=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeCSFOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF);
                    NormRespOutliers=TreeCSFOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliers;
                        NormRespInliers++;
                        if (NormRespOutliers!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliers;
                            NormRespOutliers++;
                        }
                    }
                }
                
            }
            break;
            case 30:{ // Extraction of GM (Inliers + Outliers)
                TreeEM * TreeOut=GeneralClassesVector[segment_analysis->IndexOut];
                float * NormRespInliers=TreeOut->GetNormResp();
                float * NormRespOutliers=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeOutOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexOut);
                    NormRespOutliers=TreeOutOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliers;
                        NormRespInliers++;
                        if (NormRespOutliers!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliers;
                            NormRespOutliers++;
                        }
                    }
                }
                
            }
            break;
            case 15 :{ // case where we consider the parenchyma (GM+WM) Inliers and Outliers
                TreeEM * TreeGM=GeneralClassesVector[segment_analysis->IndexGM];
                TreeEM * TreeWM=GeneralClassesVector[segment_analysis->IndexWM];
                float * NormRespInliersGM=TreeGM->GetNormResp();
                float * NormRespInliersWM=TreeWM->GetNormResp();
                float * NormRespOutliersGM=NULL;
                float * NormRespOutliersWM=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeGMOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexGM);
                    TreeEM * TreeWMOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexWM);
                    NormRespOutliersGM=TreeGMOutliers->GetNormResp();
                    NormRespOutliersWM=TreeWMOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliersGM;
                        NormRespExtracted[i]+=*NormRespInliersWM;
                        NormRespInliersGM++;
                        NormRespInliersWM++;
                        if (NormRespOutliersGM!=NULL && NormRespOutliersWM!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliersGM;
                            NormRespExtracted[i]+=*NormRespOutliersWM;
                            NormRespOutliersGM++;
                            NormRespOutliersWM++;
                        }
                    }
                }
                
            }
            break;
            case 35 :{ // case where we consider the CSF + Out Inliers and Outliers
                TreeEM * TreeCSF=GeneralClassesVector[segment_analysis->IndexCSF];
                TreeEM * TreeOut=GeneralClassesVector[segment_analysis->IndexOut];
                float * NormRespInliersCSF=TreeCSF->GetNormResp();
                float * NormRespInliersOut=TreeOut->GetNormResp();
                float * NormRespOutliersCSF=NULL;
                float * NormRespOutliersOut=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeCSFOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF);
                    TreeEM * TreeOutOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexOut);
                    NormRespOutliersCSF=TreeCSFOutliers->GetNormResp();
                    NormRespOutliersOut=TreeOutOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliersCSF;
                        NormRespExtracted[i]+=*NormRespInliersOut;
                        NormRespInliersCSF++;
                        NormRespInliersOut++;
                        if (NormRespOutliersCSF!=NULL && NormRespOutliersOut!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliersCSF;
                            NormRespExtracted[i]+=*NormRespOutliersOut;
                            NormRespOutliersCSF++;
                            NormRespOutliersOut++;
                        }
                    }
                }
                
            }
            break;
            case 25 :{ // case where we consider the CSF + GM Inliers and Outliers
                TreeEM * TreeCSF=GeneralClassesVector[segment_analysis->IndexCSF];
                TreeEM * TreeGM=GeneralClassesVector[segment_analysis->IndexGM];
                float * NormRespInliersCSF=TreeCSF->GetNormResp();
                float * NormRespInliersGM=TreeGM->GetNormResp();
                float * NormRespOutliersCSF=NULL;
                float * NormRespOutliersGM=NULL;
                if (TreeToAnalyse->GetFlagOutliers()==3) { // symmetric organisation for inlier and outlier part of the model;
                    TreeEM * TreeCSFOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexCSF);
                    TreeEM * TreeGMOutliers=TreeToAnalyse->GetNodeOutlier()->GetChild(segment_analysis->IndexGM);
                    NormRespOutliersCSF=TreeCSFOutliers->GetNormResp();
                    NormRespOutliersGM=TreeGMOutliers->GetNormResp();
                }
                for(int i=0;i<numel;i++){
                    if (L2S_PTR[i]>=0) {
                        NormRespExtracted[i]+=*NormRespInliersCSF;
                        NormRespExtracted[i]+=*NormRespInliersGM;
                        NormRespInliersCSF++;
                        NormRespInliersGM++;
                        if (NormRespOutliersCSF!=NULL && NormRespOutliersGM!=NULL) {
                            NormRespExtracted[i]+=*NormRespOutliersCSF;
                            NormRespExtracted[i]+=*NormRespOutliersGM;
                            NormRespOutliersCSF++;
                            NormRespOutliersGM++;
                        }
                    }
                }
                
            }
            break;
        default:
            break;
    }
    
    // Then test if border for all voxels on which it has to be tested. Difficult to separate GM and WM so maybe use parenchyma as whole ??
    //    int j=0;
    bool * Border=new bool[numel];
    for (int i=0; i<numel; i++) {
        Border[i]=0;
    }
    for (int i=0; i<numel; i++) {
        if (NormRespExtracted[i]>=0.5) {
            //                int * ListNeighboursToLook=Get6Neighbours(i, Dim,Shift);
            int ListNeighboursToLook[6];
            GetListNeighbours_bis(ListNeighboursToLook, i, Dim, Shift, 6);
            //            int * ListNeighboursToLook=GetListNeighbours(i, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (NormRespExtracted[ListNeighboursToLook[n]]<0.5) {
                    //                        Border[ListNeighboursToLook[n]]=1;
                    Border[i]=1;
                    break;
                    
                }
            }
            //            delete [] ListNeighboursToLook;
            //            ListNeighboursToLook=NULL;
        }
    }
    
    // Clearing memory and returning result
    delete [] NormRespExtracted;
    NormRespExtracted=NULL;
    //    delete [] Dim;
    //    Dim=NULL;
    //    delete [] Shift;
    //    Shift=NULL;
    return Border;
}

// To be used to optimise time efficiency dealing with exponentiation
inline float pow_int(const float base,
                     int exp){
    if(exp==0){return 1;}
    float result = base;
    while (--exp){result *= base;}
    return result;
}

/****************************************** METHODS FOR APPLYING LAPLACE EQUATION TO LOCATION IN PARENCHYMA *****************************/
// Obtention of mapping  given the Laplace solution
float * LaplaceMappingExt(float * LaplaceSolution, bool * ObjectOut, int * L2S, int * S2L, int numelmasked, float * PixDim, int * Dim, int * Shift,nifti_image * TestSave){
    // First create the used distance 0 and 1 and initialise them
    float * Mapping1=new float[numelmasked];
    float * Mapping0=new float[numelmasked];
    float * Mapping2=new float[numelmasked];
    bool * Border1=CreateBorderFromBool_L2S(ObjectOut, Dim, Shift, L2S, S2L, numelmasked);
    bool * MaskOut=OpposeBoolArray(ObjectOut,numelmasked);
    for (int i=0; i<numelmasked; i++) {
        Mapping1[i]=MaxDistanceValue;
        Mapping0[i]=MaxDistanceValue;
        Mapping2[i]=MaxDistanceValue;
    }
    SaveTmpResult_short(Border1,"/Users/csudre/Temp/Border.nii.gz",TestSave,L2S);
    InitialiseMappingGivenBorder_L2S(Mapping0, Border1, Dim, Shift, PixDim, L2S, S2L, numelmasked, MaskOut,0);
    InitialiseMappingGivenBorder_L2S(Mapping1, Border1, Dim, Shift, PixDim, L2S, S2L, numelmasked, MaskOut,1);
    InitialiseMappingGivenBorder_L2S(Mapping2, Border1, Dim, Shift, PixDim, L2S, S2L, numelmasked, MaskOut,2);

    //   InitialiseDistanceGivenBorder_L2S(Distance1, Border1, Dim, Shift, PixDim, L2S, S2L, numelmasked,MaskOut);
//    SaveTmpResult_short(Distance1, "/Users/csudre/Downloads/TestDistanceInitLap1.nii.gz", TestSave, L2S);
    // Need to initialise with Border otherwise no update with the Laplace solution
    // Distance0 is obtained using directly the LaplaceSolution
    float * LaplaceSolutionOpposite=CopyArray<float>(LaplaceSolution, numelmasked);
    MultiplyFloatArrayBy(LaplaceSolutionOpposite, -1, numelmasked);
    MappingSolvingWithLaplace3D(Mapping0, Border1, LaplaceSolutionOpposite, Dim, Shift, PixDim, L2S, S2L, numelmasked,TestSave);
    MappingSolvingWithLaplace3D(Mapping1, Border1, LaplaceSolutionOpposite, Dim, Shift, PixDim, L2S, S2L, numelmasked,TestSave);
    MappingSolvingWithLaplace3D(Mapping2, Border1, LaplaceSolutionOpposite, Dim, Shift, PixDim, L2S, S2L, numelmasked,TestSave);
 SaveTmpResult_short(Mapping0, "/Users/csudre/Temp/TestMapLap1Fin_xdir.nii.gz", TestSave, L2S);
 SaveTmpResult_short(Mapping1, "/Users/csudre/Temp/TestMapLap1Fin_ydir.nii.gz", TestSave, L2S);
 SaveTmpResult_short(Mapping2, "/Users/csudre/Temp/TestMapLap1Fin_zdir.nii.gz", TestSave, L2S);
    MultiplyFloatArrayBy(Mapping1,Shift[1],numelmasked);
  MultiplyFloatArrayBy(Mapping2,Shift[2],numelmasked);
  AddElementwiseInPlace(Mapping0,Mapping1,numelmasked);
  AddElementwiseInPlace(Mapping0,Mapping2,numelmasked);
    SaveTmpResult_short(Mapping0, "/Users/csudre/Temp/TestMapLap1Fin.nii.gz", TestSave, L2S);
    // Calculating normalised length
     // Clear memory and return normalised length;
    delete [] Border1;
    delete [] MaskOut;
    delete [] LaplaceSolutionOpposite;

    LaplaceSolutionOpposite=NULL;
    Border1=NULL;
    MaskOut=NULL;

    return Mapping0;
}

float * DistanceFromLobe(float * LaplaceSolution, bool * ObjectIn, bool* ObjectOut, int* L2S, int* S2L,int numelmasked, float * PixDim, int * Dim, int * Shift,nifti_image * TestSave){
   float * Distance1=new float[numelmasked];
    bool * Border1=CreateBorderFromBool_L2S(ObjectOut, Dim, Shift, L2S, S2L, numelmasked);
//    bool * MaskOut=OpposeBoolArray(ObjectOut,numelmasked);
    bool * MaskOut=CopyArray(ObjectOut,numelmasked);
    for (int i=0; i<numelmasked; i++) {
        Distance1[i]=0;
    }
//    SaveTmpResult_short(MaskOut,"/Users/csudre/Temp/bvFTD130/TestMaskOut.nii.gz",TestSave,L2S);
//    SaveTmpResult_short(Border1,"/Users/csudre/Temp/bvFTD130/TestBorder.nii.gz",TestSave,L2S);

    InitialiseDistanceGivenBorder_L2S(Distance1, Border1, Dim, Shift, PixDim, L2S, S2L, numelmasked,MaskOut);
//   SaveTmpResult_short(Distance1,"/Users/csudre/Temp/bvFTD130/TestDistInit.nii.gz",TestSave,L2S);
    float * LaplaceSolutionOpposite=CopyArray<float>(LaplaceSolution, numelmasked);
    MultiplyFloatArrayBy(LaplaceSolutionOpposite, -1, numelmasked);
    LengthSolvingWithLaplace(Distance1, Border1, LaplaceSolutionOpposite, Dim, Shift, PixDim, L2S, S2L, numelmasked,TestSave, ObjectIn);
//    SaveTmpResult_short(Distance1,"/Users/csudre/Temp/bvFTD130/TestDistFin.nii.gz",TestSave,L2S);

    delete[] Border1;
    delete[]MaskOut;
    delete[] LaplaceSolutionOpposite;
    return Distance1;
}


// Obtention of normalised length given the Laplace solution
float * NormalisedLaplaceLength(float * LaplaceSolution, bool * ObjectIn, bool * ObjectOut, int * L2S, int * S2L, int numelmasked, float * PixDim, int * Dim, int * Shift,nifti_image * TestSave){
    // First create the used distance 0 and 1 and initialise them
    float * Distance0=new float[numelmasked];
    float * Distance1=new float[numelmasked];
    bool * Border0=CreateBorderFromBool_L2S(ObjectIn, Dim, Shift, L2S, S2L, numelmasked);
    bool * Border1=CreateBorderFromBool_L2S(ObjectOut, Dim, Shift, L2S, S2L, numelmasked);
    bool * MaskOut=OpposeBoolArray(ObjectOut,numelmasked);
    for (int i=0; i<numelmasked; i++) {
        Distance0[i]=0;
        Distance1[i]=0;
    }
    InitialiseDistanceGivenBorder_L2S(Distance0, Border0, Dim, Shift, PixDim, L2S, S2L, numelmasked,ObjectIn);
//    SaveTmpResult_short(Distance0, "/Users/csudre/Downloads/TestDistanceInitLap0.nii.gz", TestSave, L2S);
    InitialiseDistanceGivenBorder_L2S(Distance1, Border1, Dim, Shift, PixDim, L2S, S2L, numelmasked,MaskOut);
//    SaveTmpResult_short(Distance1, "/Users/csudre/Downloads/TestDistanceInitLap1.nii.gz", TestSave, L2S);
    // Need to initialise with Border otherwise no update with the Laplace solution
    // Distance0 is obtained using directly the LaplaceSolution
    LengthSolvingWithLaplace(Distance0, Border0,LaplaceSolution, Dim, Shift, PixDim, L2S, S2L, numelmasked,TestSave);
//    SaveTmpResult_short(Distance0, "/Users/csudre/Downloads/TestDistanceLap0Fin.nii.gz", TestSave, L2S);
    // Distance1 is obtained using the opposite of the LaplaceSolution
    // Obtaining Opposite of LaplaceSolution
    float * LaplaceSolutionOpposite=CopyArray<float>(LaplaceSolution, numelmasked);
    MultiplyFloatArrayBy(LaplaceSolutionOpposite, -1, numelmasked);
    LengthSolvingWithLaplace(Distance1, Border1, LaplaceSolutionOpposite, Dim, Shift, PixDim, L2S, S2L, numelmasked,TestSave);
//    SaveTmpResult_short(Distance1, "/Users/csudre/Downloads/TestDistanceLap1Fin.nii.gz", TestSave, L2S);
    // Calculating normalised length
    float * DenNormalised=AddElementwise(Distance1, Distance0, numelmasked);
    vector<float *> DenToDivideVector;
    DenToDivideVector.push_back(DenNormalised);
    float * DenDivided=DivideElementwise(DenToDivideVector, numelmasked);
    float * NormalisedLength=MultiplyElementwise(Distance0, DenDivided, numelmasked);
    // Clear memory and return normalised length;
    delete [] Border0;
    delete [] Border1;
    delete [] MaskOut;
    delete [] DenNormalised;
    delete [] DenDivided;
    delete [] Distance0;
    delete [] Distance1;
    delete [] LaplaceSolutionOpposite;
    DenNormalised=NULL;
    DenDivided=NULL;
    Distance1=NULL;
    Distance0=NULL;
    LaplaceSolutionOpposite=NULL;
    Border0=NULL;
    Border1=NULL;
    MaskOut=NULL;
    
    return NormalisedLength;
}

//// Take care of the gridding based on Laplace solution or normalised length solution
//float * IntermediateCorrespondanceGridding(float * Solution, bool * Border, float ValueGrid, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked){
//    // Create the solutions that will be used in one direction or the other for the update. Note that ValueGrid is between 0 and 1 as is Solution
//   float * Solution0=CopyArray(Solution, numelmasked);
//   float * Solution1=CopyArray(Solution, numelmasked);
//    for (int i=0; i<numelmasked; i++) {
//        Solution0[i]-=ValueGrid;
//        Solution1[i]-=ValueGrid;
//    }
//    MultiplyFloatArrayBy(Solution1, -1, numelmasked);
//    // Use Solution0 to build the first to consider fixed and the first layer for the status in order to build the Map
//
//    // Warning : the mapping must be separated in the different coordinates
//    float *
//
//
//
//    // Create Map that we will need to first initialise (or maybe completely solve Distance)
//    int Iteration=0;
//    MapLengthType MapLaplace;
//    for (int i=0; i<numelmasked; i++) {
//        if (FixedDistance[i]==1) {
//            MapLaplace.insert(PairType(Distance[i],i));
//        }
//
//    }
//    // Supposedly we here only consider the inner part of the mask and the boundary but not the inner part nor the outer part of the mask
//    MapLengthType::iterator first_element=MapLaplace.begin();
//    // First update of Distance
//    bool flag_todo=1;
//    int CountPbNumeElse=0;
//    int CountPbFixed=0;
//    while (flag_todo) {
//        first_element=MapLaplace.begin();
//        if(FixedDistance[first_element->second]==0){
//            if(first_element->first<Distance[first_element->second]){
//                cout<< "Oups pb in 0 status update...";
//                Distance[first_element->second]=first_element->first;
//            }
//            MapLaplace.erase(first_element);
//            first_element=MapLaplace.begin();
//            if (MapLaplace.size()<=0) {
//                flag_todo=0;
//            }
//            flag_todo*=(Iteration<numelmasked);
//        }
//        else if (first_element->first<=Distance[first_element->second]) {
//            int TrueIndex=S2L[first_element->second];
//            FixedStatus[first_element->second]=0;
//            Distance[first_element->second]=first_element->first;
//            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
//            for (int n=0; n<6; n++) {
//                if (FixedStatus[L2S[ListNeighbours[n]]]==2) {
//                    FixedStatus[L2S[ListNeighbours[n]]]=1;
//                }
//            }
//            for (int n=0; n<6; n++) {
//                float DistanceSolved=Distance[L2S[ListNeighbours[n]]];
//                if (ListNeighbours[n]!=TrueIndex && FixedStatus[L2S[ListNeighbours[n]]]!=0) {// Check that the considered neighbour is not out of border...
//                    int * ListNeighboursBis=GetListNeighbours(ListNeighbours[n], Dim, Shift, 6);
//                    float DistanceSolved=0;
//                    int * UsedNeighbours=new int[3];
//                    int * NormedGrad=new int[3];
//                    // Look at sign of tangent at index first_element->second to define what Neighbour type to use
//                    for (int d=0; d<3; d++) {
//                        if (TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]>=0) {
//                            //                                UsedNeighbours[d]=0;
//                            //                                NormedGrad[d]=-1;
//                            UsedNeighbours[d]=1;
//                            NormedGrad[d]=-1;
//                        }
//                        else{
//                            //                                UsedNeighbours[d]=1;
//                            //                                NormedGrad[d]=1;
//                            UsedNeighbours[d]=0;
//                            NormedGrad[d]=1;
//                        }
//                    }
//                    // Calculate f as in Yezzi as well as other part in numerator
//                    float f=0;
//                    float NumeElse=0;
//                    float Denominator=0;
//                    int PbFixed=0;
//                    for (int d=0; d<3; d++) {
//                        int NeighbourIndex=ListNeighboursBis[UsedNeighbours[d]+2*d];
//                        if (NeighbourIndex!=ListNeighbours[n] && FixedDistance[L2S[NeighbourIndex]]<1) {
//                            f+=TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]*NormedGrad[d]*(LaplaceToUse[L2S[NeighbourIndex]]-LaplaceToUse[L2S[ListNeighbours[n]]])/PixDim[d];
//                            NumeElse+=fabs(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d]*Distance[L2S[NeighbourIndex]];
//                            Denominator+=fabsf(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d];
//                        }
//                        if (FixedDistance[L2S[NeighbourIndex]]<1) {
//                            PbFixed++;
//                        }
//
//
//                    }
//                    if (PbFixed) {
//                        CountPbFixed++;
//                    }
//                    if(NumeElse==0){
//                        cout<<"Pb in updating Distance"<<endl;
//                        CountPbNumeElse++;
//                    }
//                    // Check if Denominator is 0
//                    if (Denominator<=0) {
//                        cout<<"Pb in denominator for Yezzi Laplace solution";
//                        DistanceSolved=SolveQuadraticForDistance_short(L2S[ListNeighbours[n]], FixedDistance, Distance , Dim, Shift, PixDim,L2S,S2L,numelmasked);
//                        DistanceSolved=MaxDistanceValue;
//                    }
//                    else if(NumeElse!=0){
//                        DistanceSolved=(1+NumeElse)/Denominator;
//                    }
//                    else {
//                        DistanceSolved=SolveQuadraticForDistance_short(L2S[ListNeighbours[n]], FixedDistance, Distance , Dim, Shift, PixDim,L2S,S2L,numelmasked);
//                        DistanceSolved=(f+NumeElse)/Denominator;
//                        DistanceSolved=(1+NumeElse)/Denominator;
//                        DistanceSolved=MaxDistanceValue;
//
//                    }
//
//                    if(DistanceSolved<Distance[L2S[ListNeighbours[n]]]){
//                        Distance[L2S[ListNeighbours[n]]]=DistanceSolved;
//                        if (FixedDistance[L2S[ListNeighbours[n]]]==1) {
//                            MapLaplace.insert(PairType(DistanceSolved,L2S[ListNeighbours[n]]));
//                        }
//                    }
//                    delete [] UsedNeighbours;
//                    delete [] NormedGrad;
//                    delete [] ListNeighboursBis;
//                    ListNeighboursBis=NULL;
//                    UsedNeighbours=NULL;
//                    NormedGrad=NULL;
//                }
//            }
//            delete [] ListNeighbours;
//            ListNeighbours=NULL;
//            MapLaplace.erase(first_element);
//            first_element=MapLaplace.begin();
//            if (MapLaplace.size()<=0) {
//                flag_todo=0;
//            }
//            flag_todo*=(Iteration<numelmasked);
//            Iteration++;
//        }
//        else if(first_element->first>Distance[first_element->second]){
//            FixedDistance[first_element->second]=0;
//            MapLaplace.erase(first_element);
//            first_element=MapLaplace.begin();
//            if (MapLaplace.size()<=0) {
//                flag_todo=0;
//            }
//            flag_todo*=(Iteration<numelmasked);
//        }
//    }
//
//
//
//
//
//
//}

// Classify each considered voxel under a layer according to the NormDistSol value at this voxel and the number of layers wanted
int * CreateLayersFromNormDistSol(float * NormDistSol, int numbLaminae, int numelmasked,float epsilon){
    int * LayersCreated=new int[numelmasked];
    float sizeBin=1.0/numbLaminae;
    for (int i=0; i<numelmasked; i++) {
        if (NormDistSol[i]==0) {
            LayersCreated[i]=0;
        }
        else{
            LayersCreated[i]=(int)floorf((NormDistSol[i]+epsilon)/sizeBin)+1;
        }
    }
    return LayersCreated;
}


// Create border bool given a boolean segmentation and Dim, Shift and number of elements to consider
bool * CreateBorderFromBool(bool * SegToConsider, int * Dim, int * Shift){
    // Initialisation of returned bool array
    int numel=Dim[0]*Dim[1]*Dim[2];
    bool * BorderBool=new bool[numel];
    for (int i=0; i<numel; i++) {
        BorderBool[i]=0;
    }
    // Check for each element belonging to SegToConsider
    for (int i=0; i<numel; i++) {
        if (SegToConsider[i]==1) {
            int TrueIndex=i;
            int ListNeighbours[26];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 26);
            //            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
            for (int n=0; n<26; n++) {
                if (ListNeighbours[n]==TrueIndex) { // Case we are at the border of the image (cf GetListNeighbours function for details)
                    BorderBool[i]=1;
                    break;
                }
                else if(SegToConsider[ListNeighbours[n]]==0){ // Case we are at border of the segmented object
                    BorderBool[i]=1;
                    break;
                }
            }
        }
    }
    return BorderBool;
}

bool * CreateBorderExtFromBool(bool * SegToConsider, int * Dim,int * Shift,int*L2S){
    // Initialisation of returned bool array
    int numel=Dim[0]*Dim[1]*Dim[2];
    bool * BorderBool=new bool[numel];
    for (int i=0; i<numel; i++) {
        BorderBool[i]=0;
    }
    int * L2SPre;
    if (L2S!=NULL) {
        L2SPre=CopyArray(L2S, numel);
    }
    else{
        L2SPre=new int[numel];
        for (int i=0; i<numel; i++) {
            L2SPre[i]=i;
        }
    }
    for (int i=0; i<numel; i++) {
        if (SegToConsider[i]) {
            int TrueIndex=i;
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (L2SPre[TrueIndex]>=0&&ListNeighbours[n]!=TrueIndex) {
                    if (!SegToConsider[ListNeighbours[n]]) {
                        BorderBool[ListNeighbours[n]]=1;
                    }
                }
            }
      
        }
    }
    delete [] L2SPre;
    L2SPre=NULL;
    return BorderBool;
}



// Create border bool given a boolean segmentation in an L2S-S2L scheme. Note that here the inner border is built that is, the border for the voxels that belong to the object but whose neighbour do not is considered as belonging to the border. Can be modified afterwards.
bool * CreateBorderFromBool_L2S(bool * SegToConsider, int * Dim, int * Shift, int * L2S, int * S2L, int numelmasked){
    // Initialisation of returned bool array
    bool * BorderBool=new bool[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        BorderBool[i]=0;
    }
    // Check for each element belonging to SegToConsider
    for (int i=0; i<numelmasked; i++) {
        if (SegToConsider[i]==1) {
            int TrueIndex=S2L[i];
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
            //            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (ListNeighbours[n]==TrueIndex) { // Case we are at the border of the image (cf GetListNeighbours function for details)
                    BorderBool[i]=1;
                    break;
                }
                else if (L2S[ListNeighbours[n]]<0) { // Case we are at border of the mask
                    BorderBool[i]=1;
                    break;
                }
                else if(SegToConsider[L2S[ListNeighbours[n]]]==0){ // Case we are at border of the segmented object
                    BorderBool[i]=1;
                    break;
                }
            }
            // Clear memory for ListNeighbours
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
        }
    }
    return BorderBool;
}


// Initialise mapping given Border considerations in L2S-S2L scheme
void InitialiseMappingGivenBorder_L2S(float * Mapping, bool * Border, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked, bool * MaskIn,int d){
    // Reinitialise Distance
    for (int i=0; i<numelmasked; i++) {
        Mapping[i]=MaxDistanceValue;
    }
    int Coord[3];
    // Only the values on the border will be modified
    for (int i=0; i<numelmasked; i++) {
        if (Border[i]) {
            CorrespondingCoordinates_bis(Coord,S2L[i],Dim,Shift);
            Mapping[i]=Coord[d];
            int TrueIndex=S2L[i];
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
            //            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (L2S[ListNeighbours[n]]>=0 && MaskIn[L2S[ListNeighbours[n]]]==0 && Border[L2S[ListNeighbours[n]]]==0) { // The considered neighbour belong to the mask and thus the distance to the border must be coded
                    Mapping[L2S[ListNeighbours[n]]]=Mapping[i];
                }
            }
        }
    }
}

// Initialise Distance given Border considerations in L2S-S2L scheme
void InitialiseDistanceGivenBorder_L2S(float * Distance, bool * Border, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked, bool * MaskIn){
    // Reinitialise Distance
    for (int i=0; i<numelmasked; i++) {
        Distance[i]=0;
    }
    // Only the values of the direct neighbours to the border will be modified.
    for (int i=0; i<numelmasked; i++) {
        if (Border[i]) {
            int TrueIndex=S2L[i];
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
            //            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (L2S[ListNeighbours[n]]>=0 && MaskIn[L2S[ListNeighbours[n]]]==0 && Border[L2S[ListNeighbours[n]]]==0) { // The considered neighbour belong to the mask and thus the distance to the border must be coded
                    Distance[L2S[ListNeighbours[n]]]+=pow_int(10, n/2);
                }
            }
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
        }
    }
    int CountPb=0;
    for (int i=0; i<numelmasked; i++) {
        if (Distance[i]==222) {
            CountPb++;
        }
    }
    cout<<"CountPb is "<<CountPb<<endl;
    // Recode Distance if non zero
    //    int * ShiftRecode=new int[3];
    int ShiftRecode[3];
    ShiftRecode[0]=1;
    ShiftRecode[1]=10;
    ShiftRecode[2]=100;
    for (int i=0; i<numelmasked; i++) {
        if (Distance[i]>0) {
            RecodeDistance(Distance[i], PixDim, Dim, ShiftRecode);
        }
    }
    //    delete [] ShiftRecode;
    //    ShiftRecode=NULL;
}

// Need to build surface for inner and outer CSF

// Need to check that surfaces considered are topologically equivalent to spheres

// Perform some resampling Need to have ratio 1/1/1

// From Initial Flux image and Image with surfaces, solve Laplacian equation
float * SolvingLaplaceEquation(int * LabelRegions, int * Dim, int * Shift, float * PixDim, int DistMax,int * L2S, int *S2L, int numelmasked, nifti_image * TestToSave){
    // InitialiseValues for Flux and needed other values
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * OldFlux=new float[numelmasked];
    float * ResultFlux=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        if (LabelRegions[i]<2 || LabelRegions[i]==3) {
            OldFlux[i]=ValueMaxVoltage*(LabelRegions[i]>0);
            ResultFlux[i]=ValueMaxVoltage*(LabelRegions[i]>0);
        }
        else{
            OldFlux[i]=ValueMaxVoltage/2;
            ResultFlux[i]=ValueMaxVoltage/2;
        }
    }
//    SaveTmpResult_short(OldFlux,"/Users/Carole/Documents/PhD/SABRE_80/TempLook/187549I/TestLaplace.nii.gz", TestToSave, L2S);
    float * TmpFlux=ResultFlux;
    // Decreasing distance and therefore size of neighborhood used to perform the updating
    float OldEnergy=0;
    float NewEnergy=0;
    bool flag_continue=1;
    DistMax=1;
    for (int d=DistMax; d>=1; d--) {
        cout<<"Treating d "<<d<<endl;
        flag_continue=1;
        int Iteration=0;
        while(flag_continue){
            Iteration++;
            UpdateFluxIteration(ResultFlux, OldFlux, Dim, Shift, PixDim, d,L2S,S2L,numelmasked);
//            SaveTmpResult_short(ResultFlux,"/Users/Carole/Documents/PhD/SABRE_80/TempLook/187549I/TestLaplace2.nii.gz", TestToSave, L2S);
//            cout<<"Flux updated"<<endl;
            RefinementUpdatedFlux(ResultFlux, OldFlux, LabelRegions, Dim, Shift, PixDim, d,L2S,S2L,numelmasked);
//            cout<<"Flux refined"<<endl;
            NewEnergy=TotalEnergyCalculation(ResultFlux, Dim, Shift, PixDim,L2S,S2L,numelmasked);
            cout<<"New energy is now "<<NewEnergy<<" and ratio is "<<fabs(NewEnergy-OldEnergy)/OldEnergy<<endl;
            if (fabs(NewEnergy-OldEnergy)/OldEnergy<=ConvThresh) {
                flag_continue=0;
            }
            //            for (int d=0; d<3; d++) {
            //                float * GradientTmp=GradientImage(ResultFlux, d, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
            //                float MinTmp=GetMin(GradientTmp, numelmasked);
            //                float MaxTmp=GetMax(GradientTmp, numelmasked);
            //                cout<< "max is "<<MaxTmp<<" and min is "<<MinTmp<<endl;
            //                if (fabs(MinTmp) > ValueMaxVoltage/5 || fabs(MaxTmp)>ValueMaxVoltage/5) {
            //                    flag_continue=1;
            //                }
            //                delete [] GradientTmp;
            //                GradientTmp=NULL;
            //            }
            OldEnergy=NewEnergy;
            TmpFlux=OldFlux;
            OldFlux=ResultFlux;
            ResultFlux=TmpFlux;
        }
        cout<<Iteration<<" before stop at dist "<<d<<endl;
        if (TestToSave!=NULL) {
//            SaveTmpResult_short(OldFlux, "/Users/Carole/Documents/PhD/SABRE_80/TempLook/187549I/TestLaplace3.nii.gz", TestToSave, L2S);
        }
        
    }
    delete [] ResultFlux;
    ResultFlux=NULL;
    return OldFlux;
}


// Calculate new flux image from old one

void UpdateFluxIteration(float * NewUpdated, float * OldFromWhichToCalculate, int * Dim, int * Shift, float * PixDim, int Dist,int * L2S, int * S2L, int numelmasked){
    //    int numel = Dim[0]*Dim[1]*Dim[2]; // We assume that we look at 3D volumes
    // Before adding anything, 0 to all values of NewUpdated
    for (int i=0; i<numelmasked; i++) {
        NewUpdated[i]=0;
    }
    float SumNormFactor=0;
    float NormalisationFactor=0;
    // then add Shifted Old image in each direction weighted by distance of shift
    for(int x=-Dist;x<=Dist;x++){
        for (int y=-Dist+abs(x); y<=Dist-abs(x); y++) {
            for (int z=-Dist+abs(x)+abs(y); z<=Dist-abs(x)-abs(y); z++) {
                if(abs(z)+abs(x)+abs(y)>0){ // The central element is excluded
                    //                    int * Trans=new int[3];
                    int Trans[3];
                    Trans[0]=x;
                    Trans[1]=y;
                    Trans[2]=z;
                    float Distance=0;
                    if(PixDim==NULL){
                        for (int d=0; d<3; d++) {
                            Distance+=Trans[d]*Trans[d];
                        }
                    }
                    else{
                        for (int d=0; d<3; d++) {
                            Distance+=pow_int(Trans[d]*PixDim[d], 2);
                        }
                    }
                    NormalisationFactor=sqrt(Distance);
                    NormalisationFactor=Distance;
                    //                    SumNormFactor+=NormalisationFactor;
                    SumNormFactor+=1.0/NormalisationFactor;
                    float * NewShifted=ShiftedVersion(OldFromWhichToCalculate,Trans,Dim,Shift,L2S,S2L,numelmasked);
//                    float Min=GetMin(NewShifted, numelmasked);
//                    float Max=GetMax(NewShifted, numelmasked);
                    MultiplyFloatArrayBy(NewShifted,1.0/NormalisationFactor,numelmasked);
                    AddTo(NewUpdated,NewShifted,numelmasked);
                    delete [] NewShifted;
                    NewShifted=NULL;
//                    float MinUp=GetMin(NewUpdated, numelmasked);
//                    float MaxUp=GetMax(NewUpdated, numelmasked);
                    //                    delete [] Trans;
                    //                    Trans=NULL;
                }
            }
        }
    }
    // Divide obtained result by 6
    //    MultiplyFloatArrayBy(NewUpdated,1.0/SumNormFactor,numelmasked);
    MultiplyFloatArrayBy(NewUpdated, 1.0/(SumNormFactor), numelmasked);
}

// Refine flux after initial smoothing for all, taking into account 3rd surface if exist and maintaining surface "voltage"
void RefinementUpdatedFlux(float * FluxToRefine, float * OldFluxValue, int * LabelRegions,int * Dim, int* Shift, float * PixDim,int Dist, int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    // Check if there is a third surface to take into account
    bool ExistenceThirdSurface=0;
    for (int i=0; i<numelmasked; i++) {
        if (LabelRegions[i]==3) {
            ExistenceThirdSurface=1;
            break;
        }
    }
    if (ExistenceThirdSurface) { // The check and the refinements are slightly more complicated if we use a third resistive surface
        for (int i=0; i<numelmasked; i++) {
            // Consider that regions 0 and 1 are respectively the spaces corresponding to the outer surface and the inner surface, region 2 is the region
            if (LabelRegions[i]<2 || LabelRegions[i]==3) {
                FluxToRefine[i]=ValueMaxVoltage*LabelRegions[i];
            }
            
            else if (LabelRegions[i]==2) {
                int CoordinatesCentralIndex[3];
                CorrespondingCoordinates_bis(CoordinatesCentralIndex, S2L[i], Dim, Shift);
                //                int * CoordinatesCentralIndex=CorrespondingCoordinates(S2L[i], Dim, Shift);
                vector<int> IndicesToExplore=IndicesToExploreVector(S2L[i],Dist,Dim,Shift);
                int numbIndFirst=IndicesToExplore.size();
                for (int n=numbIndFirst-1; n>=0; n--) {
                    if (L2S[IndicesToExplore[n]]<0) {
                        IndicesToExplore.erase(IndicesToExplore.begin()+n);
                    }
                }
                int sizeExplo=IndicesToExplore.size();
                // Check if the 3rd surface is considered among the indices used for the flux establishment. If so, the value must be recalculated
                // Store all corresponding 3rd surface indices in explo range in IndicesThirdSurface
                bool CrossingThirdSurface=0;
                vector<int> IndicesThirdSurface;
                for (int s=0; s<sizeExplo; s++) {
                    if (LabelRegions[L2S[IndicesToExplore[s]]]==3) {
                        CrossingThirdSurface=1;
                        IndicesThirdSurface.push_back(IndicesToExplore[s]);
                    }
                }
                // Define all indices that cannot be considered anymore
                if (CrossingThirdSurface) {
                    //                    vector<int> IndicesToDeconsider;
                    //                    int sizeThirdSurface=IndicesThirdSurface.size();
                    //                    for (int t=0; t<sizeThirdSurface; t++) {
                    //                        vector<int> IndicesPartDeconsider=IndicesCrossedDirection( i,  IndicesThirdSurface[t],  Dist,Dim,Shift);
                    //                        int sizePartDec=IndicesPartDeconsider.size();
                    //                        for (int p=0;p<sizePartDec;p++) {
                    //                            IndicesToDeconsider.push_back(IndicesPartDeconsider[p]);
                    //                        }
                    //                    }
                    // Create in consequence the final list of indices to consider to update the flux
                    vector<int> FinalListIndices=RefineVectorList(IndicesToExplore,IndicesThirdSurface);
                    // Define the new value to set in Flux result
                    float SumNormFactor=0;
                    float FluxNew=0;
                    int sizeFinal=FinalListIndices.size();
                    for (int f=0; f<sizeFinal; f++) {
                        int CoordinatesIndexFinal[3];
                        CorrespondingCoordinates_bis(CoordinatesIndexFinal, FinalListIndices[f], Dim, Shift);
                        //                        int * CoordinatesIndexFinal=CorrespondingCoordinates(FinalListIndices[f],Dim,Shift);
                        float Distance=0;
                        for (int d=0; d<3; d++) {
                            Distance+=pow_int((CoordinatesIndexFinal[d]-CoordinatesCentralIndex[d])*PixDim[d],2);
                        }
                        float ToAdd=OldFluxValue[FinalListIndices[f]]*1.0/sqrtf(Distance);
                        FluxNew+=ToAdd;
                        SumNormFactor+=sqrtf(Distance);
                        //                        delete [] CoordinatesIndexFinal;
                        //                        CoordinatesIndexFinal=NULL;
                    }
                    // Normalisation to have a kernel summing to 1 in the end for the weights of the elements and setting in th
                    FluxToRefine[i]=SumNormFactor*FluxNew;
                }
                //                delete [] CoordinatesCentralIndex;
                //                CoordinatesCentralIndex=NULL;
            }
        }
    }
    else{ // Very simple refinement to simply ensure borders are not modified
        int CountPbSupMaxVoltage=0;
        for (int i=0; i<numelmasked; i++) {
            // Consider that regions 0 and 1 are respectively the spaces corresponding to the outer surface and the inner surface, region 2 is the region
            if (LabelRegions[i]<2) {
                FluxToRefine[i]=ValueMaxVoltage*LabelRegions[i];
            }
            if(LabelRegions[i]==2 && FluxToRefine[i]>ValueMaxVoltage){
                CountPbSupMaxVoltage++;
                FluxToRefine[i]=ValueMaxVoltage;
            }
        }
        if(CountPbSupMaxVoltage>0){
        cout<<"Pb SupMaxVoltage is "<<CountPbSupMaxVoltage;
        }
    }
    
}

// Given two vector lists, check if some of the second one are present in the first one and delete them if needed creating a new vector that contains the element of ListToConsider not present in the list ToDeconsider.
vector<int> RefineVectorList(vector<int> ListToConsider, vector<int> ToDeconsider){
    vector<int> RefinedVectorList;
    int numbToDeconsider=ToDeconsider.size();
    int numbInitialList=ListToConsider.size();
    for (int i=0; i<numbInitialList; i++) {
        int IndexTested=ListToConsider[i];
        bool flag_Accepted=1;
        for (int d=0; d<numbToDeconsider; d++) {
            if (IndexTested==ToDeconsider[d]) {
                flag_Accepted=0;
                break;
            }
        }
        if (flag_Accepted) {
            RefinedVectorList.push_back(IndexTested);
        }
    }
    return RefinedVectorList;
}

float * CorrectMapping(float* Mapping, bool * Border, int * L2S, int* S2L, int* Dim, int* Shift, float* PixDim, int numelmasked){
    int Neighbours[26];
    float * CorrectedMapping = CopyArray(Mapping,numelmasked);
    float Distance[26];
    for(int i=0;i<numelmasked;i++){
        bool flag_check=0;
        if (Mapping[i]>100*numelmasked){
            CorrectedMapping[i]=Mapping[0];
            Mapping[i]=Mapping[0];
        }
        if (L2S[int(Mapping[i])]<0){
            flag_check = 1;
        }
        else if (Border[L2S[int(Mapping[i])]]==0){
            flag_check = 1;
        }
        if (flag_check){
            GetListNeighbours_bis(Neighbours,Mapping[i],Dim,Shift,26);
            for (int n=0;n<26;n++){
                if (Border[L2S[Neighbours[n]]] ==1){
                    Distance[n]=GetDistanceBetweenPoints(Mapping[i],Neighbours[n],Dim,PixDim);
                }
                else{
                    Distance[n]=1000;
                }
            }
            int minInd = GetIndexMin(Distance,26);
            if (Distance[minInd]<1000){
                CorrectedMapping[i]=Neighbours[minInd];
            }
        }
    }
    return CorrectedMapping;
}

float * PerformMapping(float * Mapping, nifti_image * MapImage, int* L2S){
    int numel = MapImage->nvox;
    float * MapData = static_cast<float*>(MapImage->data);
    float * MapFinal = new float[numel];
    for (int i=0;i<numel;i++){
        if (L2S[i]<0){
            MapFinal[i]=0;
        }
        else{
            if (Mapping[L2S[i]]<numel){
                MapFinal[i]=MapData[int(Mapping[L2S[i]])];
            }
        }
    }
    return MapFinal;
}

// Solve generically the Distance given the Laplace solution that has been found according to equation 8 given in Yezzi2002
void MappingSolvingWithLaplace3D(float * Mapping, bool * Border, float * LaplaceSolution,int * Dim, int * Shift,float * PixDim,int * L2S, int * S2L, int numelmasked,nifti_image * TestImage){
//    typedef multimap<float, int> MapLengthType;

    typedef pair<float, int> PairType;
    typedef deque<PairType> MapLengthType;
    float minPos= GetMin(Mapping,numelmasked);
    SaveTmpResult_short(Mapping,"/Users/csudre/Temp/InitMapping.nii.gz",TestImage,L2S);
    // First create Tangent as will be needed all along;
    float * LaplaceToUse=CopyArray(LaplaceSolution, numelmasked);
    MultiplyFloatArrayBy(LaplaceToUse, 1.0/ValueMaxVoltage, numelmasked);
    float * TangentLaplace=Tangent(LaplaceToUse, Dim, Shift, PixDim, L2S, S2L, numelmasked);
//    float * NormGradient=NormNormedGradient(LaplaceToUse, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
//    SaveTmpResult_short(NormGradient, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestNormGradient.nii.gz", TestImage, L2S);
    int CountZeroAll=0;
    for (int i=0; i<numelmasked; i++) {
        //        bool ZeroAll=1;
        float sumTangent=0;
        for (int d=0; d<3; d++) {
            sumTangent+=pow_int(TangentLaplace[i+d*numelmasked],2);
        }
        if (fabs(sumTangent-1)>1E-6) {
            CountZeroAll++;
        }
    }

    // Then create a status array that enables to fix the distances at the border and their neighbour
    int * FixedDistance=new int[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        if (Border[i]==1) {
            FixedDistance[i]=0;
        }
        else if(Mapping[i]<MaxDistanceValue){
            FixedDistance[i]=1;
        }
        else{
            FixedDistance[i]=2;
            Mapping[i]=MaxDistanceValue;
        }
    }
    SaveTmpResult_short(FixedDistance,"/Users/csudre/Temp/InitFixed.nii.gz",TestImage,L2S);

    cout<<"CountZeroAll Tangent is "<<CountZeroAll;
    // Create Map that we will need to first initialise (or maybe completely solve Distance)
    int Iteration=0;
    MapLengthType MapLaplace;
    for (int i=0; i<numelmasked; i++) {
        if (FixedDistance[i]==1) {
            MapLaplace.push_back(PairType(Mapping[i],i));
//            MapLaplace.insert(PairType(Mapping[i],i));
        }

    }
    // Supposedly we here only consider the inner part of the mask and the boundary but not the inner part nor the outer part of the mask
    MapLengthType::iterator first_element=MapLaplace.begin();
    // First update of Distance
    bool flag_todo=1;
    if (MapLaplace.size()==0){
        flag_todo=0;
    }
    int CountPbNumeElse=0;
    int CountPbFixed=0;
    while (flag_todo) {
        first_element=MapLaplace.begin();
//        int cNZ = CountNonZero(FixedDistance,numelmasked);
//        if (cNZ == 300000){
//            SaveTmpResult_short(Mapping,"/Users/csudre/Temp/CurrentMapping.nii.gz",TestImage,L2S);
//        }
//        cout << CountNonZero(FixedDistance,numelmasked) << endl;

        if(FixedDistance[first_element->second]==0){
//            if(first_element->first<Mapping[first_element->second]){
            if(first_element->first>Mapping[first_element->second]){
                cout<< "Oups pb in 0 status update...";
                Mapping[first_element->second]=first_element->first;
            }
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
        }
        else if (first_element->first<=Mapping[first_element->second]) {
            int TrueIndex=S2L[first_element->second];
            FixedDistance[first_element->second]=0;
            Mapping[first_element->second]=first_element->first;
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
            // Checking mask validity for ListNeighbours
            for (int n=0; n<6; n++) {
                if (L2S[ListNeighbours[n]]<0) {
                    ListNeighbours[n]=TrueIndex;
                }
            }
            //            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (FixedDistance[L2S[ListNeighbours[n]]]==2) {
                    FixedDistance[L2S[ListNeighbours[n]]]=1;
                }
            }
            for (int n=0; n<6; n++) {
                //                float DistanceSolved=Distance[L2S[ListNeighbours[n]]];
                if (ListNeighbours[n]!=TrueIndex && FixedDistance[L2S[ListNeighbours[n]]]!=0) {// Check that the considered neighbour is not out of border...
                    int ListNeighboursBis[6];
                    GetListNeighbours_bis(ListNeighboursBis, ListNeighbours[n], Dim, Shift, 6);
                    for (int n2=0; n2<6; n2++) {
                        if (L2S[ListNeighboursBis[n2]]<0) {
                            ListNeighboursBis[n2]=ListNeighbours[n];
                        }
                    }
                    //                    int * ListNeighboursBis=GetListNeighbours(ListNeighbours[n], Dim, Shift, 6);
                    float MappingSolved=first_element->first;
                    //                    int * UsedNeighbours=new int[3];
                    int UsedNeighbours[3];
                    //                    int * NormedGrad=new int[3];
                    int NormedGrad[3];
                    // Look at sign of tangent at index first_element->second to define what Neighbour type to use
                    for (int d=0; d<3; d++) {
                        if (TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]>=0) {
                            UsedNeighbours[d]=1;
                            NormedGrad[d]=-1;
                        }
                        else{
                            UsedNeighbours[d]=0;
                            NormedGrad[d]=1;
                        }
                    }
                    // Calculate f as in Yezzi as well as other part in numerator
                    float f=0;
                    float NumeElse=0;
                    float Denominator=0;
                    int PbFixed=0;
                    for (int d=0; d<3; d++) {
                        int NeighbourIndex=ListNeighboursBis[UsedNeighbours[d]+2*d];
                        if (NeighbourIndex!=ListNeighbours[n] && FixedDistance[L2S[NeighbourIndex]]<1) {
                            f+=TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]*NormedGrad[d]*(LaplaceToUse[L2S[NeighbourIndex]]-LaplaceToUse[L2S[ListNeighbours[n]]])/PixDim[d];
                            NumeElse+=fabs(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d]*Mapping[L2S[NeighbourIndex]];
//                             cout<< Mapping[L2S[NeighbourIndex]]<<endl;

                            Denominator+=fabsf(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d];
                        }
                        if (FixedDistance[L2S[NeighbourIndex]]<1) {
                            PbFixed++;
                        }
                    }
                    if (PbFixed) {
                        CountPbFixed++;
                    }
                    if(NumeElse==0){
//                        cout<<"Pb in updating Distance"<<endl;
                        CountPbNumeElse++;
                    }
                    // Check if Denominator is 0
                    if (Denominator<=0) {
//                        cout<<"Pb in denominator for Yezzi Laplace solution";
                        if(L2S[ListNeighbours[n]]<0){
                            MappingSolved = MaxDistanceValue;
                        }
                    }
                    else if(NumeElse!=0){
                        MappingSolved=round((NumeElse)/Denominator);
                        if (MappingSolved<minPos){
                            cout << "Pb 1"<<endl;
                        }
                    }
                    else {
                        if(L2S[ListNeighbours[n]]<0){
                            MappingSolved = MaxDistanceValue;
                        }

                    }

//                    if(MappingSolved>=Mapping[L2S[ListNeighbours[n]]]& MappingSolved>0){
                        if(MappingSolved<MaxDistanceValue && MappingSolved>0){
                        Mapping[L2S[ListNeighbours[n]]]=MappingSolved;
                        if (FixedDistance[L2S[ListNeighbours[n]]]==1) {
                            MapLaplace.push_back(PairType(MappingSolved,L2S[ListNeighbours[n]]));
//                            MapLaplace.insert(PairType(MappingSolved,L2S[ListNeighbours[n]]));
                        }
                    }
                    //                    delete [] UsedNeighbours;
                    //                    delete [] NormedGrad;
                    //                    delete [] ListNeighboursBis;
                    //                    ListNeighboursBis=NULL;
                    //                    UsedNeighbours=NULL;
                    //                    NormedGrad=NULL;
                }
            }
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
            Iteration++;
        }
        else if(first_element->first<MaxDistanceValue){
            FixedDistance[first_element->second]=0;
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
        }
    }
    cout<<"CountPbNumeElse is "<<CountPbNumeElse<<endl;

    // Remaining MaxDistanceValue set to 0...
    for (int i=0; i<numelmasked; i++) {
//        if (Mapping[i]==MaxDistanceValue) {
//            if (i>0 && i < numelmasked){
//                Mapping[i]=(Mapping[i+1]+Mapping[i-1])/2<10*numelmasked?(Mapping[i+1]+Mapping[i-1])/2:0;
//            }
//            else{
//                Mapping[i]=0;
//            }
//        }
    }
    delete [] FixedDistance;
    FixedDistance=NULL;
    delete [] LaplaceToUse;
    LaplaceToUse=NULL;
}


// Solve generically the Distance given the Laplace solution that has been found according to equation 8 given in Yezzi2002
void MappingSolvingWithLaplace(float * Mapping, bool * Border, float * LaplaceSolution,int * Dim, int * Shift,float * PixDim,int * L2S, int * S2L, int numelmasked,nifti_image * TestImage){
    typedef multimap<float, int> MapLengthType;
    typedef pair<float, int> PairType;
    SaveTmpResult_short(Mapping,"/Users/csudre/Temp/InitMapping.nii.gz",TestImage,L2S);
    // First create Tangent as will be needed all along;
    float * LaplaceToUse=CopyArray(LaplaceSolution, numelmasked);
    MultiplyFloatArrayBy(LaplaceToUse, 1.0/ValueMaxVoltage, numelmasked);
    float * TangentLaplace=Tangent(LaplaceToUse, Dim, Shift, PixDim, L2S, S2L, numelmasked);
//    float * NormGradient=NormNormedGradient(LaplaceToUse, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
//    SaveTmpResult_short(NormGradient, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestNormGradient.nii.gz", TestImage, L2S);
    int CountZeroAll=0;
    for (int i=0; i<numelmasked; i++) {
        //        bool ZeroAll=1;
        float sumTangent=0;
        for (int d=0; d<3; d++) {
            sumTangent+=pow_int(TangentLaplace[i+d*numelmasked],2);
            //            if(TangentLaplace[i+d*numelmasked]!=0){
            //                ZeroAll=0;
            //                break;
            //            }
        }
        if (fabs(sumTangent-1)>1E-6) {
            CountZeroAll++;
        }
    }

    // Then create a status array that enables to fix the distances at the border and their neighbour
    int * FixedDistance=new int[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        if (Border[i]==1) {
            FixedDistance[i]=0;
        }
        else if(Mapping[i]>0){
            FixedDistance[i]=1;
        }
        else{
            FixedDistance[i]=2;
            Mapping[i]=-1;
        }
    }
    cout<<"CountZeroAll Tangent is "<<CountZeroAll;
//    SaveTmpResult_short(TangentLaplace, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestTangentX.nii.gz", TestImage, L2S);
//    SaveTmpResult_short(&TangentLaplace[numelmasked], "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestTangentY.nii.gz", TestImage, L2S);
//    SaveTmpResult_short(&TangentLaplace[numelmasked*2], "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestTangentZ.nii.gz", TestImage, L2S);
    // Create Map that we will need to first initialise (or maybe completely solve Distance)
    int Iteration=0;
    MapLengthType MapLaplace;
    for (int i=0; i<numelmasked; i++) {
        if (FixedDistance[i]==1) {
            MapLaplace.insert(PairType(Mapping[i],i));
        }

    }
    // Supposedly we here only consider the inner part of the mask and the boundary but not the inner part nor the outer part of the mask
    MapLengthType::iterator first_element=MapLaplace.begin();
    // First update of Distance
    bool flag_todo=1;
    if (MapLaplace.size()==0){
        flag_todo=0;
    }
    int CountPbNumeElse=0;
    int CountPbFixed=0;
    while (flag_todo) {
        first_element=MapLaplace.begin();
        int cNZ = CountNonZero(FixedDistance,numelmasked);
        if (cNZ == 300000){
            SaveTmpResult_short(Mapping,"/Users/csudre/Temp/CurrentMapping.nii.gz",TestImage,L2S);
        }
        cout << CountNonZero(FixedDistance,numelmasked) << endl;

        if(FixedDistance[first_element->second]==0){
            if(first_element->first<Mapping[first_element->second]){
                cout<< "Oups pb in 0 status update...";
                Mapping[first_element->second]=first_element->first;
            }
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
        }
        else if (first_element->first>=Mapping[first_element->second]) {
            int TrueIndex=S2L[first_element->second];
            FixedDistance[first_element->second]=0;
            Mapping[first_element->second]=first_element->first;
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
            // Checking mask validity for ListNeighbours
            for (int n=0; n<6; n++) {
                if (L2S[ListNeighbours[n]]<0) {
                    ListNeighbours[n]=TrueIndex;
                }
            }
            //            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (FixedDistance[L2S[ListNeighbours[n]]]==2) {
                    FixedDistance[L2S[ListNeighbours[n]]]=1;
                }
            }
            for (int n=0; n<6; n++) {
                //                float DistanceSolved=Distance[L2S[ListNeighbours[n]]];
                if (ListNeighbours[n]!=TrueIndex && FixedDistance[L2S[ListNeighbours[n]]]!=0) {// Check that the considered neighbour is not out of border...
                    int ListNeighboursBis[6];
                    GetListNeighbours_bis(ListNeighboursBis, ListNeighbours[n], Dim, Shift, 6);
                    for (int n2=0; n2<6; n2++) {
                        if (L2S[ListNeighboursBis[n2]]<0) {
                            ListNeighboursBis[n2]=ListNeighbours[n];
                        }
                    }
                    //                    int * ListNeighboursBis=GetListNeighbours(ListNeighbours[n], Dim, Shift, 6);
                    float MappingSolved=first_element->first;
                    //                    int * UsedNeighbours=new int[3];
                    int UsedNeighbours[3];
                    //                    int * NormedGrad=new int[3];
                    int NormedGrad[3];
                    // Look at sign of tangent at index first_element->second to define what Neighbour type to use
                    for (int d=0; d<3; d++) {
                        if (TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]>=0) {
                            //                                UsedNeighbours[d]=0;
                            //                                NormedGrad[d]=-1;
                            UsedNeighbours[d]=1;
                            NormedGrad[d]=-1;
                        }
                        else{
                            //                                UsedNeighbours[d]=1;
                            //                                NormedGrad[d]=1;
                            UsedNeighbours[d]=0;
                            NormedGrad[d]=1;
                        }
                    }
                    // Calculate f as in Yezzi as well as other part in numerator
                    float f=0;
                    float NumeElse=0;
                    float Denominator=0;
                    int PbFixed=0;
                    for (int d=0; d<3; d++) {
                        int NeighbourIndex=ListNeighboursBis[UsedNeighbours[d]+2*d];
                        if (NeighbourIndex!=ListNeighbours[n] && FixedDistance[L2S[NeighbourIndex]]<1) {
                            f+=TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]*NormedGrad[d]*(LaplaceToUse[L2S[NeighbourIndex]]-LaplaceToUse[L2S[ListNeighbours[n]]])/PixDim[d];
                            NumeElse+=fabs(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d]*Mapping[L2S[NeighbourIndex]];
//                            cout<< Mapping[L2S[NeighbourIndex]]<<endl;
                            Denominator+=fabsf(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d];
                        }
                        if (FixedDistance[L2S[NeighbourIndex]]<1) {
                            PbFixed++;
                        }


                    }
                    if (PbFixed) {
                        CountPbFixed++;
                    }
                    if(NumeElse==0){
//                        cout<<"Pb in updating Distance"<<endl;
                        CountPbNumeElse++;
                    }
                    // Check if Denominator is 0
                    if (Denominator<=0) {
//                        cout<<"Pb in denominator for Yezzi Laplace solution";
                        if(L2S[ListNeighbours[n]]<0){
                            MappingSolved = -1;
                        }
                    }
                    else if(NumeElse!=0){
                        MappingSolved=floor((NumeElse)/Denominator);
                    }
                    else {
                        if(L2S[ListNeighbours[n]]<0){
                            MappingSolved = -1;
                        }

                    }

                    if(MappingSolved>=Mapping[L2S[ListNeighbours[n]]]& MappingSolved>0){
                        Mapping[L2S[ListNeighbours[n]]]=MappingSolved;
                        if (FixedDistance[L2S[ListNeighbours[n]]]==1) {
                            MapLaplace.insert(PairType(MappingSolved,L2S[ListNeighbours[n]]));
                        }
                    }
                    //                    delete [] UsedNeighbours;
                    //                    delete [] NormedGrad;
                    //                    delete [] ListNeighboursBis;
                    //                    ListNeighboursBis=NULL;
                    //                    UsedNeighbours=NULL;
                    //                    NormedGrad=NULL;
                }
            }
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
            Iteration++;
        }
        else if(first_element->first<Mapping[first_element->second] && first_element->first>0){
            FixedDistance[first_element->second]=0;
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
        }
    }
    cout<<"CountPbNumeElse is "<<CountPbNumeElse<<endl;

    // Remaining MaxDistanceValue set to 0...
    for (int i=0; i<numelmasked; i++) {
        if (Mapping[i]==-1) {
            Mapping[i]=-1;
        }
    }
    delete [] FixedDistance;
    FixedDistance=NULL;
    delete [] LaplaceToUse;
    LaplaceToUse=NULL;
}


// Solve generically the Distance given the Laplace solution that has been found according to equation 8 given in Yezzi2002
void LengthSolvingWithLaplace(float * Distance, bool * Border, float * LaplaceSolution,int * Dim, int * Shift,float * PixDim,int * L2S, int * S2L, int numelmasked,nifti_image * TestImage, bool * Mask){
    typedef multimap<float, int> MapLengthType;
    typedef pair<float, int> PairType;
    bool * MaskShort=NULL;
    if (Mask!=NULL){
        MaskShort = CreateShort(Mask, S2L, numelmasked);
    }
    // First create Tangent as will be needed all along;
    float * LaplaceToUse=CopyArray(LaplaceSolution, numelmasked);
    MultiplyFloatArrayBy(LaplaceToUse, 1.0/ValueMaxVoltage, numelmasked);
    float * TangentLaplace=Tangent(LaplaceToUse, Dim, Shift, PixDim, L2S, S2L, numelmasked);
//    float * NormGradient=NormNormedGradient(LaplaceToUse, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
//    SaveTmpResult_short(NormGradient, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestNormGradient.nii.gz", TestImage, L2S);
    int CountZeroAll=0;
    for (int i=0; i<numelmasked; i++) {
        //        bool ZeroAll=1;
        float sumTangent=0;
        for (int d=0; d<3; d++) {
            sumTangent+=pow_int(TangentLaplace[i+d*numelmasked],2);
            //            if(TangentLaplace[i+d*numelmasked]!=0){
            //                ZeroAll=0;
            //                break;
            //            }
        }
        if (fabs(sumTangent-1)>1E-6) {
            CountZeroAll++;
        }
    }


    
    // Then create a status array that enables to fix the distances at the border and their neighbour
    int * FixedDistance=new int[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        if (Border[i]==1) {
            FixedDistance[i]=0;
        }
        else if(Distance[i]>0){
            FixedDistance[i]=1;
        }
        else{
            FixedDistance[i]=2;
            Distance[i]=MaxDistanceValue;
        }
    }

    if(MaskShort!=NULL){
        for(int i=0; i<numelmasked; i++){
            Distance[i] = MaskShort[i]?Distance[i]:0;
        }
    }
//    cout<<"CountZeroAll Tangent is "<<CountZeroAll;
//    SaveTmpResult_short(TangentLaplace, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestTangentX.nii.gz", TestImage, L2S);
//    SaveTmpResult_short(&TangentLaplace[numelmasked], "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestTangentY.nii.gz", TestImage, L2S);
//    SaveTmpResult_short(&TangentLaplace[numelmasked*2], "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestTangentZ.nii.gz", TestImage, L2S);
    // Create Map that we will need to first initialise (or maybe completely solve Distance)
    int Iteration=0;
    MapLengthType MapLaplace;
    for (int i=0; i<numelmasked; i++) {
        if (FixedDistance[i]==1) {
            MapLaplace.insert(PairType(Distance[i],i));
        }
        
    }
    // Supposedly we here only consider the inner part of the mask and the boundary but not the inner part nor the outer part of the mask
    MapLengthType::iterator first_element=MapLaplace.begin();
    // First update of Distance
    bool flag_todo=1;
    if (MapLaplace.size()==0){
        flag_todo=0;
    }
    int CountPbNumeElse=0;
    int CountPbFixed=0;
    while (flag_todo) {
        first_element=MapLaplace.begin();
        if(FixedDistance[first_element->second]==0){
            if(first_element->first<Distance[first_element->second]){
                cout<< "Oups pb in 0 status update...";
                Distance[first_element->second]=first_element->first;
            }
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
        }
        else if (first_element->first<=Distance[first_element->second]) {
            int TrueIndex=S2L[first_element->second];
            FixedDistance[first_element->second]=0;
            Distance[first_element->second]=first_element->first;
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
            // Checking mask validity for ListNeighbours
            for (int n=0; n<6; n++) {
                if (L2S[ListNeighbours[n]]<0) {
                    ListNeighbours[n]=TrueIndex;
                }
            }
            //            int * ListNeighbours=GetListNeighbours(TrueIndex, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (FixedDistance[L2S[ListNeighbours[n]]]==2) {
                    FixedDistance[L2S[ListNeighbours[n]]]=1;
                }
            }
            for (int n=0; n<6; n++) {
                //                float DistanceSolved=Distance[L2S[ListNeighbours[n]]];
                if (ListNeighbours[n]!=TrueIndex && FixedDistance[L2S[ListNeighbours[n]]]!=0) {// Check that the considered neighbour is not out of border...
                    int ListNeighboursBis[6];
                    GetListNeighbours_bis(ListNeighboursBis, ListNeighbours[n], Dim, Shift, 6);
                    for (int n2=0; n2<6; n2++) {
                        if (L2S[ListNeighboursBis[n2]]<0) {
                            ListNeighboursBis[n2]=ListNeighbours[n];
                        }
                    }
                    //                    int * ListNeighboursBis=GetListNeighbours(ListNeighbours[n], Dim, Shift, 6);
                    float DistanceSolved=0;
                    //                    int * UsedNeighbours=new int[3];
                    int UsedNeighbours[3];
                    //                    int * NormedGrad=new int[3];
                    int NormedGrad[3];
                    // Look at sign of tangent at index first_element->second to define what Neighbour type to use
                    for (int d=0; d<3; d++) {
                        if (TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]>=0) {
                            //                                UsedNeighbours[d]=0;
                            //                                NormedGrad[d]=-1;
                            UsedNeighbours[d]=1;
                            NormedGrad[d]=-1;
                        }
                        else{
                            //                                UsedNeighbours[d]=1;
                            //                                NormedGrad[d]=1;
                            UsedNeighbours[d]=0;
                            NormedGrad[d]=1;
                        }
                    }
                    // Calculate f as in Yezzi as well as other part in numerator
                    float f=0;
                    float NumeElse=0;
                    float Denominator=0;
                    int PbFixed=0;
                    for (int d=0; d<3; d++) {
                        int NeighbourIndex=ListNeighboursBis[UsedNeighbours[d]+2*d];
                        if (NeighbourIndex!=ListNeighbours[n] && FixedDistance[L2S[NeighbourIndex]]<1) {
                            f+=TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked]*NormedGrad[d]*(LaplaceToUse[L2S[NeighbourIndex]]-LaplaceToUse[L2S[ListNeighbours[n]]])/PixDim[d];
                            NumeElse+=fabs(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d]*Distance[L2S[NeighbourIndex]];
                            Denominator+=fabsf(TangentLaplace[L2S[ListNeighbours[n]]+d*numelmasked])/PixDim[d];
                        }
                        if (FixedDistance[L2S[NeighbourIndex]]<1) {
                            PbFixed++;
                        }
                        
                        
                    }
                    if (PbFixed) {
                        CountPbFixed++;
                    }
                    if(NumeElse==0){
//                        cout<<"Pb in updating Distance"<<endl;
                        CountPbNumeElse++;
                    }
                    // Check if Denominator is 0
                    if (Denominator<=0) {
//                        cout<<"Pb in denominator for Yezzi Laplace solution";
                        if(L2S[ListNeighbours[n]]>=0){
                            DistanceSolved=SolveQuadraticForDistance_short(L2S[ListNeighbours[n]], FixedDistance, Distance , Dim, Shift, PixDim,L2S,S2L,numelmasked);
                        }
                        else{ // Modified 11/10/2016
                        DistanceSolved=MaxDistanceValue;
                        }
                    }
                    else if(NumeElse!=0){
                        DistanceSolved=(1+NumeElse)/Denominator;
                    }
                    else {
                        if (L2S[ListNeighbours[n]]>=0) {
                            DistanceSolved=SolveQuadraticForDistance_short(L2S[ListNeighbours[n]], FixedDistance, Distance , Dim, Shift, PixDim,L2S,S2L,numelmasked);
                        }
                        else{ // Modified 11/10/2016
                        DistanceSolved=(f+NumeElse)/Denominator;
                        DistanceSolved=(1+NumeElse)/Denominator;
                        DistanceSolved=MaxDistanceValue;
                        }
                        
                    }
                    
                    if(DistanceSolved<Distance[L2S[ListNeighbours[n]]]){
                        Distance[L2S[ListNeighbours[n]]]=DistanceSolved;
                        if (FixedDistance[L2S[ListNeighbours[n]]]==1) {
                            MapLaplace.insert(PairType(DistanceSolved,L2S[ListNeighbours[n]]));
                        }
                    }
                    //                    delete [] UsedNeighbours;
                    //                    delete [] NormedGrad;
                    //                    delete [] ListNeighboursBis;
                    //                    ListNeighboursBis=NULL;
                    //                    UsedNeighbours=NULL;
                    //                    NormedGrad=NULL;
                }
            }
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
            Iteration++;
        }
        else if(first_element->first>Distance[first_element->second]){
            FixedDistance[first_element->second]=0;
            MapLaplace.erase(first_element);
            first_element=MapLaplace.begin();
            if (MapLaplace.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iteration<numelmasked);
        }
    }
    cout<<"CountPbNumeElse is "<<CountPbNumeElse<<endl;
    
    // Remaining MaxDistanceValue set to 0...
    for (int i=0; i<numelmasked; i++) {
        if (Distance[i]==MaxDistanceValue) {
            Distance[i]=0;
        }
    }
    delete [] FixedDistance;
    FixedDistance=NULL;
    delete [] LaplaceToUse;
    LaplaceToUse=NULL;
    delete [] TangentLaplace;
    if (MaskShort!=NULL){
        delete [] MaskShort;
    }
    TangentLaplace=NULL;
}


// Returns the float array of the values shifted according to Trans that contains the information about the translation in each direction
float * ShiftedVersion(float * ToShift, int * Trans, int * Dim, int * Shift, int* L2S, int* S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    // We assume that normally all values are above 0 therefore a -1 value correspond to a non-initialised/considered voxel
    float * ShiftedVersion=new float[numelmasked];
    for (int i=0;i<numelmasked; i++) {
        ShiftedVersion[i]=-1E18;
    }
    
    // First make sure that the input values are ok or change them accordingly
//    float MinS=GetMin(ToShift, numelmasked);
//    float MaxS=GetMax(ToShift, numelmasked);
    // Initialisation of the needed values
    int newIndex=0;
    int oldIndex=0;
    vector<int> NotPossibleVector;
    for (int i=0; i<numelmasked; i++) {
        oldIndex=S2L[i];
        int OldCoord[3];
        CorrespondingCoordinates_bis(OldCoord, oldIndex, Dim, Shift);
        //        int * OldCoord=CorrespondingCoordinates(oldIndex, Dim, Shift);
        int * NewCoord=AddElementwiseInt(OldCoord,Trans,3);
        bool CheckNewCoordPossibility=ValidityCoordinates(NewCoord, Dim);
        if (CheckNewCoordPossibility) {
            newIndex=NewCoord[0]*Shift[0]+NewCoord[1]*Shift[1]+NewCoord[2]*Shift[2];
            if (L2S[newIndex]>=0) {
                ShiftedVersion[L2S[newIndex]]=ToShift[i];
            }
            else{
                NotPossibleVector.push_back(oldIndex);
            }
            
        }
        else{
            NotPossibleVector.push_back(oldIndex);
        }
        //        delete [] OldCoord;
        delete [] NewCoord;
        //        OldCoord=NULL;
        NewCoord=NULL;
    }
    
    // Note that all voxels with no correspondance to old index are kept to -1 for the moment
    // need to be redefined. Will be change recursively
    // First initialise matrix that will define which of the elements have not been considered yet
    //    bool * NotConsidered=new bool[numelmasked];
    int CountShiftM1=0;
    int CountNotCorrected=0;
    //    int sizeNotPossible=NotPossibleVector.size();
    for (int i=0; i<numelmasked; i++) {
        if (ShiftedVersion[i]<=-1E17) {
            CountShiftM1++;
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, S2L[i], Dim, Shift, 6);
            //            int * ListNeighbours=GetListNeighbours(S2L[i], Dim, Shift, 6);
            int CountToMean=0;
            float SumToMean=0;
            for (int n=0; n<6; n++) {
                if (L2S[ListNeighbours[n]]>=0) {
                    if (fabs(ToShift[L2S[ListNeighbours[n]]])<1E16) {
                        SumToMean+=ToShift[L2S[ListNeighbours[n]]];
                        CountToMean++;
                    }
                }
            }
            if (CountToMean!=0 && fabs(SumToMean)<1E16) {
                ShiftedVersion[i]=SumToMean/CountToMean;
            }
            else{
                ShiftedVersion[i]=ToShift[i];
                CountNotCorrected++;
            }
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
        }
    }
    
    if (CountNotCorrected>0) {
        cout << "Shifting problem count is "<<CountNotCorrected<<"..."<<endl;
    }
    
    //    RecursiveConsideration(ShiftedVersion,NotConsidered,Dim,Shift,L2S,S2L,numelmasked);
    
    //    // Memory cleaning and returning results
    //    delete [] NotConsidered;
    //    NotConsidered=NULL;
    bool CheckInf=CheckContainsInf(ShiftedVersion, numelmasked);
    if (CheckInf) {
        cout<<"Pb Shifted inf"<<endl;
    }
    return ShiftedVersion;
}

// Correct recursively ShiftedVersion, so that there is no 1 anymore in NotConsidered
void RecursiveConsideration(float * ShiftedVersion, bool * NotConsidered, int *Dim, int *Shift,int* L2S, int * S2L, int numelmasked){
    bool flag_nc=0;
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    for (int i=0; i<numelmasked; i++) {
        if (NotConsidered[i]) {
            flag_nc=1;
            break;
        }
    }
    if (flag_nc) {
        for (int i=0; i<numelmasked; i++) {
            if (NotConsidered[i]) {
                int List6Neighbours[6];
                GetListNeighbours_bis(List6Neighbours, S2L[i], Dim, Shift, 6);
                //                int * List6Neighbours=GetListNeighbours(S2L[i], Dim, Shift, 6);
                // Check if at least one of the elements among the neighbours is possibly already considered and can be used and then use the mean of considered voxels
                float SumValues=0;
                int NumbCount=0;
                for (int n=0; n<6; n++) {
                    if (L2S[List6Neighbours[n]]>=0) {
                        if (!NotConsidered[L2S[List6Neighbours[n]]]) {
                            NumbCount++;
                            SumValues+=ShiftedVersion[L2S[List6Neighbours[n]]];
                        }
                    }
                    
                }
                if(NumbCount>0){
                    ShiftedVersion[i]=SumValues/NumbCount;
                    NotConsidered[i]=0;
                }
            }
        }
        RecursiveConsideration(ShiftedVersion, NotConsidered, Dim, Shift,L2S,S2L,numelmasked);
    }
    else{
        return;
    }
}


// Calculate Gradient along direction
float * GradientImage(float * ToGrad, int dim, int Type, int * Dim, int * Shift, float * PixDim,int * L2S, int*S2L,int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    //    int * TransP=new int[3];
    int TransP[3];
    
    //    int * TransM=new int [3];
    int TransM[3];
    for (int d=0; d<3; d++) {
        if (d!=dim) {
            TransP[d]=0;
            TransM[d]=0;
        }
        else{
            switch (Type) {
                    case 0:{
                        TransP[d]=1;
                        TransM[d]=-1;
                    }
                    break;
                    case 1:{
                        TransP[d]=1;
                        TransM[d]=0;
                    }
                    break;
                    case -1:{
                        TransP[d]=0;
                        TransM[d]=-1;
                    }
                    break;
                default:{
                    TransP[d]=1;
                    TransM[d]=-1;
                }
                    break;
            }
            
        }
    }
    float * ShiftedP=ShiftedVersion(ToGrad,TransP,Dim,Shift,L2S,S2L,numelmasked);
    bool CheckInf=CheckContainsInf(ShiftedP, numelmasked);
    if (CheckInf) {
        cout<<"Pb Grad inf"<<endl;
    }
    float * ShiftedM=ShiftedVersion(ToGrad,TransM,Dim,Shift,L2S,S2L,numelmasked);
    CheckInf=CheckContainsInf(ShiftedM, numelmasked);
    if (CheckInf) {
        cout<<"Pb Grad inf"<<endl;
    }
    MultiplyFloatArrayBy(ShiftedM,-1,numelmasked);
    // Initialisation of result
    float * GradientResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        GradientResult[i]=0;
    }
    // Population of result
    AddTo(GradientResult,ShiftedP,numelmasked);
    AddTo(GradientResult,ShiftedM,numelmasked);
//   cout<< "min and max"<<GetMin(ShiftedM, numelmasked)<<" "<<GetMax(ShiftedP, numelmasked);
    CheckInf=CheckContainsInf(GradientResult, numelmasked);
    if (CheckInf) {
        cout<<"Pb Grad inf"<<endl;
    }
    MultiplyFloatArrayBy(GradientResult,1/(abs(TransP[dim]-TransM[dim])*PixDim[dim]),numelmasked);
    CheckInf=CheckContainsInf(GradientResult, numelmasked);
//     cout<< "min and max"<<GetMin(GradientResult, numelmasked)<<" "<<GetMax(GradientResult, numelmasked);
    if (CheckInf) {
        cout<<"Pb Grad inf"<<endl;
    }
    // Clear memory and return Gradient result
    delete [] ShiftedM;
    delete [] ShiftedP;
    //    delete [] TransM;
    //    delete [] TransP;
    ShiftedP=NULL;
    ShiftedM=NULL;
    //    TransM=NULL;
    //    TransP=NULL;
    return GradientResult;
}

// Calculate SecondCrossed Derivative according to dim1 and dim2
float * SecondCrossedDer(float * ToGrad, int dim1, int dim2, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked){
    //    int numel = Dim[0]*Dim[1]*Dim[2];
    float * Result=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        Result[i]=0;
    }
    for (int dir1=-1; dir1<=1; dir1=dir1+2) {
        for (int dir2=-1; dir2<=1; dir2=dir2+2) {
            //            int * TransTmp=new int [3];
            int TransTmp[3];
            int tmpSign=1;
            for (int d=0; d<3; d++) {
                if (d==dim1) {
                    TransTmp[d]=dir1;
                    tmpSign*=dir1;
                }
                else if(d==dim2){
                    TransTmp[d]=dir2;
                    tmpSign*=dir2;
                }
                else{
                    TransTmp[d]=0;
                }
            }
            float * ShiftedTmp=ShiftedVersion(ToGrad, TransTmp, Dim, Shift,L2S,S2L,numelmasked);
            for (int i=0; i<numelmasked; i++) {
                Result[i]+=tmpSign*ShiftedTmp[i];
                if (Result[i]!=Result[i]){
                    cout <<"Pb NAN"<<endl;
                }
            }
            
            
            
            delete [] ShiftedTmp;
            //            delete [] TransTmp;
            ShiftedTmp=NULL;
            //            TransTmp=NULL;
        }
    }
    // Normalisation by 4*PixDim[dim1]*PixDim[dim2]
    float NormalisationFactor=1/(4*PixDim[dim1]*PixDim[dim2]);
    MultiplyFloatArrayBy(Result, NormalisationFactor, numelmasked);
    return Result;
}

float * Hessian(float * ToGrad,int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked ){
    float * HessianResult=new float[6*numelmasked];
    int sizeHR=6*numelmasked;
    for(int i=0; i<sizeHR;i++){
        HessianResult[i]=0;
    }
    float * DerXY= SecondCrossedDer(  ToGrad,  0,  1, Dim, Shift, PixDim, L2S,  S2L,  numelmasked);
    float * DerXZ= SecondCrossedDer( ToGrad,  0,  2, Dim, Shift, PixDim, L2S,   S2L,  numelmasked);
    float * DerYZ= SecondCrossedDer( ToGrad,  1,  2,  Dim,  Shift, PixDim, L2S,  S2L,  numelmasked);
    float * DerXX=SecondDer(ToGrad, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
    float * DerYY=SecondDer(ToGrad, 1, Dim, Shift, PixDim, L2S, S2L, numelmasked);
    float * DerZZ=SecondDer(ToGrad, 2, Dim, Shift, PixDim, L2S, S2L, numelmasked);
    cout << GetMax(DerXX, numelmasked)<<" "<<GetMax(DerXY, numelmasked) << " " << GetMax(DerYY, numelmasked) << " "<< GetMax(DerXZ, numelmasked) << " " << GetMax(DerZZ, numelmasked) << " " << GetMax(DerYZ, numelmasked)<<endl;
    for (int i=0;i<numelmasked;i++){
        HessianResult[i]=DerXX[i];
        HessianResult[i+numelmasked]=DerYY[i];
        HessianResult[i+2*numelmasked]=DerZZ[i];
        HessianResult[i+3*numelmasked]=DerXY[i];
        HessianResult[i+4*numelmasked]=DerXZ[i];
        HessianResult[i+5*numelmasked]=DerYZ[i];
    }
    delete [] DerXX;
    delete [] DerXY;
    delete [] DerXZ;
    delete [] DerYZ;
    delete [] DerYY;
    delete [] DerZZ;
    return HessianResult;
}

float * Vesselness(float * ToGrad,int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked,int polarity){
    float * HessianMat = Hessian(ToGrad, Dim, Shift, PixDim, L2S,S2L, numelmasked);
    float * NormHessian=new float[numelmasked];
    float * ResultVesselness=new float[numelmasked];
    for(int i=0;i<numelmasked;i++){
        ResultVesselness[i]=0;
        NormHessian[i]=0;
    }
    for(int i=0;i<numelmasked;i++){
        for (int d=0;d<6;d++ ){
            if(d<3){
                NormHessian[i]+=HessianMat[i+d*numelmasked]*HessianMat[i+d*numelmasked];
                if (NormHessian[i]!=NormHessian[i]){
                    cout <<"Pb NAN"<<endl;
                }
            }
            else{
                NormHessian[i]+=2*HessianMat[i+d*numelmasked]*HessianMat[i+d*numelmasked];
                if (NormHessian[i]!=NormHessian[i]){
                    cout <<"Pb NAN"<<endl;
                }
            }
        }
    }
    float cFactor=0.5*sqrt(GetMax(NormHessian, numelmasked));
    cout << "Initial cFactor is "<< cFactor;
    vector<float> QuantilesVec;
    QuantilesVec.push_back(0.5);
    QuantilesVec.push_back(0.25);
    QuantilesVec.push_back(0.75);
    QuantilesVec.push_back(0.99);
    vector<float *> QuantilesNorm=GetQuantilesMulti<float,bool>(NormHessian, NULL, numelmasked, 1, QuantilesVec);
    cFactor+=0.5*sqrt(QuantilesNorm[0][2]);
    cFactor/=2.0;
    cout << "Final cFactor is "<< cFactor<<endl;
    delete [] QuantilesNorm[0];
    float MatTemp[9];
    float Eigen[3];
    int CountCorr=0;
    float AbEigen[3];
    for(int i=0;i<numelmasked;i++){
        MatTemp[0]=HessianMat[i];
        MatTemp[4]=HessianMat[i+numelmasked];
        MatTemp[8]=HessianMat[i+2*numelmasked];
        MatTemp[1]=HessianMat[i+3*numelmasked];
        MatTemp[3]=MatTemp[1];
        MatTemp[2]=HessianMat[i+4*numelmasked];
        MatTemp[6]=MatTemp[2];
        MatTemp[5]=HessianMat[i+5*numelmasked];
        MatTemp[7]=MatTemp[5];
        TreeEM * TreeTest=NULL;
        
        if (TreeTest->determinant(MatTemp, 3)<=10E-7 || TreeTest->determinant(MatTemp, 3)!=TreeTest->determinant(MatTemp, 3)){
//            ResultVesselness[i]=0;
//            MatTemp[0]+=1E-5;
//            MatTemp[4]+=1E-5;
//            MatTemp[8]+=1E-5;
            CountCorr++;
        }
        SVD Decomp=SVD(MatTemp, 3, 3);
        for (int d=0;d<3;d++){
            Eigen[d]=Decomp.getSingularValues()[d];
            AbEigen[d]=fabs(Decomp.getSingularValues()[d]);
        }
        if (Eigen[2]==0 || Eigen[2]!=Eigen[2]) {
            ResultVesselness[i]=0;
        }
        else{
        int* Order= quickSort_order(AbEigen, 3);
        float RA=AbEigen[1]/AbEigen[2];
        float RB=AbEigen[0]/sqrt(AbEigen[1]*AbEigen[2]);
        float S=sqrt(AbEigen[0]*AbEigen[0]+AbEigen[1]*AbEigen[1]+AbEigen[2]*AbEigen[2]);
        if(TreeTest->determinant(MatTemp, 3)*polarity==0){
            ResultVesselness[i]=0;
        }
        else{
            ResultVesselness[i]=expf(-RB*RB/(2*0.5*0.5))*(1-expf(-RA*RA/(2*0.5*0.5)))*(1-expf(-S*S/(2*cFactor*cFactor)));
        }
        delete [] Order;
        Order=NULL;
        }
    }
    cout <<"CountCorr is "<< CountCorr<<endl;
    delete [] HessianMat;
    delete [] NormHessian;
    return ResultVesselness;
}



// Returns as a pointer to a float array of size 3 * numelmasked the value for the tangent (normalised on the 3 directions)
float * Tangent(float * ToTangent,int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked ){
    // Initialisation of TangentResult
    float * TangentResult=new float[3*numelmasked];
    for (int i=0; i<3*numelmasked; i++) {
        TangentResult[i]=0;
    }
    // Obtain the gradients in the 3 directions and populate Tangent result accordingly
    float * NormGradient=NormNormedGradient(ToTangent, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
    for (int d=0; d<3; d++) {
        float * TmpGradient=GradientImage(ToTangent, d, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
        for (int i=0; i<numelmasked; i++) {
            if (NormGradient[i]!=0) {
                TangentResult[i+d*numelmasked]=TmpGradient[i]/NormGradient[i];
            }
            //            else{
            //                TangentResult[i+d*numelmasked]=1.0/sqrt(3);
            //            }
        }
        delete [] TmpGradient;
        TmpGradient=NULL;
    }
    delete [] NormGradient;
    NormGradient=NULL;
    return TangentResult;
}

// Calculate second derivative along direction according to direction
float * SecondDer(float * ToGrad, int dim, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    //    int * TransP=new int[3];
    int TransP[3];
    //    int * TransM=new int [3];
    int TransM[3];
    for (int d=0; d<3; d++) {
        if (d!=dim) {
            TransP[d]=0;
            TransM[d]=0;
        }
        else{
            TransP[d]=1;
            TransM[d]=-1;
        }
    }
    float * ShiftedP=ShiftedVersion(ToGrad,TransP,Dim,Shift,L2S,S2L,numelmasked);
    float * ShiftedM=ShiftedVersion(ToGrad,TransM,Dim,Shift,L2S,S2L,numelmasked);
    // Initialisation of result
    float * SecondDerResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        SecondDerResult[i]=0;
    }
    // Population of result
    AddTo(SecondDerResult,ShiftedP,numelmasked);
    AddTo(SecondDerResult,ShiftedM,numelmasked);
    MultiplyFloatArrayBy(SecondDerResult, -1, numelmasked);
    AddTo(SecondDerResult, ToGrad, numelmasked);
    AddTo(SecondDerResult, ToGrad, numelmasked);
    MultiplyFloatArrayBy(SecondDerResult, -1/pow_int(PixDim[dim],2), numelmasked);
    
    // Clear memory and return SecondDer result
    delete [] ShiftedM;
    delete [] ShiftedP;
    //    delete [] TransM;
    //    delete [] TransP;
    ShiftedP=NULL;
    ShiftedM=NULL;
    //    TransM=NULL;
    //    TransP=NULL;
    return SecondDerResult;
}

float * NormedGradientSquared(float * ToGrad, int dim, int sign, int * Dim, int * Shift,float * PixDim,int * L2S, int * S2L, int numelmasked){
    //    int numel =Dim[0]*Dim[1]*Dim[2];
//    cout<<GetMin(ToGrad, numelmasked)<<" max for ToGrad and "<<GetMax(ToGrad, numelmasked)<<" min"<<endl;
    bool CheckInf=CheckContainsInf(ToGrad, numelmasked);
    if (CheckInf) {
        cout<<"Pb ToGrad inf"<<endl;
    }
    float * GradForMax=GradientImage(ToGrad, dim, -1*sign , Dim, Shift, PixDim,L2S, S2L, numelmasked);
    CheckInf=CheckContainsInf(GradForMax, numelmasked);
//    cout<<GetMax(GradForMax, numelmasked)<<" max for GradForMax...";
    if (CheckInf) {
        cout<<"Pb Grad inf"<<endl;
    }
    float * GradForMin=GradientImage(ToGrad,dim, 1*sign, Dim, Shift, PixDim, L2S,S2L,numelmasked);
    CheckInf=CheckContainsInf(GradForMin, numelmasked);
//    cout<<GetMin(GradForMin, numelmasked)<<" min for GradForMin...";
    if (CheckInf) {
        cout<<"Pb Grad inf"<<endl;
    }
    float * ZeroMatrix=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        ZeroMatrix[i]=0;
    }
    vector<float *> ForMaxVector;
    ForMaxVector.push_back(GradForMax);
    ForMaxVector.push_back(ZeroMatrix);
    vector<float *> ForMinVector;
    ForMinVector.push_back(GradForMin);
    ForMinVector.push_back(ZeroMatrix);
    float * MaxToUse=MaxElementwise(ForMaxVector,numelmasked);
    CheckInf=CheckContainsInf(MaxToUse, numelmasked);
    if (CheckInf) {
        cout<<"Pb Max inf"<<endl;
    }
    float * MinToUse=MinElementwise(ForMinVector,numelmasked);
    CheckInf=CheckContainsInf(MinToUse, numelmasked);
    if (CheckInf) {
        cout<<"Pb Min inf"<<endl;
    }
    delete [] GradForMin;
    delete [] GradForMax;
    delete [] ZeroMatrix;
    GradForMax=NULL;
    GradForMin=NULL;
    ZeroMatrix=NULL;
    vector<float *> MaxMult;
    vector<float *> MinMult;
    MaxMult.push_back(MaxToUse);
    MaxMult.push_back(MaxToUse);
    MinMult.push_back(MinToUse);
    MinMult.push_back(MinToUse);
    float * SquareMax=MultiplyElementwise(MaxMult,numelmasked);
    CheckInf=CheckContainsInf(SquareMax, numelmasked);
    if (CheckInf) {
        cout<<"Pb Max2 inf"<<endl;
    }
    float * SquareMin=MultiplyElementwise(MinMult, numelmasked);
    CheckInf=CheckContainsInf(SquareMin, numelmasked);
    if (CheckInf) {
        cout<<"Pb Min2 inf"<<endl;
    }
    delete [] MaxToUse;
    delete [] MinToUse;
    MaxToUse=NULL;
    MinToUse=NULL;
    float * FinalRes=AddElementwise(SquareMax, SquareMin, numelmasked);
    delete [] SquareMin;
    delete [] SquareMax;
    SquareMax=NULL;
    SquareMin=NULL;
    return FinalRes;
}

float * NormNormedGradient(float * ToGrad, int Type, int * Dim, int * Shift, float * PixDim,int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * AddingResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        AddingResult[i]=0;
    }
    for (int d=0; d<3; d++) {
        float * TmpNormed=NormedGradientSquared(ToGrad, d, Type, Dim, Shift, PixDim,L2S,S2L,numelmasked);
        bool CheckInf=CheckContainsInf(TmpNormed, numelmasked);
        if (CheckInf) {
            cout<<"Pb in TmpNormed inf"<<endl;
        }
        for (int i=0; i<numelmasked; i++) {
            AddingResult[i]+=TmpNormed[i];
        }
        delete [] TmpNormed;
        TmpNormed=NULL;
    }
    float * ResultNorm=PowerElementwise(AddingResult,0.5,numelmasked);
    delete [] AddingResult;
    AddingResult=NULL;
    return ResultNorm;
}

// Build curvature result (max memory used 4*numel*sizeFloat)
float * CurvatureCalculation_2(float * ImageToCurve, int * Dim, int * Shift, float * PixDim,int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    bool CheckNaN=0;
    vector<float *> GradVec;
    for (int d=0; d<3; d++) {
        float * GradToPush=GradientImage(ImageToCurve, d, 0, Dim, Shift, PixDim, L2S, S2L, numelmasked);
        CheckNaN=CheckContainsInf<float>(GradToPush, numelmasked);
        if (CheckNaN) {
            cout<<"Nan in GradToPush !";
        }
        GradVec.push_back(GradToPush);
    }
    
    float * ResultNum=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        ResultNum[i]=0;
    }
    
    for (int d1=0; d1<3; d1++) {
        for (int d2=0; d2<3; d2++) {
            if (d1!=d2) {
                float * CrossedTmp=SecondCrossedDer(ImageToCurve, d1, d2, Dim, Shift, PixDim,L2S,S2L,numelmasked);
                CheckNaN=CheckContainsNaN(CrossedTmp, numelmasked);
                if (CheckNaN) {
                    cout<<"NaN in CrossedTmp"<<endl;
                }
                vector<float *> CrossedVec;
                CrossedVec.push_back(CrossedTmp);
                CrossedVec.push_back(GradVec[d1]);
                CrossedVec.push_back(GradVec[d2]);
                float * CrossedRes=MultiplyElementwise(CrossedVec, numelmasked);
                MultiplyFloatArrayBy(CrossedRes, -2, numelmasked);
                AddTo(ResultNum, CrossedRes, numelmasked);
                delete [] CrossedRes;
                delete [] CrossedTmp;
                CrossedTmp=NULL;
                CrossedRes=NULL;
            }
        }
    }
    
    // Building Square of gradients vector and deleting gradients correspondingly
    vector<float *> Gsq;
    for (int d=0; d<3; d++) {
        float * GsqToPush=PowerElementwise(GradVec[d], 2, numelmasked);
        Gsq.push_back(GsqToPush);
        CheckNaN=CheckContainsInf(GsqToPush, numelmasked);
        if (CheckNaN) {
            cout<<"Pb with Gsq"<<endl;
        }
        delete [] GradVec[d];
        GradVec[d]=NULL;
    }
    
    // Finish Numerator by including parts with SecondDer
    for (int d1=0; d1<3; d1++) {
        float * SecondDerTmp=SecondDer(ImageToCurve, d1, Dim, Shift, PixDim, L2S,S2L,numelmasked);
        CheckNaN=CheckContainsInf(SecondDerTmp, numelmasked);
        if (CheckNaN) {
            cout<<"Pb with SecondDerTmp"<<endl;
        }
        for (int d2=0; d2<3; d2++) {
            if (d2!=d1) {
                CheckNaN=CheckContainsInf(Gsq[d2], numelmasked);
                CheckNaN=CheckContainsInf(SecondDerTmp, numelmasked);
                float * d2d2sd1=MultiplyElementwise(Gsq[d2], SecondDerTmp, numelmasked);
                CheckNaN=CheckContainsNaN(d2d2sd1, numelmasked);
                if (CheckNaN) {
                    cout<<"Pb in d2d2sd1"<<endl;
                }
                AddTo(ResultNum, d2d2sd1, numelmasked);
                delete [] d2d2sd1;
                d2d2sd1=NULL;
            }
        }
        delete [] SecondDerTmp;
        SecondDerTmp=NULL;
    }
    
    // Taking care of denominator
    float * Denominator=AddElementwise(Gsq, numelmasked);
    bool CheckInf=CheckContainsInf(Denominator, numelmasked);
    if (CheckInf) {
        cout <<"Inf in Denominator !"<<endl;
    }
    cout<<"min max for Denominator"<<GetMax(Denominator, numelmasked)<<" "<<GetMin(Denominator, numelmasked)<<endl;
    
    // Clearing square of gradients vector
    for (int d=0; d<3; d++) {
        delete [] Gsq[d];
        Gsq[d]=NULL;
    }
    
    vector<float *> Den;
    Den.push_back(Denominator);
    Den.push_back(Denominator);
    Den.push_back(Denominator);
    float * BeforeDen=PowerElementwise(Denominator, 3, numelmasked);
    cout<<"min max for BeforeDen"<<GetMax(BeforeDen, numelmasked)<<" "<<GetMin(BeforeDen, numelmasked)<<endl;
    float * TrueDen=InverseElementwise(BeforeDen, numelmasked);
    cout<<"min max for TrueDen"<<GetMax(TrueDen, numelmasked)<<" "<<GetMin(TrueDen, numelmasked)<<endl;
    delete [] BeforeDen;
    BeforeDen=NULL;
    //    float * TrueDen=DivideElementwise(Den,numelmasked);
    CheckNaN=CheckContainsNaN(TrueDen, numelmasked);
    if (CheckNaN) {
        cout<<"NaN in TrueDen !";
    }
    CheckInf=CheckContainsInf(TrueDen, numelmasked);
    if (CheckInf) {
        cout <<"Inf in TrueDen !"<<endl;
    }
    delete [] Denominator;
    Denominator=NULL;
    float * RootTrueDen=PowerElementwise(TrueDen, 0.5, numelmasked);
    CheckNaN=CheckContainsNaN(RootTrueDen, numelmasked);
    CheckInf=CheckContainsInf(RootTrueDen, numelmasked);
    if (CheckNaN || CheckInf) {
        cout<<"Pb in RootTrueDen"<<endl;
    }
    delete [] TrueDen;
    TrueDen=NULL;
    CheckNaN=CheckContainsNaN(ResultNum, numelmasked);
    CheckInf=CheckContainsInf(ResultNum, numelmasked);
    if (CheckNaN || CheckInf) {
        cout<<"Pb in ResultNum"<<endl;
    }
    float * Curvature=MultiplyElementwise(RootTrueDen, ResultNum, numelmasked);
    CheckNaN=CheckContainsNaN(Curvature, numelmasked);
    if (CheckNaN) {
        cout<<"Pb in Curvature"<<endl;
    }
    cout<< "MaxCurvature is "<<GetMax(Curvature, numelmasked)<<" and MinCurvature is "<< GetMin(Curvature, numelmasked);
    cout<< "CheckNan for curvature is "<<CheckNaN<<endl;
    delete [] RootTrueDen;
    delete [] ResultNum;
    RootTrueDen=NULL;
    ResultNum=NULL;
    
    return Curvature;
}

float * InitialiseDistanceFromSignFunction(int * SignFunction, int * Dim, int * Shift){
    int numel = Dim[0]*Dim[1]*Dim[2];
    
    float * DistInit=new float[numel];
    for (int i=0; i<numel; i++) {
        DistInit[i]=MaxDistanceValue;
    }
    for (int i=0; i<numel; i++) {
        if (SignFunction[i]>=0.5) {
            //                int * ListNeighboursToLook=Get6Neighbours(i, Dim,Shift);
            int ListNeighboursToLook[6];
            GetListNeighbours_bis(ListNeighboursToLook, i, Dim, Shift, 6);
            //            int * ListNeighboursToLook=GetListNeighbours(i, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (SignFunction[ListNeighboursToLook[n]]<-0.5) {
                    //                        Border[ListNeighboursToLook[n]]=1;
                    DistInit[i]=0;
                    break;
                    
                }
            }
            //            delete [] ListNeighboursToLook;
            //            ListNeighboursToLook=NULL;
        }
    }
    return DistInit;
}

int * InitialisationSignFunction(float * CurrentPhi, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int * InitialiseSign=new int [numel];
    for (int i=0; i<numel; i++) {
        InitialiseSign[i]=CurrentPhi[i]>0?-1:1;
    }
    return InitialiseSign;
}

int * InitialisationSignFunction(bool * SegInit, int * Dim, bool * Mask){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int * InitialiseSign=new int [numel];
    if (Mask!=NULL) {
        for (int i=0; i<numel; i++) {
            if (SegInit[i]&&Mask[i]) { // If in object distance should be negative therefore sign is negative
                InitialiseSign[i]=-1;
            }
            else{
                InitialiseSign[i]=1;
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (SegInit[i]) { // If in object distance should be negative therefore sign is negative
                InitialiseSign[i]=-1;
            }
            else{
                InitialiseSign[i]=1;
            }
        }
    }
    return InitialiseSign;
}

// Create Label (0,1,2,3) from boolean segmentation
int * CreateLaplaceLabelling(bool * SegMini, bool * SegMaxi, int * Dim){
    //    bool Crossing=CheckAndCorrectCrossing(SegMini, SegMaxi, Dim);
    int numel=Dim[0]*Dim[1]*Dim[2];
    // First create union between SegMini and SegMaxi and check for crossing
    bool * UnionSegs=new bool[numel];
    bool * InterSegs=new bool[numel];
    for (int i=0; i<numel; i++) {
        if (SegMaxi[i]==1||SegMini[i]==1) {
            UnionSegs[i]=1;
        }
        else{
            UnionSegs[i]=0;
        }
        if (SegMaxi[i]==1 && SegMini[i]==1) {
            InterSegs[i]=1;
        }
        else{
            InterSegs[i]=0;
        }
    }
    int * LabelLaplace=new int[numel];
    for (int i=0; i<numel; i++) {
        if(UnionSegs[i]==0){ // Outside both
            LabelLaplace[i]=1;
        }
        else if(InterSegs[i]){
            LabelLaplace[i]=0;
        }
        else {
            LabelLaplace[i]=2;
        }
    }
    delete [] UnionSegs;
    delete [] InterSegs;
    return LabelLaplace;
}

// Calculate Total Energy function sum at each voxel of all squared gradients along each direction
float TotalEnergyCalculation(float * NewFlux, int * Dim, int * Shift, float * PixDim,int * L2S, int * S2L, int numelmasked){
    //    int numel = Dim[0]*Dim[1]*Dim[2];
    float * EuclideanNormGradient=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        EuclideanNormGradient[i]=0;
    }
    // Sum over all direction of squared gradient
    for (int d=0; d<3; d++) {
        float * GradientDir=GradientImage(NewFlux, d, 0, Dim, Shift, PixDim,L2S,S2L,numelmasked);
        float * SquaredGradient=MultiplyElementwise(GradientDir,GradientDir,numelmasked);
        AddTo(EuclideanNormGradient,SquaredGradient,numelmasked);
        delete [] SquaredGradient;
        delete [] GradientDir;
        SquaredGradient=NULL;
        GradientDir=NULL;
    }
    // Sum over all voxels of euclidean norm of gradient
    float EuclideanResult=0;
    for (int i=0; i<numelmasked; i++) {
        EuclideanResult+=sqrtf(EuclideanNormGradient[i]);
    }
    // Clearing memory and returning result
    delete [] EuclideanNormGradient;
    EuclideanNormGradient=NULL;
    return EuclideanResult;
}

// Gives in a vector all indices around a certain CentralIndex, within a certain ExploRadius given the Dim and Shift information
vector<int> IndicesToExploreVector(int CentralIndex, int ExploRadius, int * Dim, int * Shift){
    int Coordinates[3];
    CorrespondingCoordinates_bis(Coordinates, CentralIndex, Dim, Shift);
    //    int * Coordinates=CorrespondingCoordinates(CentralIndex,Dim,Shift);
    vector<int> IndicesToExplore;
    for (int x=-ExploRadius; x<=ExploRadius;x++) {
        for (int y=-ExploRadius+abs(x); y<=ExploRadius-abs(x); y++) {
            for (int z=-ExploRadius+abs(x)+abs(y); z<=ExploRadius-abs(x)-abs(y); z++) {
                if (abs(x)+abs(y)+abs(z)>0) {
                    //                    int * newIndex=new int [3];
                    int newIndex[3];
                    newIndex[0]=Coordinates[0]+x;
                    newIndex[1]=Coordinates[1]+y;
                    newIndex[2]=Coordinates[2]+z;
                    bool ValidnewIndex=1;
                    for (int d=0; d<3; d++) {
                        ValidnewIndex*=((newIndex[d]-Dim[d]+1)<=0);
                        ValidnewIndex*=(newIndex[d]>0);
                    }
                    if (ValidnewIndex) {
                        IndicesToExplore.push_back(newIndex[0]*Shift[0]+newIndex[1]*Shift[1]+newIndex[2]*Shift[2]);
                    }
                }
            }
        }
    }
    return IndicesToExplore;
}

// Find the x y z coordinates given the index i, the Shift array and the Dim array
int * CorrespondingCoordinates(int Index, int * Dim, int * Shift){
    // Check that Index is correct
    int numel = Dim[0]*Dim[1]*Dim[2];
    if (Index<0 || Index >=numel) {
        cout<<"Index is impossible"<<endl;
        return NULL;
    }
    // Create and populate the corresponding coordinates
    int * Coordinates=new int [3];
    int tmp=Index;
    for (int d=2; d>=0; d--) {
        Coordinates[d]=tmp/Shift[d];
        tmp-=Shift[d]*Coordinates[d];
    }
    return Coordinates;
}


// Find the x y z coordinates given the index i, the Shift array and the Dim array with any variable number of dimensions (Can be used for histogram)
int * CorrespondingCoordinates_ter(int Index, int * Dim, int * Shift,int sizeDim){
    // Check that Index is correct
    int numel=1;
    for (int m=0; m<sizeDim; m++) {
        numel*=Dim[m];
    }
    if (Index<0 || Index >=numel) {
        cout<<"Index is impossible"<<endl;
        return NULL;
    }
    // Create and populate the corresponding coordinates
    int * Coordinates=new int [sizeDim];
    int tmp=Index;
    for (int d=sizeDim-1; d>=0; d--) {
        Coordinates[d]=tmp/Shift[d];
        tmp-=Shift[d]*Coordinates[d];
    }
    return Coordinates;
}

void CorrespondingCoordinates_bis(int * ResultCoordinates, int Index, int * Dim, int * Shift){
    // Initialise with -1
    for (int d=0; d<3; d++) {
        ResultCoordinates[d]=-1;
    }
    // Check that Index is correct
    int numel = Dim[0]*Dim[1]*Dim[2];
    if (Index<0 || Index >=numel) {
        cout<<"Index is impossible"<<endl;
        return;
    }
    // Create and populate the corresponding coordinates
    int tmp=Index;
    for (int d=2; d>=0; d--) {
        ResultCoordinates[d]=tmp/Shift[d];
        tmp-=Shift[d]*ResultCoordinates[d];
    }
    return;
}

nifti_image * CorrectionNii(nifti_image * NiiImage, bool * Correction){
    int numel=NiiImage->nx*NiiImage->ny*NiiImage->nz;
    int numbmodal=NiiImage->nt*NiiImage->nu;
    float * CorrectedData=new float[NiiImage->nvox];
    float * DataImage=static_cast<float*>(NiiImage->data);
    for(int i=0;i<numel;i++){
        if(!Correction[i]){
            for(int m=0;m<numbmodal;m++){
                CorrectedData[m*numel+i]=DataImage[m*numel+i];
            }
        }
        else{
            for(int m=0;m<numbmodal;m++){
                CorrectedData[m*numel+i]=0;
            }
        }
    }
    nifti_image * CorrectedNii=CreateNiiFromArray(CorrectedData,NiiImage,numel);
    delete[] CorrectedData;
    CorrectedData=NULL;
    return CorrectedNii;
}

void OROperationBool(bool * Array1, bool * Array2, bool * Result, int numel){
    if (Result==NULL) {
        Result=new bool[numel];
    }
    for (int i=0; i<numel; i++) {
        Result[i]=(Array1[i]||Array2[i]);
    }
    return;
}

void ANDOperationBool(bool * Array1, bool * Array2, bool * Result, int numel){
    if (Result==NULL) {
        Result=new bool[numel];
    }
    if (Array1==NULL || Array2==NULL){
        for(int i=0; i<numel; i++){
            Result[i] = 0;
        }
        return;
    }
    for (int i=0; i<numel; i++) {
        Result[i]=(Array1[i]==1&& Array2[i]==1);
    }
    return;
}
void XOROperationBool(bool * Array1, bool * Array2, bool * Result, int numel){
    if (Result==NULL) {
        Result=new bool[numel];
    }
    if (Array1==NULL || Array2==NULL){
        for(int i=0; i<numel; i++){
            Result[i] = 0;
        }
        return;
    }
    for (int i=0; i<numel; i++) {
        Result[i]=(Array1[i]&&!Array2[i]);
    }
}

void AddTo(float * ImageToModify, float * ImageToAdd, int numel,bool * Mask){
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            ImageToModify[i]+=ImageToAdd[i];
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                ImageToModify[i]+=ImageToAdd[i];
            }
        }
    }
    
    return;
}

bool * OpposeBoolArray(bool * ArrayToOppose, int numelmasked){
    bool * OpposedArray=new bool[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        OpposedArray[i]=ArrayToOppose[i]?0:1;
    }
    return OpposedArray;
}

void MultiplyFloatArrayBy(float * FloatArrayMultiplied, float MultiplicativeFloat, int numel, bool * Mask){
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            FloatArrayMultiplied[i]*=MultiplicativeFloat;
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                FloatArrayMultiplied[i]*=MultiplicativeFloat;
            }
        }
    }
    return;
}

float * MultiplyElementwise(float * Array1, float * Array2, int numel,bool * Mask){
    //    bool CheckNaN1=CheckContainsNaN(Array1, numel);
    //    bool CheckNaN2=CheckContainsNaN(Array2, numel);
    float * MultipliedResult=new float[numel];
    for (int i=0; i<numel; i++) {
        MultipliedResult[i]=1;
    }
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            MultipliedResult[i]=Array1[i]*Array2[i];
            if (MultipliedResult[i]!=MultipliedResult[i]) {
                cout<<"Multiplication producing NaN"<<endl;
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                MultipliedResult[i]=Array1[i]*Array2[i];
            }
            else{
                MultipliedResult[i]=0;
            }
        }
    }
    //    bool CheckNaNRes=CheckContainsNaN(MultipliedResult, numel);
    
    return MultipliedResult;
}

float * AddElementwise(float * Array1, float * Array2, int numel,bool * Mask){
    float * AddedResult=new float [numel];
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            AddedResult[i]=Array1[i]+Array2[i];
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                AddedResult[i]=Array1[i]+Array2[i];
            }
            else{
                AddedResult[i]=0;
            }
        }
    }
    return AddedResult;
}

float * AddElementwiseMasked(float * Array1, float * Array2, bool * MaskArray, int numel){
    float * AddedResult=new float[numel];
    for (int i=0; i<numel; i++) {
        AddedResult[i]=MaskArray[i]>0?Array1[i]+Array2[i]:0;
    }
    return AddedResult;
}

int * AddElementwiseInt(int * Array1, int * Array2, int numel){
    int * AddedResult=new int [numel];
    for (int i=0; i<numel; i++) {
        AddedResult[i]=Array1[i]+Array2[i];
    }
    return AddedResult;
}

float * AddElementwise(vector<float *> VectorArray, int numel,bool * Mask){
    int numbAdded=VectorArray.size();
    float * ResultAdded=new float[numel];
    for (int i=0; i<numel; i++) {
        ResultAdded[i]=0;
    }
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            for (int n=0; n<numbAdded; n++) {
                ResultAdded[i]+=VectorArray[n][i];
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                for (int n=0; n<numbAdded; n++) {
                    ResultAdded[i]+=VectorArray[n][i];
                }
            }
        }
    }
    
    return ResultAdded;
}

float * MinElementwise(vector<float *> VectorArray,int numel,bool * Mask){
    float * MinResult=new float[numel];
    int numbComp=VectorArray.size();
    for (int i=0; i<numel; i++) {
        MinResult[i]=1E18;
    }
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            for (int n=0; n<numbComp; n++) {
                if (VectorArray[n][i]<MinResult[i]) {
                    MinResult[i]=VectorArray[n][i];
                }
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                for (int n=0; n<numbComp; n++) {
                    if (VectorArray[n][i]<MinResult[i]) {
                        MinResult[i]=VectorArray[n][i];
                    }
                }
            }
        }
    }
    return MinResult;
}

float * MaxElementwise(vector<float *> VectorArray,int numel,bool * Mask){
    float * MaxResult=new float[numel];
    int numbComp=VectorArray.size();
    for (int i=0; i<numel; i++) {
        MaxResult[i]=-1E18;
    }
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            for (int n=0; n<numbComp; n++) {
                if (VectorArray[n][i]>MaxResult[i]) {
                    MaxResult[i]=VectorArray[n][i];
                }
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                for (int n=0; n<numbComp; n++) {
                    if (VectorArray[n][i]>MaxResult[i]) {
                        MaxResult[i]=VectorArray[n][i];
                    }
                }
            }
        }
    }
    return MaxResult;
}

float * MultiplyElementwise(vector<float *> VectorArray, int numel,bool * Mask){
    int numbMultiply=VectorArray.size();
    float * ResultMultiply=new float[numel];
    // Initialise with 1 everywhere
    for (int i=0; i<numel; i++) {
        ResultMultiply[i]=1;
    }
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            for (int n=0; n<numbMultiply; n++) {
                ResultMultiply[i]*=VectorArray[n][i];
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                for (int n=0; n<numbMultiply; n++) {
                    ResultMultiply[i]*=VectorArray[n][i];
                }
            }
        }
    }
    return ResultMultiply;
}

float * PowerElementwise(float * ArrayToPower, float power, int numel,bool * Mask){
    float * ResultPower=new float[numel];
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            ResultPower[i]=powf(ArrayToPower[i], power);
            if (ResultPower[i]>1E18) {
                cout<<"Pb in power inf"<<endl;
            }
        }
    }
    else {
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                ResultPower[i]=powf(ArrayToPower[i], power);
            }
            else{
                ResultPower[i]=0;
            }
        }
    }
    return ResultPower;
}

float * InverseElementwise(float * ArrayToInvert, int numel,bool * Mask){
    float * ResultInvert=new float[numel];
    for (int i=0; i<numel; i++) {
        ResultInvert[i]=1;
    }
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            if (fabs(ArrayToInvert[i])>10E-6) {
                ResultInvert[i]/=ArrayToInvert[i];
            }
            else{
                ResultInvert[i]=10E6;
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (ArrayToInvert[i]!=0 && Mask[i]>0) {
                ResultInvert[i]/=ArrayToInvert[i];
            }
        }
    }
    return ResultInvert;
}

float * DivideElementwise(vector<float *> VectorArray, int numel,bool * Mask){
    int numbDivide=VectorArray.size();
    float * ResultDivide=new float[numel];
    // Initialise with 1 everywhere
    for (int i=0; i<numel; i++) {
        ResultDivide[i]=1;
    }
    if (Mask==NULL) {
        for (int i=0; i<numel; i++) {
            for (int n=0; n<numbDivide; n++) {
                ResultDivide[i]=VectorArray[n][i]!=0?ResultDivide[i]/VectorArray[n][i]:1;
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                for (int n=0; n<numbDivide; n++) {
                    ResultDivide[i]=VectorArray[n][i]!=0?ResultDivide[i]/VectorArray[n][i]:1;
                }
            }
        }
    }
    return ResultDivide;
}

bool ValidityCoordinates(int * CoordinatesToCheck, int * Dim){
    bool Valid=1;
    for (int d=0; d<3; d++) {
        Valid*=(CoordinatesToCheck[d]<=Dim[d]-1);
        Valid*=(CoordinatesToCheck[d]>0);
    }
    return Valid;
}

/********************************** METHODS TO USE LEVEL SET AND FAST MARCHING FOR EQUIVOLUME ********************************/


// Complete Algo for level set with fast marching for equivolume
// We use as input the two binary segmentation of the In object and out object as well as the number of equivolumes that we want to define, and the information about dimension and PixDim
vector<float *> CompleteEquiVolumeLSSolving(bool * SegMini, bool * SegMaxi, int * Dim, float * PixDim, PARAM_LS* Param_LS, int * L2S, int * S2L, int & numelmasked, float * PhiIn, float * PhiOut,nifti_image * TestToSave){
    
    vector<float *> FinalPhi;
    // First correction for any crossing that might occur between SegMini and SegMaxi
    bool flag_CorrCross=CheckAndCorrectCrossing(SegMini, SegMaxi, Dim);
    if (flag_CorrCross) {
        cout<<"Correction for crossing needed"<<endl;
    }
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    // Initialisation of Shift that will be needed everywhere
    //    int * Shift=new int[3];
    int Shift[3];
    Shift[0]=1;
    for (int d=1; d<3; d++) {
        Shift[d]=Shift[d-1]*Dim[d-1];
    }
    
    //    // Check for holes in the binary structures and stop if they exist
    //    bool flag_holesMini=CheckForHoles(SegMini, Dim, Shift);
    //    bool flag_holesMaxi=CheckForHoles(SegMaxi, Dim, Shift);
    //    if (flag_holesMini || flag_holesMaxi) {
    //        cout << "Pb of holes in one of the structure, maybe need to stop there"<<endl;
    ////        delete [] Shift;
    ////        Shift=NULL;
    ////        return FinalPhi;
    //    }
    
    // Creating Mask for InBetween region
    bool * Mask=CreateMask(SegMini, SegMaxi, Dim);
    bool * MaskDil=Dilation(Mask, 3, Dim, Shift);
//    SaveTmpResult<bool>(Mask, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestMaskForLS.nii.gz", TestToSave);
    // Create SignFunction for In and Out
    L2S=MakeL2S(MaskDil, Dim);
    numelmasked=0;
    S2L=MakeS2L(MaskDil,Dim,numelmasked);
    int * SignIn=CreateSignFunction(SegMini, Dim);
    int * SignOut=CreateSignFunction(SegMaxi,Dim);
    
    int Iteration=0;
    if (PhiIn==NULL) {
        PhiIn=InitialiseDistanceFromSignFunction(SignIn, Dim, Shift);
        int * StatusIn=InitialiseStatusFromDistance(PhiIn,Dim,Mask);
        InitialiseState(StatusIn, PhiIn, Dim, Shift, PixDim);
        IterFastMarchingMap(StatusIn, PhiIn, Dim, Shift, PixDim,Iteration,Mask);
        delete [] StatusIn;
        StatusIn=NULL;
    }
    // Initialise Status, and distance before calculating anything
    
    if (PhiOut==NULL) {
        PhiOut=InitialiseDistanceFromSignFunction(SignOut, Dim, Shift);
        int * StatusOut=InitialiseStatusFromDistance(PhiOut,Dim,Mask);
        InitialiseState(StatusOut, PhiOut, Dim, Shift, PixDim);
        //Then Calculating PhiIn and PhiOut with FastMarching
        Iteration=0;
        IterFastMarchingMap(StatusOut, PhiOut, Dim, Shift, PixDim,Iteration,Mask);
        // Clearing memory before continuing
        delete [] StatusOut;
        StatusOut=NULL;
    }
    
    
    float * AMap=NULL;
    int * ProjectionIndicesIn=NULL;
    int * ProjectionIndicesOut=NULL;
    float * PhiIn_s=CreateShort<float>(PhiIn,S2L,numelmasked);
    float * PhiOut_s=CreateShort<float>(PhiOut,S2L,numelmasked);
    int * SignIn_s=CreateShort<int>(SignIn,S2L,numelmasked);
    //    int * SignOut_s=CreateShort(SignOut, S2L, numelmasked);
    // Creating Projection Map and A Map that will be needed for calculation of rho map if equivolume flag up
    if (Param_LS->flag_EquiVolume) {
        ProjectionIndicesIn=ProjectingMapIndex(PhiIn, Dim, Shift, PixDim,L2S,S2L,numelmasked);
        ProjectionIndicesOut=ProjectingMapIndex(PhiOut, Dim, Shift, PixDim, L2S,S2L,numelmasked);
        AMap=AMapCalculation(PhiIn, PhiOut, Dim, Shift, PixDim, Param_LS->MaxDist,L2S,S2L,numelmasked);
    }
    else{
        AMap=new float[numelmasked];
        for (int i=0; i<numelmasked; i++) {
            AMap[i]=1;
        }
        ProjectionIndicesIn=ProjectingMapIndex(PhiIn_s, Dim, Shift, PixDim, L2S,S2L,numelmasked);
        ProjectionIndicesOut=ProjectingMapIndex(PhiOut_s, Dim, Shift, PixDim, L2S,S2L,numelmasked);
    }
    
//    SaveTmpResult_short<int>(ProjectionIndicesIn, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestProjection.nii.gz", TestToSave,L2S);
    // Initialise the final IsoEquiVolume
    // Loop over the different values of Alpha
    int numbLaminae=Param_LS->numbLaminae;
    float EpsCurv=Param_LS->EpsCurv;
    float WidthNB=Param_LS->WidthNB;
    float PropNBSusp=Param_LS->PropNBSusp;
    vector<int *> FinalSign;
    for (int l=1; l<numbLaminae; l++) {
        float Alpha=(float)l/(float)numbLaminae;
        cout<<"Doing equi for alpha "<< Alpha;
        // Initialise
        //        float * PhiAlphaObjective=InitialiseObjectiveLS(Alpha, AMap , PhiIn, PhiOut, Dim, Shift, PixDim,Mask);
        float * RhoMapToUse=RhoMap(AMap, ProjectionIndicesIn, ProjectionIndicesOut, PhiIn_s, PhiOut_s, Dim, Shift, PixDim, Alpha, L2S,S2L,numelmasked);
//        SaveTmpResult_short(PhiIn_s, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestOut.nii.gz", TestToSave,L2S);
        float * PhiAlphaObjective=InitialiseObjectiveLS(RhoMapToUse, PhiIn_s, PhiOut_s, numelmasked);
        delete [] RhoMapToUse;
        RhoMapToUse=NULL;
        
        float * PhiAlpha=CopyArray<float>(PhiIn_s,numelmasked); // Here we consider that we begin from PhiIn
        int * SignAlpha=CopyArray<int>(SignIn_s,numelmasked);
//        SaveTmpResult_short<float>(PhiAlpha, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestPhiAlpha.nii.gz", TestToSave,L2S);
//        SaveTmpResult_short(PhiOut_s, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestPhiOuts.nii.gz", TestToSave,L2S);
        bool * NarrowBand=NarrowBandDefine(PhiAlpha, Param_LS->WidthNB, numelmasked);
        //        SaveTmpResult_short<bool>(NarrowBand, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestOut.nii.gz", TestToSave,L2S);
        bool * NarrowBandSuspicious=NarrowBandDefine(PhiAlpha, Param_LS->WidthNB*Param_LS->PropNBSusp, numelmasked);
        float * ForceField=InitialiseForceField(PhiAlpha,PhiAlphaObjective,numelmasked,NarrowBand);
//        SaveTmpResult_short(PhiAlphaObjective, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestObjective.nii.gz", TestToSave, L2S);
        bool flag_change=1;
        int CountNotChanged=0;
        int IterationLS=0;
        while (CountNotChanged<Param_LS->MaxNC) { // Solving iteratively LevelSet evolution until contour has not changed for at leas MaxNC-1 times
            IterationLS++;
            if (100*(IterationLS/100)==IterationLS) {
//                SaveTmpResult_short<float>(PhiAlpha, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestOut100.nii.gz", TestToSave,L2S);
                cout<<"Saving after another 100 iterations";
            }
            //            int * Trans=new int[3];
            //            int Trans[3];
            //            Trans[0]=1;
            //            Trans[1]=0;
            //            Trans[2]=0;
            
//            float * TestTmp=GradientImage(PhiAlpha, 0, 1, Dim, Shift, PixDim, L2S, S2L, numelmasked);
            //            float * TestShifted=ShiftedVersion(PhiAlpha, Trans, Dim, Shift, L2S, S2L, numelmasked);
//            SaveTmpResult_short(TestTmp,  "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestShift.nii.gz", TestToSave, L2S);
            //            float * TestGrad=CurvatureCalculation_2(PhiAlpha, Dim, Shift, PixDim, L2S, S2L, numelmasked);
//            SaveTmpResult_short(PhiAlpha,  "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestTmp.nii.gz", TestToSave, L2S);
            flag_change=TotalUpdateLS(PhiAlpha, SignAlpha, NarrowBand, ForceField, Dim, Shift, PixDim, EpsCurv,L2S,S2L,numelmasked, TestToSave);
//            SaveTmpResult_short(PhiAlpha,  "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestOut.nii.gz", TestToSave, L2S);
            cout<<"Something have changed ? "<<flag_change<<endl;
            UpdateNarrowBand(NarrowBandSuspicious, PhiAlpha, WidthNB*PropNBSusp, numelmasked);
            bool flag_isnear=NearBorderNB(NarrowBand, NarrowBandSuspicious, numelmasked);
            //            bool flag_isnear=IsNearBorderNarrowBand(NarrowBandSuspicious, SignAlpha, Dim, Shift, PixDim, Mask);
            if (flag_isnear) {
                cout<<"Need to update NarrowBand"<<endl;
                UpdateNarrowBand(NarrowBand,PhiAlpha,WidthNB,numelmasked);
                UpdateNarrowBand(NarrowBandSuspicious,PhiAlpha,WidthNB*PropNBSusp,numelmasked);
            }
            UpdateForceField(PhiAlpha, ForceField, PhiAlphaObjective, NarrowBand, numelmasked);
//            SaveTmpResult_short(ForceField, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestFFOut.nii.gz", TestToSave,L2S);
            cout<<"FF updated...";
            if (flag_change==0) {
                CountNotChanged++;
            }
            else{
                CountNotChanged=0;
            }
        }
        delete [] PhiAlphaObjective;
        delete [] NarrowBand;
        delete [] NarrowBandSuspicious;
        delete [] ForceField;
        PhiAlphaObjective=NULL;
        NarrowBand=NULL;
        NarrowBandSuspicious=NULL;
        ForceField=NULL;
        FinalPhi.push_back(PhiAlpha);
        delete [] SignAlpha;
        SignAlpha=NULL;
        //        FinalSign.push_back(SignAlpha);
    }
//    SaveTmpResult_short<float>(FinalPhi, "/Users/Carole/Documents/PhD/TemporaryFiles/SABRE13/TestLS.nii.gz", TestToSave, L2S);
    return FinalPhi;
}

// Check if the region NarrowBand suspicious goes over the border of NarrowBand knowing that normally NarrowBand Suspicious should be completely included in NarrowBand. No need for Mask because info taken into account in the update of NarrowBand and NarrowBandSuspicious
bool NearBorderNB(bool * NarrowBand, bool * NarrowBandSuspicious, int numelmasked){
    bool flag_isnear=0;
    for (int i=0; i<numelmasked; i++) {
        if (NarrowBandSuspicious[i] && !NarrowBand[i]) {
            flag_isnear=1;
            break;
        }
    }
    return flag_isnear;
}

// Initialise DLS Array
DLS * InitialiseDLSArray(int * InitialStatus, float * InitialDistance, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    DLS * DLSInitial=new DLS[numel];
    for (int i=0; i<numel; i++) {
        DLS DLSPrepared;
        DLSPrepared.Distance=InitialDistance[i];
        DLSPrepared.Index=i;
        DLSPrepared.Status=InitialStatus[i];
        DLSInitial[i]=DLSPrepared;
    }
    return DLSInitial;
}


// Initialise a vector of DLS that only contain Status = 1;
vector<DLS *> InitialiseDLSVectorPtr(int * InitialStatus, float * InitialDistance, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    vector<DLS *> DLSInitial;
    int PotentialPb=0;
    for (int i=0; i<numel; i++) {
        if (InitialStatus[i]==1 || (InitialStatus[i]==2 && InitialDistance[i]<300)) {
            DLS * DLSPrepared=new DLS();
            DLSPrepared->Distance=InitialDistance[i];
            if (InitialDistance[i]==0) {
                PotentialPb++;
            }
            DLSPrepared->Index=i;
            DLSPrepared->Status=InitialStatus[i];
            DLSInitial.push_back(DLSPrepared);
        }
        
    }
    cout<<"Potential pb is "<<PotentialPb<<endl;
    cout<< "DLSInitial contains "<< DLSInitial.size()<<endl;
    return DLSInitial;
}

// Initialise a vector of DLS that only contain Status = 1;
vector<DLS> InitialiseDLSVector(int * InitialStatus, float * InitialDistance, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    vector<DLS> DLSInitial;
    for (int i=0; i<numel; i++) {
        if (InitialStatus[i]==1 || (InitialStatus[i]==2 && InitialDistance[i]<300)) {
            DLS DLSPrepared;
            DLSPrepared.Distance=InitialDistance[i];
            DLSPrepared.Index=i;
            DLSPrepared.Status=InitialStatus[i];
            DLSInitial.push_back(DLSPrepared);
        }
        
    }
    cout<< "DLSInitial contains "<< DLSInitial.size()<<endl;
    return DLSInitial;
}

// Initialise the ForceField array according to initial phi used (generally PhiIn) and the Objective function PhiObjective on the considered NarrowBand. Force Considered as 0 everywhere else.
float * InitialiseForceField(float * PhiAlpha, float * PhiObjective,int numelmasked, bool * NarrowBand){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * ForceFieldInit=new float[numelmasked];
    if (NarrowBand==NULL) {
        for (int i=0; i<numelmasked; i++) {
            ForceFieldInit[i]=PhiAlpha[i]-PhiObjective[i];
        }
    }
    else{
        for (int i=0; i<numelmasked; i++) {
            if (NarrowBand[i]) {
                ForceFieldInit[i]=PhiAlpha[i]-PhiObjective[i];
            }
            else{
                ForceFieldInit[i]=0;
            }
        }
    }
    return ForceFieldInit;
}

int * InitialiseStatusFromDistance(float * PhiIn, int * Dim, bool * Mask){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int * StatusInit=new int[numel];
    for (int n=0; n<numel; n++) {
        StatusInit[n]=2;
    }
    int CountZero=0;
    if (Mask==NULL) {
        for (int n=0; n<numel; n++) {
            if (PhiIn[n]<=1) {
                StatusInit[n]=0;
                CountZero++;
            }
        }
    }
    else{
        for (int n=0; n<numel; n++) {
            if (Mask[n]) {
                if (PhiIn[n]<=1) {
                    StatusInit[n]=0;
                    CountZero++;
                }
            }
        }
    }
    cout<<"Count Zero is "<<CountZero<<endl;
    return StatusInit;
}

// Initialise PhiIn and PhiOut

// Create SignFunction from binary segmentation. Only 1 and -1 values. -1 for inside the object and 1 outside
int * CreateSignFunction(bool * BinarySeg, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int * SignResult=new int[numel];
    for (int i=0; i<numel; i++) {
        SignResult[i]=1;
    }
    for (int i=0; i<numel; i++) {
        if (BinarySeg[i]) {
            SignResult[i]=-1;
        }
    }
    return SignResult;
}


// Check for any problem of crossing and correction between two binary volumes when one is supposed to be bigger than the other. The correction is done so that the mini is inside maxi : mini is changed, maxi is kept if correction needed
bool CheckAndCorrectCrossing(bool * SegMini, bool * SegMaxi, int * Dim){
    bool flag_Correction=0;
    int numel=Dim[0]*Dim[1]*Dim[2];
    int CountCorrections=0;
    for (int i=0; i<numel; i++) {
        if (SegMini[i]) {
            if (!SegMaxi[i]) {
                flag_Correction=1;
                SegMini[i]=0;
                CountCorrections++;
            }
        }
    }
    cout<<"Correction for crossing problem is"<<CountCorrections<<endl;
    return flag_Correction;
}


bool * CheckAndFillHoles(bool * SegToCheck, int * Dim, int * Shift){
    int * BoundingBoxIndices=FindBoundingBox(SegToCheck, Dim, Shift);
    //    bool flag_holes=0;
    // First create outside border for the considered boolean segmentation
    int numel=Dim[0]*Dim[1]*Dim[2];
    float * Border=new float[numel];
    for (int i=0; i<numel; i++) {
        Border[i]=0;
    }
    bool * ResultFilledHoles=CopyArray(SegToCheck, numel);
    for (int i=0; i<numel; i++) {
        if (SegToCheck[i]<0.5) {
            //                int * ListNeighboursToLook=Get6Neighbours(i, Dim,Shift);
            int ListNeighboursToLook[6];
            GetListNeighbours_bis(ListNeighboursToLook, i, Dim, Shift, 6);
            //            int * ListNeighboursToLook=GetListNeighbours(i, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (SegToCheck[ListNeighboursToLook[n]]>=0.5 || ListNeighboursToLook[n]==i) { // Enable to take border of image as part of border... Border if neighbour is on other side or if we are at limits of image that is given by the fact that the value in ListNeighbours is the considered index.
                    //                        Border[ListNeighboursToLook[n]]=1;
                    Border[i]=1;
                    break;
                    
                }
            }
            //            delete [] ListNeighboursToLook;
            //            ListNeighboursToLook=NULL;
        }
    }
    // From Border extraction create the component labeling to see if there is more than one connected component. If so, means that there are holes in the structure
    int * LabeledBorder=ComponentLabeling(Border, 26, Dim, Shift);
    int maxLabel=GetMaxLabel(LabeledBorder, numel);
    //    if (maxLabel>1) {
    //        flag_holes=1;
    //    }
    
    for (int l=0; l<maxLabel; l++) {
        bool * BorderLabelBool=CreateLesionBool(LabeledBorder, l+1, numel);
        if (! IsBoolOutsideBoundingBox(BorderLabelBool,BoundingBoxIndices,Dim)) {
            cout<<"filling in process....."<<endl;
            OROperationBool(BorderLabelBool, ResultFilledHoles, ResultFilledHoles, numel);
        }
        delete [] BorderLabelBool;
        BorderLabelBool=NULL;
    }
    return ResultFilledHoles;
}

bool IsBoolOutsideBoundingBox(bool * LesionBool, int * BoundingBox, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    bool * BoundingBoxBool=CreateBoolBoundingBox(BoundingBox,Dim );
    bool * OutsideBoundingBoxBool=OpposeBoolArray(BoundingBoxBool, numel);
    ANDOperationBool(OutsideBoundingBoxBool, LesionBool, OutsideBoundingBoxBool, numel);
    int NonZero=CountNonZero(OutsideBoundingBoxBool, numel);
    delete [] BoundingBoxBool;
    delete [] OutsideBoundingBoxBool;
    BoundingBoxBool=NULL;
    OutsideBoundingBoxBool=NULL;
    if (NonZero>0) {
        return 1;
    }
    return 0;
}

bool * CreateBoolBoundingBox(int * BoundingBox, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    bool * ResultBoundedBox=new bool[numel];
    for (int i=0; i<numel; i++) {
        ResultBoundedBox[i]=0;
    }
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    for (int x=0; x<Dim[0]; x++) {
        if (x>=BoundingBox[0]&&x<=BoundingBox[1]) {
            for (int y=0; y<Dim[1]; y++) {
                if (y>=BoundingBox[2]&&y<=BoundingBox[3]) {
                    for (int z=0; z<Dim[2]; z++) {
                        if (z>=BoundingBox[4] && z<=BoundingBox[5]) {
                            ResultBoundedBox[x*Shift[0]+y*Shift[1]+z*Shift[2]]=1;
                        }
                    }
                }
                
            }
        }
    }
    return ResultBoundedBox;
}

int * ListCoordinatesBoolSeg(bool * LesionBool, int * Dim, int * Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int numbActive=CountNonZero(LesionBool, numel);
    int * ResultsCoordinates=new int[numbActive*3];
    int CoordResult[3];
    int j=0;
    for (int i=0;i<numel;i++){
        if(LesionBool[i]){
            CorrespondingCoordinates_bis(CoordResult, i, Dim, Shift);
            for(int d=0;d<3;d++){
                ResultsCoordinates[j*3+d]=CoordResult[d];
            }
            j++;
        }
    }
    return ResultsCoordinates;
}

float * ListCoordinatesTransformed (int * ListCoordinates, int numbActive, float * PixDim){
    float * ListTransformed=new float[3*numbActive];
    int TotalNumb=3*numbActive;
    for(int i=0;i<TotalNumb;i++){
        ListTransformed[i]=ListCoordinates[i];
    }
    for (int d=0;d<3;d++){
        float WeightDist=PixDim[d];
        for(int i=0;i<numbActive;i++){
            ListTransformed[i*3+d]*=WeightDist;
        }
    }
    return ListTransformed;
}

float * DemeanListCoordinates(float * ListCoordinates, int numbActive, int numbDir, log_level_t LOG_VERB){
    float * DemeanList = new float[numbDir * numbActive];
    float Mean[3];
    if (numbActive == 0){
        cout << "No active index to demean"<< endl;
        return DemeanList;
    }
    for(int d=0;d<3;d++){
        Mean[d]=0;
    }
    for(int i=0;i<numbActive;i++){
        for(int d=0;d<numbDir;d++){
            Mean[d] +=ListCoordinates[3*i+d];

        }
    }
    for(int d=0;d<numbDir;d++){
        Mean[d]/=1.0*numbActive;
    }
    for (int i=0; i<numbActive; i++){
        for(int d=0; d<numbDir; d++){
            DemeanList[3*i+d] = ListCoordinates[3*i+d]-Mean[d];
            if (LOG_VERB==LOG_DEBUG){
                cout << DemeanList[3*i+d]<< " ";
            }
        }
        if (LOG_VERB==LOG_DEBUG){
            cout << endl;
        }
    }
    return DemeanList;
}



int * FindBoundingBox(bool * SegToCheck, int * Dim , int * Shift){
    //    bool * BorderSegCheck=CreateBorderFromBool(SegToCheck, Dim, Shift);
    int numel = Dim[0]*Dim[1]*Dim[2];
    int * BorderInt=TranscribeArray<bool, int>(SegToCheck, numel);
    vector<int> BorderIndices=GetIndicesBorderLesion(BorderInt, 1, Dim, Shift);
    //    Initialisation of bounding box
    int numbBorder=BorderIndices.size();
    int * ResultBoundingBox=new int[6];
    for (int d=0; d<3; d++) {
        ResultBoundingBox[2*d]=Dim[d];
        ResultBoundingBox[2*d+1]=0;
    }
    for (int i=0; i<numbBorder; i++) {
        int TmpCoordinates[3];
        CorrespondingCoordinates_bis(TmpCoordinates, BorderIndices[i], Dim, Shift);
        for (int d=0; d<3; d++) {
            if (TmpCoordinates[d]>ResultBoundingBox[2*d+1]) {
                ResultBoundingBox[2*d+1]=TmpCoordinates[d];
            }
            if (TmpCoordinates[d]<ResultBoundingBox[2*d]) {
                ResultBoundingBox[2*d]=TmpCoordinates[d];
            }
        }
    }
    delete [] BorderInt;
    BorderInt=NULL;
    return ResultBoundingBox;
}

// Return as a boolean the check for the existence of holes in the structure. A hole is present if the border of the binary object if for each connected component of the binary object, the border is not connected // TO BE CHANGED : At the moment consider that the binary object is connected...
bool CheckForHoles(bool * SegToCheck, int * Dim, int * Shift){
    bool flag_holes=0;
    // First create outside border for the considered boolean segmentation
    int numel=Dim[0]*Dim[1]*Dim[2];
    float * Border=new float[numel];
    for (int i=0; i<numel; i++) {
        Border[i]=0;
    }
    for (int i=0; i<numel; i++) {
        if (SegToCheck[i]<0.5) {
            //                int * ListNeighboursToLook=Get6Neighbours(i, Dim,Shift);
            int ListNeighboursToLook[6];
            GetListNeighbours_bis(ListNeighboursToLook, i, Dim, Shift, 6);
            //            int * ListNeighboursToLook=GetListNeighbours(i, Dim, Shift, 6);
            for (int n=0; n<6; n++) {
                if (SegToCheck[ListNeighboursToLook[n]]>=0.5 || ListNeighboursToLook[n]==i) { // Enable to take border of image as part of border... Border if neighbour is on other side or if we are at limits of image that is given by the fact that the value in ListNeighbours is the considered index.
                    //                        Border[ListNeighboursToLook[n]]=1;
                    Border[i]=1;
                    break;
                    
                }
            }
            //            delete [] ListNeighboursToLook;
            //            ListNeighboursToLook=NULL;
        }
    }
    // From Border extraction create the component labeling to see if there is more than one connected component. If so, means that there are holes in the structure
    int * LabeledBorder=ComponentLabeling(Border, 26, Dim, Shift);
    int maxLabel=GetMaxLabel(LabeledBorder, numel);
    if (maxLabel>1) {
        flag_holes=1;
    }
    return flag_holes;
}

// Return the bool array of in between portion of interest when building the level set region of interest
bool * CreateMask(bool * SegMini, bool * SegMaxi, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    bool * Mask=new bool[numel];
    for (int i=0; i<numel; i++) {
        if (!SegMini[i]&&SegMaxi[i]) { // Inside outer border but outside inner border
            Mask[i]=1;
        }
        else{
            Mask[i]=0;
        }
    }
    return Mask;
}
// Create Zone of Possible for NarrowBand in between PhiIn and PhiOut // mask of possible Used to constrain further narrow bands
// Initialise Objective PhiD
// Initialise Evolving result phi
// Initialise Sign
// Initialise first NarrowBand
// UpdateCurrentPhi
// if needed update NarrowBand
// Update Force Field
//


// Recursive Geodesic neighborhood calculation given the 3D dimension, the corresponding shift
vector<int > GeodesicNeighborhood(int Index, int TypeNeighborhood, bool* Criterion, int LengthNeighborhood,int *Dim,int * Shift,int * L2S, int * S2L, int numelmasked){
    vector<int> GeodesicNeighbours;
    if (LengthNeighborhood<=1) {
        int * ListNeighbours=GetListNeighbours(S2L[Index], Dim, Shift, TypeNeighborhood);
        for (int n=0; n<TypeNeighborhood; n++) {
            if (ListNeighbours[n]!=S2L[Index] && Criterion[L2S[ListNeighbours[n]]]) {
                GeodesicNeighbours.push_back(L2S[ListNeighbours[n]]);
            }
        }
        delete [] ListNeighbours;
        ListNeighbours=NULL;
    }
    else{
        vector<int> VecTmpRecurs=GeodesicNeighborhood(Index,TypeNeighborhood,Criterion,LengthNeighborhood-1,Dim,Shift,L2S,S2L,numelmasked);
        int numbTmp=VecTmpRecurs.size();
        int ListNeighbours[26];
        GetListNeighbours_bis(ListNeighbours, S2L[Index], Dim, Shift, 26);
        //        int * ListNeighbours=GetListNeighbours(S2L[Index], Dim, Shift, 26);
        for (int tp=0; tp<numbTmp; tp++) {
            int * ListNeighTp=GetListNeighbours(S2L[VecTmpRecurs[tp]], Dim, Shift, TypeNeighborhood);
            if (IsIn(S2L[VecTmpRecurs[tp]],ListNeighbours,26) && Criterion[VecTmpRecurs[tp]] && VecTmpRecurs[tp]!=Index) {
                GeodesicNeighbours.push_back(VecTmpRecurs[tp]);
            }
            for (int n=0; n<TypeNeighborhood; n++) {
                if (L2S[ListNeighTp[n]]!=VecTmpRecurs[tp]) {
                    if (IsIn(ListNeighTp[n],ListNeighbours,26) && L2S[ListNeighTp[n]]!=Index && Criterion[L2S[ListNeighTp[n]]]) {
                        GeodesicNeighbours.push_back(L2S[ListNeighTp[n]]);
                    }
                }
            }
            delete [] ListNeighTp;
            ListNeighTp=NULL;
        }
        //        delete [] ListNeighbours;
        //        ListNeighbours=NULL;
    }
    return GeodesicNeighbours;
}

// Test to check if an index is in a list of indices given the length of this list
bool IsIn(int Index, int * ListIndices, int LengthList){
    for (int i=0; i<LengthList; i++) {
        if (ListIndices[i]==Index) {
            return 1;
        }
    }
    return 0;
}

bool IsIn(int Index, vector<int> ListIndices){
    int LengthList=ListIndices.size();
    if (LengthList==0) {
        return 1;
    }
    for (int i=0; i<LengthList; i++) {
        if (ListIndices[i]==Index) {
            return 1;
        }
    }
    return 0;
}


// Topological number calculation
int TopologicalNumber(int Index, bool * Criterion, int * Dim, int * Shift, int TypeNeighborhood, int * L2S, int * S2L, int numelmasked){
    // First obtain the List of geodesic neighbours
    int LengthNeighborhood=0;
    switch (TypeNeighborhood) {
            case 6:
            LengthNeighborhood=2;
            break;
            case 18:
            LengthNeighborhood=2;
            break;
            case 26:
            LengthNeighborhood=1;
            break;
        default:
            LengthNeighborhood=2;
            break;
    }
    vector<int> GeodesicIndices=GeodesicNeighborhood(Index, TypeNeighborhood, Criterion, LengthNeighborhood, Dim, Shift,L2S,S2L,numelmasked);
    vector<int > RefinedGeodesic;
    int numbGeod=GeodesicIndices.size();
    for (int g=0; g<numbGeod; g++) {
        if (!IsIn(GeodesicIndices[g], RefinedGeodesic)) {
            RefinedGeodesic.push_back(GeodesicIndices[g]);
        }
    }
    // Create the corresponding int * of Label of Coordinates in the frame where we can then calculate the connected components
    float * ImageForConnectedGeodesicElements=new float[27];
    for(int i=0;i<27;i++){
        ImageForConnectedGeodesicElements[i]=0;
    }
    int CoordinatesIndex[3];
    CorrespondingCoordinates_bis(CoordinatesIndex, S2L[Index], Dim, Shift);
    //    int * CoordinatesIndex=CorrespondingCoordinates(S2L[Index], Dim, Shift);
    int numbFinGeod=RefinedGeodesic.size();
    //    int * MiniShift=new int[3];
    int MiniShift[3];
    MiniShift[0]=1;
    MiniShift[1]=3;
    MiniShift[2]=9;
    //    int * MiniDim=new int[3];
    int MiniDim[3];
    MiniDim[0]=3;
    MiniDim[1]=3;
    MiniDim[2]=3;
    
    for (int i=0; i<numbFinGeod; i++) {
        int Coordinates[3];
        CorrespondingCoordinates_bis(Coordinates, S2L[RefinedGeodesic[i]], Dim, Shift);
        //        int * Coordinates=CorrespondingCoordinates(S2L[RefinedGeodesic[i]], Dim, Shift);
        int IndexMiniGrid=0;
        for (int d=0; d<3; d++) {
            IndexMiniGrid+=(Coordinates[d]-CoordinatesIndex[d]+1)*MiniShift[d];
        }
        //        delete [] Coordinates;
        //        Coordinates=NULL;
        ImageForConnectedGeodesicElements[IndexMiniGrid]=1;
    }
    //    delete [] CoordinatesIndex;
    //    CoordinatesIndex=NULL;
    int * LabelingGeodesic=ComponentLabeling(ImageForConnectedGeodesicElements, TypeNeighborhood,MiniDim,MiniShift,0.5);
    int maxLabel=GetMaxLabel(LabelingGeodesic, 27);
    delete [] LabelingGeodesic;
    LabelingGeodesic=NULL;
    return maxLabel;
}

// Returns the bool array of size numel that gives the criterion in or criterion out used for the calculation of topological numbers
bool * CreateCriterionFromSign(int * Sign, int TypeCrit, int * L2S, int * S2L,int numelmasked){
    bool * CriterionResult=new bool [numelmasked];
    for (int i=0; i<numelmasked; i++) {
        CriterionResult[i]=0;
    }
    if (TypeCrit==0) {
        return CriterionResult;
    }
    TypeCrit=(int)(TypeCrit/abs(TypeCrit));
    for (int i=0; i<numelmasked; i++) {
        if (Sign[i]==TypeCrit) {
            CriterionResult[i]=1;
        }
    }
    return CriterionResult;
}

// Compute TotalUpdate with topology preserving knowing current ForceField, current Phi and current NarrowBand as well as current sign function
bool TotalUpdateLS(float * CurrentPhi, int * Sign, bool * NarrowBand, float * ForceField, int * Dim, int * Shift, float * PixDim, float EpsCurv,int * L2S, int * S2L,int numelmasked, nifti_image * TestToSave){
    bool flag_change=0;
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * PossibleUpdate=UpdateMatrix(ForceField,NarrowBand,CurrentPhi,Dim,Shift,PixDim,EpsCurv,L2S,S2L,numelmasked);
    cout<<"Matrix updated...";
    
    bool * CriterionY=CreateCriterionFromSign(Sign,-1,L2S,S2L,numelmasked);
    bool * CriterionN=CreateCriterionFromSign(Sign,1,L2S,S2L,numelmasked);
    int CountPossibleChange=0;
    for(int i=0;i<numelmasked;i++){
        if (NarrowBand[i]) {
            if (PossibleUpdate[i]*CurrentPhi[i]>0 || PossibleUpdate[i]*CurrentPhi[i]<=0) {// Meaning that they are of same sign
                if (CurrentPhi[i]-PossibleUpdate[i]!=0) {
                    //                        flag_change=1;
                }
                CurrentPhi[i]=PossibleUpdate[i];
                if (PossibleUpdate[i]*CurrentPhi[i]<=0) {
                    Sign[i]*=-1;
                    CountPossibleChange++;
                    flag_change=1;
                }
                
            }
            else{ // Meaning that there is a possible change in border
                CountPossibleChange++;
                int TNP=TopologicalNumber(i, CriterionY, Dim, Shift, 6,L2S,S2L,numelmasked);
                int TNN=TopologicalNumber(i, CriterionN, Dim, Shift, 26,L2S,S2L,numelmasked);
                if (TNP==TNN&&TNP==1) { // Simple point, update done
                    Sign[i]*=-1;
                    CurrentPhi[i]=PossibleUpdate[i];
                    flag_change=1;
                }
                else{ // Change in sign not accepted, not simple point
                    CurrentPhi[i]=-0.0001*Sign[i];
                }
            }
        }
    }
    
    cout <<"Possible border change is "<<CountPossibleChange;
    delete [] PossibleUpdate;
    delete [] CriterionN;
    delete [] CriterionY;
    PossibleUpdate=NULL;
    CriterionY=NULL;
    CriterionN=NULL;
    return flag_change;
}

// Check if Border/LevelSet 0 is in NarrowBandSuspicious and then to know if reupdate of distance is needed
bool IsNearBorderNarrowBand(bool * NarrowBandSuspicious, int * Sign, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked){
    int numel=Dim[0]*Dim[1]*Dim[2];
    float * TmpSign=new float[numel];
    for (int i=0; i<numelmasked; i++) {
        TmpSign[i]=Sign[i];
    }
    bool flag_IsNear=0;
    for (int d=0; d<3; d++) {
        for (int t=-1; t<=1; t++) {
            float * TmpGrad=GradientImage(TmpSign, d, 1, Dim, Shift, PixDim,L2S,S2L,numelmasked);
            for (int i=0; i<numelmasked; i++) {
                if (NarrowBandSuspicious[i]) {
                    if (TmpGrad[i]!=0) {
                        flag_IsNear=1;
                        break;
                    }
                }
            }
            delete [] TmpGrad;
            TmpGrad=NULL;
            if (flag_IsNear) {
                break;
            }
        }
        if (flag_IsNear) {
            break;
        }
    }
    delete [] TmpSign;
    TmpSign=NULL;
    return flag_IsNear;
}

// Update ForceField used for LevelSet given NarrowBand
void UpdateForceField(float * CurrentPhi, float *ForceField, float * InitialObjective, bool * NarrowBand, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    for (int i=0; i<numelmasked; i++) {
        if (NarrowBand[i]) {
            ForceField[i]=CurrentPhi[i]-InitialObjective[i];
        }
    }
    return;
}


// Calculation of UpdateMatrix given ForceField F, boolean for NarrowBand, float for CurrentDistance
float * UpdateMatrix(float * ForceField, bool * NarrowBand, float * CurrentPhi, int * Dim,int * Shift,float * PixDim, float EpsCurv, int * L2S, int * S2L, int numelmasked){
    int numel = Dim[0]*Dim[1]*Dim[2];
    float * UpdateResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        UpdateResult[i]=CurrentPhi[i];
    }
    bool * BorderNarrowBand=CreateBorderFromBool_L2S(NarrowBand, Dim, Shift, L2S, S2L, numelmasked);
    float * NormedP=NormNormedGradient(CurrentPhi, 1, Dim, Shift, PixDim,L2S,S2L,numelmasked);
    float * NormedM=NormNormedGradient(CurrentPhi, -1, Dim, Shift, PixDim,L2S,S2L,numelmasked);
    float * Curvature=NULL;
    float * NormedZ=NULL;
    if (EpsCurv!=0) {
        Curvature=CurvatureCalculation_2(CurrentPhi, Dim, Shift, PixDim,L2S,S2L,numelmasked);
        bool CheckNan=CheckContainsNaN(Curvature, numelmasked);
        if (CheckNan) {
            cout<<"Stop There.."<<endl;
            cout<< CheckNan << "NaN for curvature";
        }
        
    }
    else{
        Curvature=new float[numelmasked];
        for (int i=0; i<numelmasked; i++) {
            Curvature[i]=0;
        }
    }
    if (EpsCurv!=0) { // If we have some smoothness constraint over the epsilon
        NormedZ=NormNormedGradient(CurrentPhi, 0, Dim, Shift, PixDim,L2S,S2L,numelmasked);
    }
    else{
        NormedZ=new float[numelmasked];
        for (int i=0; i<numel; i++) {
            NormedZ[i]=0;
        }
    }
    float MaxUsed=0;
    float MinUsed=0;
    int CountChanges=0;
    for(int i=0;i<numelmasked;i++){
        if (NarrowBand[i] && BorderNarrowBand[i]==0) { // Check that we are on NarrowBand but not on NarrowBand border
            if (ForceField[i]!=ForceField[i]) {
                cout<< "Pb ForceField NaN";
            }
            if (NormedP[i]!=NormedP[i]) {
                cout << "Pb NormedP NaN";
            }
            if (NormedM[i]!=NormedM[i]) {
                cout<<"Pb NormedM NaN";
            }
            if (NormedZ[i]!=NormedZ[i]) {
                cout<<"Pb NormedZ NaN";
            }
            if (Curvature[i]!=Curvature[i]) {
                cout<<"Pb Curvature NaN";
            }
            MaxUsed=ForceField[i]>0?ForceField[i]:0;
            MinUsed=ForceField[i]<0?ForceField[i]:0;
            UpdateResult[i]-=MaxUsed*NormedP[i];
            UpdateResult[i]-=MinUsed*NormedM[i];
            UpdateResult[i]+=EpsCurv*Curvature[i]*NormedZ[i];
            if (MaxUsed*NormedP[i]>0||MinUsed*NormedM[i]>0||Curvature[i]*NormedZ[i]>0) {
                CountChanges++;
                //                cout<<"Something changes...";
            }
        }
    }
    cout<<CountChanges<<" changes occurred";
    delete [] NormedP;
    delete [] NormedM;
    delete [] Curvature;
    delete [] NormedZ;
    delete [] BorderNarrowBand;
    NormedZ=NULL;
    NormedP=NULL;
    NormedM=NULL;
    Curvature=NULL;
    BorderNarrowBand=NULL;
    return UpdateResult;
}

// Update Narrow Band when phi has been modified
void UpdateNarrowBand(bool * NarrowBand, float * CurrentPhi,float WidthNB, int numelmasked){
    
    for (int i=0; i<numelmasked; i++) {
        if (fabs(CurrentPhi[i])<WidthNB && NarrowBand[i]==0) {
            NarrowBand[i]=1;
        }
        else if(fabs(CurrentPhi[i])>=WidthNB && NarrowBand[i]==1){
            NarrowBand[i]=0;
        }
    }
}


// Define bool that defines Narrow-Band to treat given the distance Phi and the width of the narrow band
bool * NarrowBandDefine(float * CurrentPhi, float WidthNB, int numelmasked){
    bool * NarrowBandResult=new bool[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        if (fabs(CurrentPhi[i])<WidthNB) {
            NarrowBandResult[i]=1;
        }
        else{
            NarrowBandResult[i]=0;
        }
    }
    return NarrowBandResult;
}




// WARNING : NEED for CLOSED Surfaces to apply the level set method

// FOLLOWING FOR FAST MARCHING FOR DISTANCE

// Given border, initialise the close region and the faraway region to get the State region to use as initialisation, the State to initialise is given so that value at border is 0 and something else otherwise
void InitialiseState(int * StateToInitialise, float * DistanceInitialise, int * Dim,int *Shift, float * PixDim, bool * Mask){
    // Initialisation so that value is 0 at border and 2 everywhere else according to the classification 0 for alive fixed, 1 for close and 2 for faraway
    int numel=Dim[0]*Dim[1]*Dim[2];
    for (int i=0; i<numel; i++) {
        if(StateToInitialise[i]!=0){
            StateToInitialise[i]=2;
            DistanceInitialise[i]=0;
        }
        else{
            DistanceInitialise[i]=0;
        }
    }
    int CountZero=0;
    int CountRestate=0;
    // Then define the close zone (all elements that belong to the 6th neighborhood of the border) and encode the number of neighbours to the considered voxels
    if (Mask!=NULL) {
        for (int i=0; i<numel; i++) {
            if (StateToInitialise[i]==0 && Mask[i]) {
                int ListNeighbours[6];
                GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
                //                int * ListNeighbours=GetListNeighbours(i, Dim, Shift, 6);
                for (int n=0; n<6; n++) {
                    if (StateToInitialise[ListNeighbours[n]]>0 && Mask[ListNeighbours[n]]) {
                        DistanceInitialise[ListNeighbours[n]]+=(n+1)*10^(n/2);
                        StateToInitialise[ListNeighbours[n]]=1; // Redundant but state close is truly done then
                    }
                }
            }
        }
        //        int * ShiftRecode=new int[3];
        int ShiftRecode[3];
        ShiftRecode[0]=1;
        ShiftRecode[1]=10;
        ShiftRecode[2]=100;
        // Correct for potential holes in border
        for (int i=0; i<numel; i++) {
            if(StateToInitialise[i]>0 && Mask[i]){
                if (DistanceInitialise[i]==222) {
                    DistanceInitialise[i]=0;
                    StateToInitialise[i]=0;
                }
                RecodeDistance(DistanceInitialise[i],PixDim,Dim,ShiftRecode);
            }
        }
        //        delete [] ShiftRecode;
        //        ShiftRecode=NULL;
        // After reinitialisation of true distance, for all elements not in border and not in close, set the distance at 300 instead of 0
        CountRestate=0;
        for (int i=0; i<numel; i++) {
            if (DistanceInitialise[i]==0 && StateToInitialise[i]==2) {
                DistanceInitialise[i]=MaxDistanceValue;
            }
            if (DistanceInitialise[i]==0 && StateToInitialise[i]==1) {
                DistanceInitialise[i]=MaxDistanceValue;
                StateToInitialise[i]=2;
                CountRestate++;
            }
            if (!Mask[i]) {
                DistanceInitialise[i]=MaxDistanceValue;
                StateToInitialise[i]=2;
            }
        }
        CountZero=0;
        for (int i=0; i<numel; i++) {
            if (StateToInitialise[i]==0) {
                CountZero++;
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (StateToInitialise[i]==0) {
                int ListNeighbours[6];
                GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
                //                int * ListNeighbours=GetListNeighbours(i, Dim, Shift, 6);
                for (int n=0; n<6; n++) {
                    if (StateToInitialise[ListNeighbours[n]]>0) {
                        DistanceInitialise[ListNeighbours[n]]+=(n+1)*10^(n/2);
                        StateToInitialise[ListNeighbours[n]]=1; // Redundant but state close is truly done then
                    }
                }
            }
        }
        //        int * ShiftRecode=new int[3];
        int ShiftRecode[3];
        ShiftRecode[0]=1;
        ShiftRecode[1]=10;
        ShiftRecode[2]=100;
        // Correct for potential holes in border
        for (int i=0; i<numel; i++) {
            if (DistanceInitialise[i]==222) {
                DistanceInitialise[i]=0;
                StateToInitialise[i]=0;
            }
            RecodeDistance(DistanceInitialise[i],PixDim,Dim,ShiftRecode);
        }
        //        delete [] ShiftRecode;
        //        ShiftRecode=NULL;
        // After reinitialisation of true distance, for all elements not in border and not in close, set the distance at 300 instead of 0
        CountRestate=0;
        for (int i=0; i<numel; i++) {
            if (DistanceInitialise[i]==0 && StateToInitialise[i]==2) {
                DistanceInitialise[i]=MaxDistanceValue;
            }
            if (DistanceInitialise[i]==0 && StateToInitialise[i]==1) {
                DistanceInitialise[i]=MaxDistanceValue;
                StateToInitialise[i]=2;
                CountRestate++;
            }
        }
        CountZero=0;
        for (int i=0; i<numel; i++) {
            if (StateToInitialise[i]==0) {
                CountZero++;
            }
        }
    }
    cout<<"Count Zero is "<<CountZero<<" and CountRestate is "<<CountRestate<<endl;
}

// Redefine distance according to given code
void RecodeDistance(float & ToRecode, float * PixDim,int * Dim, int * ShiftRecode){
    int CorrespondingCode[3];
    int ToRecodeToUse=(int)ToRecode;
    CorrespondingCoordinates_bis(CorrespondingCode, ToRecodeToUse, Dim, ShiftRecode);
    //    int * CorrespondingCode=CorrespondingCoordinates(ToRecode, Dim, ShiftRecode);
    float Distance=0;
    int Count1=0;
    for (int d=0; d<3; d++) {
        if (CorrespondingCode[d]==1) {
            Distance+=pow_int(PixDim[d], 2);
            Count1++;
        }
    }
    if (Count1>1) {
        ToRecode=sqrtf(Distance)/2;
    }
    else{
        ToRecode=sqrt(Distance);
    }
    //    delete [] CorrespondingCode;
    //    CorrespondingCode=NULL;
    return;
}


void MaxHeapify(DLS * DLSArray,int i,int n)
{
    int l,r,lr;
    //    float t;
    l=2*i+1;
    r=2*i+2;
    if((l<=n)&&(DLSArray[l].Distance>DLSArray[i].Distance))lr=l;
    else lr=i;
    if((r<=n)&&(DLSArray[r].Distance>DLSArray[lr].Distance))lr=r;
    if(lr!=i)
    {
        DLS TmpDLS=DLSArray[i].CopyDLS();
        DLSArray[i].Distance=DLSArray[lr].Distance;
        DLSArray[i].Index=DLSArray[lr].Index;
        DLSArray[i].Status=DLSArray[lr].Status;
        
        DLSArray[lr].Distance=TmpDLS.Distance;
        DLSArray[lr].Index=TmpDLS.Index;
        DLSArray[lr].Status=TmpDLS.Status;
        MaxHeapify(DLSArray,lr,n);
    }
}

void MaxHeapify( vector<DLS> & DLSVector,int i,int n)
{
    int l,r,lr;
    //    float t;
    l=2*i+1;
    r=2*i+2;
    if((l<=n)&&(DLSVector[l].Distance>DLSVector[i].Distance))lr=l;
    else lr=i;
    if((r<=n)&&(DLSVector[r].Distance>DLSVector[lr].Distance))lr=r;
    if(lr!=i)
    {
        DLS TmpDLS=DLSVector[i].CopyDLS();
        DLSVector[i].Distance=DLSVector[lr].Distance;
        DLSVector[i].Index=DLSVector[lr].Index;
        DLSVector[i].Status=DLSVector[lr].Status;
        
        DLSVector[lr].Distance=TmpDLS.Distance;
        DLSVector[lr].Index=TmpDLS.Index;
        DLSVector[lr].Status=TmpDLS.Status;
        MaxHeapify(DLSVector,lr,n);
    }
}

void MaxHeapify( vector<DLS *> & DLSVector,int i,int n)
{
    int l,r,lr;
    //    float t;
    l=2*i+1;
    r=2*i+2;
    if((l<=n)&&(DLSVector[l]->Distance>DLSVector[i]->Distance))lr=l;
    else lr=i;
    if((r<=n)&&(DLSVector[r]->Distance>DLSVector[lr]->Distance))lr=r;
    if(lr!=i)
    {
        DLS * TmpDLS=DLSVector[i]->CopyDLS_ptr();
        DLSVector[i]->Distance=DLSVector[lr]->Distance;
        DLSVector[i]->Index=DLSVector[lr]->Index;
        DLSVector[i]->Status=DLSVector[lr]->Status;
        
        DLSVector[lr]->Distance=TmpDLS->Distance;
        DLSVector[lr]->Index=TmpDLS->Index;
        DLSVector[lr]->Status=TmpDLS->Status;
        
        delete TmpDLS;
        TmpDLS=NULL;
        
        MaxHeapify(DLSVector,lr,n);
    }
}

void BuildMaxHeap(DLS * DLSArray,int n)
{
    int i;
    for(i=(n/2);i>=0;i--)
    MaxHeapify(DLSArray,i,n);
}

void BuildMaxHeap(vector<DLS> & DLSVector,int n)
{
    int i;
    for(i=(n/2);i>=0;i--)
    MaxHeapify(DLSVector,i,n);
}

void BuildMaxHeap(vector<DLS *> & DLSVector,int n)
{
    int i;
    for(i=(n/2);i>=0;i--)
    MaxHeapify(DLSVector,i,n);
}

void HeapSort(DLS * DLSArray,int n)
{
    int i;
    BuildMaxHeap(DLSArray,n);
    for(i=n;i>0;i--)
    {
        DLS TmpDLS=DLSArray[0].CopyDLS();
        DLSArray[0].Distance=DLSArray[i].Distance;
        DLSArray[0].Index=DLSArray[i].Index;
        DLSArray[0].Status=DLSArray[i].Status;
        
        DLSArray[i].Distance=TmpDLS.Distance;
        DLSArray[i].Index=TmpDLS.Index;
        DLSArray[i].Status=TmpDLS.Status;
        n--;
        MaxHeapify(DLSArray,0,n);
    }
}


void HeapSort(vector<DLS> & DLSVector,int n)
{
    int i;
    BuildMaxHeap(DLSVector,n);
    for(i=n;i>0;i--)
    {
        DLS TmpDLS=DLSVector[0].CopyDLS();
        DLSVector[0].Distance=DLSVector[i].Distance;
        DLSVector[0].Index=DLSVector[i].Index;
        DLSVector[0].Status=DLSVector[i].Status;
        
        DLSVector[i].Distance=TmpDLS.Distance;
        DLSVector[i].Index=TmpDLS.Index;
        DLSVector[i].Status=TmpDLS.Status;
        n--;
        MaxHeapify(DLSVector,0,n);
    }
}


void HeapSort(vector<DLS *> & DLSVector,int n)
{
    int i;
    BuildMaxHeap(DLSVector,n);
    for(i=n;i>0;i--)
    {
        DLS * TmpDLS=DLSVector[0]->CopyDLS_ptr();
        DLSVector[0]->Distance=DLSVector[i]->Distance;
        DLSVector[0]->Index=DLSVector[i]->Index;
        DLSVector[0]->Status=DLSVector[i]->Status;
        
        DLSVector[i]->Distance=TmpDLS->Distance;
        DLSVector[i]->Index=TmpDLS->Index;
        DLSVector[i]->Status=TmpDLS->Status;
        
        delete TmpDLS;
        TmpDLS=NULL;
        n--;
        MaxHeapify(DLSVector,0,n);
    }
}
// Use array of structure on which to apply heap sorting structure will contain the current value of distance, the current state and the corresponding index. The heap sort will always be done on the distance value, while updating the distance will be done on the distance value


// Given the initial state region, initialise the distance array to use afterwards in the Fast marching

// Determines the distance to border with fast marching using the int * State (for the settled / close / faraway definition)
void IterFastMarchingPtr(int * Status, float * DistanceFinal, int * Dim, int * Shift, float * PixDim, int & Iteration, bool * Mask){
    
    vector<DLS * > DLSVector=InitialiseDLSVectorPtr(Status, DistanceFinal, Dim);
    int sizeDLS=DLSVector.size();
    HeapSort(DLSVector, sizeDLS-1);
    // First check if there is something to do...
    bool flag_todo=1;
    while (flag_todo) {
        
        int numel=Dim[0]*Dim[1]*Dim[2];
        if (Mask ==NULL) {
            flag_todo=0;
            for (int i=0; i<numel; i++) {
                if (Status[i]>0) {
                    flag_todo=1;
                    break;
                }
            }
        }
        else{
            flag_todo=0;
            for (int i=0; i<numel; i++) {
                if (Mask[i]) {
                    if (Status[i]>0) {
                        flag_todo=1;
                        break;
                    }
                }
                
            }
        }
        if (30000*(Iteration/30000)==Iteration) {
            flag_todo=0;
        }
        
        if (!flag_todo) { // If there is nothing to do because all have been treated, go out !
            if (DLSVector.size()>0) {
                int DLSSize=DLSVector.size();
                for (int i=0; i<DLSSize; i++) {
                    delete DLSVector[i];
                    DLSVector[i]=NULL;
                }
                DLSVector.clear();
            }
            return;
        }
        // Then heap sort DLSArray
        int sizeDLSVector=DLSVector.size();
        //    HeapSort(DLSVector, sizeDLSVector-1);
        // Find element with smallest distance in Close status
        int numbToDelete=0;
        for(int s=0;s<sizeDLSVector;s++){
            if (DLSVector[s]->Distance>DistanceFinal[DLSVector[s]->Index]) {
                numbToDelete++;
            }
            else{
                break;
            }
        }
        //        cout<< numbToDelete<<"to delete"<<endl;
        // We delete in vector all elements for which DLS value is not appropriate and should be deleted.
        for (int d=0; d<numbToDelete; d++) {
            delete DLSVector[0];
            DLSVector[0]=NULL;
            DLSVector.erase(DLSVector.begin());
        }
        int SmallestIndex=DLSVector[0]->Index;
        //    for (int i=0; i<numel; i++) {
        //        if (DLSVector[i].Status==1) {
        //            SmallestIndex=DLSVector[i].Index;
        //            break;
        //        }
        //    }
        // Find the list of 6 neighbours corresponding to smallest one in Close status
        int ListNeighbours[6];
        GetListNeighbours_bis(ListNeighbours, SmallestIndex, Dim, Shift, 6);
        //        int * ListNeighbours=GetListNeighbours(SmallestIndex, Dim, Shift, 6);
        // Change to Close Status the ones that were in Far Away before
        for (int n=0; n<6; n++) {
            if (Status[ListNeighbours[n]]==2) {
                Status[ListNeighbours[n]]=1;
            }
        }
        Status[SmallestIndex]=0;
        // Determine equation to solve according to number of neighbours in close.
        //        float * DiffToUse=new float [6];
        //        float DiffToUse[6];
        ////        bool * Unknown=new bool[6];
        //        bool Unknown[6];
        //        for (int n=0; n<6; n++) {
        //            Unknown[n]=Status[ListNeighbours[n]];
        //            if (Unknown[n]) {
        //                DiffToUse[n]=-DistanceFinal[SmallestIndex];
        //            }
        //            else {
        //                DiffToUse[n]=fabs(DistanceFinal[ListNeighbours[n]]-DistanceFinal[SmallestIndex])*1/PixDim[n/2];
        //            }
        //        }
        // Solve quadratic equations according to DiffToUse and Unknown for the 6 neighbours
        for (int n=0; n<6; n++) {
            float DistanceSolved=DistanceFinal[ListNeighbours[n]];
            if (ListNeighbours[n]!=SmallestIndex && Status[ListNeighbours[n]]!=0) {// Check that the considered neighbour is not out of border...
                DistanceSolved=SolveQuadraticForDistance(ListNeighbours[n],Status,DistanceFinal,Dim,Shift,PixDim);
                DistanceFinal[ListNeighbours[n]]=DistanceSolved;
            }
            //        cout<<"DistanceFinal for "<<ListNeighbours[n]<<"is "<<DistanceSolved;
        }
        
        
        vector<DLS *> DLSVectorTmp;
        for (int n=0; n<6; n++) {
            if (ListNeighbours[n]!=SmallestIndex && Status[ListNeighbours[n]]==1) {
                DLS * DLSToAdd=new DLS();
                DLSToAdd->Status=1;
                DLSToAdd->Index=ListNeighbours[n];
                DLSToAdd->Distance=DistanceFinal[ListNeighbours[n]];
                DLSVectorTmp.push_back(DLSToAdd);
            }
        }
        HeapSort(DLSVectorTmp, DLSVectorTmp.size()-1);
        if (DLSVectorTmp.size()>0) {
            if (DLSVectorTmp[0]->Distance < DLSVector[0]->Distance) {
                cout << "Big pb in distance calculation..."<<endl;
            }
        }
        
        //        int numbInserted=0;
        //        int j=0;
        //        int numbMax=DLSVectorTmp.size()+DLSVector.size();
        int DLSTmpSize=DLSVectorTmp.size();
        int IndexLastInserted=0;
        // Add the DLS to add in DLSVector that is already ordered...
        for (int n=0; n<DLSTmpSize; n++) {
            sizeDLSVector=DLSVector.size();
            if (DLSVectorTmp[n]->Distance >=DLSVector[sizeDLSVector-1]->Distance) {
                for (int l=n; l<DLSTmpSize; l++) {
                    DLS * DLSToAdd=DLSVectorTmp[l]->CopyDLS_ptr();
                    DLSVector.push_back(DLSToAdd);
                }
                break;
            }
            DLS * DLSToAdd=DLSVectorTmp[n]->CopyDLS_ptr();
            int IndexToInsert=FindRapidUpperBound(DLSVector, DLSToAdd, IndexLastInserted);
            if (IndexToInsert==0) {
                cout <<"Need to insert at beginning"<<endl;
            }
            //            IndexLastInserted=IndexToInsert-1;
            IndexLastInserted=IndexToInsert>0?IndexToInsert-1:0;
            //            int IndexToInsert=distance(DLSVector.begin(),lower_bound(DLSVector.begin(), DLSVector.end(), DLSToAdd.Distance));
            DLSVector.insert(DLSVector.begin()+IndexLastInserted,DLSToAdd);
            //            for (int j=IndexLastInserted; j<sizeDLSVector-1; j++) {
            //                if (DLSVectorTmp[n].Distance>= DLSVector[j].Distance && DLSVectorTmp[n].Distance<DLSVector[j+1].Distance){
            //                    DLS DLSToAdd=DLSVectorTmp[n].CopyDLS();
            //                    DLSVector.insert(DLSVector.begin()+j+1, DLSToAdd);
            //                    IndexLastInserted=j+1;
            //                    break;
            //                }
            //            }
        }
        //    for (int i=0; i<sizeDLSVector; i++) {
        //        j=i+numbInserted;
        //        if (j<sizeDLSVector-1+numbInserted && numbInserted<DLSTmpSize) {
        //            if (DLSVectorTmp[numbInserted].Distance>= DLSVector[j].Distance && DLSVectorTmp[numbInserted].Distance<DLSVector[j+1].Distance) {
        //                DLS DLSToAdd=DLSVectorTmp[numbInserted].CopyDLS();
        //                DLSVector.insert(DLSVector.begin()+j+1, DLSToAdd);
        //                numbInserted++;
        ////                cout<<"Insertion at "<<j;
        //            }
        //        }
        //        if (j==sizeDLSVector-1+numbInserted) {
        //            for (int l=numbInserted; l<DLSTmpSize; l++) {
        //                DLS DLSToAdd=DLSVectorTmp[l].CopyDLS();
        //                DLSVector.push_back(DLSToAdd);
        ////                cout<<"Insertion at the end";
        //            }
        //        }
        //    }
        int sizeDLSTmp=DLSVectorTmp.size();
        for (int n=0; n<sizeDLSTmp; n++) {
            delete DLSVectorTmp[n];
            DLSVectorTmp[n]=NULL;
        }
        DLSVectorTmp.clear();
        // Update value of those in close to match the F=1;
        
        // Change the status of the one in center to alive/freeze it
        Status[SmallestIndex]=0;
        for (int i=0; i<=sizeDLSTmp; i++) {
            if (DLSVector[i]->Index==SmallestIndex) {
                delete DLSVector[i];
                DLSVector[i]=NULL;
                DLSVector.erase(DLSVector.begin()+i);
                if (i>0) {
                    cout<<"Insertion before"<<endl;
                }
                break;
            }
        }
        //        delete DLSVector[0];
        //        DLSVector.erase(DLSVector.begin());
        // Correct DLSArray with all changes
        //        int sizeDLSVec=DLSVector.size();
        //        int ToSuppress=0;
        //    for (int i=0; i<sizeDLSVec; i++) {
        //        if (DLSVector[i].Index==SmallestIndex) {
        //            DLSVector[i].Distance=DistanceFinal[SmallestIndex];
        //            DLSVector[i].Status=Status[SmallestIndex];
        //            ToSuppress=i;
        //        }
        //        for (int n=0; n<6; n++) {
        //            if (DLSVector[i].Index==ListNeighbours[n]) {
        //                DLSVector[i].Distance=DistanceFinal[ListNeighbours[n]];
        //                DLSVector[i].Status=Status[ListNeighbours[n]];
        //            }
        //
        //        }
        //    }
        //        int countSup=0;
        //        for (int j=sizeDLSVector; j>=0; j--) {
        //            if (DLSVector[j].Index==SmallestIndex) {
        //                DLSVector.erase(DLSVector.begin()+j);
        //                j--;
        //                countSup++;
        //            }
        //        }
        //        cout<<countSup<<" DLS deleted"<<endl;
        //        if (sizeDLSVec>ToSuppress) {
        //            DLSVector.erase(DLSVector.begin()+ToSuppress);
        //        }
        //        else{
        //            cout<<"Pb when trying to erase at iteration"<<Iteration;
        //            return;
        //        }
        
        // Clearing memory and recursive treatment
        //        delete [] DiffToUse;
        //        delete [] Unknown;
        //        delete [] ListNeighbours;
        //        DiffToUse=NULL;
        //        Unknown=NULL;
        //        ListNeighbours=NULL;
        Iteration++;
    }
    cout << "Have to go out of loop"<<endl;
    return;
}

nifti_image * EuclideanDistanceImage(nifti_image * BasisImage, bool * BasisObject, nifti_image * Mask){
    bool flag_comp=CheckCompatibleDimensions(BasisImage, Mask);
    if (!flag_comp && Mask!=NULL) {
        return NULL;
    }
    bool * MaskData=NULL;
    bool flag_MaskNULL=1;
    if(Mask!=NULL){
        Binarisation(Mask);
    }
    
    //    Initialisation of result
    nifti_image * ResultDistance=nifti_copy_nim_info(BasisImage);
    ResultDistance->dim[0]=3;
    ResultDistance->dim[4]=1;
    ResultDistance->dim[5]=1;
    nifti_update_dims_from_array(ResultDistance);
    ResultDistance->data=(void *) calloc(ResultDistance->nvox, sizeof(float));
    //    Needed Numbers/Arrays for following
    
    int numel=ResultDistance->nvox;
    int Dim[3];
    int Shift[3];
    float Pixdim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=ResultDistance->dim[d+1];
        Pixdim[d]=ResultDistance->pixdim[d+1];
    }
    int ProdDim=Dim[0]*Dim[1]*Dim[2];
    float ProdPix=Pixdim[0]*Pixdim[1]*Pixdim[2];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    if (Mask==NULL) {
        MaskData=new bool[numel];
        for (int i=0; i<numel; i++) {
            MaskData[i]=1;
        }
    }
    else{
        flag_MaskNULL=0;
        MaskData=static_cast<bool *>(Mask->data);
    }
    
    int * Status=new int[numel];
    float * Distance=new float[numel];
    
    for (int i=0; i<numel; i++) {
        Status[i]=0;
        Distance[i]=ProdDim*ProdPix;
        if (MaskData[i]) {
            Status[i]=2;
            if (BasisObject[i]) {
                Status[i]=0;
                Distance[i]=0;
            }
        }
    }
    
    cout << "Numb "<< CountNonZero(MaskData,numel) << " "<< CountNonZero(BasisObject, numel)<<endl;
    for (int i=0; i<numel; i++) {
        int ListNeighbours[6];
//        Status[i]=0;
//        Distance[i]=ProdDim*ProdPix;
        if (MaskData[i]) {
//            Status[i]=2;
            if (BasisObject[i]) {
                Status[i]=0;
                Distance[i]=0;
                GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
                for (int n=0; n<6; n++) {
                    int LookedIndex=ListNeighbours[n];
                    if (Status[LookedIndex]>0) {
                        Status[LookedIndex]=1;
                        float TentativeDist=GetDistanceBetweenPoints(i, LookedIndex, Dim, Pixdim);
                        if (TentativeDist<Distance[LookedIndex]) {
                            Distance[LookedIndex]=TentativeDist;
                        }
                    }
                }
            }
        }
    }
    
    
//    nifti_image * DistanceInit=CreateNiiFromArray(Distance, ResultDistance, numel);
//    nifti_set_filenames(DistanceInit, "/Users/Carole/Documents/PhD/SABRE_80/DistanceInit.nii.gz", 0, 0);
//    nifti_image_write(DistanceInit);
//    nifti_image_free(DistanceInit);
//    
//    
//    nifti_image * StatusInit=CreateNiiFromArray(Status, ResultDistance, numel);
//    nifti_set_filenames(StatusInit, "/Users/Carole/Documents/PhD/SABRE_80/StatusInit.nii.gz", 0, 0);
//    nifti_image_write(StatusInit);
//    nifti_image_free(StatusInit);
    //    From that initialisation perform the IterMarching
    int iteration=1;
    if(CountNonZero(Status,numel)==0){
        return NULL;
    }
    IterFastMarchingMap(Status, Distance, Dim, Shift, Pixdim, iteration,MaskData);
    //    Filling the results, freeing memory and returning
    float * ResultDistanceData=static_cast<float*>(ResultDistance->data);
    for (int i=0; i<numel; i++) {
        ResultDistanceData[i]=Distance[i];
    }
    if (flag_MaskNULL) {
        delete [] MaskData;
        MaskData=NULL;
    }
    if (Distance!=NULL) {
        delete [] Distance;
        Distance=NULL;
    }
    if (Status!=NULL) {
        delete [] Status;
        Status=NULL;
    }
    return ResultDistance;
}


// Determines the distance to border with fast marching using the int * State (for the settled / close / faraway definition)
void IterFastMarchingMap(int * Status, float * DistanceFinal, int * Dim, int * Shift, float * PixDim, int & Iteration, bool * Mask){
    
    typedef std::multimap <float, int> MapLengthType;
    typedef std::pair <float, int> PairType;
    MapLengthType MapLength;
    MapLengthType::iterator first_element=MapLength.begin();
    
    // First Initialisation of the MapFromBorder
    int numel=Dim[0]*Dim[1]*Dim[2];
    if (Mask!=NULL) {
        for (int n=0; n<numel; n++) {
            if(Mask[n]==1){
            if (Status[n]>0 && Mask[n]==1) {
                MapLength.insert(PairType(DistanceFinal[n],n));
            }
            }
        }
    }
    else{
        for (int n=0; n<numel; n++) {
            if (Status[n]==1) {
                MapLength.insert(PairType(DistanceFinal[n],n));
            }
        }
    }
    if (MapLength.size()==0){
        return ;
    }
    first_element=MapLength.begin();
    bool flag_todo=1;
    int Iter=1;
    while (flag_todo>0) {
        if(Status[first_element->second]==0){
            if(first_element->first<DistanceFinal[first_element->second]){
                cout<< "Oups pb in 0 status update...";
                DistanceFinal[first_element->second]=first_element->first;
            }
            if (first_element->first>=250) {
//                cout<<"Problem to check"<<endl;
            }
            MapLength.erase(first_element);
            first_element=MapLength.begin();
            if (MapLength.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iter<numel);
        }
        else if (first_element->first<=DistanceFinal[first_element->second]) {
            if (first_element->first>=250) {
//                cout<<"To check !"<<endl;
            }
            Status[first_element->second]=0;
            DistanceFinal[first_element->second]=first_element->first;
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, first_element->second, Dim, Shift, 6);
            //            int * ListNeighbours=GetListNeighbours(first_element->second, Dim, Shift, 6);
            if (Mask!=NULL) {
                for (int n=0; n<6; n++) {
                    if (Status[ListNeighbours[n]]==2) {
                        Status[ListNeighbours[n]]=1;
                    }
                }
                for (int n=0; n<6; n++) {
                    float DistanceSolved=DistanceFinal[ListNeighbours[n]];
                    if (ListNeighbours[n]!=first_element->second && Status[ListNeighbours[n]]!=0 && (Mask[ListNeighbours[n]]==1)) {// Check that the considered neighbour is not out of border...
                        DistanceSolved=SolveQuadraticForDistance(ListNeighbours[n],Status,DistanceFinal,Dim,Shift,PixDim);
                        if(DistanceSolved<DistanceFinal[ListNeighbours[n]]){
                            DistanceFinal[ListNeighbours[n]]=DistanceSolved;
                            if (Status[ListNeighbours[n]]==1) {
                                MapLength.insert(PairType(DistanceSolved,ListNeighbours[n]));
                            }
                        }
                        
                    }
                }
            }
            else{
                for (int n=0; n<6; n++) {
                    if (Status[ListNeighbours[n]]==2) {
                        Status[ListNeighbours[n]]=1;
                    }
                }
                for (int n=0; n<6; n++) {
                    float DistanceSolved=DistanceFinal[ListNeighbours[n]];
                    if (ListNeighbours[n]!=first_element->second && Status[ListNeighbours[n]]!=0) {// Check that the considered neighbour is not out of border...
                        DistanceSolved=SolveQuadraticForDistance(ListNeighbours[n],Status,DistanceFinal,Dim,Shift,PixDim);
                        if(DistanceSolved<DistanceFinal[ListNeighbours[n]]){
                            DistanceFinal[ListNeighbours[n]]=DistanceSolved;
                            if (Status[ListNeighbours[n]]==1) {
                                MapLength.insert(PairType(DistanceSolved,ListNeighbours[n]));
                            }
                        }
                    }
                }
            }
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
            MapLength.erase(first_element);
            first_element=MapLength.begin();
            if (MapLength.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iter<numel);
            Iter++;
        }
        else if(first_element->first>DistanceFinal[first_element->second]){
            Status[first_element->second]=0;
            MapLength.erase(first_element);
            first_element=MapLength.begin();
            if (MapLength.size()<=0) {
                flag_todo=0;
            }
            flag_todo*=(Iter<numel);
        }
        
        
        // Checking if Status still contains 1 or 2 values
        //        if(Mask!=NULL){
        //            for (int n=0; n<numel; n++) {
        //                if (Status[n]>0 && Mask[n]) {
        //                    flag_todo=1;
        //                    break;
        //                }
        //            }
        //        }
        //        else{
        //        for (int n=0; n<numel; n++) {
        //            if (Status[n]>0) {
        //                flag_todo=1;
        //                break;
        //            }
        //        }
        //        }
        
    }
    Iteration=Iter;
//    float TestMax=GetMax(DistanceFinal, Mask, numel);
    return;
}



// Determines the distance to border with fast marching using the int * State (for the settled / close / faraway definition)
void IterFastMarching(int * Status, vector<DLS> & DLSVectorBis, float * DistanceFinal, int * Dim, int * Shift, float * PixDim, int & Iteration, bool * Mask){
    
    vector<DLS> DLSVector=InitialiseDLSVector(Status, DistanceFinal, Dim);
    int sizeDLS=DLSVector.size();
    HeapSort(DLSVector, sizeDLS-1);
    // First check if there is something to do...
    bool flag_todo=1;
    while (flag_todo) {
        
        int numel=Dim[0]*Dim[1]*Dim[2];
        if (Mask ==NULL) {
            flag_todo=0;
            for (int i=0; i<numel; i++) {
                if (Status[i]>0) {
                    flag_todo=1;
                    break;
                }
            }
        }
        else{
            flag_todo=0;
            for (int i=0; i<numel; i++) {
                if (Mask[i]) {
                    if (Status[i]>0) {
                        flag_todo=1;
                        break;
                    }
                }
                
            }
        }
        if (300000*(Iteration/300000)==Iteration) {
            flag_todo=0;
        }
        
        if (!flag_todo) { // If there is nothing to do because all have been treated, go out !
            return;
        }
        // Then heap sort DLSArray
        int sizeDLSVector=DLSVector.size();
        //    HeapSort(DLSVector, sizeDLSVector-1);
        // Find element with smallest distance in Close status
        int numbToDelete=0;
        for(int s=0;s<sizeDLSVector;s++){
            if (DLSVector[s].Distance>DistanceFinal[DLSVector[s].Index]) {
                numbToDelete++;
            }
            else{
                break;
            }
        }
        //        cout<< numbToDelete<<"to delete"<<endl;
        // We delete in vector all elements for which DLS value is not appropriate and should be deleted.
        for (int d=0; d<numbToDelete; d++) {
            DLSVector.erase(DLSVector.begin());
        }
        int SmallestIndex=DLSVector[0].Index;
        //    for (int i=0; i<numel; i++) {
        //        if (DLSVector[i].Status==1) {
        //            SmallestIndex=DLSVector[i].Index;
        //            break;
        //        }
        //    }
        // Find the list of 6 neighbours corresponding to smallest one in Close status
        int ListNeighbours[6];
        GetListNeighbours_bis(ListNeighbours, SmallestIndex, Dim, Shift, 6);
        //        int * ListNeighbours=GetListNeighbours(SmallestIndex, Dim, Shift, 6);
        // Change to Close Status the ones that were in Far Away before
        for (int n=0; n<6; n++) {
            if (Status[ListNeighbours[n]]==2) {
                Status[ListNeighbours[n]]=1;
            }
        }
        Status[SmallestIndex]=0;
        // Determine equation to solve according to number of neighbours in close.
        //        float * DiffToUse=new float [6];
        //        float DiffToUse[6];
        //        bool * Unknown=new bool[6];
        //        bool Unknown[6];
        //        for (int n=0; n<6; n++) {
        //            Unknown[n]=Status[ListNeighbours[n]];
        //            if (Unknown[n]) {
        //                DiffToUse[n]=-DistanceFinal[SmallestIndex];
        //            }
        //            else {
        //                DiffToUse[n]=fabs(DistanceFinal[ListNeighbours[n]]-DistanceFinal[SmallestIndex])*1/PixDim[n/2];
        //            }
        //        }
        // Solve quadratic equations according to DiffToUse and Unknown for the 6 neighbours
        for (int n=0; n<6; n++) {
            float DistanceSolved=DistanceFinal[ListNeighbours[n]];
            if (ListNeighbours[n]!=SmallestIndex && Status[ListNeighbours[n]]!=0) {// Check that the considered neighbour is not out of border...
                DistanceSolved=SolveQuadraticForDistance(ListNeighbours[n],Status,DistanceFinal,Dim,Shift,PixDim);
                DistanceFinal[ListNeighbours[n]]=DistanceSolved;
            }
            //        cout<<"DistanceFinal for "<<ListNeighbours[n]<<"is "<<DistanceSolved;
        }
        
        vector<DLS> DLSVectorTmp;
        for (int n=0; n<6; n++) {
            if (ListNeighbours[n]!=SmallestIndex && Status[ListNeighbours[n]]==1) {
                DLS DLSToAdd;
                DLSToAdd.Status=1;
                DLSToAdd.Index=ListNeighbours[n];
                DLSToAdd.Distance=DistanceFinal[ListNeighbours[n]];
                DLSVectorTmp.push_back(DLSToAdd);
            }
        }
        HeapSort(DLSVectorTmp, DLSVectorTmp.size()-1);
        //        int numbInserted=0;
        //        int j=0;
        //        int numbMax=DLSVectorTmp.size()+DLSVector.size();
        int DLSTmpSize=DLSVectorTmp.size();
        int IndexLastInserted=0;
        // Add the DLS to add in DLSVector that is already ordered...
        for (int n=0; n<DLSTmpSize; n++) {
            sizeDLSVector=DLSVector.size();
            if (DLSVectorTmp[n].Distance >=DLSVector[sizeDLSVector-1].Distance) {
                for (int l=n; l<DLSTmpSize; l++) {
                    DLS DLSToAdd=DLSVectorTmp[l].CopyDLS();
                    DLSVector.push_back(DLSToAdd);
                }
                break;
            }
            DLS DLSToAdd=DLSVectorTmp[n].CopyDLS();
            int IndexToInsert=FindRapidUpperBound(DLSVector, DLSToAdd, IndexLastInserted);
            IndexLastInserted=IndexToInsert;
            //            int IndexToInsert=distance(DLSVector.begin(),lower_bound(DLSVector.begin(), DLSVector.end(), DLSToAdd.Distance));
            DLSVector.insert(DLSVector.begin()+IndexToInsert,DLSToAdd);
            //            for (int j=IndexLastInserted; j<sizeDLSVector-1; j++) {
            //                if (DLSVectorTmp[n].Distance>= DLSVector[j].Distance && DLSVectorTmp[n].Distance<DLSVector[j+1].Distance){
            //                    DLS DLSToAdd=DLSVectorTmp[n].CopyDLS();
            //                    DLSVector.insert(DLSVector.begin()+j+1, DLSToAdd);
            //                    IndexLastInserted=j+1;
            //                    break;
            //                }
            //            }
        }
        //    for (int i=0; i<sizeDLSVector; i++) {
        //        j=i+numbInserted;
        //        if (j<sizeDLSVector-1+numbInserted && numbInserted<DLSTmpSize) {
        //            if (DLSVectorTmp[numbInserted].Distance>= DLSVector[j].Distance && DLSVectorTmp[numbInserted].Distance<DLSVector[j+1].Distance) {
        //                DLS DLSToAdd=DLSVectorTmp[numbInserted].CopyDLS();
        //                DLSVector.insert(DLSVector.begin()+j+1, DLSToAdd);
        //                numbInserted++;
        ////                cout<<"Insertion at "<<j;
        //            }
        //        }
        //        if (j==sizeDLSVector-1+numbInserted) {
        //            for (int l=numbInserted; l<DLSTmpSize; l++) {
        //                DLS DLSToAdd=DLSVectorTmp[l].CopyDLS();
        //                DLSVector.push_back(DLSToAdd);
        ////                cout<<"Insertion at the end";
        //            }
        //        }
        //    }
        //    DLSVectorTmp.clear();
        // Update value of those in close to match the F=1;
        
        // Change the status of the one in center to alive/freeze it
        Status[SmallestIndex]=0;
        DLSVector.erase(DLSVector.begin());
        // Correct DLSArray with all changes
        //        int sizeDLSVec=DLSVector.size();
        //        int ToSuppress=0;
        //    for (int i=0; i<sizeDLSVec; i++) {
        //        if (DLSVector[i].Index==SmallestIndex) {
        //            DLSVector[i].Distance=DistanceFinal[SmallestIndex];
        //            DLSVector[i].Status=Status[SmallestIndex];
        //            ToSuppress=i;
        //        }
        //        for (int n=0; n<6; n++) {
        //            if (DLSVector[i].Index==ListNeighbours[n]) {
        //                DLSVector[i].Distance=DistanceFinal[ListNeighbours[n]];
        //                DLSVector[i].Status=Status[ListNeighbours[n]];
        //            }
        //
        //        }
        //    }
        //        int countSup=0;
        //        for (int j=sizeDLSVector; j>=0; j--) {
        //            if (DLSVector[j].Index==SmallestIndex) {
        //                DLSVector.erase(DLSVector.begin()+j);
        //                j--;
        //                countSup++;
        //            }
        //        }
        //        cout<<countSup<<" DLS deleted"<<endl;
        //        if (sizeDLSVec>ToSuppress) {
        //            DLSVector.erase(DLSVector.begin()+ToSuppress);
        //        }
        //        else{
        //            cout<<"Pb when trying to erase at iteration"<<Iteration;
        //            return;
        //        }
        
        // Clearing memory and recursive treatment
        //        delete [] DiffToUse;
        //        delete [] Unknown;
        //        delete [] ListNeighbours;
        //        DiffToUse=NULL;
        //        Unknown=NULL;
        //        ListNeighbours=NULL;
        Iteration++;
    }
    cout << "Have to go out of loop"<<endl;
    return;
}

int FindRapidLowerBound(vector<DLS> DLSVector, DLS DLSToFind, int IndexLastInserted){
    int sizeDLSVec=DLSVector.size()-IndexLastInserted;
    int sizeTotVec=DLSVector.size();
    if (DLSToFind.Distance>=DLSVector[sizeTotVec-1].Distance) {
        return sizeDLSVec;
    }
    
    else{
        float ToFind=DLSToFind.Distance;
        int step=sizeDLSVec/2;
        int count=sizeDLSVec;
        int first=IndexLastInserted;
        int Index=IndexLastInserted;
        while (count > 0) {
            Index  = first;
            step = count / 2;
            float Test=DLSVector[Index+step].Distance;
            if (Test < ToFind) {
                first = Index+step+1;
                count -= step + 1;
            } else count = step;
        }
        return first;
    }
}

int FindRapidLowerBound(vector<DLS *> DLSVector, DLS * DLSToFind, int IndexLastInserted){
    int sizeDLSVec=DLSVector.size()-IndexLastInserted;
    int sizeTotVec=DLSVector.size();
    if (DLSToFind->Distance>=DLSVector[sizeTotVec-1]->Distance) {
        return sizeDLSVec;
    }
    
    else{
        float ToFind=DLSToFind->Distance;
        int step;
        int count=sizeDLSVec;
        int first=IndexLastInserted;
        int Index=IndexLastInserted;
        while (count > 0) {
            Index  = first;
            step = count / 2;
            float Test=DLSVector[Index+step]->Distance;
            if (Test < ToFind) {
                first = Index+step+1;
                count -= step + 1;
            } else count = step;
        }
        return first;
    }
}

int FindRapidUpperBound(vector<DLS> DLSVector, DLS DLSToFind, int IndexLastInserted){
    int sizeDLSVec=DLSVector.size()-IndexLastInserted;
    int sizeTotVec=DLSVector.size();
    if (DLSToFind.Distance>=DLSVector[sizeTotVec-1].Distance) {
        return sizeTotVec-1;
    }
    if (DLSVector[0].Distance>DLSToFind.Distance) {
        cout<<"Pb if adding"<<endl;
        return 1;
    }
    
    else{
        float ToFind=DLSToFind.Distance;
        int step;
        int count=sizeDLSVec;
        int first=sizeTotVec-1;
        int Index=sizeTotVec-1;
        while (count > 0) {
            Index  = first;
            step = count / 2;
            float Test=DLSVector[Index-step].Distance;
            if (Test > ToFind) {
                first = Index-step-1;
                count -= step + 1;
            } else count = step;
        }
        return first;
    }
}

int FindRapidUpperBound(vector<DLS *> DLSVector, DLS * DLSToFind, int IndexLastInserted){
    int sizeDLSVec=DLSVector.size()-IndexLastInserted;
    int sizeTotVec=DLSVector.size();
    if (DLSToFind->Distance>=DLSVector[sizeTotVec-1]->Distance) {
        return sizeTotVec-1;
    }
    if (DLSVector[0]->Distance>DLSToFind->Distance) {
        cout<<"Pb if adding"<<endl;
        return 1;
    }
    
    else{
        float ToFind=DLSToFind->Distance;
        int step;
        int count=sizeDLSVec;
        int first=sizeTotVec-1;
        int Index=sizeTotVec-1;
        while (count > 0) {
            Index  = first;
            step = count / 2;
            float Test=DLSVector[Index-step]->Distance;
            if (Test > ToFind) {
                first = Index-step-1;
                count -= step + 1;
            } else count = step;
        }
        return first;
    }
}

// Determines the distance to border with fast marching using the int * State (for the settled / close / faraway definition)
void RecurseFastMarching(int * Status, vector<DLS> & DLSVector, float * DistanceFinal, int * Dim, int * Shift, float * PixDim, int & Iteration, bool * Mask){
    // First check if there is something to do...
    bool flag_todo=0;
    int numel=Dim[0]*Dim[1]*Dim[2];
    if (Mask ==NULL) {
        for (int i=0; i<numel; i++) {
            if (Status[i]>0) {
                flag_todo=1;
                break;
            }
        }
    }
    else{
        for (int i=0; i<numel; i++) {
            if (Mask[i]) {
                if (Status[i]>0) {
                    flag_todo=1;
                    break;
                }
            }
            
        }
    }
    if (100000*(Iteration/100000)==Iteration) {
        flag_todo=0;
    }
    
    if (!flag_todo) { // If there is nothing to do because all have been treated, go out !
        return;
    }
    // Then heap sort DLSArray
    int sizeDLSVector=DLSVector.size();
    //    HeapSort(DLSVector, sizeDLSVector-1);
    // Find element with smallest distance in Close status
    int SmallestIndex=0;
    //    for (int i=0; i<numel; i++) {
    //        if (DLSVector[i].Status==1) {
    //            SmallestIndex=DLSVector[i].Index;
    //            break;
    //        }
    //    }
    // Find the list of 6 neighbours corresponding to smallest one in Close status
    int ListNeighbours[6];
    GetListNeighbours_bis(ListNeighbours, SmallestIndex, Dim, Shift, 6);
    //    int * ListNeighbours=GetListNeighbours(SmallestIndex, Dim, Shift, 6);
    // Change to Close Status the ones that were in Far Away before
    for (int n=0; n<6; n++) {
        if (Status[ListNeighbours[n]]==2) {
            Status[ListNeighbours[n]]=1;
        }
    }
    // Determine equation to solve according to number of neighbours in close.
    //    float * DiffToUse=new float [6];
    //    float DiffToUse[6];
    //    bool * Unknown=new bool[6];
    //    bool Unknown[6];
    //    for (int n=0; n<6; n++) {
    //        Unknown[n]=Status[ListNeighbours[n]];
    //        if (Unknown[n]) {
    //            DiffToUse[n]=-DistanceFinal[SmallestIndex];
    //        }
    //        else {
    //            DiffToUse[n]=fabs(DistanceFinal[ListNeighbours[n]]-DistanceFinal[SmallestIndex])*1/PixDim[n/2];
    //        }
    //    }
    
    // Solve quadratic equations according to DiffToUse and Unknown for the 6 neighbours
    for (int n=0; n<6; n++) {
        float DistanceSolved=DistanceFinal[ListNeighbours[n]];
        if (ListNeighbours[n]!=SmallestIndex) {// Check that the considered neighbour is not out of border...
            DistanceSolved=SolveQuadraticForDistance(ListNeighbours[n],Status,DistanceFinal,Dim,Shift,PixDim);
        }
        DistanceFinal[ListNeighbours[n]]=DistanceSolved;
        cout<<"DistanceFinal for "<<ListNeighbours[n]<<"is "<<DistanceSolved;
    }
    
    vector<DLS> DLSVectorTmp;
    for (int n=0; n<6; n++) {
        if (ListNeighbours[n]!=SmallestIndex) {
            DLS DLSToAdd;
            DLSToAdd.Status=1;
            DLSToAdd.Index=ListNeighbours[n];
            DLSToAdd.Distance=DistanceFinal[ListNeighbours[n]];
            DLSVectorTmp.push_back(DLSToAdd);
        }
    }
    HeapSort(DLSVectorTmp, DLSVectorTmp.size()-1);
    int numbInserted=0;
    int j=0;
    int numbMax=DLSVectorTmp.size()+DLSVector.size();
    int DLSTmpSize=DLSVectorTmp.size();
    // Add the DLS to add in DLSVector that is already orderered...
    for (int i=0; i<sizeDLSVector; i++) {
        j=i+numbInserted;
        if (j<numbMax-1 && numbInserted<DLSTmpSize) {
            if (DLSVectorTmp[numbInserted].Distance>= DLSVector[j].Distance && DLSVectorTmp[numbInserted].Distance<DLSVector[j+1].Distance) {
                DLS DLSToAdd=DLSVectorTmp[numbInserted].CopyDLS();
                DLSVector.insert(DLSVector.begin()+j+1, DLSToAdd);
                numbInserted++;
                cout<<"Insertion at "<<j;
            }
        }
        if (j==numbMax-1) {
            for (int l=numbInserted; l<DLSTmpSize; l++) {
                DLS DLSToAdd=DLSVectorTmp[l].CopyDLS();
                DLSVector.push_back(DLSToAdd);
                cout<<"Insertion at the end";
            }
        }
    }
    DLSVectorTmp.clear();
    // Update value of those in close to match the F=1;
    
    // Change the status of the one in center to alive/freeze it
    Status[SmallestIndex]=0;
    // Correct DLSArray with all changes
    //    int sizeDLSVec=DLSVector.size();
    int ToSuppress=0;
    //    for (int i=0; i<sizeDLSVec; i++) {
    //        if (DLSVector[i].Index==SmallestIndex) {
    //            DLSVector[i].Distance=DistanceFinal[SmallestIndex];
    //            DLSVector[i].Status=Status[SmallestIndex];
    //            ToSuppress=i;
    //        }
    //        for (int n=0; n<6; n++) {
    //            if (DLSVector[i].Index==ListNeighbours[n]) {
    //                DLSVector[i].Distance=DistanceFinal[ListNeighbours[n]];
    //                DLSVector[i].Status=Status[ListNeighbours[n]];
    //            }
    //
    //        }
    //    }
    DLSVector.erase(DLSVector.begin()+ToSuppress);
    // Clearing memory and recursive treatment
    //    delete [] DiffToUse;
    //    delete [] Unknown;
    //    delete [] ListNeighbours;
    //    DiffToUse=NULL;
    //    Unknown=NULL;
    //    ListNeighbours=NULL;
    Iteration++;
    RecurseFastMarching(Status, DLSVector, DistanceFinal, Dim, Shift, PixDim,Iteration,Mask);
}

// Solve the problem of the distance according to
float SolveQuadraticForDistance(int Index, int * Status, float * DistanceFinal, int * Dim, int * Shift, float * PixDim){
    // First determine list of 6 neighbours for considered index
    int ListNeighbours[6];
    GetListNeighbours_bis(ListNeighbours, Index, Dim, Shift, 6);
    //    int * ListNeighbours=GetListNeighbours(Index, Dim, Shift, 6);
    // Initialise list of Possible solution (8 since 8 possibilities for the quadrants)
    //    float * PossibleDist=new float[8];
    float PossibleDist[8];
    for (int p=0; p<8; p++) { // Distance cannot be negative so easy way to check afterwards
        PossibleDist[p]=-1;
    }
    // Solving for each quadrant, remembering that in Neighbours for 6 it is first on x, then on y then on z
    // Use CombinationBis defined in TreeEM to get the possible combinations of 3 among 6
    //    int * Possibilities=new int[3];
    int Possibilities[3];
    for (int d=0; d<3; d++) {
        Possibilities[d]=2;
    }
    TreeEM Tmp;
    int * Combinations=Tmp.CombinationBis(Possibilities,3);
    // Loop over the eight possibilities to solve for Possible Dist
    for (int p=0; p<8; p++) {
        // Check how many of the considered neighbours can be used/ are known
        vector<int> Known;
        int NeighboursConsidered [3];
        for (int l=0; l<3; l++) {
            NeighboursConsidered[l]=ListNeighbours[Combinations[l+3*p]+(int)pow_int(2,l)*(l>0)];
            if (NeighboursConsidered[l]!=Index) {
                if (Status[NeighboursConsidered[l]]<1 ) {
                    Known.push_back(l);
                }
            }
        }
        int CountKnown=Known.size();
        if (CountKnown==0) {
            PossibleDist[p]=MaxDistanceValue;
        }
        else if(CountKnown==1){
            PossibleDist[p]=PixDim[Known[0]]+DistanceFinal[NeighboursConsidered[Known[0]]];
        }
        else{ // Here we have to solve the quadratic equation if possible
            float a=0;
            float b=0;
            float c=0;
            float d=0;
            for (int k=0; k<CountKnown; k++) {
                a+=pow_int(1/PixDim[Known[k]], 2);
                b-=2*DistanceFinal[NeighboursConsidered[Known[k]]]/pow_int(PixDim[Known[k]],2);
                c+=pow_int(DistanceFinal[NeighboursConsidered[Known[k]]]/PixDim[Known[k]], 2);
            }
            d=pow_int(b, 2)-4*a*(c-1);
            if (d>0) {
                PossibleDist[p]=(-b+sqrtf(d)/(2*a));
            }
            else{
                float minTest=1E18;
                for (int k=0; k<CountKnown; k++) {
                    if (PixDim[Known[k]]+DistanceFinal[NeighboursConsidered[Known[k]]]<minTest) {
                        minTest=PixDim[Known[k]]+DistanceFinal[NeighboursConsidered[Known[k]]];
                    }
                }
                PossibleDist[p]=minTest;
            }
        }
    }
    // Now take the minimum from all the Possible dist
    float minDistResult=1E18;
    for (int p=0; p<8; p++) {
        if (PossibleDist[p]<minDistResult && PossibleDist[p]>0) {
            minDistResult=PossibleDist[p];
        }
    }
    // Clearing memory
    delete [] Combinations;
    //    delete [] PossibleDist;
    //    delete [] ListNeighbours;
    //    delete [] Possibilities;
    Combinations=NULL;
    //    PossibleDist=NULL;
    //    ListNeighbours=NULL;
    //    Possibilities=NULL;
    
    return minDistResult;
}

// Solve the problem of the distance according to
float SolveQuadraticForDistance_short(int Index, int * Status, float * DistanceFinal, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked){
    // First determine list of 6 neighbours for considered index
    int ListNeighbours[6];
    int TrueIndex=S2L[Index];
    GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim, Shift, 6);
    // Checking and correcting ListNeighbours for mask
    for (int n=0; n<6; n++) {
        if (L2S[ListNeighbours[n]]<0) { // the neighbour in the list is not part of the mask
            ListNeighbours[n]=TrueIndex;
        }
    }
    
    
    //    int * ListNeighbours=GetListNeighbours(S2L[Index], Dim, Shift, 6);
    // Initialise list of Possible solution (8 since 8 possibilities for the quadrants)
    //    float * PossibleDist=new float[8];
    float PossibleDist[8];
    for (int p=0; p<8; p++) { // Distance cannot be negative so easy way to check afterwards
        PossibleDist[p]=-1;
    }
    // Solving for each quadrant, remembering that in Neighbours for 6 it is first on x, then on y then on z
    // Use CombinationBis defined in TreeEM to get the possible combinations of 3 among 6
    //    int * Possibilities=new int[3];
    int Possibilities[3];
    for (int d=0; d<3; d++) {
        Possibilities[d]=2;
    }
    TreeEM Tmp;
    int * Combinations=Tmp.CombinationBis(Possibilities,3);
    // Loop over the eight possibilities to solve for Possible Dist
    for (int p=0; p<8; p++) {
        // Check how many of the considered neighbours can be used/ are known
        vector<int> Known;
        int NeighboursConsidered [3];
        for (int l=0; l<3; l++) {
            NeighboursConsidered[l]=ListNeighbours[Combinations[l+3*p]+(int)pow_int(2,l)*(l>0)];
            if (NeighboursConsidered[l]!=TrueIndex) {
                if (Status[L2S[NeighboursConsidered[l]]]<1 ) {
                    Known.push_back(l);
                }
            }
        }
        int CountKnown=Known.size();
        if (CountKnown==0) {
            PossibleDist[p]=MaxDistanceValue;
        }
        else if(CountKnown==1){
            PossibleDist[p]=PixDim[Known[0]]+DistanceFinal[L2S[NeighboursConsidered[Known[0]]]];
        }
        else{ // Here we have to solve the quadratic equation if possible
            float a=0;
            float b=0;
            float c=0;
            float d=0;
            for (int k=0; k<CountKnown; k++) {
                a+=pow_int(1/PixDim[Known[k]], 2);
                b-=2*DistanceFinal[L2S[NeighboursConsidered[Known[k]]]]/pow_int(PixDim[Known[k]],2);
                c+=pow_int(DistanceFinal[L2S[NeighboursConsidered[Known[k]]]]/PixDim[Known[k]], 2);
            }
            d=pow_int(b, 2)-4*a*(c-1);
            if (d>0) {
                PossibleDist[p]=(-b+sqrtf(d)/(2*a));
            }
            else{
                float minTest=1E18;
                for (int k=0; k<CountKnown; k++) {
                    if (PixDim[Known[k]]+DistanceFinal[L2S[NeighboursConsidered[Known[k]]]]<minTest) {
                        minTest=PixDim[Known[k]]+DistanceFinal[L2S[NeighboursConsidered[Known[k]]]];
                    }
                }
                PossibleDist[p]=minTest;
            }
        }
    }
    // Now take the minimum from all the Possible dist
    float minDistResult=1E18;
    for (int p=0; p<8; p++) {
        if (PossibleDist[p]<minDistResult && PossibleDist[p]>0) {
            minDistResult=PossibleDist[p];
        }
    }
    // Clearing memory
    delete [] Combinations;
    //    delete [] PossibleDist;
    //    delete [] ListNeighbours;
    //    delete [] Possibilities;
    Combinations=NULL;
    //    PossibleDist=NULL;
    //    ListNeighbours=NULL;
    //    Possibilities=NULL;
    
    return minDistResult;
}



/*********************** FUNCTIONS SPECIFICALLY NEEDED FOR EQUIVOLUME **********************************/

// First curvature

// Second curvature

// AMap
// Calculate AMap given curvature 1 and curvature 2 for in and out
float * AMapCalculation(float * PhiIn, float * PhiOut, int * Dim,int * Shift, float * PixDim, float MaxDist,int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * AMapResult=new float [numelmasked];
    for (int i=0; i<numelmasked; i++) {
        AMapResult[i]=0;
    }
    //    int * Sign = CreateSignFromSignedDistance(PhiIn,  PhiOut,  Dim);
    for (int i=0; i<numelmasked; i++) {
        if (PhiIn[i]==0) { // Meaning that we are at levelset 0 of inner surface and that we thus have to calculate Ain
            float dist=fabs(PhiOut[i]);
            int OutIndex=FindProjection(i, PhiOut, Dim, Shift, PixDim,L2S,S2L,numelmasked);
            float * CurvIn=CurvatureParaboloidCalculation(i,PhiIn,Dim, Shift, MaxDist,PixDim,L2S,S2L,numelmasked);
            float * CurvOut=CurvatureParaboloidCalculation(OutIndex,PhiOut,Dim, Shift, MaxDist,PixDim,L2S,S2L,numelmasked);
            float Diff1=CurvIn[0]-CurvOut[1];
            float Diff2=CurvIn[1]-CurvOut[1];
            int Sign1=Diff1==0?0:(int)(Diff1/fabs(Diff1));
            int Sign2=Diff2==0?0:(int)(Diff2/fabs(Diff2));
            AMapResult[i]=1/(1+Sign1*0.5*dist*CurvIn[0])*1/(1+Sign2*0.5*dist*CurvIn[1]);
            AMapResult[OutIndex]=1/(1-Sign1*0.5*dist*CurvOut[0])*1/(1-Sign2*0.5*dist*CurvOut[1]);
            delete [] CurvOut;
            delete [] CurvIn;
            CurvOut=NULL;
            CurvIn=NULL;
        }
    }
    // As not same number of voxels in in and out, need to change AMap to give something to all voxels on out border that do not have anything yet as for areas. Might be subject to change if we want to take the mean or begin by the Aout and mean on Ain or linear interpolation. Actually we will need it only if we begin from out instead of
    for (int i=0; i<numelmasked; i++) {
        if (PhiOut[i]==0 && AMapResult[i]==0) {
            float dist=fabs(PhiIn[i]);
            int InIndex=FindProjection(i, PhiIn, Dim, Shift, PixDim,L2S,S2L,numelmasked);
            float * CurvIn=CurvatureParaboloidCalculation(InIndex,PhiIn,Dim,Shift,MaxDist,PixDim,L2S,S2L,numelmasked);
            float * CurvOut=CurvatureParaboloidCalculation(i,PhiOut,Dim,Shift,MaxDist,PixDim,L2S,S2L,numelmasked);
            float Diff1=CurvIn[0]-CurvOut[1];
            float Diff2=CurvIn[1]-CurvOut[1];
            int Sign1=Diff1==0?0:(int)(Diff1/fabs(Diff1));
            int Sign2=Diff2==0?0:(int)(Diff2/fabs(Diff2));
            // We do not want to change AMapResult for in curve so we update only AMapResult[i]
            //            AMapResult[]=1/(1+Sign1*0.5*dist*CurvIn[0])*1/(1+Sign2*0.5*dist*CurvIn[1]);
            AMapResult[i]=1/(1-Sign1*0.5*dist*CurvOut[0])*1/(1-Sign2*0.5*dist*CurvOut[1]);
        }
    }
    return AMapResult;
}


int * CreateSignFromSignedDistance(float * PhiIn, float * PhiOut, int * Dim){
    int numel = Dim[0]*Dim[1]*Dim[2];
    int * Sign=new int[numel];
    for (int i=0; i<numel; i++) {
        Sign[i]=PhiIn[i]*PhiOut[i]<=0?1:-1;
    }
    return Sign;
}
// Final rho map
// Returns as a float array the rho value for both when beginning from the out or the in surface
float * RhoMap(float * AMap, float * PhiIn, float * PhiOut, int * Dim, int * Shift, float * PixDim,float Alpha, int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * RhoMapResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        RhoMapResult[i]=Alpha;
    }
    //    int * Sign=CreateSignFromSignedDistance(PhiIn, PhiOut, Dim);
    
    for (int i=0; i<numelmasked; i++) {
        int InIndex=FindProjection(i, PhiIn, Dim, Shift, PixDim,L2S,S2L,numelmasked);
        int OutIndex=FindProjection(i, PhiOut,Dim, Shift, PixDim,L2S,S2L,numelmasked);
        if (AMap[InIndex]!=AMap[OutIndex]) { // Otherwise it is naturally alpha
            RhoMapResult[i]=1/(AMap[OutIndex]-AMap[InIndex])*(-AMap[InIndex]+sqrt(Alpha*AMap[OutIndex]*AMap[OutIndex]+(1-Alpha)*AMap[InIndex]*AMap[InIndex]));
        }
    }
    //    delete [] Sign;
    return RhoMapResult;
}


// Returns as a float array the rho value for both when beginning from the out or the in surface. Use this time the map of projection indices. Avoid recalculating projection each time we change the alpha value.
float * RhoMap(float * AMap, int * ProjIn, int * ProjOut, float * PhiIn, float * PhiOut, int * Dim, int * Shift, float * PixDim,float Alpha, int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * RhoMapResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        RhoMapResult[i]=Alpha;
    }
    for (int i=0; i<numelmasked; i++) {
        int InIndex=ProjIn[i];
        int OutIndex=ProjOut[i];
        if (AMap[InIndex]!=AMap[OutIndex]) { // Otherwise it is naturally alpha
            RhoMapResult[i]=1/(AMap[OutIndex]-AMap[InIndex])*(-AMap[InIndex]+sqrt(Alpha*AMap[OutIndex]*AMap[OutIndex]+(1-Alpha)*AMap[InIndex]*AMap[InIndex]));
        }
    }
    return RhoMapResult;
}

// For all elements in Mask, gives the index of the corresponding projection on the surface of choice (assuming that there is a zero level for the considered)
int * ProjectingMapIndex(float * ProjectionSurface, int * Dim, int * Shift, float * PixDim, int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    int * ProjectionResult=new int [numelmasked];
    for (int i=0; i<numelmasked; i++) {
        ProjectionResult[i]=-1;
    }
    for (int i=0; i<numelmasked; i++) {
        ProjectionResult[i]=FindProjection(i, ProjectionSurface,  Dim, Shift, PixDim,L2S,S2L,numelmasked);
    }
    return ProjectionResult;
}

//Initialise objective level set given PhiIn, PhiOut, Alpha and AMap
float * InitialiseObjectiveLS(float Alpha, float * AMap, float * PhiIn, float * PhiOut, int * Dim, int * Shift, float * PixDim,int * L2S, int * S2L, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * RhoMapToUse=RhoMap(AMap, PhiIn, PhiOut, Dim, Shift, PixDim, Alpha, L2S,S2L,numelmasked);
    float * ObjectiveResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) {
        ObjectiveResult[i]=(1-RhoMapToUse[i])*PhiIn[i]-RhoMapToUse[i]*PhiOut[i];
    }
    delete [] RhoMapToUse;
    RhoMapToUse=NULL;
    return ObjectiveResult;
}

// Initialise objective LS when RhoMap is already known given PhiIn and PhiOut
float * InitialiseObjectiveLS(float * RhoMapToUse, float * PhiIn, float * PhiOut, int numelmasked){
    //    int numel=Dim[0]*Dim[1]*Dim[2];
    float * ObjectiveResult=new float[numelmasked];
    for (int i=0; i<numelmasked; i++) { // Initialise with equivalent to infinite distance
        ObjectiveResult[i]=1E18;
    }
    for (int i=0; i<numelmasked; i++) {
        //            ObjectiveResult[i]=(1-RhoMapToUse[i])*PhiIn[i]-RhoMapToUse[i]*PhiOut[i];
        ObjectiveResult[i]=(1-RhoMapToUse[i])*PhiIn[i]+RhoMapToUse[i]*PhiOut[i]; // Use of + because PhiIn will always be positive in the mask and PhiOut always negative.
    }
    return ObjectiveResult;
}

// Gives the corresponding index projected on a certain surface given the level set of this surface
int FindProjection(int IndexProjected, float * ProjectionSurface, int * Dim, int * Shift, float * PixDim,int * L2S, int * S2L, int numelmasked){
    int ProjectedResult=0;
    int CoordinatesInitial[3];
    CorrespondingCoordinates_bis(CoordinatesInitial, S2L[IndexProjected], Dim, Shift);
    //    int * CoordinatesInitial=CorrespondingCoordinates(S2L[IndexProjected], Dim, Shift);
    // Create and initialise Translation array
    //    float * Trans=new float[3];
    float Trans[3];
    for (int d=0; d<3; d++) {
        Trans[d]=0;
    }
    // List of 6 neighbours for indexProjected
    int ListNeigh[6];
    GetListNeighbours_bis(ListNeigh, S2L[IndexProjected], Dim, Shift, 6);
    //    int * ListNeigh=GetListNeighbours(S2L[IndexProjected], Dim, Shift, 6);
    float SumTrans=0;
    // Fill with initial value for difference used as gradient, taking care of possible problem of border Do we have to add mask option as well ?
    for (int d=0; d<3; d++) {
        float TmpDiff=ProjectionSurface[L2S[ListNeigh[d*2+1]]]-ProjectionSurface[L2S[ListNeigh[d*2]]];
        if (ListNeigh[d*2+1]!=S2L[IndexProjected] && ListNeigh[d*2]!=S2L[IndexProjected]) { // Meaning according to definitin of ListNeigh that we are not on border
            TmpDiff/=2*PixDim[d];
        }
        else{// The difference is not symmetric, only dividing by 1*PixDim[d
            TmpDiff/=PixDim[d];
        }
        Trans[d]=TmpDiff;
        SumTrans+=TmpDiff*TmpDiff;
    }
    for (int d=0; d<3; d++) {
        Trans[d]/=sqrtf(SumTrans)*ProjectionSurface[IndexProjected];
    }
    //    delete [] ListNeigh;
    //    ListNeigh=NULL;
    // Creating translated coordinates according to equation 3 in Wahenaert
    //    float * TranslatedCoor=new float[3];
    float TranslatedCoor[3];
    for (int d=0; d<3; d++) {
        TranslatedCoor[d]=CoordinatesInitial[d]-Trans[d];
    }
    // Then find closest index that is truly on surface and that would be closest to corresponding floating point.
    // First get all index corresponding to closest values
    vector<int> PossibleClose;
    //    int * PossibleIndices=new int[6];
    int PossibleIndices[6];
    //    int * TabSize=new int[3];
    int TabSize[3];
    for (int d=0; d<3; d++) {
        PossibleIndices[d*2]=(int)floorf(TranslatedCoor[d]);
        PossibleIndices[d*2+1]=(int)ceilf(TranslatedCoor[d]);
        TabSize[d]=2;
    }
    TreeEM Test;
    
    int * CombPossible=Test.CombinationBis(TabSize, 3);
    for (int i=0; i<8; i++) {
        //        int * NewPossible=new int[3];
        int NewPossible[3];
        for (int d=0; d<3; d++) {
            NewPossible[d]=PossibleIndices[CombPossible[i*3+d]+2*d];
        }
        bool flag_valid=ValidityCoordinates(NewPossible, Dim);
        if (flag_valid) {
            int IndexToAdd=0;
            for (int d=0; d<3; d++) {
                IndexToAdd+=Shift[d]*NewPossible[d];
            }
            PossibleClose.push_back(L2S[IndexToAdd]);
        }
        //        delete [] NewPossible;
        //        NewPossible=NULL;
    }
    delete [] CombPossible;
    //    delete [] TabSize;
    //    delete [] PossibleIndices;
    
    int numbClose=PossibleClose.size();
    vector<int > PossibleZero;
    for (int s=0; s<numbClose; s++) {
        if (ProjectionSurface[PossibleClose[s]]) {
            PossibleZero.push_back(PossibleClose[s]);
        }
    }
    int numbZero=PossibleZero.size();
    if (numbZero==1) { // In the possible int definition of the floating index, only one correspond to the zero level set.
        ProjectedResult = PossibleZero[0];
    }
    else if (numbZero>1) { // Among the possible corresponding indices, more than one correspond to zero level set, choice of the closest one then
        int minInd=0;
        float minDist=1E18;
        for (int z=0; z<numbZero; z++) {
            //            float * TmpCoord=new float[3];
            float TmpCoord[3];
            int tmp=PossibleZero[z];
            for (int d=2; d>=0; d--) {
                TmpCoord[d]=floorf(tmp/Shift[d]);
                tmp-=(int)(TmpCoord[d]*Shift[d]);
            }
            float Dist=GetDistanceBetweenPoints<float, float>(TranslatedCoor,TmpCoord,Dim,PixDim);
            //            delete [] TmpCoord;
            //            TmpCoord=NULL;
            if (Dist<minDist) {
                minInd=z;
                minDist=Dist;
            }
        }
        ProjectedResult=PossibleZero[minInd];
    }
    else if (numbClose==0){
        //        cout<<"Pb with translation"<<endl;
        ProjectedResult=IndexProjected;
    }
    else{ // we will return the one with the smallest value
        //        cout<< "Not directly on zero surface"<<endl;
        float minValue=1E18;
        int minInd=0;
        for (int c=0; c<numbClose; c++) {
            if (fabs(ProjectionSurface[PossibleClose[c]])<minValue) {
                minValue=fabsf(ProjectionSurface[PossibleClose[c]]);
                minInd=c;
            }
        }
        ProjectedResult=PossibleClose[minInd];
    }
    
    return ProjectedResult;
}

// Given two points with their floating coordinates (instead of normally their integer ones) due to possibility of non integer in
float GetDistanceBetweenFloatingPoints(float * Point1, float * Point2, float * PixDim){
    float Dist=0;
    for (int d=0; d<3; d++) {
        float MultFactor=PixDim==NULL?1:PixDim[d];
        float DistTmp=(fabsf(Point1[d]-Point2[d])*MultFactor);
        Dist+=DistTmp*DistTmp;
    }
    return sqrtf(Dist);
}

float * SignedDistance(float * AbsDistance, int * Sign, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    float * SignedDistanceRes=new float[numel];
    for (int i=0; i<numel; i++) {
        SignedDistanceRes[i]=fabsf(AbsDistance[i])*Sign[i];
    }
    return SignedDistanceRes;
}

// Paraboloid fitting
float * CurvatureParaboloidCalculation(int Index,float * Phi,int * Dim,int *Shift,float MaxDist,float *PixDim,int * L2S, int * S2L, int numelmasked, float Std){
    float * CurvResult=new float [2];
    int CoordIndex[3];
    CorrespondingCoordinates_bis(CoordIndex, S2L[Index], Dim, Shift);
    //    int * CoordIndex=CorrespondingCoordinates(S2L[Index], Dim, Shift);
    vector<int> ToUseIndices=GetIndicesToExploreFloatDist(S2L[Index], MaxDist, Dim, Shift, PixDim);
    int sizeToUse=ToUseIndices.size();
    for (int l=sizeToUse-1; l>=0; l--) {
        if (L2S[ToUseIndices[l]]<0) {
            ToUseIndices.erase(ToUseIndices.begin()+l);
        }
    }
    int numbNeigh=ToUseIndices.size();
    float * Y=new float[numbNeigh];
    float * W=new float[numbNeigh];
    float * MatrixLSQ=new float[numbNeigh *9];
    for (int i=0; i<numbNeigh*9; i++) {
        MatrixLSQ[i]=0;
    }
    for (int n=0; n<numbNeigh; n++) {
        Y[n]=Phi[ToUseIndices[n]]-Phi[Index];
        int CoordN[3];
        CorrespondingCoordinates_bis(CoordN, ToUseIndices[n], Dim, Shift);
        //        int * CoordN=CorrespondingCoordinates(ToUseIndices[n], Dim, Shift);
        //        float * Diff=new float[3];
        float Diff[3];
        for (int d=0; d<3; d++) {
            Diff[d]=(CoordN[d]-CoordIndex[d])*PixDim[d];
        }
        float Dist=GetDistanceBetweenPoints<int,int>(CoordN, CoordIndex, Dim, PixDim);
        W[n]=expf(-Dist*Dist/(2*Std*Std)); // careful, the weighting is not normalised...
        // Filling corresponding line of MatrixLSQ
        for (int d1=0; d1<3; d1++) {
            MatrixLSQ[n*9+d1]=Diff[d1];
            MatrixLSQ[n*9+d1+3]=Diff[d1]*Diff[d1];
            for (int d2=d1+1; d2<3; d2++) {
                MatrixLSQ[n*9+6+d2+d1-1]=Diff[d1]*Diff[d2];
            }
        }
        //        delete [] CoordN;
        //        delete [] Diff;
        //        CoordN=NULL;
        //        Diff=NULL;
    }
    // Weighting y and MatrixLSQ
    for (int n=0; n<numbNeigh; n++) {
        float MultW=sqrtf(W[n]);
        Y[n]*=MultW;
        for (int i=0; i<9; i++) {
            MatrixLSQ[n*9+i]*=MultW;
        }
        
    }
    SVD ResultSVD=SVD(MatrixLSQ,numbNeigh,9);
    TreeEM T;
    float * UResult=ResultSVD.getU();
    float * VResult=ResultSVD.getV();
    float * EResult=ResultSVD.getSingularValues();
    float * TransposeV=T.TransposeMatrix(VResult, 9, 9);
    float * TransposeU=T.TransposeMatrix(UResult, numbNeigh, 9);
    // Create E pseudo inverted
    //    float * EPseudoI=new float[9*9];
    float EPseudoI[81];
    for (int i=0; i<81; i++) {
        EPseudoI[i]=0;
    }
    for (int i=0; i<9; i++) {
        if (EResult[i]!=0) {
            EPseudoI[i+9*i]=1/EResult[i];
        }
    }
    //    int * SizePMatrix=new int [4];
    int SizePMatrix[4];
    SizePMatrix[0]=9;
    SizePMatrix[1]=9;
    SizePMatrix[2]=9;
    SizePMatrix[3]=9;
    float * ProductVE=T.ProductMatrix(TransposeV, EPseudoI, SizePMatrix);
    SizePMatrix[3]=numbNeigh;
    float * ProductVEUt=T.ProductMatrix(ProductVE, TransposeU, SizePMatrix);
    SizePMatrix[1]=numbNeigh;
    SizePMatrix[2]=numbNeigh;
    SizePMatrix[3]=1;
    float * ResultBetaCoeffs=T.ProductMatrix(ProductVEUt, Y, SizePMatrix);
    delete [] ProductVEUt;
    delete [] ProductVE;
    delete [] TransposeU;
    delete [] TransposeV;
    //    delete [] EPseudoI;
    delete [] MatrixLSQ;
    delete [] W;
    delete [] Y;
    //    delete [] CoordIndex;
    //    CoordIndex=NULL;
    MatrixLSQ=NULL;
    W=NULL;
    Y=NULL;
    ProductVE=NULL;
    ProductVEUt=NULL;
    TransposeV=NULL;
    TransposeU=NULL;
    //    EPseudoI=NULL;
    // Creation of L and Q form
    //    float * LVector=new float[3];
    float LVector[3];
    for (int d=0; d<3; d++) {
        LVector[d]=ResultBetaCoeffs[d];
    }
    //    float * QMatrix=new float[9];
    float QMatrix[9];
    for (int q=0; q<9; q++) {
        QMatrix[q]=0;
    }
    for (int d1=0; d1<3; d1++) {
        for (int d2=0; d2<3; d2++) {
            if (d1==d2) {
                QMatrix[d1+3*d2]=ResultBetaCoeffs[3+d1];
            }
            else{
                QMatrix[d1+3*d2]=ResultBetaCoeffs[5+d1+d2];
            }
        }
    }
    // Solving in eigenvalues and eigenvectors
    // Supposedly vectors are in columns
    Eigenvalue EigenResult=Eigenvalue(QMatrix, 3);
    float * EigenVaQ=EigenResult.getRealEigenValues();
    float * EigenVeQ=EigenResult.getV();
    // Try to see if one of the eigenvectors is orthogonal to L
    int IndexOrth=-1;
    for (int j=0; j<3; j++) {
        float TryOrth=0;
        for (int i=0; i<3; i++) {
            TryOrth+=EigenVeQ[j+3*i]*LVector[i];
        }
        if (fabs(TryOrth)<10E-2) {
            cout<<"this is the orthogonal";
            IndexOrth=j;
            break;
        }
    }
    if (IndexOrth>=0) {
        int r=0;
        for (int j=0; j<3; j++) {
            if (j!=IndexOrth) {
                CurvResult[r]=EigenVaQ[j];
                r++;
            }
        }
    }
    else{
        cout<<"Potential pb with detection of orthogonal"<<endl;
        float MinEigen=1E18;
        // Consider then that the curvature that has to be eliminated is the one that correspond to the smallest eigenvalue
        for (int j=0 ; j<3; j++) {
            if (EigenVaQ[j]<MinEigen) {
                IndexOrth=j;
                MinEigen=EigenVaQ[j];
            }
        }
        int r=0;
        for (int j=0; j<3; j++) {
            if (j!=IndexOrth) {
                CurvResult[r]=EigenVaQ[j];
                r++;
            }
        }
        
    }
    //    delete [] QMatrix;
    //    delete [] LVector;
    //    delete [] SizePMatrix;
    delete [] ResultBetaCoeffs;
    //    QMatrix=NULL;
    //    LVector=NULL;
    //    SizePMatrix=NULL;
    ResultBetaCoeffs=NULL;
    return CurvResult;
}
// Depend on distance considered, based on signed distance function, sigma used for gaussian weighting



bool * CreateBoolSegFromSumPriorsIdx(nifti_image * SummarisedSeg,vector<float *> PriorsVector ,vector<int> IndexVector,int * L2S,float PriorsThresh){
    if(SummarisedSeg==NULL){
        return NULL;
    }
    if (IndexVector.size()==0) {
        return NULL;
    }
    int numel=SummarisedSeg->nx*SummarisedSeg->ny*SummarisedSeg->nz;
    float * PriorsAdded=AddArray(PriorsVector, numel);
    int sizeIdx=IndexVector.size();
    float * DataSummarised=static_cast<float *>(SummarisedSeg->data);
    int numbclasses=SummarisedSeg->nu*SummarisedSeg->nt;
    vector<float *> ClassesToAddVector;
    for (int s=0; s<sizeIdx;s++) {
        if (IndexVector[s]<numbclasses) {
            ClassesToAddVector.push_back(&DataSummarised[numel*IndexVector[s]]);
        }
    }
    float * DataFin=AddArray(ClassesToAddVector, numel);
    bool * Result=new bool[numel];
    for (int i=0; i<numel; i++) {
        Result[i]=0;
        if (L2S[i]>=0) {
            if (PriorsAdded[i]>PriorsThresh && DataFin[i]>0.5) {
                Result[i]=1;
            }
        }
    }
    if (DataFin!=NULL) {
        delete [] DataFin;
        DataFin=NULL;
    }
    if (PriorsAdded!=NULL) {
        delete [] PriorsAdded;
        PriorsAdded=NULL;
    }
    return Result;
}


bool * CreateBoolObjectFromParcellation(nifti_image * ParcellationImage, vector<int> ElementsToAssociate){
    int numel=ParcellationImage->nvox;
    int numbAssoc=ElementsToAssociate.size();
    bool * ParcellatedMask=new bool[numel];
    for (int i=0; i<numel; i++) {
        ParcellatedMask[i]=0;
    }
    float * ParcellatedData_PTR=static_cast<float *>(ParcellationImage->data);
    for (int n=0 ; n<numbAssoc; n++) {
        for (int i=0; i<numel; i++) {
            if(ParcellatedData_PTR[i]==ElementsToAssociate[n]){
                ParcellatedMask[i]=1;
            }
        }
    }
    return ParcellatedMask;
}

/*********************** FUNCTIONS FOR LESION FEATURES IN TERMS OF NORMALISED DISTANCE BETWEEN VENTRICLES AND CORTEX ********************/

// Given the lesion segmentation and the result of the normalised distance between ventricles and cortex, gives back an array of the proportion of lesion volume in each lamina and the corresponding volume
float * ProportionLesionVolumeDistance(nifti_image * LesionSeg, float * LengthNormSol, int NumberLaminae, float * PixDim, int * L2S, int * S2L, int numelmasked){
    // First transform in short the result of the lesion segmentation
    float * LesionToShort=static_cast<float *>(LesionSeg->data);
    float * LesionShort=CreateShort(LesionToShort, S2L, numelmasked);
    float * LengthNormSol_s=CreateShort(LengthNormSol, S2L, numelmasked);
    // Initialise the final result
    float * VolumeLayer=new float[NumberLaminae];
    float * ProportionLesVolume=new float [NumberLaminae * 4];
    for (int n=0; n<NumberLaminae; n++) {
        ProportionLesVolume[4*n]=0;
        ProportionLesVolume[4*n+1]=0;
        ProportionLesVolume[4*n+2]=0;
        ProportionLesVolume[4*n+3]=0;
        VolumeLayer[n]=0;
    }
    float sizeBin=1.0/(float)NumberLaminae;
    float sumTotLes=0;
    float VolVoxel=1;
    for (int d=0; d<3; d++) {
        VolVoxel*=PixDim[d];
    }
    int CountSup=0;
    int CountPbIndexBin=0;
    // Add progressively the probabilities (or binarised voxels)
    for (int i=0 ; i<numelmasked; i++) {
        int IndexBin=(int)(floorf(LengthNormSol_s[i]/sizeBin));
        if (IndexBin==NumberLaminae) {
            //                cout<<"Problem with IndexBin..."<<endl;
            CountPbIndexBin++;
            IndexBin=NumberLaminae-1;
        }
        if (LengthNormSol_s[i]>0.1) {
            CountSup++;
        }
        ProportionLesVolume[4*IndexBin]+=LesionShort[i];
        ProportionLesVolume[4*IndexBin+1]+=LesionShort[i];
        ProportionLesVolume[4*IndexBin+2]+=LesionShort[i];
        ProportionLesVolume[4*IndexBin+3]+=LesionShort[i];
        sumTotLes+=LesionShort[i];
        VolumeLayer[IndexBin]++;
    }
    cout<<"CountSup 0.1 is "<< CountSup<<" and CountPbIndexBin is "<<CountPbIndexBin<<endl;
    // Normalise against sumTotLes if non zero
    if (sumTotLes>0) {
        for (int n=0; n<NumberLaminae; n++) {
            ProportionLesVolume[4*n]/=sumTotLes;
            ProportionLesVolume[4*n+1]*=VolVoxel;
            ProportionLesVolume[4*n+2]/=VolumeLayer[n];
            ProportionLesVolume[4*n+3]/=(VolumeLayer[n]/numelmasked*sumTotLes);
        }
    }
    // Clear memory before returning ProportionLesVolume
    delete [] LesionShort;
    LesionShort=NULL;
    delete [] LengthNormSol_s;
    LengthNormSol_s=NULL;
    return ProportionLesVolume;
}



//Gives the weight to the different bins for the layers related information. Allows to account for jumps between layers due to low resolution
void GetWeightedBin(float * WeightIndexBin,int index,int NumberLaminae,float *LengthNormSol_s, int numelmasked, int * L2S, int * S2L, nifti_image * BasisImage){
    
    int Dim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=BasisImage->dim[d+1];
    }
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    for (int l=0; l<MaxNumberLaminae; l++) {
        WeightIndexBin[l]=0;
    }
    float sizeBin=1.0/NumberLaminae;
    float FloatIndexValue=LengthNormSol_s[index]/sizeBin-0.5;
    int IndexBin=(int)(floorf(LengthNormSol_s[index]/sizeBin-0.5));
    IndexBin=IndexBin>=0?IndexBin:0;
    float DiffIndex=FloatIndexValue-IndexBin;
    int TrueIndex=S2L[index];
    int ListNeighbours[6];
    GetListNeighbours_bis(ListNeighbours, TrueIndex, Dim , Shift, 6);
    //        For each of the neighbours, if possible, give the IndexBin
    int IndexBinNeighbours[6];
    int minLayer=MaxNumberLaminae;
    int maxLayer=-1;
    for (int n=0; n<6; n++) {
        IndexBinNeighbours[n]=IndexBin;
        int IndexTempShort=L2S[ListNeighbours[n]];
        if (IndexTempShort>=0 && ListNeighbours[n]!=TrueIndex) {
            IndexBinNeighbours[n]=(int)floorf(LengthNormSol_s[IndexTempShort]/sizeBin-0.5);
        }
        if(IndexBinNeighbours[n]>maxLayer){
            maxLayer=IndexBinNeighbours[n];
        }
        if (IndexBinNeighbours[n]<minLayer) {
            minLayer=IndexBinNeighbours[n];
        }
    }
    //        With the just obtained range of layers spanned by the neighbours, we apply a Gaussian weighting for the layers upper and under the IndexBin according to distance towards border
    int RangeUnder=IndexBin-minLayer;
    int RangeAbove=maxLayer-IndexBin;
    if (RangeUnder>0) {
        float sumTempRangeUnder=0;
        float TempRangeUnder[20];
        for (int r=0; r<20; r++) {
            TempRangeUnder[r]=0;
        }
        for (int r=0; r<RangeUnder; r++) {
            int indexRange=IndexBin-r>=0?IndexBin-r:0;
            TempRangeUnder[indexRange]=exp(-0.5*r*r);
            sumTempRangeUnder+=TempRangeUnder[indexRange];
        }
        for (int r=0; r<RangeUnder; r++) {
            int indexRange=IndexBin-r>=0?IndexBin-r:0;
            TempRangeUnder[indexRange]/=sumTempRangeUnder;
        }
        for (int r=0; r<RangeUnder; r++) {
            int indexRange=IndexBin-r>=0?IndexBin-r:0;
            WeightIndexBin[indexRange]+=TempRangeUnder[indexRange]*DiffIndex;
        }
    }
    else{
        WeightIndexBin[IndexBin]+=DiffIndex;
    }
    //        Similar weighting for range above
    if (RangeAbove>0) {
        float sumTempRangeAbove=0;
        float TempRangeAbove[20];
        for (int r=0; r<20; r++) {
            TempRangeAbove[r]=0;
        }
        for (int r=0; r<RangeAbove; r++) {
            int indexRange=IndexBin+r<NumberLaminae?IndexBin+r:NumberLaminae-1;
            TempRangeAbove[indexRange]=exp(-0.5*r*r);
            sumTempRangeAbove+=TempRangeAbove[indexRange];
        }
        for (int r=0; r<RangeAbove; r++) {
            int indexRange=IndexBin+r<NumberLaminae?IndexBin+r:NumberLaminae-1;
            TempRangeAbove[indexRange]/=sumTempRangeAbove;
        }
        for (int r=1; r<RangeAbove; r++) {
            int indexRange=IndexBin+r<NumberLaminae?IndexBin+r:NumberLaminae-1;
            WeightIndexBin[indexRange]+=TempRangeAbove[indexRange]*(1-DiffIndex);
        }
        int indexRange=IndexBin+1<NumberLaminae?IndexBin+1:NumberLaminae-1;
        WeightIndexBin[indexRange]+=TempRangeAbove[IndexBin]*(1-DiffIndex);
    }
    else{
        int indexRange=IndexBin+1<NumberLaminae?IndexBin+1:NumberLaminae-1;
        WeightIndexBin[indexRange]+=(1-DiffIndex);
    }
    
}

// Given the lesion segmentation and the result of the normalised distance between ventricles and cortex, gives back an array of the proportion of lesion volume in each lamina and the corresponding volume. Compared to the previous function, this attributes proportions to each layer when looking at the layer of the nearby voxels when the change is too steep.
float * ProportionLesionVolumeDistanceWeighted(nifti_image * LesionSeg, float * LengthNormSol, int NumberLaminae, float * PixDim, int * L2S, int * S2L, int numelmasked){
    // First transform in short the result of the lesion segmentation
    float * LesionToShort=static_cast<float *>(LesionSeg->data);
    float * LesionShort=CreateShort(LesionToShort, S2L, numelmasked);
    float * LengthNormSol_s=CreateShort(LengthNormSol, S2L, numelmasked);
    int Dim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=LesionSeg->dim[d+1];
    }
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    // Initialise the final result
    float * VolumeLayer=new float[NumberLaminae];
    float * ProportionLesVolume=new float [NumberLaminae * 4];
    for (int n=0; n<NumberLaminae; n++) {
        ProportionLesVolume[4*n]=0;
        ProportionLesVolume[4*n+1]=0;
        ProportionLesVolume[4*n+2]=0;
        ProportionLesVolume[4*n+3]=0;
        VolumeLayer[n]=0;
    }
    //    float sizeBin=1.0/(float)NumberLaminae;
    float sumTotLes=0;
    float VolVoxel=1;
    for (int d=0; d<3; d++) {
        VolVoxel*=PixDim[d];
    }
    int CountSup=0;
    ////    Determine if we consider the image as isotropic or anisotropic according to max PixDimRatio
    //    float MinPixDim=GetMin(PixDim, 3);
    //    float RatioPixDim[3];
    //    bool AnisotropicDimension[3];
    //    bool flag_anisotropic=0;
    //    for (int d=0; d<3; d++) {
    //        RatioPixDim[d]=PixDim[d]/MinPixDim;
    //        AnisotropicDimension[d]=1;
    //        if (RatioPixDim[d]>2) {
    //            AnisotropicDimension[d]=0;
    //            flag_anisotropic=1;
    //        }
    //    }
    // Add progressively the probabilities (or binarised voxels) according to the proportion decided in
    for (int i=0 ; i<numelmasked; i++) {
        float WeightIndexBin[20];
        for (int l=0; l<20; l++) {
            WeightIndexBin[l]=0;
        }
        GetWeightedBin(WeightIndexBin, i,NumberLaminae,LengthNormSol_s, numelmasked,  L2S, S2L, LesionSeg);
        
        
        if (LengthNormSol_s[i]>0.1) {
            CountSup++;
        }
        
        //        Put according to the weight of LesionShort into the corresponding laminae
        for (int l=0; l<NumberLaminae; l++) {
            ProportionLesVolume[4*l]+=LesionShort[i]*WeightIndexBin[l];
            ProportionLesVolume[4*l+1]+=LesionShort[i]*WeightIndexBin[l];
            ProportionLesVolume[4*l+2]+=LesionShort[i]*WeightIndexBin[l];
            ProportionLesVolume[4*l+3]+=LesionShort[i]*WeightIndexBin[l];
            VolumeLayer[l]+=WeightIndexBin[l];
        }
        sumTotLes+=LesionShort[i];
        
    }
    cout<<"CountSup 0.1 is "<< CountSup<<endl;
    // Normalise against sumTotLes if non zero
    if (sumTotLes>0) {
        for (int n=0; n<NumberLaminae; n++) {
            ProportionLesVolume[4*n]/=sumTotLes;
            ProportionLesVolume[4*n+1]*=VolVoxel;
            ProportionLesVolume[4*n+2]/=VolumeLayer[n];
            ProportionLesVolume[4*n+3]/=(VolumeLayer[n]/numelmasked*sumTotLes);
        }
    }
    // Clear memory before returning ProportionLesVolume
    delete [] LesionShort;
    LesionShort=NULL;
    delete [] LengthNormSol_s;
    LengthNormSol_s=NULL;
    return ProportionLesVolume;
}


// Given the lesion segmentation and the result of the normalised distance between ventricles and cortex, gives back an array of the number of disconnected lesions present in each layer and the corresponding volume
int * CountLesionNormDistance(nifti_image * LesionLabelCorr, float * LengthNormSol, int NumberLaminae, float * PixDim, int * L2S, int * S2L, int numelmasked){
    // First transform in short array the result of the lesion segmentation
    float * LabelToShort=static_cast<float *>(LesionLabelCorr->data);
    float * LabelShort=CreateShort(LabelToShort, S2L, numelmasked);
    int * LabelShort_int=TranscribeArray<float, int>(LabelShort, numelmasked);
    delete [] LabelShort;
    LabelShort=NULL;
    float * LengthNormSol_s=CreateShort(LengthNormSol, S2L, numelmasked);
    // Initialise the final result
    int * CountLes=new int [NumberLaminae ];
    for (int n=0; n<NumberLaminae; n++) {
        CountLes[n]=-1;
    }
    float sizeBin=1.0/(float)NumberLaminae;
    
    float VolVoxel=1;
    for (int d=0; d<3; d++) {
        VolVoxel*=PixDim[d];
    }
    
    set<int> SetLaminae[20];
    // Add progressively the labels into the sets
    for (int i=0 ; i<numelmasked; i++) {
        if (LabelShort_int[i]>0) {
            int IndexBin=(int)(floorf(LengthNormSol_s[i]/sizeBin));
            SetLaminae[IndexBin].insert(LabelShort_int[i]);
        }
    }
    
    // Count and store the number of different label per set;
    for (int i=0; i<NumberLaminae; i++) {
        CountLes[i]=SetLaminae[i].size();
    }
    
    
    // Clear memory before returning ProportionLesVolume
    delete [] LabelShort_int;
    LabelShort_int=NULL;
    delete [] LengthNormSol_s;
    LengthNormSol_s=NULL;
    return CountLes;
}

//Returns in a float array of size
float * LayersLesIntensityRelation(nifti_image * LesionSeg,float * LengthNormSol, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    // Initialise the final result that for each modality contains the min mean and max ratio to the healthy appearing mean value of WM for all of the layers considered
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    //    int numel=TreeToAnalyse->GetNumberElements();
    int NumberLaminae=segment_analysis->numbLaminae[0];
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    float * ResultLayersIntensities=new float[numbmodal*4*NumberLaminae];
    int sizeResult=numbmodal*4*NumberLaminae;
    
    for (int i=0; i<sizeResult; i++) {
        ResultLayersIntensities[i]=0;
    }
    int sizeResultTmp=numbmodal*NumberLaminae;
    float * MaxPossible= new float [sizeResultTmp];
    float * MinPossible= new float [sizeResultTmp];
    float * MeanPossible= new float [sizeResultTmp];
    float * MahalPossible=new float [sizeResultTmp];
    float * SumTotPossible= new float [NumberLaminae];
    for (int l=0; l<sizeResultTmp; l++) {
        MinPossible[l]=2;
        MaxPossible[l]=-1;
        MeanPossible[l]=0;
        MahalPossible[l]=0;
    }
    for (int l=0; l<NumberLaminae; l++) {
        SumTotPossible[l]=0;
    }
    //    float sizeBin=1.0/NumberLaminae;
    
    //    In order to use directly the DataCorrected, we keep all the used array in their long form
    float * DataCorrected=TreeToAnalyse->GetDataBFCorrected();
    int * S2L=TreeToAnalyse->GetS2L();
    int * L2S=TreeToAnalyse->GetL2S();
    float * LesionDataSeg=static_cast<float *>(LesionSeg->data);
    float * LesionDataSeg_masked=CreateShort(LesionDataSeg, S2L, numelmasked);
    float * LengthNormSol_masked=CreateShort(LengthNormSol, S2L, numelmasked);
    
    //    Fill the MeanPossible, MaxPossible and MinPossible as well as SumTotPossible
    for (int i=0; i<numelmasked; i++) {
        if (LesionDataSeg_masked[i]>0) {
            float WeightedBin[20];
            GetWeightedBin(WeightedBin, i, NumberLaminae, LengthNormSol_masked, numelmasked, L2S, S2L, LesionSeg);
            //                We only consider in the statistics the voxels that contribute to at most two main laminae. For this purpose, check ratio to max in Weighted Bin. If Count of non zero is above 3, do not consider, if 3, consider the two major ones, if 1, then only 1 to consider
            int CountNonZeroWeight=CountNonZero(WeightedBin, NumberLaminae);
            float MaxWeight=GetMax(WeightedBin, NumberLaminae);
            if (MaxWeight>0.7) {
                CountNonZeroWeight=1;
            }
            int IndexMax=GetIndexMax(WeightedBin,NumberLaminae);
            if (IndexMax==NumberLaminae || IndexMax==-1) {
                cout<<"Problem with IndexMax...";
            }
            switch (CountNonZeroWeight) {
                    case 1: {// Normal case where voxel is completely surrounded by its own layer or so high that other weights do not count.
                        int IndexBin=IndexMax;
                        for (int m=0; m<numbmodal; m++) {
                            
                            if (DataCorrected[m*numelmasked+i]<MinPossible[IndexBin+m*NumberLaminae]) {
                                MinPossible[IndexBin+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
                            }
                            if (DataCorrected[m*numelmasked+i]>MaxPossible[IndexBin+m*NumberLaminae]) {
                                MaxPossible[IndexBin+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
                            }
                            MeanPossible[IndexBin+m*NumberLaminae]+=LesionDataSeg_masked[i]*DataCorrected[m*NumberLaminae+i];
                        }
                        SumTotPossible[IndexBin]+=LesionDataSeg_masked[i];
                    }
                    
                    break;
                    case 2:{ // Case where we consider it can belong to both sides. Bring the min for both layers and use weights for calculation of the mean.
                        //Check on which side is the other most important weight
                        int Index1;
                        int Index2;
                        float Weight1;
                        float Weight2;
                        if (IndexMax>=NumberLaminae-1) {
                            Index1=NumberLaminae-1;
                            Index2=NumberLaminae-2;
                            Weight1=WeightedBin[Index1];
                            Weight2=WeightedBin[Index2];
                        }
                        else if (IndexMax==0) {
                            Index1=0;
                            Index2=1;
                            Weight1=WeightedBin[Index1];
                            Weight2=WeightedBin[Index2];
                        }
                        else{
                            Index1=IndexMax;
                            Index2=WeightedBin[IndexMax+1]>WeightedBin[IndexMax-1]?IndexMax+1:IndexMax-1;
                            Weight1=WeightedBin[Index1];
                            Weight2=WeightedBin[Index2];
                        }
                        for (int m=0; m<numbmodal; m++) {
                            
                            if (DataCorrected[m*numelmasked+i]<MinPossible[Index1+m*NumberLaminae]) {
                                MinPossible[Index1+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
                            }
                            if (DataCorrected[m*numelmasked+i]<MinPossible[Index2+m*NumberLaminae]) {
                                MinPossible[Index2+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
                            }
                            if (DataCorrected[m*numelmasked+i]>MaxPossible[Index1+m*NumberLaminae]) {
                                MaxPossible[Index1+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
                            }
                            if (DataCorrected[m*numelmasked+i]>MaxPossible[Index2+m*NumberLaminae]) {
                                MaxPossible[Index2+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
                            }
                            MeanPossible[Index1+m*NumberLaminae]+=LesionDataSeg_masked[i]*DataCorrected[m*NumberLaminae+i]*Weight1;
                            MeanPossible[Index2+m*NumberLaminae]+=LesionDataSeg_masked[i]*DataCorrected[m*NumberLaminae+i]*Weight2;
                        }
                        SumTotPossible[Index1]+=LesionDataSeg_masked[i]*Weight1;
                        SumTotPossible[Index2]+=LesionDataSeg_masked[i]*Weight2;
                    }
                    break;
                default: // We have more than three important weights, we should not consider this point in the estimation process
                    break;
            }
            
            //                int IndexBin=floor(LengthNormSol_masked[i]/sizeBin);
            //                IndexBin=IndexBin>=NumberLaminae?NumberLaminae-1:IndexBin;
            //                    for (int m=0; m<numbmodal; m++) {
            //
            //                        if (DataCorrected[m*numelmasked+i]<MinPossible[IndexBin+m*NumberLaminae]) {
            //                            MinPossible[IndexBin+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
            //                        }
            //                        if (DataCorrected[m*numelmasked+i]>MaxPossible[IndexBin+m*NumberLaminae]) {
            //                            MaxPossible[IndexBin+m*NumberLaminae]=DataCorrected[m*numelmasked+i];
            //                        }
            //                        MeanPossible[IndexBin+m*NumberLaminae]+=LesionDataSeg_masked[i]*DataCorrected[m*NumberLaminae+i];
            //                    }
            //                SumTotPossible[IndexBin]+=LesionDataSeg_masked[i];
        }
    }
    
    // Get the mean of the normal healthy WM (global for the moment but we may do it
    MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    float * MeanHealthyWM=MeanGeneralClasses[segment_analysis->IndexWM];
    
    //    Get the ratio for Min,Mean and Max and store them consecutively in  Result min mean max for each layer of modality 1,...
    int sizeResultModal=3*NumberLaminae;
    for (int m=0; m<numbmodal; m++) {
        for (int l=0; l<NumberLaminae; l++) {
            ResultLayersIntensities[m*sizeResultModal+3*l]=MinPossible[m*NumberLaminae+l]/MeanHealthyWM[m];
            ResultLayersIntensities[m*sizeResultModal+3*l+1]=MeanPossible[m*NumberLaminae+l]/(SumTotPossible[l]*MeanHealthyWM[m]);
            ResultLayersIntensities[m*sizeResultModal+3*l+2]=MaxPossible[m*NumberLaminae+l]/MeanHealthyWM[m];
        }
    }
    
    
    //    Clearing memory and returning result;
    int numbClasses=MeanGeneralClasses.size();
    for (int c=0; c<numbClasses; c++) {
        delete [] MeanGeneralClasses[c];
        MeanGeneralClasses[c]=NULL;
    }
    delete [] MaxPossible;
    delete [] MinPossible;
    delete [] SumTotPossible;
    delete [] MeanPossible;
    MaxPossible=NULL;
    MinPossible=NULL;
    SumTotPossible=NULL;
    MeanPossible=NULL;
    
    return ResultLayersIntensities;
    
}



// Returns in an int array the minimal and maximal laminae on which each lesion connected component spans. The int array is of size 3*MaxLabel in order to return both the minimum and the maximum laminae (For each label alternance of minimum and maximum)
int * ExtentLesionNormDist(int * LesionLabel, float * SolNormDist, int NumberLaminae,  int * L2S, int * S2L, int numelmasked ){
    // First Create the short version from the LesionLabel
    int * LesionLabelShort=CreateShort(LesionLabel, S2L, numelmasked);
    float * SolNormDist_s=CreateShort(SolNormDist, S2L, numelmasked);
    int MaxLabel=GetMaxLabel(LesionLabelShort, numelmasked);
    if (MaxLabel==0) {
        return NULL;
    }
    // Initialise the result
    int * ResultExtent=new int[3*MaxLabel];
    for (int l=0; l<MaxLabel; l++) {
        ResultExtent[3*l]=l+1; // We need to keep the label as well in case some have been discarded earlier or if some are not included in the current max. Note that if some labels between 0 and MaxLabel have been discarded earlier, they will appear but the corresponding extent will not make sense
        ResultExtent[3*l+1]=NumberLaminae;
        ResultExtent[3*l+2]=-1;
    }
    float sizeBin=1.0/(NumberLaminae);
    // Browse through the LesionLabels to determine the extent
    for (int i=0; i<numelmasked; i++) {
        int Label=LesionLabelShort[i];
        if (Label>0) {
            int LaminaeBin=(int)(floor(SolNormDist_s[i]/sizeBin));
            if (LaminaeBin<ResultExtent[3*(Label-1)+1]) {
                ResultExtent[3*(Label-1)+1]=LaminaeBin;
            }
            if (LaminaeBin>ResultExtent[3*(Label-1)+2]) {
                ResultExtent[3*(Label-1)+2]=LaminaeBin;
            }
        }
    }
    delete [] LesionLabelShort;
    delete [] SolNormDist_s;
    LesionLabelShort=NULL;
    SolNormDist_s=NULL;
    return ResultExtent;
}



float * AnisotropicMorphologicalChange(float * CountHistogram1, int KernelSize, vector<int> dim, bool Value, float * PixDim){
    
    int numel=1;
    int numbDim=dim.size();
    float maxPixDim=GetMax(PixDim, numbDim);
    float minPixDim=GetMin(PixDim, numbDim);
    float * ratioPixDim=new float[numbDim];
    for (int d=0; d<numbDim; d++) {
        numel*=dim[d];
        ratioPixDim[d]=PixDim[d]/maxPixDim;
        ratioPixDim[d]=minPixDim/PixDim[d];
    }
    // To do filtering, kernel must be at least of size 2.
    KernelSize=KernelSize<3?3:KernelSize;
    int ChangeSign=Value==0?1:-1;
    
    // Construction of the kernel
    float * Kernel=new float[KernelSize];
    //    int kernelradius=KernelSize/2;
    for(int i =0;i<KernelSize;i++){
        Kernel[i]=1;
    }
    
    
    // Construction of the Shift array
    int *  Shift=new int[numbDim];
    for(int c=0;c<numbDim;c++){
        if(c>0){
            Shift[c]=Shift[c-1]*dim[c-1];
        }
        else{
            Shift[c]=1;
        }
    }
    
    // Copying the initial array to erode
    int SizeHistogram=Shift[numbDim-1]*dim[numbDim-1];
    float * ErodedResult=new float[SizeHistogram];
    for (int i=0; i<SizeHistogram; i++) {
        ErodedResult[i]=CountHistogram1[i];
    }
    
    for(int c=0;c<numbDim;c++){ // To do the blurring in each direction
        for(int j=0;j<SizeHistogram/(dim[c]);j++){
            int i=0;
            int * RemainDim=new int[numbDim-1];
            int * IndRemainDim=new int[numbDim-1];
            int * RemainShift=new int[numbDim-1];
            int * FinalShift=new int[numbDim-1];
            for(int i=0;i<numbDim-1;i++){
                RemainShift[i]=1;
                FinalShift[i]=1;
            }
            for(int d=0;d<numbDim;d++){
                if(d!=c){
                    RemainDim[i]=dim[d];
                    IndRemainDim[i]=d;
                    i++;
                }
            }
            for(int i=0;i<numbDim-1;i++){
                if(i>0){
                    RemainShift[i]=RemainShift[i-1]*RemainDim[i-1];
                }
            }
            int t=j;
            int tmp=0;
            int * Index=new int[numbDim-1];
            for(int i=numbDim-2;i>=0;i--){
                tmp=t/RemainShift[i];
                t=t-tmp*RemainShift[i];
                Index[i]=tmp;
            }
            for(int i=0;i<numbDim-1;i++){
                if(c<IndRemainDim[i]){
                    FinalShift[i]=dim[c]*RemainShift[i];
                }
                else{
                    FinalShift[i]=RemainShift[i];
                }
            }
            int FinalIndex=0;
            for(int i=0;i<numbDim-1;i++){
                FinalIndex+=Index[i]*FinalShift[i];
            }
            for(int i=0;i<dim[c];i++){
                
                //                float tmpkernel=0;
                int FinalIndexB=FinalIndex+i*Shift[c];
                if ((CountHistogram1[FinalIndexB]-Value)*ChangeSign<1) {
                    
                    //                    float SumKernelTmp=0;
                    for(int k=0;k<KernelSize;k++){
                        if(i-KernelSize/2+k>=0 && i-KernelSize/2+k<dim[c]){ // Only when remains in image considered for kernel. Main pb is that the kernel is then not normalised anymore
                            if (CountHistogram1[FinalIndexB+(-KernelSize/2+k)*Shift[c]]==!Value) {
                                ErodedResult[FinalIndexB]+=ChangeSign*ratioPixDim[c];
                            }
                        }
                    }
                    ErodedResult[FinalIndexB]=ErodedResult[FinalIndexB]>1?1:ErodedResult[FinalIndexB];
                    ErodedResult[FinalIndexB]=ErodedResult[FinalIndexB]<0?0:ErodedResult[FinalIndexB];
                }
            }
            delete [] Index;
            Index=NULL;
            if(RemainShift!=NULL){
                delete [] RemainShift;
                RemainShift=NULL;
            }
            if(RemainDim!=NULL){
                delete [] RemainDim;
                RemainDim=NULL;
            }
            if(IndRemainDim!=NULL){
                delete [] IndRemainDim;
                IndRemainDim=NULL;
            }
            if(FinalShift!=NULL){
                delete [] FinalShift;
                FinalShift=NULL;
            }
        }
        //        float sumNorm=0;
        
        //        for(int l=0;l<SizeHistogram;l++){
        //            Gaussian_tmp[l]/=sumNorm;
        //        }
        
    }
    delete [] Kernel;
    Kernel=NULL;
    delete [] Shift;
    Shift=NULL;
    return ErodedResult;
}












float * Erosion_bis(float * CountHistogram1, int KernelSize, vector<int> dim, bool Value){
    
    int numel=1;
    int numbDim=dim.size();
    for (int d=0; d<numbDim; d++) {
        numel*=dim[d];
    }
    bool * CountHistogram=TranscribeArray<float, bool>(CountHistogram1, numel);
    // To do filtering, kernel must be at least of size 2.
    KernelSize=KernelSize<3?3:KernelSize;
    
    // Construction of the kernel
    float * Kernel=new float[KernelSize];
    //        int kernelradius=KernelSize/2;
    for(int i =0;i<KernelSize;i++){
        Kernel[i]=1;
    }
    
    
    // Construction of the Shift array
    int *  Shift=new int[numbDim];
    for(int c=0;c<numbDim;c++){
        if(c>0){
            Shift[c]=Shift[c-1]*dim[c-1];
        }
        else{
            Shift[c]=1;
        }
    }
    
    // Copying the initial array to erode
    int SizeHistogram=Shift[numbDim-1]*dim[numbDim-1];
    bool * ErodedResult=new bool[SizeHistogram];
    for (int i=0; i<SizeHistogram; i++) {
        ErodedResult[i]=CountHistogram[i];
    }
    
    for(int c=0;c<numbDim;c++){ // To do the blurring in each direction
        for(int j=0;j<SizeHistogram/(dim[c]);j++){
            int i=0;
            //            int RemainDim[numbDim-1];
            //            int IndRemainDim[numbDim-1];
            //            int RemainShift[numbDim-1];
            //            int FinalShift[numbDim-1];
            int * RemainDim=new int[numbDim-1];
            int * IndRemainDim=new int[numbDim-1];
            int * RemainShift=new int[numbDim-1];
            int * FinalShift=new int[numbDim-1];
            for(int i=0;i<numbDim-1;i++){
                RemainShift[i]=1;
                FinalShift[i]=1;
            }
            for(int d=0;d<numbDim;d++){
                if(d!=c){
                    RemainDim[i]=dim[d];
                    IndRemainDim[i]=d;
                    i++;
                }
            }
            for(int i=0;i<numbDim-1;i++){
                if(i>0){
                    RemainShift[i]=RemainShift[i-1]*RemainDim[i-1];
                }
            }
            int t=j;
            int tmp=0;
            int * Index=new int[numbDim-1];
            for(int i=numbDim-2;i>=0;i--){
                tmp=t/RemainShift[i];
                t=t-tmp*RemainShift[i];
                Index[i]=tmp;
            }
            for(int i=0;i<numbDim-1;i++){
                if(c<IndRemainDim[i]){
                    FinalShift[i]=dim[c]*RemainShift[i];
                }
                else{
                    FinalShift[i]=RemainShift[i];
                }
            }
            int FinalIndex=0;
            for(int i=0;i<numbDim-1;i++){
                FinalIndex+=Index[i]*FinalShift[i];
            }
            for(int i=0;i<dim[c];i++){
                
                //                    float tmpkernel=0;
                int FinalIndexB=FinalIndex+i*Shift[c];
                if (ErodedResult[FinalIndexB]==Value) {
                    
                    //                    float SumKernelTmp=0;
                    for(int k=0;k<KernelSize;k++){
                        if(i-KernelSize/2+k>=0 && i-KernelSize/2+k<dim[c]){ // Only when remains in image considered for kernel. Main pb is that the kernel is then not normalised anymore
                            if (CountHistogram[FinalIndexB+(-KernelSize/2+k)*Shift[c]]==!Value) {
                                ErodedResult[FinalIndexB]=!Value;
                            }
                        }
                    }
                }
            }
            delete [] Index;
            Index=NULL;
            if(RemainShift!=NULL){
                delete [] RemainShift;
                RemainShift=NULL;
            }
            if(RemainDim!=NULL){
                delete [] RemainDim;
                RemainDim=NULL;
            }
            if(IndRemainDim!=NULL){
                delete [] IndRemainDim;
                IndRemainDim=NULL;
            }
            if(FinalShift!=NULL){
                delete [] FinalShift;
                FinalShift=NULL;
            }
        }
        //            float sumNorm=0;
        
        //        for(int l=0;l<SizeHistogram;l++){
        //            Gaussian_tmp[l]/=sumNorm;
        //        }
        
    }
    //        delete [] Gaussian_tmp2;
    //        Gaussian_tmp2=NULL;
    delete [] Kernel;
    Kernel=NULL;
    delete [] Shift;
    Shift=NULL;
    float * FinalEroded=TranscribeArray<bool, float>(ErodedResult, numel);
    delete [] ErodedResult;
    ErodedResult=NULL;
    return FinalEroded;
    
}




bool * Dilation(bool * ToDilate, int DilationValue, int * Dim, int * Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    bool * Dilated=new bool[numel];
    for (int i=0; i<numel; i++) {
        Dilated[i]=0;
    }
    for (int i=0; i<numel; i++) {
        if (ToDilate[i]) {
            Dilated[i]=1;
            int ListNeighbours[6];
            GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
            //            int * ListNeighbours=GetListNeighbours(i, Dim, Shift, 6);
            for (int n=0;n<6;n++) {
                if (ToDilate[ListNeighbours[n]]==0 && ListNeighbours[n]!=i) {
                    vector<int> ListExplo=IndicesToExploreVector(i, DilationValue, Dim, Shift);
                    int numbList=ListExplo.size();
                    if (numbList==0) {
                        cout<<"nothing in explore..."<<endl;
                    }
                    for (int l=0; l<numbList; l++) {
                        Dilated[ListExplo[l]]=1;
                    }
                    break;
                }
            }
            //            delete [] ListNeighbours;
            //            ListNeighbours=NULL;
            
            //            int * ListNeighbours=GetListNeighbours(i, Dim, Shift, 26);
            //            int * Coord=CorrespondingCoordinates(i, Dim, Shift);
            //            for (int n=0; n<26; n++) {
            //                if (!ToDilate[ListNeighbours[n]] && ListNeighbours[n]!=i) {
            //                    for (int l=0; l<Dilation; l++) {
            //                        for (int d=0; d<3; d++) {
            //                            int newValue=Coord[d]+l;
            //                            if (newValue>0 && newValue<=Dim[d]-1) {
            //                                Dilated[i+Shift[d]*l]=1;
            //                            }
            //                            newValue=Coord[d]-l;
            //                            if (newValue>0 && newValue<=Dim[d]-1) {
            //                                Dilated[i-Shift[d]*l]=1;
            //                            }
            //                        }
            //                    }
            //                }
            //            }
        }
    }
    return Dilated;
}


// Save TemporaryResult based on existing nifti_image float
void  SaveTmpResult(float * ResultToSave, string FilenameToSave, nifti_image * ImageToUse){
    // Create Image to fill with ResultToSave
    nifti_image * ImageToFill=nifti_copy_nim_info(ImageToUse);
    ImageToFill->data=(void *)calloc(ImageToFill->nvox, sizeof(float));
    float * Filling_PTR=static_cast<float *>(ImageToFill->data);
    int numel=ImageToFill->nvox;
    for (int i=0; i<numel; i++) {
        Filling_PTR[i]=ResultToSave[i];
    }
    nifti_set_filenames(ImageToFill, FilenameToSave.c_str(), 0, 0);
    nifti_image_write(ImageToFill);
    nifti_image_free(ImageToFill);
    ImageToFill=NULL;
    return;
}

// Save vector of float in 4D image given a 3D image
void  SaveTmpResult(vector<float *> ResultToSave, string FilenameToSave, nifti_image * ImageToUse){
    // Create Image to fill with ResultToSave
    nifti_image * ImageToFill=nifti_copy_nim_info(ImageToUse);
    ImageToFill->dim[0]=ResultToSave.size()>1?4:3;
    ImageToFill->dim[4]=ResultToSave.size();
    nifti_update_dims_from_array(ImageToFill);
    int numbClasses=ResultToSave.size();
    ImageToFill->data=(void *)calloc(ImageToFill->nvox, sizeof(float));
    float * Filling_PTR=static_cast<float *>(ImageToFill->data);
    int numel=ImageToFill->nx*ImageToFill->ny*ImageToFill->nz;
    for (int i=0; i<numel; i++) {
        for (int n=0; n<numbClasses; n++) {
            Filling_PTR[i+n*numel]=ResultToSave[n][i];
        }
    }
    nifti_set_filenames(ImageToFill, FilenameToSave.c_str(), 0, 0);
    nifti_image_write(ImageToFill);
    nifti_image_free(ImageToFill);
    ImageToFill=NULL;
    return;
}

// Create L2S and S2L that are needed to avoid time consuming operations when calculating gradients...
int * MakeL2S(bool * Mask, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int * L2S= new int [numel];
    bool * Mask_PTR = Mask;
    int * L2S_PTR = L2S;
    int tempindex=0;
    
    if (Mask!=NULL) {
        for (int i=0; i<numel; i++,Mask_PTR++,L2S_PTR++) {
            if ((*Mask_PTR)>0) {
                (*L2S_PTR)=tempindex;
                tempindex++;
                
            }
            else{
                (*L2S_PTR)=-1;
            }
        }
    }
    
    else { // If Mask is NULL, all are considered as active
        for (int i=0; i<numel; i++,L2S_PTR++) {
            *L2S_PTR=i;
        }
    }
    return L2S;
}

float GetSum(float * ArrayToSum, int numel){
    float Sum=0;
    for (int i=0;i<numel;i++){
        Sum+=ArrayToSum[i];
    }
    return Sum;
}

float GetMax(float * ArrayToMax,int numel){
    float MaxFound=-1E18;
    for (int i=0; i<numel; i++) {
        if (MaxFound<ArrayToMax[i]) {
            MaxFound=ArrayToMax[i];
        }
    }
    return MaxFound;
}

float GetMin(float * ArrayToMin,int numel){
    float MinFound=1E18;
    for (int i=0; i<numel; i++) {
        if (MinFound>ArrayToMin[i]) {
            MinFound=ArrayToMin[i];
        }
    }
    return MinFound;
}

// Creates a S2L array of index as integers
int * MakeS2L(bool * Mask, int * Dim, int & numelmasked){
    int numel = Dim[0]*Dim[1]*Dim[2];
    numelmasked=0;
    if(Mask==NULL){
        numelmasked=numel;
        int * S2L=new int[numel];
        for (int i=0; i<numel; i++) {
            S2L[i]=i;
        }
        return S2L;
    }
    bool * Mask_PTR = Mask;
    for (int i=0; i<numel; i++) {
        if (Mask[i]>0) {
            numelmasked++;
        }
    }
    int * S2L=new int[numelmasked];
    int * S2L_PTR=S2L;
    int tempindex=0;
    for (int i=0; i<numel; i++) {
        if ((*Mask_PTR)>0) {
            S2L_PTR[tempindex]=i;
            tempindex++;
        }
        Mask_PTR++;
    }
    return S2L;
    
}


/********************** METHODS FOR FINDING CORRESPONDING STANDARD SPACE ANGLE *************************/

// Read text file containing affine transformation and return corresponding 4 by 4 float array
float * ReadAffineFromTextFile(string TreeTextFile){
    ifstream text (TreeTextFile.c_str());
    if(!text){
        std::cout<<"could not open the text file properly ! in ReadAffineFromTextFile"<<endl;
        return NULL;
    }
    else{
        float * ReadMatrix=new float[16];
        for (int i=0; i<16; i++) {
            ReadMatrix[i]=0;
        }
        std::string line;
        for (int l=0; l<4; l++) {
            getline(text,line);
            istringstream in(line);
            for (int l1 =0; l1<4; l1++) {
                float value;
                in >> value;
                //                ReadMatrix[l*4+l1]=value;
                ReadMatrix[l+4*l1]=value;
            }
        }
        return ReadMatrix;
    }
}

// Read text file containing affine transformation and return corresponding mat44
mat44 ReadAffineFromTextFilemat44(string TreeTextFile){
    mat44 ReturnM;
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            ReturnM.m[i][j]=0;
        }
    }
    ifstream text (TreeTextFile.c_str());
    if(!text){
        std::cout<<"could not open the text file properly ! in ReadAffineFromTextFilemat44"<<endl;
        return ReturnM;
    }
    else{
        std::string line;
        for (int l=0; l<4; l++) {
            getline(text,line);
            istringstream in(line);
            for (int l1 =0; l1<4; l1++) {
                float value;
                in >> value;
                ReturnM.m[l][l1]=value;
            }
        }
        return ReturnM;
    }
}

// Transform a mat44 into a float array of size 16
void TranscribeMat44(mat44 M, float * TranscribedM){
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            TranscribedM[i*4+j]=M.m[j][i];
        }
    }
    return;
}

// Transform a float array of size 16 into a mat44
mat44 TranscribeFloatToMat44(float * MToTranscribe){
    mat44 TranscribedM;
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            TranscribedM.m[i][j]=MToTranscribe[i*4+j];
        }
    }
    return TranscribedM;
}

// Given an index, the dimension of the image and the global transformation (Combination of ijk to xyz and xyz to template space), give the corresponding x y z float array
void TransformedIndexToTemplateXYZ(mat44 * Transformation, int Index, int * Dim, float * xyz){
    
    //    First determination of index coordinates
    int Shift[3];
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Dim[1]*Shift[1];
    int Coordinates[3];
    float CoordinatesF[3];
    int tmp=Index;
    for (int d=2; d>=0; d--) {
        Coordinates[d]=tmp/Shift[d];
        tmp-=Coordinates[d]*Shift[d];
        CoordinatesF[d]=Coordinates[d];
    }
    //    Then calculation of xyz given what we have
    seg_mat44_mul(Transformation, CoordinatesF, xyz);
}


// Get as a float Theta angle from index, Transformation and dim
float ThetaAngleFromXYZ(float * XYZ){
    float ValueToACos=sqrtf(fabsf(XYZ[2])/(XYZ[0]*XYZ[0]+XYZ[1]*XYZ[1]+XYZ[2]*XYZ[2]));
    return acosf(ValueToACos);
}


//Get as a float phi angle from XYZ (presumably obtained)
float PhiAngleFromXYZ(float * XYZ){
    return atan2f(XYZ[1], XYZ[0]);
}

//Given a boolean (mask or border) array of size numel, the dimension and the transformation, returns the corresponding float array with the theta values at the true values of the boolean mask
float * ThetaAngleBorder(bool * MaskToTheta, mat44 * Transfo, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    float * ThetaArray=new float[numel];
    for (int i=0; i<numel; i++) {
        ThetaArray[i]=0;
        if (MaskToTheta[i]==1) {
            float XYZtmp[3];
            TransformedIndexToTemplateXYZ(Transfo , i, Dim, XYZtmp);
            ThetaArray[i]=ThetaAngleFromXYZ(XYZtmp);
        }
    }
    return ThetaArray;
}


// Same as before but for angle phi
float * PhiAngleBorder(bool * MaskToPhi, mat44 * Transfo, int * Dim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    float * PhiArray=new float[numel];
    for (int i=0; i<numel; i++) {
        PhiArray[i]=0;
        if (MaskToPhi[i]==1) {
            float XYZtmp[3];
            TransformedIndexToTemplateXYZ(Transfo , i, Dim, XYZtmp);
            PhiArray[i]=PhiAngleFromXYZ(XYZtmp);
        }
    }
    return PhiArray;
}

nifti_image * CreateQuadrantResult(nifti_image * SegLesBasis, SEG_ANALYSIS * segment_analysis, TreeEM* TreeToAnalyse){
    nifti_image * QuadrantResult=NULL;
    if (segment_analysis->flag_MNITransform && segment_analysis->flag_MNITemplate) {
        
    nifti_image * MNITemplate=ReadFromFilename(segment_analysis->filename_MNITemplate);
    
    mat44 MNIMatCorrToInd=MNITemplate->qto_ijk;
    float CentreMNI_xyz[4];
    for (int d=0; d<3; d++) {
        CentreMNI_xyz[d]=0;
    }
    CentreMNI_xyz[3]=1;
    
    mat44 ImageMatCorrToWorld=SegLesBasis->qto_xyz;
    float * TransfoMatrix=ReadAffineFromTextFile(segment_analysis->filename_MNITransform);
    float * MNIMatToInd=new float[16];
    TranscribeMat44(MNIMatCorrToInd, MNIMatToInd);
    float * ImageMatToWorld=new float[16];
    //            int SizeMatVec[4];
    //            SizeMatVec[0]=4;
    //            SizeMatVec[1]=4;
    //            SizeMatVec[2]=4;
    //            SizeMatVec[3]=1;
    //            float * CentreMNI_ijk=TreeToAnalyse->ProductMatrix(MNIMatToInd, CentreMNI_xyz, SizeMatVec);
    
    int SizeTransfo[4];
    SizeTransfo[0]=4;
    SizeTransfo[1]=4;
    SizeTransfo[2]=4;
    SizeTransfo[3]=4;

    TranscribeMat44(ImageMatCorrToWorld, ImageMatToWorld);
    float * Transfo1=TreeToAnalyse->ProductMatrix(TransfoMatrix, ImageMatToWorld,SizeTransfo);
    
    //            float * TransfoTot=TreeToAnalyse->ProductMatrix(MNIMatToInd, Transfo1, SizeTransfo);
    //            Normally the direct multiplication of the coordinates vector will give the corresponding coordinate vector in the MNI template thus allowing for the separation in quadrants
    
    //            Create the quadrant image according to code for quadrants
    QuadrantResult=QuadrantTransformation(Transfo1,CentreMNI_xyz, SegLesBasis,TreeToAnalyse->GetL2S());


    if (Transfo1!=NULL) {
        delete [] Transfo1;
        Transfo1=NULL;
    }
    if (TransfoMatrix!=NULL) {
        delete [] TransfoMatrix;
        TransfoMatrix=NULL;
    }
    if (MNITemplate!=NULL) {
        nifti_image_free(MNITemplate);
        MNITemplate=NULL;
    }
    }
    return QuadrantResult;

}

nifti_image * QuadrantTransformation(float * TransfoTot,float * CoordinatesCenterMNI, nifti_image * SegLesBasis, int * L2S){
    if (SegLesBasis==NULL) {
        return NULL;
    }
    //    Initialisation
    nifti_image * QuadrantResultImage=nifti_copy_nim_info(SegLesBasis);
    QuadrantResultImage->data=(void *)calloc(SegLesBasis->nvox, sizeof(float));
    float * QuadrantResultData=static_cast<float*>(QuadrantResultImage->data);
    int numel=SegLesBasis->nvox;
    int CoordInd[3];
    float CoordInd4[4];
    int Dim[3];
    int Shift[3];
    for (int d=0; d<3; d++) {
        CoordInd[d]=0;
        CoordInd4[d]=0;
        Dim[d]=SegLesBasis->dim[d+1];
    }
    CoordInd4[3]=1;
    Shift[0]=1;
    Shift[1]=Dim[0];
    Shift[2]=Shift[1]*Dim[1];
    TreeEM * TreeToUse=NULL;
    int SizeProd[4];
    SizeProd[0]=4;
    SizeProd[1]=4;
    SizeProd[2]=4;
    SizeProd[3]=1;
    //    Filling
    for (int i=0; i<numel; i++) {
        if (L2S[i]>=0 || L2S==NULL) {
            CorrespondingCoordinates_bis(CoordInd, i, Dim, Shift);
            for (int d=0; d<3; d++) {
                CoordInd4[d]=CoordInd[d];
            }
            float * ResultMNI= TreeToUse->ProductMatrix(TransfoTot, CoordInd4, SizeProd);
            if (i==1938087) {
                cout<<"Stopping for test..."<<endl;
                cout<<"Warning..."<<endl;
            }
            QuadrantResultData[i]=CodeQuadrant(ResultMNI, CoordinatesCenterMNI);
            if (ResultMNI!=NULL) {
                delete [] ResultMNI;
                ResultMNI=NULL;
            }
        }
    }
    return QuadrantResultImage;
}

float CodeQuadrant(float * CoordinatesResult, float * CoordinatesCenter){
    float CodeQuadrant=0;
    for (int d=0; d<3; d++) {
        CodeQuadrant+=(CoordinatesResult[d]>CoordinatesCenter[d]?2*pow_int(10,d):pow_int(10,d));
    }
    return CodeQuadrant;
}

int * CodePlaneFromQuadrant(nifti_image * QuadrantResult){
    int numel = QuadrantResult->nvox;
    int * PlaneCode=new int[numel];
    for (int i=0; i<numel; i++) {
        PlaneCode[i]=0;
    }
    int Dim[3];
    int Shift[3];
    for (int d=0; d<3; d++) {
        Dim[d]=QuadrantResult->dim[d+1];
        Shift[d]=d>0?Dim[d-1]*Shift[d-1]:1;
    }
    float * QuadrantData=static_cast<float*>(QuadrantResult->data);
//    First get all the planes as elements for which one of the direct neighbours is not equal
    int ListNeighbours[6];
    for (int i=0; i<numel; i++) {
        if (QuadrantData[i]!=0) {
            
        list<int> ValuesNeighbors;
        ValuesNeighbors.push_back(QuadrantData[i]);
        GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
        for (int n=0; n<6; n++) {
            if (QuadrantData[ListNeighbours[n]]!=0) {
                ValuesNeighbors.push_back(QuadrantData[ListNeighbours[n]]);
            }
        }
        ValuesNeighbors.sort();
        ValuesNeighbors.unique();
        int SizeList=ValuesNeighbors.size();
        if (SizeList>1) {
            set<int> DiffSet;
            std::list<int>::iterator it_b = ValuesNeighbors.begin();
            std::list<int>::iterator it_c = ValuesNeighbors.begin();
            std::advance(it_c, 1);
            for (int s=0; s<SizeList-1; s++) {
                int Diff=*it_c-*it_b;
                DiffSet.insert(Diff);
                if (it_c!=ValuesNeighbors.end()) {
                    advance(it_b, 1);
                    advance(it_c, 1);
                }
            }
            int SumDiff=0;
            SumDiff=std::accumulate<std::set<int>::iterator,int>(DiffSet.begin(),DiffSet.end(),0);
            PlaneCode[i]=SumDiff;
        }
    }
    }
    return PlaneCode;
}

bool * PlaneSelectionFromCode(int * PlaneCode, nifti_image * QuadrantCode, int DirFixed){
    int numel=QuadrantCode->nvox;
    bool * PlaneBool=new bool[numel];
    for (int i=0; i<numel; i++) {
        PlaneBool[i]=0;
    }
    for (int i=0; i<numel; i++) {
        if (PlaneCode[i]>0) {
            int Code[3];
            int tmp=PlaneCode[i];
            for (int d=2;d>=0; d--) {
                Code[d]=tmp/pow_int(10, d);
                tmp=tmp-Code[d]*pow_int(10,d);
            }
            if (Code[DirFixed]>0) {
                PlaneBool[i]=1;
            }
        }
        
    }
    return PlaneBool;
}

int * SidesFromQuadrant(nifti_image * QuadrantImage, int Dir){
    int numel=QuadrantImage->nvox;
    float * QuadrantData=static_cast<float*>(QuadrantImage->data);
    int * ResultSides=new int[numel];
    for (int i=0; i<numel; i++) {
        ResultSides[i]=0;
    }
    switch (Dir) {
            case 0:
        {
            for (int i=0; i<numel; i++) {
                if (QuadrantData[i]>0) {
                    ResultSides[i]=(int)QuadrantData[i]%10==1?1:2;
                }
            }
        }
            break;
            case 1:{
                for (int i=0; i<numel; i++) {
                    if (QuadrantData[i]>0) {
                        ResultSides[i]=(int)QuadrantData[i]%100<=20?1:2;
                    }
                }
            }
            break;
            case 2:{
                for (int i=0; i<numel; i++) {
                    if (QuadrantData[i]>0) {
                        ResultSides[i]=(int)QuadrantData[i]/100==1?1:2;
                    }
                }
            }
            break;
        default:
            break;
    }
    return ResultSides;
}

void CorrectingSegmentation(nifti_image * SegToAnalyse, bool * CorrectionToWithdraw){
    int numel=SegToAnalyse->nvox;
    int CountCorr=0;
    float * CorrectingData=static_cast<float*>(SegToAnalyse->data);
    if (CorrectionToWithdraw==NULL) {
        return;
    }
    for (int i=0; i<numel; i++) {
        if (CorrectionToWithdraw[i]) {
            if (CorrectingData[i]) {
                CountCorr++;
            }
            CorrectingData[i]=0;
        }
    }
    cout<<"Correction of "<<CountCorr<<" with this new correction"<<endl;
    return;
}


bool * ExternalGMBorderWM(nifti_image * SegToAnalyse, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    // First segment GM inliers
    float * NormRespGMI=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
    int numelmasked = TreeToAnalyse->GetNumberMaskedElements();
    int * L2S=TreeToAnalyse->GetL2S();
    int numel=TreeToAnalyse->GetNumberElements();
    bool * GMISeg=ThresholdArray<float, bool>(NormRespGMI, 0.4, numelmasked);
    bool * GMISegLong=CreateLong(GMISeg, L2S, numel);
    delete [] GMISeg;
    //    nifti_image * GMSegNii=CreateNiiFromArray(GMISegLong, SegToAnalyse, numel);
    //    int * CompGM=ComponentLabeling(GMISegLong, 6);
    if (segment_analysis->flag_inPriorsDGM && segment_analysis->flag_inPriorsICSF) {
        nifti_image * PriorsDGM=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
        nifti_image * PriorsICSF=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
        float * ICSFData=static_cast<float*>(PriorsICSF->data);
        float * DGMData=static_cast<float*>(PriorsDGM->data);
        for (int i=0; i<numel; i++) {
            if (DGMData[i]+ICSFData[i]>0 && GMISegLong[i]) {
                GMISegLong[i]=0;
            }
        }
        nifti_image_free(PriorsICSF);
        PriorsICSF=NULL;
        nifti_image_free(PriorsDGM);
        PriorsDGM=NULL;
    }
    vector<int>DimVector;
    DimVector.push_back(SegToAnalyse->dim[1]);
    DimVector.push_back(SegToAnalyse->dim[2]);
    DimVector.push_back(SegToAnalyse->dim[3]);
    bool * EnlargedGMI=ErosionTemplate(GMISegLong, 3, DimVector, 0);
    
    // Get distance to WMInliers
    bool * WMIShort=ThresholdArray<float, bool>(TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexWM)->GetNormResp(), 0.4, numelmasked);
    bool * WMI=CreateLong(WMIShort, L2S, numel);
    
    nifti_image * DistanceWM=EuclideanDistanceImage(SegToAnalyse, WMI, TreeToAnalyse->GetMask());
    //    Check situation for each voxel belonging to other than GM inliers with respect to mean distance
    float * DistOut=static_cast<float*>(DistanceWM->data);
    int ListNeighbours[6];
    int Dim[3];
    int Shift[3];
    Dim[0]=DimVector[0];
    Dim[1]=DimVector[1];
    Dim[2]=DimVector[2];
    Shift[0]=1;
    Shift[1]=DimVector[0];
    Shift[2]=Shift[1]*Dim[1];
    bool * ToSuppress=new bool[numel];
    for (int i=0; i<numel; i++) {
        ToSuppress[i]=0;
        if (EnlargedGMI[i]&&!GMISegLong[i]) {
            GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
            float AveDistOut=0;
            int CountAv=0;
            for (int n=0; n<6; n++) {
                if (GMISegLong[ListNeighbours[n]]) {
                    AveDistOut+=DistOut[ListNeighbours[n]];
                    CountAv++;
                }
            }
            if (CountAv>0) {
                AveDistOut/=CountAv;
            }
            if (DistOut[i]>=AveDistOut) {
                ToSuppress[i]=1;
            }
        }
    }
    nifti_image_free(DistanceWM);
    delete [] EnlargedGMI;
    delete [] GMISegLong;
    delete [] WMI;
    delete [] WMIShort;
    return ToSuppress;
    
}

// Provide a segmentation of the outside part of GM that should not be taken into account for lesion segmentation
bool * ExternalGMBorderCorrection(nifti_image * SegToAnalyse,TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    // First segment GM inliers
    float * NormRespGMI=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
    int numelmasked = TreeToAnalyse->GetNumberMaskedElements();
    int * L2S=TreeToAnalyse->GetL2S();
    int numel=TreeToAnalyse->GetNumberElements();
    bool * GMISeg=ThresholdArray<float, bool>(NormRespGMI, 0.4, numelmasked);
    bool * GMISegLong=CreateLong(GMISeg, L2S, numel);
    delete [] GMISeg;
//    nifti_image * GMSegNii=CreateNiiFromArray(GMISegLong, SegToAnalyse, numel);
//    int * CompGM=ComponentLabeling(GMISegLong, 6);
    if (segment_analysis->flag_inPriorsDGM && segment_analysis->flag_inPriorsICSF) {
        nifti_image * PriorsDGM=ReadFromFilename(segment_analysis->filename_inPriorsDGM);
        nifti_image * PriorsICSF=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
        float * ICSFData=static_cast<float*>(PriorsICSF->data);
        float * DGMData=static_cast<float*>(PriorsDGM->data);
        for (int i=0; i<numel; i++) {
            if (DGMData[i]+ICSFData[i]>0 && GMISegLong[i]) {
                GMISegLong[i]=0;
            }
        }
        nifti_image_free(PriorsICSF);
        PriorsICSF=NULL;
        nifti_image_free(PriorsDGM);
        PriorsDGM=NULL;
    }
    vector<int>DimVector;
    DimVector.push_back(SegToAnalyse->dim[1]);
    DimVector.push_back(SegToAnalyse->dim[2]);
    DimVector.push_back(SegToAnalyse->dim[3]);
    bool * EnlargedGMI=ErosionTemplate(GMISegLong, 3, DimVector, 0);
    
    // Get sum of Distance to Mask
    bool * MaskData=static_cast<bool*>(TreeToAnalyse->GetMask()->data);
    bool * OpposeMaskData=OpposeBoolArray(MaskData, numel);
    nifti_image * OpposeMaskNii=CreateNiiFromArray(OpposeMaskData, SegToAnalyse, numel);
    bool * TotalImage=new bool[numel];
    for (int i=0; i<numel; i++) {
        TotalImage[i]=1;
    }
    nifti_image * TotalImageNii=CreateNiiFromArray(TotalImage, SegToAnalyse, numel);
    nifti_image * DistanceOut=EuclideanDistanceImage(SegToAnalyse, OpposeMaskData, TotalImageNii);
//    Check situation for each voxel belonging to other than GM inliers with respect to mean distance
    nifti_image_free(TotalImageNii);
    float * DistOut=static_cast<float*>(DistanceOut->data);
    int ListNeighbours[6];
    int Dim[3];
    int Shift[3];
    Dim[0]=DimVector[0];
    Dim[1]=DimVector[1];
    Dim[2]=DimVector[2];
    Shift[0]=1;
    Shift[1]=DimVector[0];
    Shift[2]=Shift[1]*Dim[1];
    bool * ToSuppress=new bool[numel];
    for (int i=0; i<numel; i++) {
        ToSuppress[i]=0;
        if (EnlargedGMI[i]&&!GMISegLong[i]) {
            GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
            float AveDistOut=0;
            int CountAv=0;
            for (int n=0; n<6; n++) {
                if (GMISegLong[ListNeighbours[n]]) {
                    AveDistOut+=DistOut[ListNeighbours[n]];
                    CountAv++;
                }
            }
            if (CountAv>0) {
                AveDistOut/=CountAv;
            }
            if (DistOut[i]<=AveDistOut) {
                ToSuppress[i]=1;
            }
        }
    }
    nifti_image_free(DistanceOut);
    nifti_image_free(OpposeMaskNii);
    delete [] EnlargedGMI;
    delete [] GMISegLong;
    delete [] OpposeMaskData;
    return ToSuppress;
    
}

void CorrectWMI(TreeEM* TreeToAnalyse,nifti_image* ToCorrect,nifti_image* BaseCorrection, SEG_ANALYSIS* segment_analysis){
    vector<int> Modalities=segment_analysis->vecModalities;
    int IndexFLAIR;
    std::vector<int>::iterator it;
            it = find (Modalities.begin(), Modalities.end(), 3);
            if (it!=Modalities.end()){
                IndexFLAIR=std::distance(Modalities.begin(), it)+1;
            }
            else{
                IndexFLAIR=2;
            }
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    int numel=TreeToAnalyse->GetNumberElements();
    int * L2S = TreeToAnalyse->GetL2S();
    float * DataFloat=CreateLongPaddingMulti<float>(TreeToAnalyse->GetDataBFCorrected(),0.0,L2S,numel,numbmodal);
    float * DataFloatInterest=&DataFloat[numel*(IndexFLAIR-1)];
    float * ToCorr=static_cast<float*> (ToCorrect->data);
    float * BaseCorrFloat=static_cast<float*>(BaseCorrection->data);
    float * ToCorrMean=GetMeanDataMulti<float,float>(DataFloat,ToCorr,numel,numbmodal);
    vector<float> quantiles;
    quantiles.push_back(segment_analysis->thresh_quant);
    vector<float*> QuantCorr=GetQuantilesMulti<float,float>(DataFloat,BaseCorrFloat,numel,numbmodal,quantiles);
    cout << "Obtained Quant corr"<<endl;
    float * CorrMean=GetMeanDataMulti<float,float>(DataFloat,BaseCorrFloat,numel,numbmodal);
    cout<<"ToCorrMean "<<ToCorrMean[0]<<" "<<ToCorrMean[min(numbmodal-1,1)]<<" "<<IndexFLAIR<<endl;
    int CountCorr=0;
    for(int i=0;i<numel;i++){
        if(ToCorr[i]>0){
            if(DataFloatInterest[i]>QuantCorr[IndexFLAIR-1][0]){
                ToCorr[i]=0;
                CountCorr++;
            }
        }
    }
    cout <<"Correction done " << CountCorr<<endl;

    delete [] CorrMean;
    delete [] ToCorrMean;
    ToCorrMean=NULL;
    CorrMean=NULL;
    CorrMean=GetMeanDataMulti<float,float>(DataFloat,ToCorr,numel,numbmodal);
    delete [] DataFloat;
    cout<<"CorrMean "<<CorrMean[0]<<" "<<CorrMean[min(numbmodal-1,1)]<<" "<<IndexFLAIR<<" QuantCorr "<<QuantCorr[IndexFLAIR-1][0]<<endl;
    delete [] CorrMean;
    return;
}



bool * VentricleGMBorderCorrection(nifti_image * SegToAnalyse, TreeEM * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    float * NormRespGMI=TreeToAnalyse->GetNodeInlier()->GetChild(segment_analysis->IndexGM)->GetNormResp();
    int numelmasked = TreeToAnalyse->GetNumberMaskedElements();
    int * L2S=TreeToAnalyse->GetL2S();
    int numel=TreeToAnalyse->GetNumberElements();
    bool * GMISeg=ThresholdArray<float, bool>(NormRespGMI, 0.4, numelmasked);
    bool * GMISegLong=CreateLong(GMISeg, L2S, numel);
    delete [] GMISeg;
    //    nifti_image * GMSegNii=CreateNiiFromArray(GMISegLong, SegToAnalyse, numel);
    //    int * CompGM=ComponentLabeling(GMISegLong, 6);
    if ( segment_analysis->flag_inPriorsICSF) {
        nifti_image * PriorsICSF=ReadFromFilename(segment_analysis->filename_inPriorsICSF);
        float * ICSFData=static_cast<float*>(PriorsICSF->data);
        for (int i=0; i<numel; i++) {
            if (ICSFData[i]==0 && GMISegLong[i]) {
                GMISegLong[i]=0;
            }
        }
        nifti_image_free(PriorsICSF);
        PriorsICSF=NULL;
    }
    vector<int>DimVector;
    DimVector.push_back(SegToAnalyse->dim[1]);
    DimVector.push_back(SegToAnalyse->dim[2]);
    DimVector.push_back(SegToAnalyse->dim[3]);
    bool * EnlargedGMI=ErosionTemplate(GMISegLong, 3, DimVector, 0);
    
    // Get Distance to Out
    bool * MaskData=static_cast<bool*>(TreeToAnalyse->GetMask()->data);
    bool * OpposeMaskData=OpposeBoolArray(MaskData, numel);
    bool * TotalImage=new bool[numel];
    for (int i=0; i<numel; i++) {
        TotalImage[i]=1;
    }
    nifti_image * TotalImageNii=CreateNiiFromArray(TotalImage, SegToAnalyse, numel);
    nifti_image * OpposeMaskNii=CreateNiiFromArray(OpposeMaskData, SegToAnalyse, numel);
    nifti_image * DistanceOut=EuclideanDistanceImage(SegToAnalyse, OpposeMaskData, TotalImageNii);
    nifti_image_free(TotalImageNii);
    //    Check situation for each voxel belonging to other than GM inliers with respect to mean distance
    float * DistOut=static_cast<float*>(DistanceOut->data);
    int ListNeighbours[6];
    int Dim[3];
    int Shift[3];
    Dim[0]=DimVector[0];
    Dim[1]=DimVector[1];
    Dim[2]=DimVector[2];
    Shift[0]=1;
    Shift[1]=DimVector[0];
    Shift[2]=Shift[1]*Dim[1];
    bool * ToSuppress=new bool[numel];
    for (int i=0; i<numel; i++) {
        ToSuppress[i]=0;
        if (EnlargedGMI[i]&&!GMISegLong[i]) {
            GetListNeighbours_bis(ListNeighbours, i, Dim, Shift, 6);
            float AveDistOut=0;
            int CountAv=0;
            for (int n=0; n<6; n++) {
                if (GMISegLong[ListNeighbours[n]]) {
                    AveDistOut+=DistOut[ListNeighbours[n]];
                    CountAv++;
                }
            }
            if (CountAv>0) {
                AveDistOut/=CountAv;
            }
            if (DistOut[i]>AveDistOut) {
                ToSuppress[i]=1;
            }
        }
    }
    nifti_image_free(DistanceOut);
    nifti_image_free(OpposeMaskNii);
    delete [] EnlargedGMI;
    delete [] GMISegLong;
    delete [] OpposeMaskData;
    return ToSuppress;
}


bool * PotentialSPRegion(nifti_image * QuadrantImage, bool * VentricleSeg, bool * CGMBool, float DistanceThreshold, nifti_image * Mask ){
//    Before all, get all relevant info (numel Dim Shift PixDim...)
    int numel=QuadrantImage->nvox;
    int Dim[3];
    int Shift[3];
    float PixDim[3];
    for (int d=0; d<3; d++) {
        Dim[d]=QuadrantImage->dim[d+1];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
        PixDim[d]=QuadrantImage->pixdim[d+1];
    }
//    First Find the medial plane relevant for the analysis
    int * PlaneCode=CodePlaneFromQuadrant(QuadrantImage);
    bool * PlaneBool=PlaneSelectionFromCode(PlaneCode, QuadrantImage, 0);
//    bool * PlaneBoolMask=MultiplyElementwiseChoose<bool, bool, bool>(PlaneBool, static_cast<bool*>(Mask->data), numel);
    int * SeparateSides = SidesFromQuadrant(QuadrantImage, 0);
    bool * OpposedPlane=OpposeBoolArray(PlaneBool, numel);
    int * VentricleSides=MultiplyElementwiseChoose<bool, int, int>(VentricleSeg, SeparateSides, numel);
//    nifti_image * VentriclesSidesNii=CreateNiiFromArray(VentricleSides, QuadrantImage, numel);
//    nifti_set_filenames(VentriclesSidesNii, "/Users/Carole/Documents/PhD/CUSHING/VentriclesSides.nii.gz", 0, 0);
//    nifti_image_write(VentriclesSidesNii);
    bool * VentricleSide1=UpperThresholdArray<int, bool>(VentricleSides, 2, numel);
    bool * VentriclesSide2=ThresholdArray<int, bool>(VentricleSides, 1, numel);
//    Then obtain the distance map from it and threshold it
    nifti_image * DistanceSide1=EuclideanDistanceImage(QuadrantImage, VentricleSide1, Mask);
    nifti_image * DistanceSide2=EuclideanDistanceImage(QuadrantImage, VentriclesSide2, Mask);
//        nifti_image * DistancePlane=EuclideanDistanceImage(QuadrantImage, PlaneBool, Mask);
//    bool * ThresholdedDistancePlane=UpperThresholdArray<float, bool>(static_cast<float*>(DistancePlane->data), DistanceThreshold, numel);
    bool * ThresholdedDistanceSide1=UpperThresholdArray<float, bool>(static_cast<float*>(DistanceSide1->data), DistanceThreshold, numel);
    bool * ThresholdedDistanceSide2=UpperThresholdArray<float, bool>(static_cast<float*>(DistanceSide2->data), DistanceThreshold, numel);
//    Then obtain the distance map from the ventricles and threshold it
    nifti_image * DistanceVentricles=EuclideanDistanceImage(QuadrantImage, VentricleSeg, Mask);
    bool * ThresholdedDistanceVentr=UpperThresholdArray<float, bool>(static_cast<float*>(DistanceVentricles->data), DistanceThreshold, numel);
//    Then obtain the distance map from the CGMPriors and threshold it
    nifti_image * DistanceCGM=EuclideanDistanceImage(QuadrantImage, CGMBool, Mask);
    bool * ThresholdedDistanceCGM=ThresholdArray<float, bool>(static_cast<float*>(DistanceCGM->data), DistanceThreshold, numel);
//    Find the intersection of the two thresholded array.
//    nifti_image * CGMBoolNii=CreateNiiFromArray(ThresholdedDistanceCGM, QuadrantImage, numel);
//    nifti_set_filenames(CGMBoolNii, "/Users/Carole/Documents/PhD/BAMBI_ADNI/CGMThresh.nii.gz", 0, 0);
//    nifti_image_write(CGMBoolNii);
//    nifti_image_free(CGMBoolNii);
    
//    nifti_set_filenames(DistanceVentricles, "/Users/Carole/Documents/PhD/BAMBI_ADNI/DistanceVentricle.nii.gz", 0, 0);
////    nifti_set_filenames(DistancePlane, "/Users/Carole/Documents/PhD/BAMBI_ADNI/DistancePlane.nii.gz", 0, 0);
//    nifti_image_write(DistanceVentricles);
////    nifti_image_write(DistancePlane);
//     nifti_set_filenames(DistanceSide1, "/Users/Carole/Documents/PhD/BAMBI_ADNI/DistanceSide1.nii.gz", 0, 0);
//     nifti_set_filenames(DistanceSide2, "/Users/Carole/Documents/PhD/BAMBI_ADNI/DistanceSide2.nii.gz", 0, 0);
//    nifti_image_write(DistanceSide1);
//    nifti_image_write(DistanceSide2);
    
    
    bool * FinalSPZone=new bool[numel];
//    ANDOperationBool(ThresholdedDistancePlane, ThresholdedDistanceVentr, FinalSPZone, numel);
    ANDOperationBool(ThresholdedDistanceSide1, ThresholdedDistanceSide2, FinalSPZone, numel);
    nifti_image * FinalSPNii=CreateNiiFromArray(FinalSPZone, QuadrantImage, numel);
//    nifti_set_filenames(FinalSPNii, "/Users/Carole/Documents/PhD/CUSHING/DistanceIntersection.nii.gz", 0, 0);
//    nifti_image_write(FinalSPNii);
    nifti_image_free(FinalSPNii);
    ANDOperationBool(FinalSPZone, ThresholdedDistanceCGM, FinalSPZone, numel);
    delete [] ThresholdedDistanceVentr;
//    delete [] ThresholdedDistancePlane;
    delete [] PlaneBool;
    delete [] PlaneCode;
//    nifti_image_free(DistancePlane);
    nifti_image_free(DistanceVentricles);
    nifti_image_free(DistanceCGM);
    nifti_image_free(DistanceSide2);
    nifti_image_free(DistanceSide1);
//    nifti_image_free(OpposedPlaneNii);
    delete [] OpposedPlane;
    delete [] VentriclesSide2;
    delete [] VentricleSides;
    delete [] VentricleSide1;
    delete [] SeparateSides;
    return FinalSPZone;
}


/**************** TO DO HISTOGRAM MATCHING AND POLYNOMIAL FIT ***********/
float * HistogramFitting(float * RefData, float * FloatData, int numel, int FittingOrder){
    //    Check and initialise
    if (RefData==NULL || FloatData==NULL) {
        return NULL;
    }
    int sizeCoeffs=FittingOrder+1;
    float * CoeffResults=NULL;
    //    Create the big matrix with different powers.
    float * FloatMatrixForLS=new float[numel*sizeCoeffs];
    int sizeAMatrix=numel*sizeCoeffs;
    for (int i=0; i<sizeAMatrix; i++) {
        FloatMatrixForLS[i]=0;
    }
    for (int o=0; o<sizeCoeffs; o++) {
        for (int i=0; i<numel; i++) {
            FloatMatrixForLS[i+numel*o]=pow_int(FloatData[i], o);
        }
    }
    
    //    Then steps for pseudo inverse calculation
    TreeEM * TreeUse=NULL;
    float * TransposedFloatMatrixForLS=TreeUse->TransposeMatrix(FloatMatrixForLS, numel, sizeCoeffs);
    int SizeProduct[4];
    SizeProduct[0]=sizeCoeffs;
    SizeProduct[1]=numel;
    SizeProduct[2]=numel;
    SizeProduct[3]=sizeCoeffs;
    
    float * PreCoeff=TreeUse->ProductMatrix(TransposedFloatMatrixForLS, FloatMatrixForLS, SizeProduct);
    float * InvPreCoeff=TreeUse->InvertMatrix(PreCoeff, sizeCoeffs);
    SizeProduct[1]=sizeCoeffs;
    SizeProduct[2]=sizeCoeffs;
    SizeProduct[3]=numel;
    float * PreCoeffFinal=TreeUse->ProductMatrix(InvPreCoeff, TransposedFloatMatrixForLS, SizeProduct);
    SizeProduct[1]=numel;
    SizeProduct[2]=numel;
    SizeProduct[3]=1;
    CoeffResults=TreeUse->ProductMatrix(PreCoeffFinal, RefData, SizeProduct);
    
    //    Cleaning everything before returning
    if (PreCoeff!=NULL) {
        delete [] PreCoeff;
        PreCoeff=NULL;
    }
    if (FloatMatrixForLS!=NULL){
        delete [] FloatMatrixForLS;
        FloatMatrixForLS=NULL;
    }
    if (TransposedFloatMatrixForLS!=NULL) {
        delete [] TransposedFloatMatrixForLS;
        TransposedFloatMatrixForLS=NULL;
    }
    if (PreCoeffFinal!=NULL) {
        delete [] PreCoeffFinal;
        PreCoeffFinal=NULL;
    }
    if (InvPreCoeff!=NULL) {
        delete [] InvPreCoeff;
        InvPreCoeff=NULL;
    }
    
    return CoeffResults;
}

// From the two vectors of string filename refering to images (either both merged or both separated), perform the histogram matching given the order of fit and return in a float array, the series of corresponding coefficient for each modalities
vector<float> CompleteHistogramMatching(SEG_ANALYSIS * segment_analysis,bool * Mask=NULL){
    vector<char *> RefImagesFileNameChar=segment_analysis->filename_RefImages;
    vector<char *> FloatImagesFileNameChar=segment_analysis->filename_FloatImages;
    int sizeMaskVec = segment_analysis->filename_vectorMask.size();
    int orderFit=segment_analysis->orderMatch;
    int sizeVector=RefImagesFileNameChar.size();
    vector<float> FinalCoeffs;
    if (RefImagesFileNameChar.size() !=FloatImagesFileNameChar.size() ||(sizeMaskVec>1 && sizeMaskVec!=FloatImagesFileNameChar.size()) || sizeVector==0) {
        cout<<"Not same size for matching so impossible or void vector "<< RefImagesFileNameChar.size()<<" and "<<FloatImagesFileNameChar.size()<<endl;
        
        return FinalCoeffs;
    }
    
    vector<string> RefImagesFileName;
    vector<string> FloatImagesFileName;
    vector<string> MaskImagesFileName;
    for (int s=0; s<sizeVector; s++) {
        RefImagesFileName.push_back(RefImagesFileNameChar[s]);
        FloatImagesFileName.push_back(FloatImagesFileNameChar[s]);
        if(sizeMaskVec>1){
            MaskImagesFileName.push_back(segment_analysis->filename_vectorMask[s]);
        }
//        else if(segment_analysis->flag_maskMatch){
//            MaskImagesFilename.push_back(segment_analysis->filename_maskMatch);
//        }
//        else if(segment_analysis->flag_mask){
//            MaskImagesFileName.push_back(segment_analysis->filename_mask);
//        }
    }
    
    vector<nifti_image*> RefImages=ReadFromFilenamesVector(RefImagesFileName);
    vector<nifti_image*> FloatImages=ReadFromFilenamesVector(FloatImagesFileName);
    vector<nifti_image*> MaskImages=ReadFromFilenamesVector(MaskImagesFileName);
    //    Check for number of modalities per images and that they are compatible with each other and initialise final result
    //    bool flag_compModa=1;
    int numel=0;
    int sumModa=0;
    for (int s=0; s<sizeVector; s++) {
        int  numbmodalRef=RefImages[s]->nu*RefImages[s]->nt;
        int numbmodalFlo=FloatImages[s]->nu*FloatImages[s]->nt;
        int numelRef = RefImages[s]->nx*RefImages[s]->ny*RefImages[s]->nz;
        int numelFlo=FloatImages[s]->nx*FloatImages[s]->ny*FloatImages[s]->nz;
        if (numbmodalRef!=numbmodalFlo || numelFlo!=numelRef) {
            //            flag_compModa=0;
            return FinalCoeffs;
            break;
        }
        if(numel>0&&numel!=numelRef){
            cout<<"Images with not same numel"<<endl;
            return FinalCoeffs;
        }
        numel=numelRef;
        sumModa+=numbmodalRef;
    }
    int Dim[3];
    Dim[0]=RefImages[0]->nx;
    Dim[1]=RefImages[0]->ny;
    Dim[2]=RefImages[0]->nz;
    int numelmasked=0;
    int * S2L = NULL;
    if (sizeMaskVec==0){
        S2L=MakeS2L(Mask, Dim, numelmasked);
    }
    int sumModaTemp=0;
    for (int s=0; s<sizeVector; s++) {
        if (S2L==NULL){
            numelmasked=0;
            nifti_image * MaskTempNii=MaskImages[s];
            Binarisation(MaskTempNii);
            bool * MaskToUse = static_cast<bool*>(MaskTempNii->data);
            S2L=MakeS2L(MaskToUse, Dim, numelmasked);
        }
        int numbModalRef=RefImages[s]->nt*RefImages[s]->nu;
        float * RefData=static_cast<float * >(RefImages[s]->data);
        float * FloatData=static_cast<float *>(FloatImages[s]->data);
        for (int m=0; m<numbModalRef; m++) {
            float * RefDataModa= CreateShort(&RefData[numel*m], S2L, numelmasked);
            float * FloatDataModa=CreateShort(&FloatData[numel*m], S2L, numelmasked);
            float * CoeffsHistMatch=HistogramFitting(RefDataModa, FloatDataModa, numelmasked, orderFit);
            if (CoeffsHistMatch!=NULL) {
                for (int o=0; o<orderFit+1; o++) {
                    FinalCoeffs.push_back(CoeffsHistMatch[o]);
                    //                    FinalCoeffs[(orderFit+1)*sumModaTemp+o]=CoeffsHistMatch[o];
                }
            }
            sumModaTemp++;
            if (CoeffsHistMatch!=NULL) {
                delete [] CoeffsHistMatch;
                CoeffsHistMatch=NULL;
            }
            if (FloatDataModa!=NULL) {
                delete [] FloatDataModa;
                FloatDataModa=NULL;
            }
            if (RefDataModa!=NULL) {
                delete [] RefDataModa;
                RefDataModa=NULL;
            }

        }
        if (S2L !=NULL) {
            delete [] S2L;
            S2L=NULL;
        }
    }
    for (int s=0; s<sizeVector; s++) {
        if (RefImages[s]!=NULL) {
            nifti_image_free(RefImages[s]);
            RefImages[s]=NULL;
        }
        if (FloatImages[s]!=NULL) {
            nifti_image_free(FloatImages[s]);
            FloatImages[s]=NULL;
        }
        if(sizeMaskVec>1){
            if(MaskImages[s]!=NULL){
                nifti_image_free(MaskImages[s]);
            }
        }
    }

    return FinalCoeffs;
}


//Printing on a text file the results for the histogram matching. For each set of images, name of the reference image, name of the floating image then for the number of modalities, one line of coeffs for each modality
void PrintingCoeffsHistMatch(vector<float> CoeffsHist, SEG_ANALYSIS *segment_analysis, ostream& TxtFile){
    if (CoeffsHist.size()==0) { // meaning that there is no Coeffs hist to print
        return;
    }
    
    int sizeVector=segment_analysis->filename_RefImages.size();
    int sizeCoeffsUnit=segment_analysis->orderMatch+1;
    vector<char*> NamesRef=segment_analysis->filename_RefImages;
    vector<char*> NamesFloat=segment_analysis->filename_FloatImages;
    int currentModal=0;
    for (int s=0; s<sizeVector; s++) {
        nifti_image * RefImage=ReadFromFilename(segment_analysis->filename_RefImages[s]);
        int numbmodal=RefImage->nu*RefImage->nt;
        TxtFile << "RefImage "<<NamesRef[s]<<endl;
        TxtFile << "FloatImage "<<NamesFloat[s]<<endl;
        for (int m=0; m<numbmodal; m++) {
            TxtFile<<"Moda "<<m<<" ";
            for (int o=0; o<sizeCoeffsUnit; o++) {
                TxtFile<<CoeffsHist[o+currentModal*sizeCoeffsUnit]<<" ";
            }
            currentModal++;
            TxtFile<<endl;
        }
        TxtFile<<endl;
        if(RefImage!=NULL){
            nifti_image_free(RefImage);
            RefImage=NULL;
        }
    }
}

// Apply a polynomial change in a piecewise fashion according to the coeffs stored in the vector CoeffMatching. The changes from one piecewise to the other occur at Threshold
float * ApplyingPolyfitPiecewise(vector<vector<float> >AffineCoeffs,float * BlurredLesion,vector<float>TFTV,int numel){
    int sizePW=AffineCoeffs.size();
    int CheckPW=TFTV.size();
    if (sizePW !=CheckPW+1) {
        cout << "Pb in the number of piecewise to perform"<<endl;
        return NULL;
    }
    float * FinalTransformed= new float [numel];
    for (int i=0; i<numel; i++) {
        FinalTransformed[i]=-10;
    }
    for (int pw=0; pw<sizePW; pw++) {
        vector<float> CoeffMatching=AffineCoeffs[pw];
        float Max=1E32;
        if (CheckPW>pw) {
            Max=TFTV[pw];
        }
        int orderFit=CoeffMatching.size();
        for (int i=0; i<numel; i++) {
            if(BlurredLesion[i]<Max && FinalTransformed[i]<0){
                FinalTransformed[i]=0;
                for (int o=0; o<orderFit; o++) {
                    FinalTransformed[i]+=CoeffMatching[o]*pow_int(BlurredLesion[i], o);
                }
            }
            
        }

    }
    return FinalTransformed;
}

//Apply a polynomial change according to coeffs in CoeffMatching and then thresholding values
float * ApplyingPolyfitWT(vector<float> CoeffMatching, float * ImageToModify, float Threshold,int numel){
    int orderFit=CoeffMatching.size();
    float * TransformedImageData=new float[numel];
    for (int i=0; i<numel; i++) {
        TransformedImageData[i]=0;
    }
    for (int i=0; i<numel; i++) {
            for (int o=0; o<orderFit; o++) {
                TransformedImageData[i]+=CoeffMatching[o]*pow_int(ImageToModify[i], o);
            }
        if(TransformedImageData[i]<Threshold){
            TransformedImageData[i]=Threshold;
        }
        
    }
    return TransformedImageData;

}


nifti_image * ApplyingPolyfitMatching(vector<float> CoeffMatching, nifti_image * ImageToModify,bool * MaskToApply){
    if(ImageToModify==NULL){
        return NULL;
    }
    //    Derive order fit from number of modalities and number of coeffs
    int numbCoeffs=CoeffMatching.size();
    int Dim[3];
    Dim[0]=ImageToModify->nx;
    Dim[1]=ImageToModify->ny;
    Dim[2]=ImageToModify->nz;
    int numbmodal=ImageToModify->nu*ImageToModify->nt;
    int orderFit=numbCoeffs/numbmodal-1;
    int numel=ImageToModify->nx*ImageToModify->ny*ImageToModify->nz;
    int * L2S = MakeL2S(MaskToApply, Dim);
    //    Create and initialise the result image
    nifti_image * TransformedImage=nifti_copy_nim_info(ImageToModify);
    TransformedImage->data=(void *) calloc(ImageToModify->nvox, sizeof(float));
    float * TransformedImageData=static_cast<float *>( TransformedImage->data);
    float * ImageToModifyData=static_cast<float *>(ImageToModify->data);
    for (int i=0; i<numel*numbmodal; i++) {
        TransformedImageData[i]=0;
    }
    for (int m=0; m<numbmodal; m++) {
        for (int i=0; i<numel; i++) {
            if(L2S[i]>-1){
                for (int o=0; o<orderFit+1; o++) {
                    TransformedImageData[m*numel+i]+=CoeffMatching[m*(orderFit+1)+o]*pow_int(ImageToModifyData[m*numel+i], o);
                }
            }
        }
    }
    if(L2S!=NULL){
        delete [] L2S;
        L2S=NULL;
    }
    return TransformedImage;
}


TextureDescriptors1 * CreateTextureDescriptors1(bool * SegToUse, float * DataInit, TreeEM * TreeToAnalyse){
    TextureDescriptors1 * TextResult=new TextureDescriptors1();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    TextResult->Mean=GetMeanData(DataInit, SegToUse, numelmasked);
    TextResult->Variance=GetVarianceData(DataInit, SegToUse, numelmasked);
    TextResult->Skewness=GetSkewnessData(DataInit, SegToUse, numelmasked);
    TextResult->Kurtosis=GetKurtosisData(DataInit, SegToUse, numelmasked);
    return TextResult;
}

TextureDescriptors * CreateTextureDescriptors(bool * SegToUse, float * DataInit, vector<float *> ShiftedData, float* PixDimShift, TreeEM * TreeToAnalyse){
    TextureDescriptors * TextResult=new TextureDescriptors();
    int numbbins=128;
    int numbmodal=2;
    int sizeShifts=ShiftedData.size();
//    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int numbbinsGet=(int)(numbbins/pow_int(2, (numbmodal-1)));
    if (numbbinsGet<=0) {
        return NULL;
    }
    float MinPixDim=GetMin(PixDimShift, sizeShifts);
//    float MeanData=GetMeanData(DataInit, SegToUse, numelmasked);
//    float VarianceData=GetVarianceData(DataInit,SegToUse,numelmasked );
    float SumWeightShift=0;
    for (int s=0; s<sizeShifts; s++) {
        SumWeightShift+=MinPixDim/PixDimShift[s];
    }
    int numelhist=(int)pow_int(numbbinsGet,numbmodal);
    float * InvariantGLMC=new float [numelhist];
    for (int i=0; i<numelhist; i++) {
        InvariantGLMC[i]=0;
    }
    int CountPbGLMC=0;
//    int CountPbCorr=0;
//    float sizeBin=(float)1.0/numbbinsGet;
    vector<int> DimHist;
    for (int m=0; m<numbmodal; m++) {
        DimHist.push_back(numbbinsGet);
    }
    for (int s=0; s<sizeShifts; s++) {
        float WeightShift=MinPixDim/(PixDimShift[s]*SumWeightShift);
        float * GLMC=GetGLMC(SegToUse, DataInit, ShiftedData[s], TreeToAnalyse);
//        float MeanShift=GetMeanData(ShiftedData[s], SegToUse, numelmasked);
//        float VarianceShift=GetVarianceData(ShiftedData[s],SegToUse,numelmasked);
//        float TempCorrelation=0;
        float TempCorrelationBis=0;
        float * ParamHist=GetParamFromHistogram(GLMC, DimHist);
        for (int i=0; i<numelhist; i++) {
            int i1=i/numbbinsGet;
//            float i1u=(i1+0.5)*sizeBin;
            int i2=i-i1*numbbinsGet;
//            float i2u=(i2+0.5)*sizeBin;
            InvariantGLMC[i]+=GLMC[i]*WeightShift;
            if (GLMC[i]>1) {
                CountPbGLMC++;
            }
            TempCorrelationBis+=GLMC[i]*(i2-ParamHist[0])*(i1-ParamHist[1])/sqrt(ParamHist[2]*ParamHist[3]);
//            TempCorrelation+=GLMC[i]*(i2u-MeanData)*(i1u-MeanShift)/sqrtf(VarianceShift*VarianceData);
//            if (fabs(TempCorrelation)>1) {
//                cout<<"Pb in corr..."<<endl;
//                cout<<GLMC[i]*(i2u-MeanData)*(i1u-MeanShift)/sqrtf(VarianceShift*VarianceData)<<endl;
//                cout<<CountNonZero(SegToUse, numelmasked)<<endl;
//                cout<<CountNonZero(GLMC, numelhist)<<endl;
//                cout<<GetMin(DataInit, SegToUse, numelmasked)<<endl;
//                cout<<GetMax(GLMC, numelhist)<<endl;
//                CountPbCorr++;
//            }
            
        }
        delete [] ParamHist;
        ParamHist=NULL;
        TextResult->Correlation+=TempCorrelationBis*WeightShift;
        delete [] GLMC;
        GLMC=NULL;
    }
    
    for (int i=0; i<numbbinsGet; i++) {
        for (int j=0; j<numbbinsGet; j++) {
            int IndexIJ=i*numbbinsGet+j;
//            float iu=(i+0.5)*sizeBin;
//            float ju=(j+0.5)*sizeBin;
            TextResult->Contrast+=InvariantGLMC[IndexIJ]*pow_int((i-j), 2);
            TextResult->Homogeneity+=InvariantGLMC[IndexIJ]*(1.0/(1+abs(i-j)));
            TextResult->Energy+=pow_int(InvariantGLMC[IndexIJ], 2);
            if (InvariantGLMC[IndexIJ]>10E-6) {
                TextResult->Entropy-=InvariantGLMC[IndexIJ]*logf(InvariantGLMC[IndexIJ]);
            }
        }
    }
    delete [] InvariantGLMC;
    InvariantGLMC=NULL;
    return TextResult;
    
    
}

float * GetGLMC(bool * SegToCheck, float * DataCorr, float * DataShifted, TreeEM * TreeToAnalyse){
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int sizeSeg=CountNonZero(SegToCheck, numelmasked);
    float * IntensitiesForHist=new float[2*sizeSeg];
    int j=0;
    for (int i=0; i<numelmasked; i++) {
        if (SegToCheck[i]) {
            IntensitiesForHist[j]=DataCorr[i];
            IntensitiesForHist[j+sizeSeg]=DataShifted[i];
            j++;
        }
    }
    float * ResultGLMC=MakeHistogram(IntensitiesForHist,sizeSeg,2);
    float CheckGLMCSum=SumOverMask<float,float>(ResultGLMC, NULL, 0, 64*64);
    if (CheckGLMCSum>1+10E-5) {
        cout << "PbGLMCSup1";
    }
    delete [] IntensitiesForHist;
    IntensitiesForHist=NULL;
    return ResultGLMC;
    
}


/* Make the Histogram of the data given the mask and outlier beliefs taken out (in use only with EMS otherwise everything under mask taken into account)*/
float * MakeHistogram(float * DataImage, int sizeSeg, int numbmodal){
    // First Create the NormMask image
    int numbbins=128;
    // then check that the number of bins set for the tree is compatible with
    int numbbinsGet=(int)(numbbins/pow_int(2, (numbmodal-1)));
    if (numbbinsGet<=0) {
        return NULL;
    }
    int numelhist=(int)pow_int(numbbinsGet,numbmodal);
    //float * DataHistogram=new float[(int)powf(numbbins,numbmodal)]{0};
    float * DataHistogramTotal_PTR=new float[numelhist];//{0};
    for(int i=0;i<numelhist;i++){
        DataHistogramTotal_PTR[i]=0;
    }
    float sizeBin=(float)1.0/numbbinsGet;
    //        int *L2S_PTR=this->GetL2S();
    
    vector<float *> Data_PTRModalVector;

    
    for (int m=0; m<numbmodal; m++) {
        //Data_PTRModalVector.push_back(&static_cast<float*>(this->GetDataImage()->data)[m*numel]);
        Data_PTRModalVector.push_back(&DataImage[m*sizeSeg]);
    }

    float tmpValue[MaxNumbModal];//{0};
    
    for(int i=0;i<MaxNumbModal;i++){
        tmpValue[i]=0;
    }
    int twopowmodal=(int)pow_int(2,numbmodal);
    int twopowMaxmodal=(int)pow_int(2,MaxNumbModal);
    //        int indexTab[twopowMaxmodal];//{0};
    int *indexTab=new int[twopowMaxmodal];
    for(int i=0;i<twopowMaxmodal;i++){
        indexTab[i]=0;
    }
    //        float valuePerc[twopowMaxmodal];//{1};
    float *valuePerc=new float[twopowMaxmodal];
    for(int i=0;i<twopowMaxmodal;i++){
        valuePerc[i]=1;
    }
//    int CountNormRespZero=0;
    float SumNormResp=0;
    for (int i=0; i<sizeSeg; i++) {
        for (int m=0; m<numbmodal; m++) {
            int twopowm=(int)pow_int(2,m);
            tmpValue[m]=*Data_PTRModalVector[m]/sizeBin-0.5;
            tmpValue[m]=tmpValue[m]>(numbbinsGet-1)?numbbinsGet-1:tmpValue[m];
            tmpValue[m]=tmpValue[m]<0?0:tmpValue[m];
            for (int c=0; c<twopowm; c++) {
                indexTab[c+twopowm]=indexTab[c];
                valuePerc[c+twopowm]=valuePerc[c];
            }
            int binspowm=(int)pow_int(numbbinsGet,m);
            int floorTmpValuem=(int)floorf(tmpValue[m]);
            for (int c=0; c<twopowm; c++) {
                indexTab[c]+=(int)(binspowm*floorTmpValuem);
                indexTab[c+twopowm]+=binspowm*floorTmpValuem+1;
                valuePerc[c]*=(1-tmpValue[m]+floorTmpValuem);
                valuePerc[c+twopowm]*=(tmpValue[m]-floorTmpValuem);
            }
        }
        float sumValuePerc=0;
        for (int c=0; c<twopowmodal; c++) {
            sumValuePerc+=valuePerc[c];
        }
        //cout<<"sumValuePerc "<< sumValuePerc<<" for index "<<i<<endl;

            

            for(int p=0; p<twopowmodal; p++) {
                DataHistogramTotal_PTR[indexTab[p]]+=(float)valuePerc[p];
                
            }
            SumNormResp++;
        
        for (int p=0; p<twopowmodal; p++) {
            indexTab[p]=0;
            valuePerc[p]=1;
        }
        for (int m=0; m<numbmodal; m++) {
            Data_PTRModalVector[m]++;
        }
    }
    //cout<<"CountNormRespZero is"<<CountNormRespZero<<endl;
    delete [] indexTab;
    indexTab=NULL;
    delete [] valuePerc;
    valuePerc=NULL;
    //                delete [] tmpValue;
    //                tmpValue=NULL;
    float SumDataHistogram=0;
    
    //        float NumberDataHistogramZero=0;
    //        int numelmasked=this->GetNumberMaskedElements();
    int binspowmodal=(int)pow_int(numbbinsGet,numbmodal);
    
    //Normalisation of the DataHistogram in order to properly calculate the KLD afterwards:
    for(int i=0;i<binspowmodal;i++){
        SumDataHistogram+=DataHistogramTotal_PTR[i];
    }
    if(SumDataHistogram>0){
        for(int i=0;i<binspowmodal;i++){
            DataHistogramTotal_PTR[i]/=SumDataHistogram;
        }
    }
//    cout <<SumOverMask<float,float>(DataHistogramTotal_PTR, NULL, 0, numelhist)<<endl;

    return DataHistogramTotal_PTR;
}

float * GetParamFromHistogram(float * Histogram, vector<int> DimHist){
    int numbmod=DimHist.size();
    float * ParamHist=new float[numbmod*numbmod];
    int * Dim=new int[numbmod];
    int * Shift=new int[numbmod];
    int sizeHist=1;
    for (int m=0; m<numbmod; m++) {
        ParamHist[m]=0;
        Shift[m]=sizeHist;
        sizeHist*=DimHist[m];
        Dim[m]=DimHist[m];
    }
    for (int i=0; i<sizeHist; i++) {
        int * Coord=CorrespondingCoordinates_ter(i,Dim,Shift,numbmod);
        for (int m=0; m<numbmod; m++) {
            ParamHist[m]+=Histogram[i]*Coord[m];
        }
        delete [] Coord;
        Coord=NULL;
    }
    
    for (int i=0; i<sizeHist; i++) {
        int * Coord=CorrespondingCoordinates_ter(i,Dim,Shift,numbmod);
        for (int m=0; m<numbmod; m++) {
            ParamHist[m+numbmod]+=(Coord[m]-ParamHist[m])*(Coord[m]-ParamHist[m])*Histogram[i];
        }
        delete [] Coord;
        Coord=NULL;
    }
    delete [] Dim;
    delete [] Shift;
    Dim=NULL;
    Shift=NULL;
    return ParamHist;

}


/*************** METHODS to get LACUNES ************************/


// Selection of all outliers dark in both T1 and FLAIR

// Image of all outliers ?
nifti_image * CodedOutliers(TreeEM  * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
    int numbmodal=segment_analysis->vecModalities.size();
    vector<int> Modalities=segment_analysis->vecModalities;
    if (numbmodal==0) {
        Modalities=GetModalitiesFromTextFile(segment_analysis);
    }
    numbmodal=TreeToAnalyse->GetNumberModalities();
    int * IndicesOrder=new int [3*numbmodal];
    for (int i=0; i<3*numbmodal; i++) {
        IndicesOrder[i]=0;
    }
//    Order of intensities according to tissue and modalities
    for (int m=0; m<numbmodal; m++) {
        switch (Modalities[m]) {
                case 1:{
                    IndicesOrder[m*3]=segment_analysis->IndexCSF;
                    IndicesOrder[m*3+1]=segment_analysis->IndexGM;
                    IndicesOrder[m*3+2]=segment_analysis->IndexWM;
                }
                break;
                case 2:{
                    IndicesOrder[m*3]=segment_analysis->IndexWM;
                IndicesOrder[m*3+1]=segment_analysis->IndexGM;
                IndicesOrder[m*3+2]=segment_analysis->IndexCSF;
                }
                break;
                case 3:{
                    IndicesOrder[m*3]=segment_analysis->IndexCSF;
                    IndicesOrder[m*3+1]=segment_analysis->IndexWM;
                    IndicesOrder[m*3+2]=segment_analysis->IndexGM;
                }
                break;
            default:{
                IndicesOrder[m*3]=segment_analysis->IndexCSF;
                IndicesOrder[m*3+1]=segment_analysis->IndexWM;
                IndicesOrder[m*3+2]=segment_analysis->IndexGM;
            }
                break;
        }
    }
//    Initialisation of results and needed information
    float * DataToUse=TreeToAnalyse->GetDataBFCorrected();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int * S2L=TreeToAnalyse->GetS2L();
    nifti_image * ResultsCoded=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    ResultsCoded->dim[0]=3;
    ResultsCoded->dim[4]=1;
    nifti_update_dims_from_array(ResultsCoded);
    ResultsCoded->data=(void *)calloc(ResultsCoded->nvox, sizeof(float));
    float * ResultsData=static_cast<float *>(ResultsCoded->data);
    int numel=ResultsCoded->nvox;
    for (int i=0; i<numel; i++) {
        ResultsData[i]=0;
    }
    float * NormRespOutliers=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    int numbToCode=numbmodal;
    if( segment_analysis->numbCoded >0 && segment_analysis->numbCoded<numbmodal){
        numbToCode=segment_analysis->numbCoded;
    }
    cout <<"Progressive Indices order is ";
    for (int c=0; c<3*numbmodal; c++) {
        cout << IndicesOrder[c];
    }
    cout<<endl;
//    Filling the data according to the relationships to the Means of GeneralClasses
    for (int m=0; m<numbToCode; m++) {
        float * DataToLook=&DataToUse[numelmasked*m];
        for (int i=0; i<numelmasked; i++) {
            if (NormRespOutliers[i]>0.5) {
                if (DataToLook[i]<MeanGeneralClasses[IndicesOrder[m*3]][m]) {
                    ResultsData[S2L[i]]+=pow_int(10,m)*1;
                }
                else if (DataToLook[i]<MeanGeneralClasses[  IndicesOrder[m*3+1]][m]){
                    ResultsData[S2L[i]]+=pow_int(10,m)*2;
                }
                else if (DataToLook[i]<MeanGeneralClasses[IndicesOrder[m*3+2]][m]){
                    ResultsData[S2L[i]]+=pow_int(10,m)*3;
                    
                }
                else {
                    ResultsData[S2L[i]]+=pow_int(10, m)*4;
                }
            }

        }
    }
    delete [] IndicesOrder;
    IndicesOrder=NULL;
    int numbclasses=MeanGeneralClasses.size();
    for (int c=0; c<numbclasses; c++) {
        delete [] MeanGeneralClasses[c];
        MeanGeneralClasses[c]=NULL;
    }
    return ResultsCoded;

}


// Image of all outliers with a mask on the outliers
nifti_image * CodedOutliersMask(TreeEM  * TreeToAnalyse, bool * OutlierMaskShort, SEG_ANALYSIS * segment_analysis){
    int numbmodal=segment_analysis->vecModalities.size();
    vector<int> Modalities=segment_analysis->vecModalities;
    if (numbmodal==0) {
        Modalities=GetModalitiesFromTextFile(segment_analysis);
    }
    numbmodal=TreeToAnalyse->GetNumberModalities();
    int * IndicesOrder=new int [3*numbmodal];
    for (int i=0; i<3*numbmodal; i++) {
        IndicesOrder[i]=0;
    }
    //    Order of intensities according to tissue and modalities
    for (int m=0; m<numbmodal; m++) {
        switch (Modalities[m]) {
                case 1:{
                    IndicesOrder[m*3]=segment_analysis->IndexCSF;
                    IndicesOrder[m*3+1]=segment_analysis->IndexGM;
                    IndicesOrder[m*3+2]=segment_analysis->IndexWM;
                }
                break;
                case 2:{
                    IndicesOrder[m*3]=segment_analysis->IndexWM;
                    IndicesOrder[m*3+1]=segment_analysis->IndexGM;
                    IndicesOrder[m*3+2]=segment_analysis->IndexCSF;
                }
                break;
                case 3:{
                    IndicesOrder[m*3]=segment_analysis->IndexCSF;
                    IndicesOrder[m*3+1]=segment_analysis->IndexWM;
                    IndicesOrder[m*3+2]=segment_analysis->IndexGM;
                }
                break;
            default:{
                IndicesOrder[m*3]=segment_analysis->IndexCSF;
                IndicesOrder[m*3+1]=segment_analysis->IndexWM;
                IndicesOrder[m*3+2]=segment_analysis->IndexGM;
            }
                break;
        }
    }
    //    Initialisation of results and needed information
    float * DataToUse=TreeToAnalyse->GetDataBFCorrected();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    int * S2L=TreeToAnalyse->GetS2L();
    nifti_image * ResultsCoded=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    ResultsCoded->dim[0]=3;
    ResultsCoded->dim[4]=1;
    nifti_update_dims_from_array(ResultsCoded);
    ResultsCoded->data=(void *)calloc(ResultsCoded->nvox, sizeof(float));
    float * ResultsData=static_cast<float *>(ResultsCoded->data);
    int numel=ResultsCoded->nvox;
    for (int i=0; i<numel; i++) {
        ResultsData[i]=0;
    }
    vector<float *> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    int numbToCode=numbmodal;
    if( segment_analysis->numbCoded >0 && segment_analysis->numbCoded<numbmodal){
        numbToCode=segment_analysis->numbCoded;
    }
    cout <<"Progressive Indices order is ";
    for (int c=0; c<3*numbmodal; c++) {
        cout << IndicesOrder[c];
    }
    cout<<endl;
    int power_m=0;
    //numbToCode=2;
    //    Filling the data according to the relationships to the Means of GeneralClasses
    for (int m=0; m<min(numbToCode,2); m++) {
        if (numbToCode == 1){
            power_m = 1;
        }
        else {
            power_m = m;
        }
        float * DataToLook=&DataToUse[numelmasked*m];
        for (int i=0; i<numelmasked; i++) {
            if (OutlierMaskShort[i]) {
                if (DataToLook[i]<MeanGeneralClasses[IndicesOrder[m*3]][m]) {
                    ResultsData[S2L[i]]+=pow_int(10,power_m)*1;
                }
                else if (DataToLook[i]<MeanGeneralClasses[  IndicesOrder[m*3+1]][m]){
                    ResultsData[S2L[i]]+=pow_int(10,power_m)*2;
                }
                else if (DataToLook[i]<MeanGeneralClasses[IndicesOrder[m*3+2]][m]){
                    ResultsData[S2L[i]]+=pow_int(10,power_m)*3;
                    
                }
                else {
                    ResultsData[S2L[i]]+=pow_int(10, power_m)*4;
                }
            }
            
        }
    }
    delete [] IndicesOrder;
    IndicesOrder=NULL;
    int numbclasses=MeanGeneralClasses.size();
    for (int c=0; c<numbclasses; c++) {
        delete [] MeanGeneralClasses[c];
        MeanGeneralClasses[c]=NULL;
    }
    return ResultsCoded;
    
}



nifti_image * OutliersOrigin(TreeEM  * TreeToAnalyse, SEG_ANALYSIS * segment_analysis){
//    Initialisation of the results
    nifti_image * ResultsOrigin=nifti_copy_nim_info(TreeToAnalyse->GetDataImage());
    ResultsOrigin->dim[0]=3;
    ResultsOrigin->dim[4]=1;
    nifti_update_dims_from_array(ResultsOrigin);
    ResultsOrigin->data=(void *) calloc(ResultsOrigin->nvox, sizeof(float));
    float *OriginData=static_cast<float *>(ResultsOrigin->data);
    int numel=ResultsOrigin->nvox;
    for (int i=0; i<numel; i++) {
        OriginData[i]=0;
    }
    
    vector<TreeEM*> OutliersClasses=TreeToAnalyse->GetNodeOutlier()->GetChildren();
    int numbclasses=OutliersClasses.size();
    vector<float *> OutliersNormResp;
    float* OutliersGlobalNormResp=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    for (int c=0; c<numbclasses; c++) {
        OutliersNormResp.push_back(OutliersClasses[c]->GetNormResp());
    }
    
    int * S2L=TreeToAnalyse->GetS2L();
    int numelmasked=TreeToAnalyse->GetNumberMaskedElements();
    for (int i=0; i<numelmasked; i++) {
        if (OutliersGlobalNormResp[i]>0.5) {
            float Max=0;
            int Index=-1;
            for (int c=0; c<numbclasses; c++) {
                if(OutliersNormResp[c][i]>Max){
                    Max=OutliersNormResp[c][i];
                    Index=c;
                }
            }
            OriginData[S2L[i]]=Index+1;
        }
    }
    return ResultsOrigin;
}

float * OutlierSelection(TreeEM* TreeToAnalyse, float * OutlierCoding, float * OutlierOrigin, vector<float> CodeSelection, vector<float> OriginSelection, bool * RejectedZone){
    int * L2S = TreeToAnalyse->GetL2S();
    int numel=TreeToAnalyse->GetNumberElements();
    int numbOrigin=OriginSelection.size();
    int numbSelection=CodeSelection.size();
    float * OutlierNormResp=TreeToAnalyse->GetNodeOutlier()->GetNormResp();
    float * ResultSelection=new float[numel];
    for (int i=0; i<numel; i++) {
        ResultSelection[i]=0;
        if (! RejectedZone[i]) {
            bool flag_Origin=0;
            bool flag_Selection=0;
            for (int s=0; s<numbSelection; s++) {
                if (fabs(OutlierCoding[i]-CodeSelection[s])<=0.001) {
                    flag_Selection=1;
                    break;
                }
            }
            for (int s=0; s<numbOrigin; s++) {
                if (OutlierOrigin[i]==OriginSelection[s]) {
                    flag_Origin=1;
                    break;
                }
            }
            if (flag_Origin*flag_Selection) {
                ResultSelection[i]=OutlierNormResp[L2S[i]];
            }
        }
    }
    return ResultSelection;
}

vector<TreeEM *> SelectionPVClasses(TreeEM* TreeToAnalyse, int Index1, int Index2){
    vector<TreeEM*> PotentialClasses1=TreeToAnalyse->GetNodeInlier()->GetChild(Index1)->GetChildren();
    int size1=PotentialClasses1.size();
    vector<TreeEM*> PotentialClasses2=TreeToAnalyse->GetNodeInlier()->GetChild(Index2)->GetChildren();
    int size2=PotentialClasses2.size();
    vector<float*> MeanGeneralClasses=TreeToAnalyse->GetMeanGeneralClassesVector();
    float * Mean1=MeanGeneralClasses[Index1];
    float * Mean2=MeanGeneralClasses[Index2];
    vector<TreeEM* > PVVector;
    int numbmodal=TreeToAnalyse->GetNumberModalities();
    cout<<size1<<" "<<size2<<endl;
    cout <<"Mean 1 "<<Mean1[0] << " "<< Mean1[1] << " "<< Mean1[2]<<endl;
    cout <<"Mean 2 "<<Mean2[0] << " "<< Mean2[1] << " "<< Mean2[2]<<endl;
    for (int i=0; i<size1; i++) {
        bool flag_PV=1;
        float * MeanLeaf=PotentialClasses1[i]->GetMeanDirect();
        for (int m=0; m<numbmodal; m++) {
            cout<<MeanLeaf[m]<<" "<<Mean1[m]<<" "<<Mean2[m]<<endl;
            flag_PV*=((MeanLeaf[m]>=Mean1[m]&&MeanLeaf[m]<=Mean2[m])||(MeanLeaf[m]>=Mean2[m]&&MeanLeaf[m]<=Mean1[m])||fabs(2*MeanLeaf[m]-Mean1[m]-Mean2[m])<0.01);
        }
        if (flag_PV) {
            PVVector.push_back(PotentialClasses1[i]);
        }
        delete [] MeanLeaf;
        MeanLeaf=NULL;
    }
    for (int i=0; i<size2; i++) {
        bool flag_PV=1;
        float * MeanLeaf=PotentialClasses2[i]->GetMeanDirect();
        for (int m=0; m<numbmodal; m++) {
            flag_PV*=((MeanLeaf[m]>=Mean1[m]&&MeanLeaf[m]<=Mean2[m])||(MeanLeaf[m]>=Mean2[m]&&MeanLeaf[m]<=Mean1[m]));
        }
        if (flag_PV) {
            PVVector.push_back(PotentialClasses2[i]);
        }
        delete [] MeanLeaf;
        MeanLeaf=NULL;
    }
    return PVVector;
}

float * AddNormResp(vector<TreeEM*> VectorToAdd){
    if(VectorToAdd.size()==0){
        return NULL;
    }
    int numelmasked=VectorToAdd[0]->GetNumberMaskedElements();
    vector<float *>vectorFloatToAdd;
    int numbLeaves=VectorToAdd.size();
    for (int l=0; l<numbLeaves; l++) {
        vectorFloatToAdd.push_back(VectorToAdd[l]->GetNormResp());
    }
    float * ResultAdded=AddArray(vectorFloatToAdd, numelmasked);
    return ResultAdded;
}


vector<int> LabelToDiscard(int * ComponentPV, bool * RejectedZonePV, int * Dim, int * Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
//    int maxLabel=GetMaxLabel(ComponentPV, numel);
    bool * ExtBorderReject=CreateBorderExtFromBool(RejectedZonePV, Dim, Shift, NULL);
    set<int> SetIndicesToDel;
    for (int i=0; i<numel; i++) {
        if ((ExtBorderReject[i]||RejectedZonePV[i])  && ComponentPV[i]>0) {
            SetIndicesToDel.insert(ComponentPV[i]);
        }
    }
    int sizeDel=SetIndicesToDel.size();
    cout << "Number of labels to discard is "<<sizeDel<<endl;
    std::vector<int> LabelDiscarded(sizeDel);
    std::copy(SetIndicesToDel.begin(), SetIndicesToDel.end(), LabelDiscarded.begin());
    delete [] ExtBorderReject;
    ExtBorderReject=NULL;
    return LabelDiscarded;
}

int * TreatingLabelFromSetDiscard(int * ComponentPV, vector<int> LabelsDiscarded, int numel){
    int * TreatedPV=CopyArray(ComponentPV, numel);
    int sizeDel=LabelsDiscarded.size();
    for (int s=0; s<sizeDel; s++) {
        int Discarded=LabelsDiscarded[s];
        for (int i=0; i<numel; i++) {
            if (ComponentPV[i]==Discarded) {
                TreatedPV[i]=0;
            }
            else if (ComponentPV[i]>Discarded){
                TreatedPV[i]--;
            }
        }
    }
    return TreatedPV;
}

int * TreatingPreLabel(int * ComponentPV, bool *RejectedZonePV,int * Dim, int * Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    int maxLabel=GetMaxLabel(ComponentPV, numel);
    int * TreatedResults=CopyArray(ComponentPV, numel);
    for (int l=0; l<maxLabel; l++) {
        vector<int> VectBorderExtIndices=GetIndicesBorderLesionExt(ComponentPV,l+1,Dim,Shift);
        int sizeVec=VectBorderExtIndices.size();
        bool flag_AcceptedPV=1;
        for (int i=0; i<sizeVec; i++) {
            if (RejectedZonePV[VectBorderExtIndices[i]]) {
                flag_AcceptedPV=0;
            }
        }
        if (!flag_AcceptedPV) {
            for (int i=0; i<numel; i++) {
                if (ComponentPV[i]==l+1) {
                    TreatedResults[i]=0;
                }
                else if (ComponentPV[i]>=l+1){
                    TreatedResults[i]--;
                }
            }
        }

    }
    return TreatedResults;
}

vector<int> ReadClassifFromTextFile(SEG_ANALYSIS * segment_analysis){
    vector<int > ResultsVector;
    ifstream text (segment_analysis->filename_inOutText);
    //    text.open(TreeTextFile,ios::in);
    if(!text){
        std::cout<<"could not open the text file properly !"<<endl;
        return ResultsVector;
    }
    else{
        std::string line;
        //        int numbGchild=0;
        string arry[5];
        int i;
        while( getline(text, line) ) // Oos! missed a )
        {
              stringstream str(line);
              for(i = 0; i < 5; i++){
                   getline(str, arry[i], ',');
              }
              if (arry[0]=="Label"){

              }
              else{
                  //std::string::size_type sz;   // alias of size_t
                  std::istringstream str2(arry[4]);
                  int i;
                  str2 >> i;
//                  ResultsVector.push_back(std::stoi(arry[4],&sz));
                  ResultsVector.push_back(i);
              }
        }
        return ResultsVector;
    }
}

int ReadClassif(string line){
    istringstream in(line);
    string first;
    in >> first;
    int x ;
    int y;
    int z;
    int Classif;
    in >> x;
    in >> y;
    in >> z;
    cout <<"x "<< x<< " y "<< y << " z "<<z<<endl;
    in >> Classif;
    return Classif;
}

vector<Outlier *> ReadOutliersFromTextFile(SEG_ANALYSIS * segment_analysis, TreeEM * TreeToAnalyse){
    vector<Outlier *> ResultsVector;
    ifstream text (segment_analysis->filename_inOutText);
    //    text.open(TreeTextFile,ios::in);
    if(!text){
        std::cout<<"could not open the text file properly !"<<endl;
        return ResultsVector;
    }
    else{
        std::string line;
        //        int numbGchild=0;
        while(getline(text,line)){
            Outlier * OutlierToAdd=ReadOutlier(text, TreeToAnalyse, segment_analysis);
            ResultsVector.push_back(OutlierToAdd);
        }
        return ResultsVector;
    }
}


Outlier * ReadOutlier(istream & text, TreeEM * TreeResult,SEG_ANALYSIS * segment_analysis){
    int IndexWM=segment_analysis->IndexWM;
    int IndexGM=segment_analysis->IndexGM;
    int IndexCSF=segment_analysis->IndexCSF;
    int IndexOut=segment_analysis->IndexOut;
    Outlier * OutlierToAdd=new Outlier();
    int numbmodal=TreeResult->GetNumberModalities();
    string line;
    getline(text,line);
    //    cout<<line<<endl;
    istringstream in(line);
    string first;
    in >> first;
    if(first=="Label"){
        
    }
    getline(text,line);
    int OutlierClass;
    int Modality;
    float MeanCode;
    float Volume;
    float Surface;
    float SAV;
    float Compactness;
    float MahalVecValuesQuant;
    float MahalMinValues;
    float MahalMaxValues;
    float MahalMeanValues;
    float MeanLesionValues;
    float VarianceLesionValues;
    float ProportionNeighbourValue;
    int CentreGravValues;
    float DiffCentreGravValues;
    bool DGMBelonging;
    float SPPotProp;
    float PropICSF;
    float PropECSF;
    float PropDGM;
    float PropCGM;
    float PropWMH;
    float DistanceValues;
    float RatioBB;
    float ExtentBoxValues;
    //float ExtentBoxVolumeValues;
    float TextureValues;
    float PropOriginValues;
    float * ProportionNeighbour=new float[4];
    float * Mean=new float[numbmodal];
    float * Variance=new float[numbmodal];
    float * ProportionOrigin=new float[5];
    float * ExtentBB=new float[3];
    int * BBRelGrav=new int[6];
    float * ExtentVolumeBB=new float[3];
    float * RatioBoundingBox=new float[5];
    vector<float> VectorDiffGrav;
    vector<int> CentreGravity;
    vector<float> DistanceGMI;
    vector<float> DistanceWMI;
    vector<float> DistanceCSFI;
    vector<float> DistanceOutI;
    vector<float> DistanceVentricle;
    vector<TextureDescriptors *> Texture;
    vector<TextureDescriptors1 *> Texture1;
    vector<float *> MahalVec;
    vector<float *> MahalVecQuant;
    for (int m=0; m<numbmodal; m++) {
        float * ToPushMahalVec=new float[3];
        float * ToPushMahalVecQuant=new float[3];
        MahalVec.push_back(ToPushMahalVec);
        MahalVecQuant.push_back(ToPushMahalVecQuant);
        Texture.push_back(NULL);
        Texture1.push_back(NULL);
    }
    float * ToPushMahalVec=new float[3];
    float * ToPushMahalVecQuant=new float[3];
    MahalVec.push_back(ToPushMahalVec);
    MahalVecQuant.push_back(ToPushMahalVecQuant);
    while(!line.empty()){
        istringstream in2(line);
        //        cout<<line<<endl;
        string type;
        if(!line.empty()){
            in2 >>type;
        }
        else{
            type.clear();
        }
        if(type == "OutlierType"){ // WARNING Temporarily not set
            in2>> OutlierClass;
            OutlierType Test=static_cast<OutlierType>(OutlierClass);
            OutlierToAdd->OutlierClass=Test;
        }
               else if(type == "MeanCode"){
            in2 >> MeanCode;
            OutlierToAdd->MeanOC=MeanCode;
        }
        else if(type == "Volume"){
            in2 >> Volume;
            OutlierToAdd->Volume=Volume;
        }
        else if(type == "Surface"){
            in2 >> Surface;
            OutlierToAdd->Surface=Surface;
        }
        else if(type == "SAV"){
            in2 >> SAV;
            OutlierToAdd->SAV=SAV;
        }
        else if(type == "Compactness"){
            in2 >> Compactness;
            OutlierToAdd->Compactness=Compactness;
        }
        else if(type == "PropICSF"){
            in2 >> PropICSF;
            OutlierToAdd->PropICSF=PropICSF;
        }
        else if(type == "PropECSF"){
            in2 >> PropECSF;
            OutlierToAdd->PropECSF=PropECSF;
        }
        else if(type == "PropDGM"){
            in2 >> PropDGM;
            OutlierToAdd->PropDGM=PropDGM;
        }
        else if(type == "PropCGM"){
            in2 >> PropCGM;
            OutlierToAdd->PropCGM=PropCGM;
        }
        else if(type == "PropWMH"){
            in2 >> PropWMH;
            OutlierToAdd->PropWMHNeigh=PropWMH;
        }
        else if(type == "SPPotProp"){
            in2 >> SPPotProp;
            OutlierToAdd->SPPotProp=SPPotProp;
        }
        else if(type == "DGMBelonging"){
            in2 >> DGMBelonging;
            OutlierToAdd->DGMBelonging=DGMBelonging;
        }
        else if (type == "ProportionNeighWM"){
            in2 >> ProportionNeighbourValue;
            ProportionNeighbour[IndexWM]=ProportionNeighbourValue;
        }
        else if (type == "ProportionNeighCSF"){
            in2 >> ProportionNeighbourValue;
            ProportionNeighbour[IndexCSF]=ProportionNeighbourValue;
        }
        else if (type == "ProportionNeighGM"){
            in2 >> ProportionNeighbourValue;
            ProportionNeighbour[IndexGM]=ProportionNeighbourValue;
        }
        else if (type == "ProportionNeighOut"){
            in2 >> ProportionNeighbourValue;
            ProportionNeighbour[IndexOut]=ProportionNeighbourValue;
        }
        else if (type == "RatioBB"){
            for (int c=0; c<5; c++) {
                in2 >> RatioBB;
                RatioBoundingBox[c]=RatioBB;
            }
            OutlierToAdd->RatioBoundingBox=RatioBoundingBox;
        }
        else if (type == "BoundingBoxRelGrav" ){
            for (int d=0; d<6; d++) {
                in2 >> ExtentBoxValues;
                BBRelGrav[d]=(int)ExtentBoxValues;
                
            }
            OutlierToAdd->BoundingBox=BBRelGrav;
        }
        else if (type == "ExtentBox"){
            for (int d=0; d<3; d++) {
                in2 >> ExtentBoxValues;
                ExtentBB[d]=ExtentBoxValues;
            }
            OutlierToAdd->ExtentBB=ExtentBB;
        }
        else if (type == "RatioExtentVolume"){
            for (int d=0; d<3; d++) {
                in2 >> ExtentBoxValues;
                ExtentVolumeBB[d]=ExtentBoxValues;
            }
            OutlierToAdd->ExtentVolumeBB=ExtentVolumeBB;
        }
        else if (type == "ProportionOrigin"){
            for (int c=0; c<4; c++) {
                in2 >> PropOriginValues;
                ProportionOrigin[c]=PropOriginValues;
            }
            OutlierToAdd->ProportionOrigin=ProportionOrigin;
        }
        else if (type == "DistanceVentricle"){
            for (int d=0; d<3; d++) {
                in2 >> DistanceValues;
                DistanceVentricle.push_back(DistanceValues);
            }
            OutlierToAdd->DistanceVentricle=DistanceVentricle;
        }
        else if (type == "DistanceWMI"){
            for (int d=0; d<3; d++) {
                in2 >> DistanceValues;
                DistanceWMI.push_back(DistanceValues);
            }
            OutlierToAdd->DistanceWMI=DistanceWMI;
        }
        else if (type == "DistanceGMI"){
            for (int d=0; d<3; d++) {
                in2 >> DistanceValues;
                DistanceGMI.push_back(DistanceValues);
            }
            OutlierToAdd->DistanceGMI=DistanceGMI;
        }
        else if (type == "DistanceCSFI"){
            for (int d=0; d<3; d++) {
                in2 >> DistanceValues;
                DistanceCSFI.push_back(DistanceValues);
            }
            OutlierToAdd->DistanceCSFI=DistanceCSFI;
        }
        else if (type == "DistanceOutI"){
            for (int d=0; d<3; d++) {
                in2 >> DistanceValues;
                DistanceOutI.push_back(DistanceValues);
            }
            OutlierToAdd->DistanceOutI=DistanceOutI;
        }
        else if (type == "MeanLesion"){
            for (int m=0; m<numbmodal; m++) {
                in2 >> MeanLesionValues;
                Mean[m]=MeanLesionValues;
            }
            OutlierToAdd->Mean=Mean;
        }
        else if (type == "VarianceLesion"){
            for (int m=0; m<numbmodal; m++) {
                in2 >> VarianceLesionValues;
                Variance[m]=VarianceLesionValues;
            }
            OutlierToAdd->Variance=Variance;
        }
        else if (type == "CentreGravity"){
            for (int d=0; d<3; d++) {
                in2 >> CentreGravValues;
                CentreGravity.push_back(CentreGravValues);
            }
            OutlierToAdd->CentreGravity=CentreGravity;
        }
        else if (type == "DiffCentreGravity"){
            for (int d=0; d<3; d++) {
                in2 >> DiffCentreGravValues;
                VectorDiffGrav.push_back(DiffCentreGravValues);
            }
            OutlierToAdd->VectorDiffGrav=VectorDiffGrav;
        }
        else if (type == "DistanceToCentreGrav"){
            in2 >> DiffCentreGravValues;
            OutlierToAdd->DistanceGrav=DiffCentreGravValues;
        }
        else if (type == "TextureDescriptors"){
            in2 >> Modality;
            in2 >> TextureValues;
            TextureDescriptors * TextureToPlace=new TextureDescriptors();
            TextureToPlace->Contrast=TextureValues;
            in2 >> TextureValues;
            TextureToPlace->Homogeneity=TextureValues;
            in2 >> TextureValues;
            TextureToPlace->Entropy=TextureValues;
            in2 >> TextureValues;
            TextureToPlace->Energy=TextureValues;
            in2 >> TextureValues;
            TextureToPlace->Correlation=TextureValues;
            Texture[Modality]=TextureToPlace;
        }
        else if (type == "TextureDescriptors1"){
            in2 >> Modality;
            in2 >> TextureValues;
            TextureDescriptors1 * TextureToPlace=new TextureDescriptors1();
            TextureToPlace->Mean=TextureValues;
            in2 >> TextureValues;
            TextureToPlace->Variance=TextureValues;
            in2 >> TextureValues;
            TextureToPlace->Skewness=TextureValues;
            in2 >> TextureValues;
            TextureToPlace->Kurtosis=TextureValues;
            Texture1[Modality]=TextureToPlace;
        }
        else if (type == "MahalVecMin"){
            for (int m=0; m<numbmodal+1; m++) {
                in2 >> MahalMinValues;
                MahalVec[m][0]=MahalMinValues;
            }
        }
        else if (type == "MahalVecMean"){
            for (int m=0; m<numbmodal+1; m++) {
                in2 >> MahalMeanValues;
                MahalVec[m][1]=MahalMeanValues;
            }
        }
        else if (type == "MahalVecMax"){
            for (int m=0; m<numbmodal+1; m++) {
                in2 >> MahalMaxValues;
                MahalVec[m][2]=MahalMaxValues;
            }
        }

        else if(type == "MahalVecQuant"){
                    
                    for(int m=0;m<numbmodal+1;m++){
                        getline(text,line);
                        istringstream in3(line);
                        for (int q=0; q<3; q++) {
                            in3 >>MahalVecValuesQuant;
                            MahalVecQuant[m][q]=MahalVecValuesQuant;
                        }
                    }
        }
                               getline(text,line);
    }
        OutlierToAdd->MahalVecQuant=MahalVecQuant;
        OutlierToAdd->MahalVec=MahalVec;
        OutlierToAdd->Texture=Texture;
        OutlierToAdd->Texture1=Texture1;
    OutlierToAdd->ProportionNeighbour=ProportionNeighbour;
        return OutlierToAdd;
}





/******************* PREPARE LABEL FUSION LIKE SYSTEM FOR PIVOT DATA *************************/

nifti_image * FinalROIPlacement(vector<nifti_image *> VectorNiiEx, vector<nifti_image *> VectorNiiROI, nifti_image * ImageRef, nifti_image * ROIRef,nifti_image * Mask, string  TxtFileCoMFinalString){
    ofstream TxtFile(TxtFileCoMFinalString.c_str());
//    First get the labeled components for each image ROI
    int numbEx=VectorNiiEx.size();
    int numbROI=VectorNiiROI.size();
    int numel=ImageRef->nvox;
    
    if (numbEx!=numbROI) {
        return NULL;
    }
    bool * MaskData=static_cast<bool*>(Mask->data);
//    nifti_image * MaskFloat=CreateNiiFromArray(MaskData, ImageRef, numel);
    int Dim[3];
    float PixDim[3];
    int Shift[3];
    vector<int> DimVector;
    for (int d=0; d<3; d++) {
        Dim[d]=ImageRef->dim[d+1];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
        PixDim[d]=ImageRef->pixdim[d+1];
        DimVector.push_back(Dim[d]);
    }
    int CGMask=GetCenterGravity(MaskData, Dim);
//    float * CreatedTest=CreateSphereAroundVox(CGMask, Dim, Shift, PixDim, 5.5);
//    nifti_image* TestCircle=CreateNiiFromArray(CreatedTest, ImageRef, numel);
//    nifti_set_filenames(TestCircle, "/Users/Carole/Documents/PhD/POPPY/CoordCorresp/TestCircle.nii.gz", 0, 0);
//    nifti_image_write(TestCircle);
//    nifti_image_free(TestCircle);
//    TestCircle=NULL;
//    delete [] CreatedTest;
//    CreatedTest=NULL;
//    Starting with the reference for which we get also the Centre of gravity. Assumption that the number of CC will be conserved through non rigid registration
    int * LabelROIRef=ComponentLabeling(ROIRef, 26);
    int numbROIRef=GetMaxLabel(LabelROIRef, numel);
    if (numbROIRef > 4) {
        cout << "Situation problematic LFROI Pb registration "<< endl;
        int* ROIRefOrdered=OrderedVolumeLabel(LabelROIRef, 2, numel);
        string FilenamePA=nifti_makebasename(ROIRef->fname);
        nifti_image * ROIRefOrderedNii=CreateNiiFromArray(ROIRefOrdered, ROIRef, numel);
        
        int Index=FilenamePA.find_last_of('/');
        string FilenamePA_b=FilenamePA.substr(0,Index+1);
        string FilenamePA_e=FilenamePA.substr(Index+1,FilenamePA.length());
        string FilenameSave=FilenamePA_b+"TestRefOrdered_"+FilenamePA_e+".nii.gz";
        nifti_set_filenames(ROIRefOrderedNii, FilenameSave.c_str(), 0, 0);
        nifti_image_write(ROIRefOrderedNii);
        nifti_image_free(ROIRefOrderedNii);
        bool * OpposeMask=OpposeBoolArray(MaskData, numel);
        float * WeightROI=new float[numbROIRef];
        float * ROIData=static_cast<float*>(ROIRef->data);
        int * CorrespGrav=CorrespondingCoordinates(CGMask, Dim, Shift);
        for (int r=0; r<numbROIRef; r++) {
            bool * ROIBool=CreateLesionBool(ROIRefOrdered, r+1, numel);
            bool * OpposeROI=OpposeBoolArray(ROIBool, numel);
            MultiplyElementwiseChange(OpposeROI, ROIRefOrdered, numel);
            WeightROI[r]=GetMeanData(ROIData, ROIBool, numel);
            
            int * BBInd=FindBoundingBox(ROIBool, Dim, Shift);
            int *NewBBInd=new int[6];
            for(int d=0;d<3;d++){
//                cout << CorrespGrav[d] << " " << BBInd[2*d] << " " << BBInd[2*d +1]<<endl;
                NewBBInd[2*d]=BBInd[2*d];
                NewBBInd[2*d+1]=BBInd[2*d+1];
                if (d==2){
                NewBBInd[2*d]=CorrespGrav[d]+CorrespGrav[d]-BBInd[2*d+1];
                NewBBInd[2*d+1]=CorrespGrav[d]+CorrespGrav[d]-BBInd[2*d];
//                    cout << CorrespGrav[d] << " " << NewBBInd[2*d] << " " << NewBBInd[2*d +1]<<endl;
                }
//            if (BBInd[2*d]<CorrespGrav[d] && BBInd[2*d+1]>CorrespGrav[d]) {
//                cout << "Too central for region "<< r<<endl;
//                WeightROI[r]=0;
//            }
            }
            
            bool * BBTot=CreateBoolBoundingBox(NewBBInd, Dim);
            
            MultiplyElementwiseChange(BBTot, ROIRefOrdered, numel);
            cout << CountNonZero(BBTot, numel) << endl;
            if (CountNonZero(BBTot, numel)<CountNonZero(ROIBool, numel)/100) {
                cout << "Without enough symmetric finding for region "<< r<<endl;
                WeightROI[r]=0;
            }
            int SizeLabel=GetLabelSize(r+1, ROIRefOrdered, numel);
            ANDOperationBool(OpposeMask, ROIBool, ROIBool, numel);
            if (CountNonZero(ROIBool, numel)>SizeLabel/2) {
                WeightROI[r]=0;
                cout << "Will have to discard region "<< r<< endl;
            }

            delete [] BBTot;
            delete [] BBInd;
        }
        delete [] OpposeMask;
        cout << "Final Weights are ";
        for (int r=0; r<numbROIRef; r++) {
            cout << " " << WeightROI[r];
        }
        cout << endl;
        cout << CountNonZero(WeightROI, numbROIRef) << "still maintained regions"<<endl;
        vector<float> WeightToDelete;
        //int * order;
        float ValueMinWeight=-1;
        if (CountNonZero(WeightROI, numbROIRef)>4) {
            cout << "Still something to delete"<<endl;
            float* WeightTemp=CopyArray(WeightROI, numbROIRef);
            quickSort(WeightTemp, numbROIRef);
            ValueMinWeight=WeightTemp[numbROIRef-1-4];
        }
//        float ValueMinWeight=WeightROI[GetIndexNValue(WeightROI, 3, 0, numbROIRef)];
        for (int i=0; i<numel; i++) {
//            LabelROIRef[i]=WeightROI[ROIRefOrdered[i]]<ValueMinWeight?0:ROIRefOrdered[i];
            ROIRefOrdered[i]=WeightROI[ROIRefOrdered[i]-1]==0?0:ROIRefOrdered[i]*MaskData[i];
            if (ValueMinWeight>0) {
                ROIRefOrdered[i]=WeightROI[ROIRefOrdered[i]-1]<=ValueMinWeight?0:ROIRefOrdered[i]*MaskData[i];
            }
        }
        nifti_image * LabelROICorrectedNii=CreateNiiFromArray(ROIRefOrdered, ROIRef, numel);
        delete [] LabelROIRef;
        LabelROIRef=NULL;
        LabelROIRef=ComponentLabeling(LabelROICorrectedNii, 26);
        nifti_set_filenames(LabelROICorrectedNii, FilenameSave.c_str(), 0, 0);
        nifti_image_write(LabelROICorrectedNii);
        nifti_image_free(LabelROICorrectedNii);
        delete [] ROIRefOrdered;
        delete [] WeightROI;
        ROIRefOrdered=NULL;
        numbROIRef=GetMaxLabel(LabelROIRef, numel);
        cout << "new numbROIRef" << numbROIRef << endl;
    }
    vector< vector<nifti_image *> > EuclideanVector;
    vector<vector<bool*> > VectorFinal;
    vector< bool* > LabelEnlarged;
    vector<int> CentreGravVector;
    vector<float*> DataForNCC;
    vector< vector<float> > WeightLabelNCC;
    float * DataRef=static_cast<float*>(ImageRef->data);
    DataForNCC.push_back(DataRef);
    for (int l=0; l<numbROIRef; l++) {
        LabelEnlarged.push_back(NULL);
    }
    for (int l=0; l<numbROIRef; l++) {
        bool * LabelBoolRefToPush=CreateLesionBool(LabelROIRef, l+1, numel);
        bool * EnlargedLabelRef=ErosionTemplate(LabelBoolRefToPush, 5, DimVector, 0);
        vector<bool *> LabelSeparated;
        LabelSeparated.push_back(LabelBoolRefToPush);
        LabelEnlarged[l]=EnlargedLabelRef;
        VectorFinal.push_back(LabelSeparated);
        int CentreGravToPush=GetCenterGravity(LabelBoolRefToPush, Dim);
        cout << CentreGravToPush << " centre gravity reference " << l << endl;
        CentreGravVector.push_back(CentreGravToPush);
        vector<nifti_image *> EuclideanDistanceVectorToPush;
        EuclideanVector.push_back(EuclideanDistanceVectorToPush);
        vector<float> WeightToPush;
        WeightLabelNCC.push_back(WeightToPush);
    }
    
    cout<<"Reference treated"<<endl;
    
    //    Need to calculate for each label and each of the example image in their corresponding vector the NCC
    for (int i=0; i<numbEx; i++) {
        float * DataComp=static_cast<float*>(VectorNiiEx[i]->data);
        DataForNCC.push_back(DataComp);
    }
    vector< float* > VectorNCCperLabel;
    vector< int * > VectorOrderNCCperLabel;
    vector<float *> VectorWeightNCCperLabel;
    for (int lr=0; lr<numbROIRef; lr++) {
        float * NCCToPush=new float[numbEx];
        float * WeightNCC=new float[numbEx];
        float SumWeight=0;
        for (int i=0; i<numbEx; i++) {
            WeightNCC[i]=1;
            float NCCValue=NCCCalculation(DataForNCC[0],DataForNCC[i],LabelEnlarged[lr],numel);
            NCCToPush[i]=NCCValue;
        }
        float * NCCToPushCopy=CopyArray(NCCToPush, numbEx);
        int * OrderNCCToPush=quickSort_order(NCCToPushCopy, numbEx);
        delete [] NCCToPushCopy;
        NCCToPushCopy=NULL;
//        VectorNCCperLabel.push_back(NCCToPush);
//        VectorOrderNCCperLabel.push_back(OrderNCCToPush);
        
//        float MaxNCC=GetMax(NCCToPush, numbEx);
        for (int i=0; i<numbEx; i++) {
//            float Weight=NCCToPush[i]/MaxNCC;
            float Weight=exp(-0.5*i);
            WeightNCC[OrderNCCToPush[i]]=Weight;
            float * ROIExData=static_cast<float*>(VectorNiiROI[i]->data);
            bool * Overlap=MultiplyElementwiseChoose<bool, float, bool>(LabelEnlarged[lr], ROIExData, numel);
            if (CountNonZero(Overlap, numel)<10) { // If no overlap between regions
                WeightNCC[OrderNCCToPush[i]]=0;
                cout << "No overlap with label enlarged for labe "<< lr << " and example " << i << endl;
            }
            SumWeight+=Weight;
        }
        for (int i=0; i<numbEx; i++) {
            WeightNCC[i]/=SumWeight;
            cout << WeightNCC[i] << " " << endl;
        }
        
        VectorWeightNCCperLabel.push_back(WeightNCC);
        delete [] NCCToPush;
        delete [] OrderNCCToPush;
        NCCToPush=NULL;
        OrderNCCToPush=NULL;
    }
    cout<<"NCC performed "<<endl;
    
// WARNING FOR THE LABELS NEED FIRST TO GET THE CORRESPONDING label index of the REF ROI.
    vector<int *> VecLabel;
    cout << "NumbEx is " << numbEx <<endl;
    cout << "NumbROINii is "<< VectorNiiROI.size() << endl;
    cout << "Numel is " << numel << endl ;
    for (int i=0; i<numbEx; i++) {
        int * LabelROIToPush=ComponentLabeling(VectorNiiROI[i], 26);
        int numbLab=GetMaxLabel(LabelROIToPush, numel);
        cout<<" Number labels for image "<<i<<" is "<<numbLab<<endl;
        vector<int> CentreGravVector_ind;
        vector<int> IndexCorrVector;
        vector<bool*> LabelBoolSeparatedROI;
        for (int l=0; l<numbLab; l++) {
            bool * LabelBoolROIToPush=CreateLesionBool(LabelROIToPush, l+1, numel);
            LabelBoolSeparatedROI.push_back(LabelBoolROIToPush);
            int CentreGravToPush=GetCenterGravity(LabelBoolROIToPush, Dim);
            cout <<"CG " <<CentreGravToPush<< " " << i << " " << l << endl;
            bool * CentreGravBool=new bool[numel];
            for (int n=0; n<numel; n++) {
                if (n==CentreGravToPush) {
                    CentreGravBool[n]=1;
                }
                else{
                    CentreGravBool[n]=0;
                }
            }
//            int CountNZ=CountNonZero(CentreGravBool, numel);
//            int CountNZMask=CountNonZero(MaskData, numel);
            cout << "Starting point "<< l<< " " << CountNonZero<bool>(CentreGravBool, numel) << endl;
            nifti_image * EuclideanDistanceToPush=EuclideanDistanceImage(ImageRef,CentreGravBool,Mask);
//            nifti_set_filenames(EuclideanDistanceToPush, "/Users/Carole/Documents/PhD/POPPY/CoordCorresp/TestED.nii.gz", 0, 0);
//            nifti_image_write(EuclideanDistanceToPush);
            delete [] CentreGravBool;
            CentreGravBool=NULL;
            CentreGravVector_ind.push_back(CentreGravToPush);
            int CorrespListInd=0;
            float DistMax=1000;
            for (int lr=0; lr<numbROIRef; lr++) {
                float Dist=GetDistanceBetweenPoints(CentreGravToPush, CentreGravVector[lr], Dim, PixDim);
                if (Dist<DistMax) {
                    DistMax=Dist;
                    CorrespListInd=lr;
                    cout << "Corresp Index is " << lr;
                }
            }
            EuclideanVector[CorrespListInd].push_back(EuclideanDistanceToPush);
            IndexCorrVector.push_back(CorrespListInd);
            VectorFinal[CorrespListInd].push_back(LabelBoolROIToPush);
//            WeightLabelNCC[CorrespListInd].push_back(VectorNCCperLabel[CorrespListInd][i]);
            WeightLabelNCC[CorrespListInd].push_back(VectorWeightNCCperLabel[CorrespListInd][i]);
        }
        delete [] LabelROIToPush;
        LabelROIToPush=NULL;
    }
    
    cout<<"Individual cases calculated "<<endl;
//   1 vectors of bool array obtained. One for the mask themselves. One vector for each individual ROI containing as first element the ROI itself and as subsequent those of the example images.
    

    
//    Then calculate the weighted sum of the distance maps squared
    vector<float *> FinalVectorDist;
    for (int lr=0;lr<numbROIRef;lr++){
        int numbMaps=EuclideanVector[lr].size();
        cout <<"numbMaps "<< numbMaps << " for lr " << lr << endl;
        float * WeightedDist=new float[numel];
        for(int i=0;i<numel;i++){
            WeightedDist[i]=0;
        }
        for(int n=0;n<numbMaps;n++){
            float Weight=WeightLabelNCC[lr][n];
            cout << Weight << endl;
            float * InitDist=static_cast<float*>(EuclideanVector[lr][n]->data);
            cout << GetMin(InitDist, MaskData, numel) << " " << CountNonZero(InitDist,numel) << endl;
            if (GetMin(InitDist, MaskData,numel)<10) {
                for(int i=0;i<numel;i++){
                    WeightedDist[i]+=InitDist[i]*InitDist[i]*Weight;
                }
            }

        }
        FinalVectorDist.push_back(WeightedDist);
    }
    
    cout<<"Distance Weighted sum calculated"<<endl;
    
//    Then find the minimum
    int * MinIndArray=new int[numbROIRef];
    for(int lr =0;lr<numbROIRef;lr++){
//        int MinInd=GetIndexMin(FinalVectorDist[lr], numel);
        int MinInd=GetIndexMinMasked(FinalVectorDist[lr],MaskData,numel);
        cout << MaskData[MinInd] << " is of mask " << MinInd << endl;
        MinIndArray[lr]=MinInd;
        int * CorrespIndices=CorrespondingCoordinates(MinInd, Dim, Shift);
        cout<<" Centre of mass index is ";
        if (TxtFile){
            TxtFile << "Centre of mass index is ";
        }
        for (int d =0;d<3;d++){
            cout<<CorrespIndices[d]<<" ";
            if (TxtFile){
                TxtFile << CorrespIndices[d]<<" ";
            }
        }
        delete [] CorrespIndices;
        CorrespIndices=NULL;
        cout<<endl;
    }
    
//   Then produce the final image by translating for each of the label the original label in first position of VectorFinal
    float * NewFinalLabel;//=new float[numel];
//    for(int i=0;i<numel;i++){
//        NewFinalLabel[i]=0;
//    }
    
    int CorrespCGMask[3];
    CorrespondingCoordinates_bis(CorrespCGMask, CGMask, Dim, Shift);
    vector<float*> ROIToSum;
    for (int lr=0; lr<numbROIRef; lr++) {
        int CorrespIndicesSol[3];
        CorrespondingCoordinates_bis(CorrespIndicesSol, MinIndArray[lr], Dim, Shift);
        float Radius=2.5;
        if (CorrespCGMask[0]<CorrespIndicesSol[0]) { // Sol is posterior WARNING Not checking orientation at the moment
            Radius=5.75;
        }
        float * NewROI=CreateSphereAroundVox(MinIndArray[lr], Dim, Shift, PixDim, Radius);
        ROIToSum.push_back(NewROI);
    }
    NewFinalLabel=AddArray(ROIToSum, numel);
//        for(int lr=0;lr<numbROIRef;lr++){
//            bool * LabelToTranslate=VectorFinal[lr][0];
//            int CorrespIndices[3];
//            int CorrespIndicesSol[3];
//            int CorrespIndicesInit[3];
//            CorrespondingCoordinates_bis(CorrespIndicesInit, CentreGravVector[lr], Dim, Shift);
//            CorrespondingCoordinates_bis(CorrespIndicesSol, MinIndArray[lr], Dim, Shift);
//            int Translation[3];
//            for(int d=0;d<3;d++){
//                Translation[d]=CorrespIndicesSol[d]-CorrespIndicesInit[d];
//            }
//            for(int i=0;i<numel;i++){
//            if(LabelToTranslate[i]){
//                CorrespondingCoordinates_bis(CorrespIndices, i, Dim, Shift);
//                int TranslatedInd=0;
//                for(int d=0;d<3;d++){
//                    TranslatedInd+=(CorrespIndices[d]+Translation[d])*Shift[d];
//                }
//                NewFinalLabel[TranslatedInd]=1;
//                
//            }
//        }
//    }
    
    cout<<"Final image produced "<<endl;
    nifti_image * NewMaskToReturn=CreateNiiFromArray(NewFinalLabel, ImageRef, numel);
    
//    Clear all memory not needed anymore
    delete [] NewFinalLabel;
    delete [] MinIndArray;
    for(int lr=0;lr<numbROIRef;lr++){
        delete [] ROIToSum[lr];
        ROIToSum[lr]=NULL;
        delete [] FinalVectorDist[lr];
        FinalVectorDist[lr]=NULL;
        delete [] LabelEnlarged[lr];
        LabelEnlarged[lr]=NULL;
        int numbED=EuclideanVector[lr].size();
        for(int ed=0;ed<numbED;ed++){
            nifti_image_free(EuclideanVector[lr][ed]);
            EuclideanVector[lr][ed]=NULL;
        }
        int numbVF=VectorFinal[lr].size();
        for(int vf=0;vf<numbVF;vf++){
            delete [] VectorFinal[lr][vf];
            VectorFinal[lr][vf]=NULL;
        }
    }
    
    return NewMaskToReturn;
    
}


void ExtractWriteCoMComponent(nifti_image * ImageToLabel, int Neigh, string Filename){
    ofstream TxtFileCom(Filename.c_str());
    int * CCArray=ComponentLabeling(ImageToLabel, Neigh);
    int Dim[3];
    int Shift[3];
    for (int d=0; d<3; d++) {
        Dim[d]=ImageToLabel->dim[d+1];
        Shift[d]=d>0?Dim[d-1]*Shift[d-1]:1;
    }
    int numel=ImageToLabel->nvox;
    int numbLabel=GetMaxLabel(CCArray, numel);
    for (int l=0; l<numbLabel; l++) {
        bool * LabelBool=CreateLesionBool(CCArray, l+1, numel);
        int IndCG=GetCenterGravity(LabelBool, Dim);
        int CorrespInd[3];
        CorrespondingCoordinates_bis(CorrespInd, IndCG, Dim, Shift);
        TxtFileCom << "Label " << l+1<< " ";
        for (int d=0; d<3; d++) {
            TxtFileCom << CorrespInd[d] <<" ";
                }
        TxtFileCom<<endl;
        delete [] LabelBool;
        LabelBool=NULL;
    }
    
}

float * CreateSphereAroundVox(int Index, int * Dim , int * Shift, float* PixDim, float Distance){
    int maxNumbVoxel=0;
    for (int d=0; d<3; d++) {
        int RatioNumb=ceil(Distance/PixDim[d]);
        if (RatioNumb>maxNumbVoxel) {
            maxNumbVoxel=RatioNumb;
        }
    }
    // Create Bounding Box limits based on maxNumbVoxel and DimFixed
    //    First get the Corresponding coordinates for Index
    int CorrespInd[3];
    CorrespondingCoordinates_bis(CorrespInd, Index, Dim, Shift);
    int BB[6];
    int numel=1;
    for (int d=0; d<3; d++) {
        numel*=Dim[d];
        BB[2*d]=0;
        BB[2*d+1]=0;

            BB[2*d]=CorrespInd[d]-maxNumbVoxel;
            BB[2*d+1]=CorrespInd[d]+maxNumbVoxel;
        
    }
    bool * BoundingBoxBool=CreateBoolBoundingBox(BB, Dim);
    //    int NZ=CountNonZero(BoundingBoxBool, numel);
    float * FinalROI=new float[numel];
    for (int i=0; i<numel; i++) {
        FinalROI[i]=0;
        if (BoundingBoxBool[i]) {
            float DistanceBP=GetDistanceBetweenPoints(Index, i, Dim, PixDim);
            if (DistanceBP<Distance) {
                FinalROI[i]=1;
            }
            else if (DistanceBP<Distance+1){
                FinalROI[i]=Distance+1-DistanceBP;
            }
        }
    }
    delete [] BoundingBoxBool;
    BoundingBoxBool=NULL;
    return FinalROI;
}

float * CreateCircleAroundVox(int Index, int * Dim, int * Shift, float * PixDim, float Distance, int DimFixed){
    int maxNumbVoxel=0;
    for (int d=0; d<3; d++) {
        int RatioNumb=ceil(Distance/PixDim[d]);
        if (RatioNumb>maxNumbVoxel) {
            maxNumbVoxel=RatioNumb;
        }
    }
    // Create Bounding Box limits based on maxNumbVoxel and DimFixed
//    First get the Corresponding coordinates for Index
    int CorrespInd[3];
    CorrespondingCoordinates_bis(CorrespInd, Index, Dim, Shift);
    int BB[6];
    int numel=1;
    for (int d=0; d<3; d++) {
        numel*=Dim[d];
        BB[2*d]=0;
        BB[2*d+1]=0;
        if (d==DimFixed) {
            BB[2*d]=CorrespInd[d];
            BB[2*d+1]=CorrespInd[d];
        }
        else{
            BB[2*d]=CorrespInd[d]-maxNumbVoxel;
            BB[2*d+1]=CorrespInd[d]+maxNumbVoxel;
        }
    }
    
    bool * BoundingBoxBool=CreateBoolBoundingBox(BB, Dim);
//    int NZ=CountNonZero(BoundingBoxBool, numel);
    float * FinalROI=new float[numel];
    for (int i=0; i<numel; i++) {
        FinalROI[i]=0;
        if (BoundingBoxBool[i]) {
            float DistanceBP=GetDistanceBetweenPoints(Index, i, Dim, PixDim);
            if (DistanceBP<Distance) {
                FinalROI[i]=1;
            }
            else if (DistanceBP<Distance+1){
                FinalROI[i]=Distance+1-DistanceBP;
            }
        }
    }
    delete [] BoundingBoxBool;
    BoundingBoxBool=NULL;
    return FinalROI;
}



// This method provides a way of storing the local information needed for the bullseye (Volume of each are, BinarySeg Volume, ProbaSeg Volume based on QuadrantImage LaplaceLayers and LesionImage
int * LocalSummaryLesionNumber(nifti_image * Lesion, nifti_image * Quadrant, nifti_image * Layers){
    //    First create the summarising array for localisation
    int DimQ[4];
    for (int d=0; d<4; d++) {
        DimQ[d]=pow_int(10, d);
    }

    int numel=Lesion->nvox;
    set<int> * LocalisationData=new set<int>[32];
    float *QuadrantData=static_cast<float*>(Quadrant->data);
    float *LesionData=static_cast<float*>(Lesion->data);
    int * ConnectedLesion=ComponentLabeling(Lesion, 6);
    float *LayersData=static_cast<float*>(Layers->data);
    int CountPb=0;
    for (int i=0; i<numel; i++) {
        if (QuadrantData[i]>0 && LayersData[i]>0) {
            if (LesionData[i]>0) {
                
            int LayersToAdd=LayersData[i]>4?4:LayersData[i];
            int LocalisationValue=10*QuadrantData[i]+LayersToAdd;
            int * IndexQ= CorrespondingCoordinates_ter(LocalisationValue, DimQ, DimQ,4);
            int ValueFin=0;
            for (int d=0; d<4; d++) {
                ValueFin+=d>0?pow_int(2,d-1)*4*(IndexQ[d]-1):IndexQ[d]-1;
            }
            if (ValueFin>32) {
                CountPb++;
                ValueFin=31;
            }
            delete [] IndexQ;
            IndexQ=NULL;
            LocalisationData[ValueFin].insert(ConnectedLesion[i]);
            }
        }
    }
    //    nifti_image * LocalisationNii=CreateNiiFromArray(LocalisationData, Lesion, numel);
    //    nifti_set_filenames(LocalisationNii, "/Users/Carole/Documents/PhD/BAMBI_ADNI/AtestLS.nii.gz", 0, 0);
    //    nifti_image_write(LocalisationNii);
    //    nifti_image_free(LocalisationNii);
    //    LocalisationNii=NULL;
    // Initialisation of the resulting array. For each of the 32 regions, given as LesionProb LesionBin VolTotal
    int * ResultSummary=new int[33];
    //int numbRS=33;
    for (int i=0; i<33; i++) {
        ResultSummary[i]=0;
    }
    //    int max=GetMax(LocalisationData, numel);
    for (int i=0; i<32; i++) {
        ResultSummary[i]=LocalisationData[i].size();
    }
    ResultSummary[32]=GetMaxLabel(ConnectedLesion, Lesion->nvox);
    //    float max2=GetMax(ResultSummary, numbRS);
    delete [] LocalisationData;
    delete [] ConnectedLesion;
    return ResultSummary;
}

// This method provides a way of storing the local information needed for the bullseye (Volume of each are, BinarySeg Volume, ProbaSeg Volume based on QuadrantImage LaplaceLayers and LesionImage
int * LocalSummaryLesionNumber_bis(nifti_image * Lesion, nifti_image * Lobes, nifti_image * Layers){
    //    First create the summarising array for localisation
    int DimQ[4];
    for (int d=0; d<4; d++) {
        DimQ[d]=pow_int(10, d);
    }
    
    int numel=Lesion->nvox;
    float * LobesData=static_cast<float*>(Lobes->data);
    int * LobesDataInt=TranscribeArray<float, int>(LobesData, numel);
    
    float * LayersData=static_cast<float*>(Layers->data);
    int * LayersDataInt=TranscribeArray<float, int>(LayersData, numel);
    
    int numbLobes=GetMaxLabel(LobesDataInt, numel);
    int numbLayers=GetMaxLabel(LayersDataInt, numel);
    numbLayers=numbLayers>4?4:numbLayers;
    int numbTot=numbLobes*numbLayers;
    set<int> * LocalisationData=new set<int>[numbTot];

    float *LesionData=static_cast<float*>(Lesion->data);
    int * ConnectedLesion=ComponentLabeling(Lesion, 6);

    int CountPb=0;
    for (int i=0; i<numel; i++) {
        if (LobesData[i]>0 && LayersData[i]>0) {
            if (LesionData[i]>0) {
                
                int LayersToAdd=LayersData[i]>numbLayers?numbLayers:LayersData[i];
                int ValueFin=(LobesData[i]-1)*4+(LayersToAdd-1);
                if (ValueFin>numbTot) {
                    CountPb++;
                    ValueFin=numbTot-1;
                }
                LocalisationData[ValueFin].insert(ConnectedLesion[i]);
            }
        }
    }
    //    nifti_image * LocalisationNii=CreateNiiFromArray(LocalisationData, Lesion, numel);
    //    nifti_set_filenames(LocalisationNii, "/Users/Carole/Documents/PhD/BAMBI_ADNI/AtestLS.nii.gz", 0, 0);
    //    nifti_image_write(LocalisationNii);
    //    nifti_image_free(LocalisationNii);
    //    LocalisationNii=NULL;
    // Initialisation of the resulting array. For each of the 32 regions, given as LesionProb LesionBin VolTotal
    int * ResultSummary=new int[numbTot+1];
    int numbRS=numbTot+1;
    for (int i=0; i<numbRS; i++) {
        ResultSummary[i]=0;
    }
    //    int max=GetMax(LocalisationData, numel);
    for (int i=0; i<numbTot; i++) {
        ResultSummary[i]=LocalisationData[i].size();
    }
    ResultSummary[numbRS]=GetMaxLabel(ConnectedLesion, Lesion->nvox);
    //    float max2=GetMax(ResultSummary, numbRS);
    delete [] LocalisationData;
    delete [] ConnectedLesion;
    return ResultSummary;
}






// This method provides a way of storing the local information needed for the bullseye (Volume of each are, BinarySeg Volume, ProbaSeg Volume based on QuadrantImage LaplaceLayers and LesionImage
float * LocalSummaryMahal(nifti_image * Lesion, nifti_image * Quadrant, nifti_image * Layers, nifti_image * MahalImage){
    if (MahalImage==NULL) {
        cout <<"No MahalImage" <<endl;
        return NULL;
    }
    //    First create the summarising array for localisation
    int DimQ[4];
    for (int d=0; d<4; d++) {
        DimQ[d]=pow_int(10, d);
    }
    int numbMahal=MahalImage->dim[4];
    int numel=Lesion->nvox;
    float * LocalisationData=new float[(numbMahal+1)*33];
    for (int m=0; m<=numbMahal; m++) {
        for (int i=0; i<33; i++) {
            LocalisationData[m*33+i]=0;
        }
    }
    float *QuadrantData=static_cast<float*>(Quadrant->data);
    float *LesionData=static_cast<float*>(Lesion->data);
    float *LayersData=static_cast<float*>(Layers->data);
    float *MahalData=static_cast<float*>(MahalImage->data);
    int CountPb=0;
    for (int i=0; i<numel; i++) {
        if (QuadrantData[i]>0 && LayersData[i]>0) {
            if (LesionData[i]>0) {
                
            
            int LayersToAdd=LayersData[i]>4?4:LayersData[i];
            int LocalisationValue=10*QuadrantData[i]+LayersToAdd;
            int * IndexQ= CorrespondingCoordinates_ter(LocalisationValue, DimQ, DimQ,4);
            int ValueFin=0;
            for (int d=0; d<4; d++) {
                ValueFin+=d>0?pow_int(2,d-1)*4*(IndexQ[d]-1):IndexQ[d]-1;
            }
            if (ValueFin>32) {
                CountPb++;
                ValueFin=31;
            }
            delete [] IndexQ;
            IndexQ=NULL;
                for (int m=0; m<numbMahal; m++) {
                    LocalisationData[m*33+ValueFin]+=LesionData[i]*MahalData[m*numel+i];
                    LocalisationData[m*33+32]+=LesionData[i]*MahalData[m*numel+i];
                }
                LocalisationData[numbMahal*33+ValueFin]+=LesionData[i];
                LocalisationData[numbMahal*33+32]+=LesionData[i];
        }
        }

        }
    //    nifti_image * LocalisationNii=CreateNiiFromArray(LocalisationData, Lesion, numel);
    //    nifti_set_filenames(LocalisationNii, "/Users/Carole/Documents/PhD/BAMBI_ADNI/AtestLS.nii.gz", 0, 0);
    //    nifti_image_write(LocalisationNii);
    //    nifti_image_free(LocalisationNii);
    //    LocalisationNii=NULL;
    // Initialisation of the resulting array. For each of the 32 regions, given as LesionProb LesionBin VolTotal

    int numbRS=numbMahal*33;
    float * ResultSummary=new float[numbRS];
    for (int i=0; i<numbRS; i++) {
        ResultSummary[i]=0;
    }
    //    int max=GetMax(LocalisationData, numel);
    for (int m=0; m<numbMahal; m++) {
        for (int i=0; i<33; i++) {
            if(LocalisationData[33*numbMahal+i]>0){
            ResultSummary[33*m+i]=LocalisationData[33*m+i]/LocalisationData[33*(numbMahal)+i];
            }
        }
    }

    //    float max2=GetMax(ResultSummary, numbRS);
    delete [] LocalisationData;
    return ResultSummary;
}


vector<float *> LocalSummaryStats(nifti_image * WMNii, nifti_image * Lobes, nifti_image * Layers , nifti_image * MahalNii){
    vector<float *> ResultsStats;
    if (MahalNii==NULL) {
        cout <<"No MahalImage" <<endl;
        return ResultsStats;
    }
    //    First create the summarising array for localisation
    int numbMahal=MahalNii->dim[4];
    int numel=WMNii->nvox;
    
    float *LobesData=static_cast<float*>(Lobes->data);
    float *WMData=static_cast<float*>(WMNii->data);
    float *LayersData=static_cast<float*>(Layers->data);
    float *MahalData=static_cast<float*>(MahalNii->data);
    float MaxLayers=GetMax(LayersData, numel)-1;
    // Threshold WMData at 0.5
    bool * WMMask=ThresholdArray<float, bool>(WMData, 0.5, numel);
    // Change Layers so as to get not 5 but truly 4 layers.
    for (int i=0; i<numel; i++) {
        LayersData[i]=LayersData[i]>MaxLayers?MaxLayers:LayersData[i];
    }
    float MaxLobes=GetMax(LobesData, numel);
    int numbTot=MaxLobes*MaxLayers;
    int numbStats=9*(numbTot+1);
    for (int i=0; i<numbMahal; i++) {
        float * ToPush=new float[numbStats];
        for (int s=0; s<numbStats; s++) {
            ToPush[s]=0;
        }
        ResultsStats.push_back(ToPush);
    }
    cout << GetMin(LayersData, numel)<<" ";
    cout << GetMax(LayersData, numel)<<" ";
    cout << GetMin(LobesData, numel)<< " " ;
    cout << GetMax(LobesData, numel) << endl;
    for (int l=1; l<MaxLayers+1; l++) {
        bool * LayerMask=EqualArray<float, bool>(LayersData, (float)l, numel);
        ANDOperationBool(LayerMask, WMMask, LayerMask, numel);
        for (int r=1; r<=MaxLobes; r++) {
            // First create the mask over WM Layer and Lobe
            bool * LobeMask=EqualArray<float, bool >(LobesData, (float)r, numel);
            int Numb=CountNonZero(LobeMask, numel);
            cout << "Non zero in "<<r<<" "<<l<<" "<<Numb<<" "<<numel<<" "<<numbMahal<<endl;
            ANDOperationBool(LobeMask, LayerMask, LobeMask, numel);
            for (int m=0; m<numbMahal; m++) {
                float * ToPlace=GetStatisticData(&MahalData[m*numel], LobeMask, numel);
                for (int s=0; s<9; s++) {
                    ResultsStats[m][s+(l-1)*9+(r-1)*(int)MaxLayers*9]=ToPlace[s];
                }
                delete ToPlace;
                ToPlace=NULL;
            }
            delete [] LobeMask;
            LobeMask=NULL;
        }
        delete [] LayerMask;
        LayerMask=NULL;
    }
    for (int m=0; m<numbMahal; m++) {
        float * ToPlace=GetStatisticData(&MahalData[m*numel], WMMask, numel);
        for (int s=0; s<9; s++) {
            ResultsStats[m][numbTot*9+s]=ToPlace[s];
        }
        delete ToPlace;
        ToPlace=NULL;
    }
    delete WMMask;
    WMMask=NULL;
    return ResultsStats;

}


// This method provides a way of storing the local information needed for the bullseye (Volume of each are, BinarySeg Volume, ProbaSeg Volume based on QuadrantImage LaplaceLayers and LesionImage
float * LocalSummaryMahal_bis(nifti_image * Lesion, nifti_image * Lobes, nifti_image * Layers, nifti_image * MahalImage){
    if (MahalImage==NULL) {
        cout <<"No MahalImage" <<endl;
        return NULL;
    }
    //    First create the summarising array for localisation
    int DimQ[4];
    for (int d=0; d<4; d++) {
        DimQ[d]=pow_int(10, d);
    }
    int numbMahal=MahalImage->dim[4];
    int numel=Lesion->nvox;

    float *LobesData=static_cast<float*>(Lobes->data);
    float *LesionData=static_cast<float*>(Lesion->data);
    float *LayersData=static_cast<float*>(Layers->data);
    float *MahalData=static_cast<float*>(MahalImage->data);
    float MaxLayers=GetMax(LayersData, numel)-1;
    float MaxLobes=GetMax(LobesData, numel);
    int numbTot=MaxLobes*MaxLayers;
    float * LocalisationData=new float[(numbMahal+1)*(numbTot+1)];
    for (int m=0; m<=numbMahal; m++) {
        for (int i=0; i<numbTot+1; i++) {
            LocalisationData[m*(numbTot+1)+i]=0;
        }
    }
    int CountPb=0;
    for (int i=0; i<numel; i++) {
        if (LobesData[i]>0 && LayersData[i]>0) {
            if (LesionData[i]>0) {
                
                LesionData[i]=LesionData[i]>1?1:LesionData[i];
                int LayersToAdd=LayersData[i]>MaxLayers?MaxLayers:LayersData[i];
                int ValueFin=(LobesData[i]-1)*MaxLayers+LayersToAdd-1;
                if (ValueFin>numbTot) {
                    CountPb++;
                    ValueFin=numbTot-1;
                }
                for (int m=0; m<numbMahal; m++) {
                    LocalisationData[m*(numbTot+1)+ValueFin]+=LesionData[i]*MahalData[m*numel+i];
                    LocalisationData[m*(numbTot+1)+numbTot]+=LesionData[i]*MahalData[m*numel+i];
                }
                LocalisationData[numbMahal*(numbTot+1)+ValueFin]+=LesionData[i];
                LocalisationData[numbMahal*(numbTot+1)+numbTot]+=LesionData[i];
            }
        }
        
    }
    //    nifti_image * LocalisationNii=CreateNiiFromArray(LocalisationData, Lesion, numel);
    //    nifti_set_filenames(LocalisationNii, "/Users/Carole/Documents/PhD/BAMBI_ADNI/AtestLS.nii.gz", 0, 0);
    //    nifti_image_write(LocalisationNii);
    //    nifti_image_free(LocalisationNii);
    //    LocalisationNii=NULL;
    // Initialisation of the resulting array. For each of the 32 regions, given as LesionProb LesionBin VolTotal
    
    int numbRS=numbMahal*(numbTot+1);
    float * ResultSummary=new float[numbRS];
    for (int i=0; i<numbRS; i++) {
        ResultSummary[i]=0;
    }
    //    int max=GetMax(LocalisationData, numel);
    for (int m=0; m<numbMahal; m++) {
        for (int i=0; i<numbTot+1; i++) {
            if(LocalisationData[(numbTot+1)*numbMahal+i]>0){
                ResultSummary[(numbTot+1)*m+i]=LocalisationData[(numbTot+1)*m+i]/LocalisationData[(numbTot+1)*(numbMahal)+i];
            }
        }
    }
    
    //    float max2=GetMax(ResultSummary, numbRS);
    delete [] LocalisationData;
    return ResultSummary;
}





// This method provides a way of storing the local information needed for the bullseye (Volume of each are, BinarySeg Volume, ProbaSeg Volume based on QuadrantImage LaplaceLayers and LesionImage
float * LocalSummaryLesion(nifti_image * Lesion, nifti_image * Quadrant, nifti_image * Layers){
//    First create the summarising array for localisation
    int DimQ[4];
    for (int d=0; d<4; d++) {
        DimQ[d]=pow_int(10, d);
    }
    float VolumeVoxel=1;
    for (int d=0; d<3; d++) {
        VolumeVoxel*=Lesion->pixdim[d+1];
    }
    int numel=Lesion->nvox;
    int * LocalisationData=new int[numel];
    float *QuadrantData=static_cast<float*>(Quadrant->data);
    float *LesionData=static_cast<float*>(Lesion->data);
    float *LayersData=static_cast<float*>(Layers->data);
    int CountPb=0;
    for (int i=0; i<numel; i++) {
        if (QuadrantData[i]>0 && LayersData[i]>0) {
            int LayersToAdd=LayersData[i]>4?4:LayersData[i];
            int LocalisationValue=10*QuadrantData[i]+LayersToAdd;
            int * IndexQ= CorrespondingCoordinates_ter(LocalisationValue, DimQ, DimQ,4);
            int ValueFin=0;
            for (int d=0; d<4; d++) {
                ValueFin+=d>0?pow_int(2,d-1)*4*(IndexQ[d]-1):IndexQ[d]-1;
            }
            if (ValueFin>32) {
                CountPb++;
            }
            delete [] IndexQ;
            IndexQ=NULL;
            LocalisationData[i]=ValueFin+1;
        }
        else{
            LocalisationData[i]=0;
        }
    }
//    nifti_image * LocalisationNii=CreateNiiFromArray(LocalisationData, Lesion, numel);
//    nifti_set_filenames(LocalisationNii, "/Users/Carole/Documents/PhD/BAMBI_ADNI/AtestLS.nii.gz", 0, 0);
//    nifti_image_write(LocalisationNii);
//    nifti_image_free(LocalisationNii);
//    LocalisationNii=NULL;
// Initialisation of the resulting array. For each of the 32 regions, given as LesionProb LesionBin VolTotal
    float * ResultSummary=new float[3*34];
    int numbRS=3*34;
    for (int i=0; i<3*34; i++) {
        ResultSummary[i]=0;
    }
//    int max=GetMax(LocalisationData, numel);
    for (int i=0; i<numel; i++) {
        ResultSummary[32*3]+=LesionData[i];
        ResultSummary[32*3+1]+=(LesionData[i]>0.1);
        ResultSummary[32*3+2]+=(LayersData[i]>0);
        if (LocalisationData[i]>0) {
            ResultSummary[(LocalisationData[i]-1)*3]+=LesionData[i];
            ResultSummary[(LocalisationData[i]-1)*3+1]+=(LesionData[i]>0.1);
            ResultSummary[(LocalisationData[i]-1)*3+2]+=1;
        }
    }
    for (int i=0; i<numbRS; i++) {
        ResultSummary[i]*=VolumeVoxel;
    }
    for (int i=0; i<32; i++) {
        ResultSummary[33*3]+=ResultSummary[i*3];
        ResultSummary[33*3+1]+=ResultSummary[i*3+1];
        ResultSummary[33*3+2]+=ResultSummary[i*3+2];
    }
//    float max2=GetMax(ResultSummary, numbRS);
    delete [] LocalisationData;
    return ResultSummary;
}


// This method provides a way of storing the local information needed for the bullseye (Volume of each are, BinarySeg Volume, ProbaSeg Volume based on QuadrantImage LaplaceLayers and LesionImage
float * LocalSummaryLesion_bis(nifti_image * Lesion, nifti_image * Lobes, nifti_image * Layers){
    //    First create the summarising array for localisation
    int DimQ[4];
    for (int d=0; d<4; d++) {
        DimQ[d]=pow_int(10, d);
    }
    float VolumeVoxel=1;
    for (int d=0; d<3; d++) {
        VolumeVoxel*=Lesion->pixdim[d+1];
    }
    int numel=Lesion->nvox;
    int * LocalisationData=new int[numel];
    float *LobesData=static_cast<float*>(Lobes->data);
    float *LesionData=static_cast<float*>(Lesion->data);
    float *LayersData=static_cast<float*>(Layers->data);
    float MaxLobes=GetMax(LobesData, numel);
    float MaxLayers=GetMax(LayersData, numel)-1;
    int numbTot=(MaxLayers)*MaxLobes;
    int CountPb=0;
    for (int i=0; i<numel; i++) {
        if (LobesData[i]>0 && LayersData[i]>0) {
            int LayersToAdd=LayersData[i]>MaxLayers?MaxLayers:LayersData[i];
            int ValueFin=(LobesData[i]-1)*(MaxLayers)+(LayersToAdd-1);
            if (ValueFin>numbTot) {
                CountPb++;
            }
            LocalisationData[i]=ValueFin+1;
        }
        else{
            LocalisationData[i]=0;
        }
    }
    //    nifti_image * LocalisationNii=CreateNiiFromArray(LocalisationData, Lesion, numel);
    //    nifti_set_filenames(LocalisationNii, "/Users/Carole/Documents/PhD/BAMBI_ADNI/AtestLS.nii.gz", 0, 0);
    //    nifti_image_write(LocalisationNii);
    //    nifti_image_free(LocalisationNii);
    //    LocalisationNii=NULL;
    // Initialisation of the resulting array. For each of the 32 regions, given as LesionProb LesionBin VolTotal
    float * ResultSummary=new float[3*(numbTot+1)];
    int numbRS=3*(numbTot+1);
    for (int i=0; i<numbRS; i++) {
        ResultSummary[i]=0;
    }
    //    int max=GetMax(LocalisationData, numel);
    for (int i=0; i<numel; i++) {
        ResultSummary[numbTot*3]+=LesionData[i];
        ResultSummary[numbTot*3+1]+=(LesionData[i]>0.1);
        ResultSummary[numbTot*3+2]+=(LayersData[i]>0);
        if (LocalisationData[i]>0) {
            LesionData[i]=LesionData[i]>1?1:LesionData[i];
            ResultSummary[(LocalisationData[i]-1)*3]+=LesionData[i];
            ResultSummary[(LocalisationData[i]-1)*3+1]+=(LesionData[i]>0.1);
            ResultSummary[(LocalisationData[i]-1)*3+2]+=1;
        }
    }
    for (int i=0; i<numbRS; i++) {
        ResultSummary[i]*=VolumeVoxel;
    }
    //    float max2=GetMax(ResultSummary, numbRS);
    delete [] LocalisationData;
    return ResultSummary;
}


void PrintLocalSummary(float * LocalSummaryToPrint,ostream& TxtFileLS){
    for (int i=0; i<34; i++) {
        TxtFileLS<<LocalSummaryToPrint[i*3]<<" "<<LocalSummaryToPrint[i*3+1]<<" "<<LocalSummaryToPrint[i*3+2]<<endl;
    }
}

void PrintLocalSummaryStats(vector<float *> LocalSummaryToPrint,ostream& TxtFileLS){
    int numbMahal=LocalSummaryToPrint.size();
    for (int i=0; i<41; i++) {
        for (int m=0; m<numbMahal; m++) {
            TxtFileLS << "Mod"<<m<<" ";
            for (int s=0; s<9; s++) {
                TxtFileLS<<LocalSummaryToPrint[m][i*9+s]<<" ";
            }
        
        }
        TxtFileLS<<endl;
    }
}


void PrintLocalSummaryNumber(int * LocalSummaryToPrint,ostream& TxtFileLS){
    for (int i=0; i<33; i++) {
        TxtFileLS<<LocalSummaryToPrint[i]<<endl;
    }
}

void PrintLocalSummaryMahal(float * LocalSummaryToPrint,int numbMahal, ostream& TxtFileLS){
    for (int i=0; i<33; i++) {
        for (int m=0; m<numbMahal; m++) {
             TxtFileLS<<LocalSummaryToPrint[numbMahal*i+m]<<" ";
        }
       TxtFileLS<<endl;
    }
}

void PrintLocalSummaryTot(float * LocalSummaryVol, int * LocalSummaryNumber, float * LocalSummaryMahal, int numbMahal, ostream& TxtFileLS){
    for (int i=0; i<33; i++) {
        TxtFileLS<<LocalSummaryVol[i*3]<<" "<<LocalSummaryVol[i*3+1]<<" "<<LocalSummaryVol[i*3+2]<<" ";
        TxtFileLS<<LocalSummaryNumber[i]<<" ";
        for (int m=0; m<numbMahal; m++) {
            TxtFileLS<<LocalSummaryMahal[numbMahal*i+m]<<" ";
        }
        TxtFileLS << endl;
    }
}

void PrintLocalSummaryTot_bis(float * LocalSummaryVol, int * LocalSummaryNumber, float * LocalSummaryMahal, int numbMahal, int numbTot, ostream& TxtFileLS){
    for (int i=0; i<(numbTot+1); i++) {
        TxtFileLS<<LocalSummaryVol[i*3]<<" "<<LocalSummaryVol[i*3+1]<<" "<<LocalSummaryVol[i*3+2]<<" ";
        TxtFileLS<<LocalSummaryNumber[i]<<" ";
        for (int m=0; m<numbMahal; m++) {
            TxtFileLS<<LocalSummaryMahal[numbMahal*i+m]<<" ";
        }
        TxtFileLS << endl;
    }
}


/********************** NEEDED TO GET PERIVASCULAR SPACES *****************/

nifti_image * VesselFromSeeds(bool* Seeds,nifti_image* MahalNii,nifti_image* Mask,float * HeatData,float * VesselLong){
    int numel = MahalNii->nx*MahalNii->ny*MahalNii->nz;
    nifti_image * NewMask=Binarisation(Mask);
    bool * MaskData=static_cast<bool*>(NewMask->data);
    int * Vessels=new int[numel];
    for(int i=0;i<numel;i++){
        Vessels[i]=Seeds[i];
    }
    for(int i=0;i<numel;i++){
        if (Seeds[i]){
            int * AddedVessel=CreateBoolVesselFromSeed(i,Vessels,MahalNii,MaskData,HeatData,VesselLong);
            for(int j=0;j<numel;j++){
                if (Vessels[j]<1){
                Vessels[j]+=AddedVessel[j];
//                Vessels[j]-=Seeds[j];
                }
            }
            delete [] AddedVessel;
            AddedVessel=NULL;
        }
    }
    nifti_image * VesselsNii=CreateNiiFromArray(Vessels,MahalNii,numel);
    delete [] Vessels;
    return VesselsNii;
}

// Create the Code image for EPVS in the case of mahalanobis distance image with modalities T1 FLAIR T2 in this order
nifti_image * CreateCodePVSFromMahal(nifti_image * MahalNii){
    float * DataMahal=static_cast<float *>(MahalNii->data);
    int numel=MahalNii->nx*MahalNii->ny*MahalNii->nz;
    float * Code=new float[numel];
    for(int i=0;i<numel;i++){
        Code[i]=-1*DataMahal[numel+i]-DataMahal[2*numel+i]+DataMahal[3*numel+i];
    }
    nifti_image * CodeImage=CreateNiiFromArray(Code,MahalNii,numel);
    delete [] Code;
    return CodeImage;
}


bool * CreateSeedsForVessel_bis(nifti_image * SeedHeatMap,bool * SeedPrevious, nifti_image* MahalNii,float Thresh){
    float * HeatData=static_cast<float *>(SeedHeatMap->data);
    float * MahalData=static_cast<float *>(MahalNii->data);
    int numel=SeedHeatMap->nvox;
    float * MahalT1=&MahalData[numel];
    float * MahalT2=&MahalData[3*numel];
    float * MahalFLAIR=&MahalData[2*numel];
    cout<<MahalFLAIR[100]<<" "<<MahalT2[1000]<<" "<<MahalT1[10000]<<endl;
    bool * Seeds=new bool[numel];
    bool * NewSeed=new bool[numel];
    for(int i=0;i<numel;i++){
        Seeds[i]=0;
        NewSeed[i]=0;
        //cout<<MahalFLAIR[i]<<" "<<MahalT2[i]<<" "<<MahalT1[i]<<endl;
        if(MahalT1[i]<0.5 && MahalFLAIR[i]<1 && MahalT2[i]>-0.5 && HeatData[i]>Thresh){
            Seeds[i]=1;
        }
        else if (HeatData[i]>100){
            Seeds[i]=1;
        }

    }
    nifti_image * SeedNii=CreateNiiFromArray(Seeds,SeedHeatMap,numel);
    int * Labels=ComponentLabeling(SeedNii,6);
    int maxLabel=GetMaxLabel(Labels,numel);
    for(int l=0;l<maxLabel;l++){
        bool * LabelBool = CreateLesionBool(Labels,l+1,numel);
        int  IndMax= GetIndexMaxMask(HeatData,LabelBool,numel);
        if (!SeedPrevious[IndMax]){
        NewSeed[IndMax]=1;
        }
    }
    delete [] Seeds;
    return NewSeed;
}

bool * CreateSeedsForVessel(nifti_image * SeedHeatMap, nifti_image* MahalNii,float Thresh){
    float * HeatData=static_cast<float *>(SeedHeatMap->data);
    float * MahalData=static_cast<float *>(MahalNii->data);
    int numel=SeedHeatMap->nvox;
    float * MahalT1=&MahalData[numel];
    float * MahalT2=&MahalData[3*numel];
    float * MahalFLAIR=&MahalData[2*numel];
    cout<<MahalFLAIR[100]<<" "<<MahalT2[1000]<<" "<<MahalT1[10000]<<endl;
    bool * Seeds=new bool[numel];
    bool * NewSeed=new bool[numel];
    for(int i=0;i<numel;i++){
        Seeds[i]=0;
        NewSeed[i]=0;
        //cout<<MahalFLAIR[i]<<" "<<MahalT2[i]<<" "<<MahalT1[i]<<endl;
        if(MahalT1[i]<0.5 && MahalFLAIR[i]<0.5 && MahalT2[i]>-0.5 && HeatData[i]>Thresh){
            Seeds[i]=1;
            if (HeatData[i]>100){
                NewSeed[i]=1;
            }
        }
        else if (HeatData[i]>100){
            NewSeed[i]=1;
        }

    }
    nifti_image * SeedNii=CreateNiiFromArray(Seeds,SeedHeatMap,numel);
    int * Labels=ComponentLabeling(SeedNii,6);
    int maxLabel=GetMaxLabel(Labels,numel);
    for(int l=0;l<maxLabel;l++){
        bool * LabelBool = CreateLesionBool(Labels,l+1,numel);
        int  IndMax= GetIndexMaxMask(HeatData,LabelBool,numel);
        NewSeed[IndMax]=1;
    }
    delete [] Seeds;
    return NewSeed;
}

int *CreateBoolVesselFromSeed(int Index,int * Seeds,nifti_image * MahalNii,bool* MaskData,float * HeatData,float * VesselLong){
    float * MahalData=static_cast<float *>(MahalNii->data);
    int numel = MahalNii->nx*MahalNii->ny*MahalNii->nz;
    float * MahalT1=&MahalData[numel];
    float * MahalFLAIR=&MahalData[2*numel];
    float * MahalT2=&MahalData[3*numel];
    bool flag_Continue=1;
    int ListNeighbours[6];
    int IndexTemp=Index;
    int * Vessel=new int[numel];
    for(int i=0;i<numel;i++){
        Vessel[i]=0;
        if (Seeds[i]>=1){
            Vessel[i]=1;
        }
    }
    Vessel[Index]=1;
//    int IndexInitChange=0;
    int Dim[3];
    int Shift[3];
    Shift[0]=1;
    for(int d=0;d<3;d++){
        Dim[d]=MahalNii->dim[d+1];
        if(d>0){
            Shift[d]=Dim[d-1]*Shift[d-1];
        }
    }
    int Neigh=6;
    int CountVesselNeighbour=Neigh;
    int minCountVesselNeighbour=24;
    int numberOp=0;
    float WeightMahal[3];
    WeightMahal[0]=-1;
    WeightMahal[1]=-1;
    WeightMahal[2]=1;

    float WeightCode[3];
    WeightCode[0]=0;
    WeightCode[1]=3;
    WeightCode[2]=3;

//    float CodeAverageInit=WeightMahal[0]*MahalT1[Index]+WeightMahal[1]*MahalFLAIR[Index]+WeightMahal[2]*MahalT2[Index];
    int numbVessel=1;
    float CodeAverage=CodeAverage;
    while(flag_Continue){
        flag_Continue=0;

    GetListNeighbours_bis(ListNeighbours,IndexTemp,Dim,Shift,Neigh);
    float GradientNorm[6];
    float CodeMahal[6];
//    float minGradNorm=300;
    float maxCodeMahal=-300;
    int IndexToChange=0;
    float VesselSum=0;
    float HeatSum=0;
    float CodeSum=0;
    for(int i=0;i<Neigh;i++){
        VesselSum+=VesselLong[ListNeighbours[i]];
        HeatSum+=HeatData[ListNeighbours[i]];
        CodeSum+=WeightMahal[0]*MahalT1[ListNeighbours[i]]+WeightMahal[1]*MahalFLAIR[ListNeighbours[i]]+WeightMahal[2]*MahalT2[ListNeighbours[i]];
    }
    for(int i=0;i<Neigh;i++){
        CodeMahal[i]=WeightMahal[0]*MahalT1[ListNeighbours[i]]+WeightMahal[1]*MahalFLAIR[ListNeighbours[i]]+WeightMahal[2]*MahalT2[ListNeighbours[i]];
        float CodeMahalBis=WeightCode[0]*CodeMahal[i]/CodeSum+WeightCode[1]*HeatData[ListNeighbours[i]]/HeatSum+WeightCode[2]*VesselLong[ListNeighbours[i]]/VesselSum;
        GradientNorm[i]=(MahalT1[IndexTemp]-MahalT1[ListNeighbours[i]])*(MahalT1[IndexTemp]-MahalT1[ListNeighbours[i]])+(MahalFLAIR[IndexTemp]-MahalFLAIR[ListNeighbours[i]])*(MahalFLAIR[IndexTemp]-MahalFLAIR[ListNeighbours[i]])+(MahalT2[IndexTemp]-MahalT2[ListNeighbours[i]])*(MahalT2[IndexTemp]-MahalT2[ListNeighbours[i]]);
        CountVesselNeighbour=CountNeighbourBinary(Vessel,ListNeighbours[i],Dim,Shift,Neigh);
        float CodeAverageTemp=(CodeAverage*numbVessel+CodeMahal[i])/(numbVessel+1);
        //if (GradientNorm[i]<minGradNorm && MahalT1[ListNeighbours[i]]<0.5 && MahalFLAIR[ListNeighbours[i]]<1 && MahalT2[ListNeighbours[i]]>0.5 && !Vessel[ListNeighbours[i]] &&  MaskData[ListNeighbours[i]]&& CountVesselNeighbour<=minCountVesselNeighbour){
        if (CodeMahalBis>maxCodeMahal && CodeMahal[i]>0 && MahalT1[ListNeighbours[i]]<0.5 && MahalFLAIR[ListNeighbours[i]]<1 && MahalT2[ListNeighbours[i]]>-1 && !Vessel[ListNeighbours[i]] &&  MaskData[ListNeighbours[i]]&& CountVesselNeighbour<=minCountVesselNeighbour){
//            minGradNorm=GradientNorm[i];
            maxCodeMahal=CodeMahalBis;
            minCountVesselNeighbour=CountVesselNeighbour;
            IndexToChange=ListNeighbours[i];
//            if (numberOp==0){
//                IndexInitChange=ListNeighbours[i];
//            }
            flag_Continue=1;
            numberOp++;
            numbVessel++;
            CodeAverage=CodeAverageTemp;
        }
    }
    if(flag_Continue){
        Vessel[IndexToChange]=numbVessel+1;
        IndexTemp=IndexToChange;
    }
    }

    numberOp=0;
    minCountVesselNeighbour=24;
    flag_Continue=1;
    IndexTemp=Index;
    while(flag_Continue){
        flag_Continue=0;

    GetListNeighbours_bis(ListNeighbours,IndexTemp,Dim,Shift,Neigh);
    float GradientNorm[6];
    float CodeMahal[6];
//    float minGradNorm=300;
    float maxCodeMahal=-300;
    int IndexToChange=0;
    float VesselSum=0;
    float HeatSum=0;
    float CodeSum=0;
    for(int i=0;i<Neigh;i++){
        VesselSum+=VesselLong[ListNeighbours[i]];
        HeatSum+=HeatData[ListNeighbours[i]];
        CodeSum+=WeightMahal[0]*MahalT1[ListNeighbours[i]]+WeightMahal[1]*MahalFLAIR[ListNeighbours[i]]+WeightMahal[2]*MahalT2[ListNeighbours[i]];
    }
    for(int i=0;i<Neigh;i++){
        CodeMahal[i]=WeightMahal[0]*MahalT1[ListNeighbours[i]]+WeightMahal[1]*MahalFLAIR[ListNeighbours[i]]+WeightMahal[2]*MahalT2[ListNeighbours[i]];
        float CodeMahalBis=WeightCode[0]*CodeMahal[i]/CodeSum+WeightCode[1]*HeatData[ListNeighbours[i]]/HeatSum+WeightCode[2]*VesselLong[ListNeighbours[i]]/VesselSum;
        GradientNorm[i]=(MahalT1[IndexTemp]-MahalT1[ListNeighbours[i]])*(MahalT1[IndexTemp]-MahalT1[ListNeighbours[i]])+(MahalFLAIR[IndexTemp]-MahalFLAIR[ListNeighbours[i]])*(MahalFLAIR[IndexTemp]-MahalFLAIR[ListNeighbours[i]])+(MahalT2[IndexTemp]-MahalT2[ListNeighbours[i]])*(MahalT2[IndexTemp]-MahalT2[ListNeighbours[i]]);
//        CountVesselNeighbour=CountNeighbourBinary(Vessel,ListNeighbours[i],Dim,Shift,Neigh);
//        float CodeAverageTemp=(CodeAverage*numbVessel+CodeMahal[i])/(numbVessel+1);
        GradientNorm[i]=(MahalT1[IndexTemp]-MahalT1[ListNeighbours[i]])*(MahalT1[IndexTemp]-MahalT1[ListNeighbours[i]])+(MahalFLAIR[IndexTemp]-MahalFLAIR[ListNeighbours[i]])*(MahalFLAIR[IndexTemp]-MahalFLAIR[ListNeighbours[i]])+(MahalT2[IndexTemp]-MahalT2[ListNeighbours[i]])*(MahalT2[IndexTemp]-MahalT2[ListNeighbours[i]]);
        CountVesselNeighbour=CountNeighbourBinary(Vessel,ListNeighbours[i],Dim,Shift,Neigh);
        if (CodeMahalBis>maxCodeMahal && CodeMahal[i]>0 && MahalT1[ListNeighbours[i]]<0.5 && MahalFLAIR[ListNeighbours[i]]<1 && MahalT2[ListNeighbours[i]]>-1 && !Vessel[ListNeighbours[i]] &&  MaskData[ListNeighbours[i]]&& CountVesselNeighbour<=minCountVesselNeighbour){
        //if (GradientNorm[i]<minGradNorm && MahalT1[ListNeighbours[i]]<0.5 && MahalFLAIR[ListNeighbours[i]]<1 && MahalT2[ListNeighbours[i]]>0.5 && !Vessel[ListNeighbours[i]] &&  MaskData[ListNeighbours[i]]&& CountVesselNeighbour<=minCountVesselNeighbour && ListNeighbours[i]!=IndexInitChange){
//            minGradNorm=GradientNorm[i];
            minCountVesselNeighbour=CountVesselNeighbour;
            IndexToChange=ListNeighbours[i];
//            if (numberOp==0){
//                IndexInitChange=ListNeighbours[i];
//            }
            flag_Continue=1;
            numberOp++;
        }
    }
    if(flag_Continue){
        Vessel[IndexToChange]=numberOp+1;
        IndexTemp=IndexToChange;
    }
    }


return Vessel;
}

nifti_image * CreateEntropy(nifti_image * SegToAnalyse, SEG_ANALYSIS * segment_analysis){
    int Rad=segment_analysis->RadEntropy;
    float * Data=static_cast<float*>(SegToAnalyse->data);
    int numel=SegToAnalyse->nvox;
    float Transf=segment_analysis->MaxValueEntr;
    MultiplyFloatArrayBy(Data,Transf,numel);
    bool * Mask=NULL;
    nifti_image * MaskNii=NULL;
    int *L2S=NULL;
    int* S2L=NULL;
    int numelmasked=0;
    int Dim[3];
    int Shift[3];
    if(segment_analysis->flag_mask){
         MaskNii=ReadFromFilename(segment_analysis->filename_mask);
         Mask=static_cast<bool*>(MaskNii->data);

    }
    for(int d=0;d<3;d++){
        Dim[d]=SegToAnalyse->dim[d+1];
        Shift[d]=d>0?Shift[d-1]*Dim[d-1]:1;
    }
    L2S=MakeL2S(Mask,Dim);
    S2L=MakeS2L(Mask,Dim,numelmasked);

    float * DataShort=CreateShort(Data,S2L,numelmasked);
    float * EntropyShort=new float[numelmasked];
    vector<int *> ShiftedVector;
    for(int x=-Rad;x<Rad;x++){
        for(int y=-Rad;y<Rad;y++){
            for(int z=-Rad;z<Rad;z++){
                if(x*x+y*y+z*z<Rad*Rad){
                    int Trans[3];
                    Trans[0]=x;
                    Trans[1]=y;
                    Trans[2]=z;
                    float * ShiftedTemp=ShiftedVersion(DataShort,Trans,Dim,Shift,L2S,S2L,numelmasked);
                    int * ShiftedInt=TranscribeArray<float,int>(ShiftedTemp,numelmasked);
                    delete [] ShiftedTemp;
                    ShiftedVector.push_back(ShiftedInt);
                }
            }
        }
    }
    int size=ShiftedVector.size();
    for(int i=0;i<numelmasked;i++){
        float Entropy=0;
        vector<int>numbers;

        for(int n=0;n<size;n++){
            numbers.push_back(ShiftedVector[n][i]);
        }
        typedef map<int,float> CounterMap;
        CounterMap counts;
        for (int n = 0; n < size; ++n)
        {
           CounterMap::iterator it(counts.find(numbers[n]));
           if (it != counts.end()){
              it->second+=1.0/size;
           } else {
              counts[numbers[n]] = 1.0/size;
           }
        }
        map<int, float>::iterator it;
        for (it = counts.begin(); it != counts.end(); it++)
        {
             Entropy-=log(it->second)*it->second;
        }
        EntropyShort[i]=Entropy;
    }
    float * EntropyLong=CreateLong(EntropyShort,L2S,numel);
    nifti_image*EntropyNii=CreateNiiFromArray(EntropyLong,SegToAnalyse,numel);
    delete [] L2S;
    delete [] S2L;
    delete [] EntropyShort;
    delete [] DataShort;
    for(int s=0;s<size;s++){
        delete [] ShiftedVector[s];
    }
    nifti_image_free(SegToAnalyse);
    return EntropyNii;
}

float* CreateLineFromCoMBB(bool* Seg, int CoM, int* BB, float * MainVector, int* Dim,int* Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
        float *LineCreated=new float[numel];
    int *ListCoord= ListCoordinatesBoolSeg(Seg,Dim,Shift);
//    int L=CountNonZero(Seg,numel);
    cout << "First found element z"<< ListCoord[2] << " BBz "<<BB[4]<< " "<<BB[5]<<endl;
    cout << "First found element x"<< ListCoord[0] << " BBx "<<BB[0]<<" "<<BB[1]<<endl;
    cout << "First found element y"<< ListCoord[1] << " BBy "<<BB[2]<< " "<<BB[3]<<endl;
    float * Vector=new float[3];
    int Diff_Flag=-1;
    if(ListCoord[0]==BB[0]){
        if(ListCoord[1]==BB[2]){
            Vector[0]=1;
            Vector[1]=1;
            Vector[2]=1;
            cout << "case 1";
        }
        else if(ListCoord[1]==BB[3]){
            Vector[0]=1;
            Vector[1]=-1;
            Vector[2]=1;
            cout << "case 2";
        }
        else {
            Diff_Flag=1;
        }
    }
    else if(ListCoord[0]==BB[1]){
        if(ListCoord[1]==BB[2]){
            Vector[0]=-1.0;
            Vector[1]=1.0;
            Vector[2]=1.0;
            cout << "case 3";
        }
        else if (ListCoord[1]==BB[3]) {
            Vector[0]=-1.0;
            Vector[1]=-1.0;
            Vector[2]=1.0;
            cout << "case 4";
        }
        else{
            Diff_Flag=1;
        }
    }
    else {
        Diff_Flag=0;
    }

    if(Diff_Flag<0){
    float NormalisationFactor=0;
    for(int d=0;d<3;d++){
        float Diff=BB[2*d+1]-BB[2*d];
        Vector[d]*=(float)Diff;
        NormalisationFactor+=Diff*Diff;
        cout<< Vector[d]<<" ";
    }
    cout <<endl;
    cout << "Vector expected "<< NormalisationFactor <<" "<< sqrtf(NormalisationFactor)<< " ";
    for(int d=0;d<3;d++){
        Vector[d]/=sqrtf(NormalisationFactor);
        cout << Vector[d]<<" ";
    }
    cout << endl;
    // Initialising and filling Line and Vector

    for (int i=0;i<numel;i++){
        LineCreated[i]=0;
        if(Seg[i]){
            for(int d=0;d<3;d++){
                MainVector[i+d*numel]=Vector[d];
            }
        }
    }
    }
    else if(Seg[CoM]){
        float NormalisationFactor=0;
        cout <<"Not borders but CoM in Seg "<<endl;
        for(int d=0;d<3;d++){
            float Diff=abs(BB[2*d+1]-ListCoord[d])>abs(BB[2*d]-ListCoord[d])?BB[2*d+1]-ListCoord[d]:BB[2*d]-ListCoord[d];
            Vector[d]=(float)Diff;
            NormalisationFactor+=Diff*Diff;
            cout<< Vector[d]<<" ";
        }
        cout << endl;
        cout << "Vector expected "<< NormalisationFactor <<" "<< sqrtf(NormalisationFactor)<< " ";
        for(int d=0;d<3;d++){
            Vector[d]/=sqrtf(NormalisationFactor);
            cout << Vector[d]<<" ";
        }
        cout << endl;
        for (int i=0;i<numel;i++){
            LineCreated[i]=0;
            if(Seg[i]){
                for(int d=0;d<3;d++){
                    MainVector[i+d*numel]=Vector[d];
                }
            }
        }

    }
    else if (!Seg[CoM]){ // mean that there is more than one direction
        cout << "Don't know what to do yet..."<<endl;
        float NormalisationFactor=0;
        cout <<"Not borders but CoM in Seg "<<endl;
        for(int d=0;d<3;d++){
            float Diff=abs(BB[2*d+1]-ListCoord[d])>abs(BB[2*d]-ListCoord[d])?BB[2*d+1]-ListCoord[d]:BB[2*d]-ListCoord[d];
            Vector[d]=(float)Diff;
            NormalisationFactor+=Diff*Diff;
            cout<< Vector[d]<<" ";
        }
        cout << endl;
        cout << "Vector expected "<< NormalisationFactor <<" "<< sqrtf(NormalisationFactor)<< " ";
        for(int d=0;d<3;d++){
            Vector[d]/=sqrtf(NormalisationFactor);
            cout << Vector[d]<<" ";
        }
        cout << endl;
        for (int i=0;i<numel;i++){
            LineCreated[i]=0;
            if(Seg[i]){
                for(int d=0;d<3;d++){
                    MainVector[i+d*numel]=Vector[d];
                }
            }
        }
    }
    int * CoM_coord=CorrespondingCoordinates(CoM,Dim,Shift);
    float x=(float)CoM_coord[0];
    float y=(float)CoM_coord[1];
    float z=(float)CoM_coord[2];

    LineCreated[CoM]=1;
    // Going first into positive direction of vector
    while( x<=BB[1]+1 && y<=BB[3]+1 && z<=BB[5]+1 && x>=BB[0]-1 && y>=BB[2]-1 && z>=BB[4]-1){
        x+=Vector[0];
        y+=Vector[1];
        z+=Vector[2];
        int ind=(int)(round(x)*Shift[0]+round(y)*Shift[1]+round(z)*Shift[2]);
        LineCreated[ind]=1;
    }
     x=(float)CoM_coord[0];
     y=(float)CoM_coord[1];
     z=(float)CoM_coord[2];
    while( x<=BB[1]+1 && y<=BB[3]+1 && z<=BB[5]+1 && x>=BB[0]-1 && y>=BB[2]-1 && z>=BB[4]-1){
        x-=Vector[0];
        y-=Vector[1];
        z-=Vector[2];
        int ind=(int)(round(x)*Shift[0]+round(y)*Shift[1]+round(z)*Shift[2]);
        LineCreated[ind]=1;
    }
    delete[]Vector;
    return LineCreated;
}

//float * FindOrientedBB(bool * Seg, int* Dim, int* Shift,int * BB){
//    int numel = Dim[0]*Dim[1]*Dim[2];
//    int numbLabel = CountNonZero(Seg,numel);
//    bool * Border = CreateBorderFromBool(Seg,Dim,Shift);
//    int numbBorder= CountNonZero(Border,numel);
//    int *ListCoord= ListCoordinatesBoolSeg(Seg,Dim,Shift);
//    if(numbBorder <6){

//    }
//}

vector <Face > ConvexHullFrom3D(int * ListCoord, int numbBorder, int* Dim, float *PixDim ){
    // First transform all elements in ListCoord in floating points
    vector<float*> ListBorderFloat;
    vector<float*> ProjectionLine;
    vector<bool> OnlineBool;
    for(int i=0;i<numbBorder;i++){
        float * TranscribedPoint=new float[3];
        for(int d=0;d<3;d++){
            TranscribedPoint[d]=ListCoord[i*3+d]*PixDim[d];
        }
        ListBorderFloat.push_back(TranscribedPoint);
    }
 // First choose initial point
    float * InitialPoint=CopyArray(ListBorderFloat[0],3);
    int IndexMax=-1;
    int DistMax=-1;
    for (int i=0;i<numbBorder;i++){
        float TempDist=GetDistanceBetweenFloatingPoints(InitialPoint,ListBorderFloat[i],PixDim);
        if (TempDist>DistMax){
            DistMax=TempDist;
            IndexMax=i;
        }
    }
    float * FurthestPointInitial = CopyArray(ListBorderFloat[IndexMax],3);
    // Find furthest point from line
    int IndexMax2=-1;
    DistMax=-1;
    for(int i=0;i<numbBorder;i++){
        float TempDist=DistanceFromLineFloat(InitialPoint,FurthestPointInitial,ListBorderFloat[i]);
        float * ProjectionTemp = ProjectionToLine(InitialPoint, FurthestPointInitial,ListBorderFloat[i]);
        bool flag_OnLine=1;
        for(int d=0;d<3;d++){
            if (fabs(ListBorderFloat[i][d]-ProjectionTemp[d])>PixDim[d]){
                flag_OnLine=0;
            }
        }
        delete [] ProjectionTemp;
        OnlineBool.push_back(flag_OnLine);
        if (TempDist>DistMax && !flag_OnLine){
            DistMax=TempDist;
            IndexMax2=i;
        }
    }
    if (IndexMax2==-1){
        cout << "All coordinates along line"<<endl;
        vector<Face> Results;
        Point Temp;
        vector<Point> V;
        V.push_back(Temp.transcribe(InitialPoint));
        V.push_back(Temp.transcribe(FurthestPointInitial));
        V.push_back(Temp.transcribe(FurthestPointInitial));
        for(int i=0;i<numbBorder;i++){
            delete [] ListBorderFloat[i];
        }
        Results.push_back(Face(V));
        return Results;
    }
    // Then check where other points fall with respect to the newly built triangle
    float * ThirdPointPlane=CopyArray(ListBorderFloat[IndexMax2],3);
    float Vect1[3];
    float Vect2[3];
    for(int d=0;d<3;d++){
        Vect1[d]=InitialPoint[d]-FurthestPointInitial[d];
        Vect2[d]=InitialPoint[d]-ThirdPointPlane[d];
    }
    int CountOnPlane=0;
    float * Normal=CrossProduct(Vect1,Vect2);
    float * NormalisedNormal=NormalisedVector(Normal);
    int IndexMax3=-1;
    DistMax=-1;
    for(int i=0;i<numbBorder;i++){
        bool flag_OnPlane=1;
        if(!OnlineBool[i]){
            float * ProjectedTemp=ProjectionToPlane(InitialPoint,NormalisedNormal,ListBorderFloat[i]);
            for(int d=0;d<3;d++){
                if(fabs(ProjectedTemp[d]-ListBorderFloat[i][d])>PixDim[d]){
                    flag_OnPlane=0;
                }
            }
            if(!flag_OnPlane){
                float DistTemp=GetDistanceBetweenFloatingPoints(ListBorderFloat[i],ProjectedTemp,NULL);
                if (DistTemp>DistMax){
                    IndexMax3=i;
                    DistMax=DistTemp;
                }
            }
            delete [] ProjectedTemp;

        }
        OnlineBool[i]=flag_OnPlane;
        CountOnPlane+=flag_OnPlane;
    }
    cout << "Count on Plane is "<< CountOnPlane << " and number in Border is "<<numbBorder<<endl;
    if (CountOnPlane==numbBorder){
        cout << "All coordinates on plane"<<endl;
        vector<Face> Results;
        vector<Point> V;
        Point Temp;
        V.push_back(Temp.transcribe(InitialPoint));
        V.push_back(Temp.transcribe(FurthestPointInitial));
        V.push_back(Temp.transcribe(ThirdPointPlane));
        for(int i=0;i<numbBorder;i++){
            delete [] ListBorderFloat[i];
        }
        Results.push_back(Face(V));
        return Results;
    }
    float * FourthElement=NULL;

    FourthElement=CopyArray(ListBorderFloat[IndexMax3],3);
    deque<Face> Faces;
        vector<Point> FaceInit;
        Point Temp;
        FaceInit.push_back(Temp.transcribe(InitialPoint));
        FaceInit.push_back(Temp.transcribe(FurthestPointInitial));
        FaceInit.push_back(Temp.transcribe(ThirdPointPlane));
        Face FaceTemp=Face(FaceInit);
        Point NormalTemp=FaceTemp.normal();
        Point Vector41=Temp.transcribe(InitialPoint)-Temp.transcribe(FourthElement);
        if (Vector41.dot(NormalTemp)<0){
            Point TempSwap=FaceInit[1];
            FaceInit[1]=FaceInit[2];
            FaceInit[2]=TempSwap;
        }
        Faces.push_back(Face(FaceInit));
        Face Face2=Face(Temp.transcribe(FurthestPointInitial),Temp.transcribe(ThirdPointPlane),Temp.transcribe(FourthElement));
        ReorientFace(Face2,Temp.transcribe(InitialPoint) );
        Faces.push_back(Face2);
        Face Face3 = Face(Temp.transcribe(ThirdPointPlane),Temp.transcribe(FourthElement),Temp.transcribe(InitialPoint));
        ReorientFace(Face3,Temp.transcribe(FurthestPointInitial));
        Faces.push_back(Face3);
        Face Face4=Face(Temp.transcribe(FourthElement),Temp.transcribe(InitialPoint),Temp.transcribe(FurthestPointInitial));
        ReorientFace(Face4,Temp.transcribe(ThirdPointPlane));
        Faces.push_back(Face4);
        cout << Faces.size();

    int numberOut=0;
    int fsize=Faces.size();
        InsidePolyhedronList(Faces, ListBorderFloat,OnlineBool,numbBorder,numberOut);
    cout << "Number still out is "<< numberOut<<endl;
    if(numberOut==0){
        cout << "Everything within initial tetrahedron"<<endl;
        vector<Face> Results;
        for(int f=0;f<fsize;f++){
            Results.push_back(Faces[f]);
        }
        for(int i=0;i<numbBorder;i++){
            delete [] ListBorderFloat[i];
        }

        return Results;
    }
    // Associate a face to each of the points out

//    int * AssociatedFace=new int[numberOut];
//    float * AssociatedDistance = new float[numberOut];
//    bool * FaceToTake=new bool[fsize];
//    float * FaceMaxDist=new float[fsize];
//    int * IndexFurthest=new int [fsize];
//    deque<vector<int> >PointSet;
//    for (int f=0;f<fsize;f++){
//        FaceMaxDist[f]=-1;
//        FaceToTake[f]=0;
//        IndexFurthest[f]=-1;
//        vector<int> VectorIndices;
//        PointSet.push_back(VectorIndices);
//    }
//    int indexAssociatedOut=0;
//    for (int b=0;b<numbBorder;b++){
//        if(!OnlineBool[b]){
//            float DistMin=1000;
//            int ChosenFace=-1;
//            Point Temp;
//            Temp.transcribe(ListBorderFloat[b]);
//            for(int f=0;f<fsize;f++){
//                float DistanceTemp=DistanceFromFace(Faces[f],Temp);
//                if (DistanceTemp<DistMin){
//                    DistMin=DistanceTemp;
//                    ChosenFace=f;
//                }
//            }
//            if (DistMin>FaceMaxDist[ChosenFace]){
//                IndexFurthest[ChosenFace]=b;
//                FaceMaxDist[ChosenFace]=DistMin;
//            }
//            AssociatedFace[indexAssociatedOut]=ChosenFace;
//            FaceToTake[ChosenFace]=1;
//            PointSet[ChosenFace].push_back(b);
//            AssociatedDistance[indexAssociatedOut]=DistMin;
//            indexAssociatedOut++;
//        }
//    }
    vector<int> PointsStillOut;
    for(int b=0;b<numbBorder;b++){
        if(!OnlineBool[b]){
            PointsStillOut.push_back(b);
        }
    }
    deque<vector<int> >PointSet=AssociatePointsToFace(Faces,PointsStillOut,ListBorderFloat);
   vector<Face> FacesFin;

    // Associate a point set to each of the faces
    while (Faces.size()>0){
        // Check if there are points associated to face
        if (PointSet[0].size()==0){
            FacesFin.push_back(Faces[0]);
            Faces.pop_front();
            PointSet.pop_front();
        }
        else{
        // Find furthest away element among points associated to face
        int numbPoints=PointSet[0].size();
        int IndexMax=-1;
        float DistMax=-1000;
        for (int b=0;b<numbPoints;b++){
            Point Temp;
            Temp.transcribe(ListBorderFloat[PointSet[0][b]]);
            float DistTemp=DistanceFromFace(Faces[0],Temp);
            if (DistTemp>DistMax){
                IndexMax=b;
                DistMax=DistTemp;
            }
        }
        vector<Face> AdjacentFaces;
        // Find list of three faces adjacent to face studied
        int fsize=Faces.size();
        for (int ftest=1;ftest<fsize;ftest++){
            Face FaceCheck=Faces[ftest];
            if(IsAdjacent(Faces[0],FaceCheck)){
                AdjacentFaces.push_back(FaceCheck);
            }
        }
        int ffin=FacesFin.size();
        if (AdjacentFaces.size()<3){
            for(int ftest=0;ftest<ffin;ftest++){
                Face FaceCheck=FacesFin[ftest];
                if(IsAdjacent(Faces[0],FaceCheck)){
                    AdjacentFaces.push_back(FaceCheck);
                }
            }
        }

        // Create new faces related to the chosen point
        deque<Face> NewFaces;
        for(int a=0;a<3;a++){
            vector<Point> v1;
            vector<Point> v2;
            v1.push_back(Temp.transcribe(ListBorderFloat[PointSet[0][IndexMax]]));
            v2.push_back(Temp.transcribe(ListBorderFloat[PointSet[0][IndexMax]]));
            int d=DifferentInAdjacent3(Faces[0],AdjacentFaces[a]);
            v1.push_back(AdjacentFaces[a].v[d]);
            v2.push_back(AdjacentFaces[a].v[d]);
            for(int ve=0;ve<3;ve++){
                if (ve!=d){
                    if(v1.size()==2){
                        v1.push_back(AdjacentFaces[a].v[ve]);
                     }
                    else{
                        v2.push_back(AdjacentFaces[a].v[ve]);
                    }
                }
            }
            Point ReorientComp;
            if(FacesFin.size()>0){
                ReorientComp=FacesFin[0].v[0];
            }
            else{
                ReorientComp=Faces[1].v[0];
            }
            Face Face1=Face(v1);
            ReorientFace(Face1,ReorientComp);

            Face Face2=Face(v2);
            ReorientFace(Face2,ReorientComp);
            NewFaces.push_back(Face1);
            NewFaces.push_back(Face2);
        }
        // Classify the point set as taken care of or not according to if they are in the new polyhedron
        int CountInsidePlus=0;
        vector<int> RemainingPoints;
        for (int p=0;p<numbPoints;p++){
            if(InsidePolyhedron(NewFaces,Temp.transcribe(ListBorderFloat[PointSet[0][p]]))){
                OnlineBool[PointSet[0][p]]=1;
                CountInsidePlus++;
            }
            else{
                RemainingPoints.push_back(PointSet[0][p]);
            }
        }
        cout<<"CountInsidePlus is "<< CountInsidePlus<<endl;
        // Associate the points still out to the 6 new faces
        deque<vector<int> > AssociatedPoints=AssociatePointsToFace(NewFaces,RemainingPoints,ListBorderFloat);
        for(int i=0;i<6;i++){
            if(AssociatedPoints[i].size()==0){
                FacesFin.push_back(NewFaces[i]);
                PointSet.push_back(AssociatedPoints[i]);
            }
            else{
                Faces.push_back(NewFaces[i]);
            }
        }

        // Pop out the First PointSet and the First Face
        PointSet.pop_front();
        Faces.pop_front();
}

    }

   return FacesFin;
}

vector <Point> MMBBFromConvexHull(vector<Face> FaceVector){
    int fsize=FaceVector.size();
    vector<Point> Results;
    if(fsize==1){
        if (FaceVector[0].area()==0){
            Results.push_back(FaceVector[0].v[0]);
            Results.push_back(FaceVector[0].v[1]);
            return Results;
        }
        else{
            return RectangleFromFace(FaceVector[0]);                 
        }
    }
    if(fsize==4){
        float A=0;
        int I=-1;
        for(int i=0;i<4;i++){
            float ATemp=FaceVector[i].area();
            if(ATemp>A){
                A=ATemp;
                I=i;                 
            }
        }
        vector <Point> Results=RectangleFromFace(FaceVector[I]);
        int AdjacentIndex=I==0?1:0;
        cout <<"Max Area is for face "<< I<< "Adjacent is "<< AdjacentIndex<<endl;
        int DifferentIndex=DifferentInAdjacent3(FaceVector[I],FaceVector[AdjacentIndex]);
        float DiffFromFace=DistanceFromFace(FaceVector[I],FaceVector[AdjacentIndex].v[DifferentIndex]);
        Point NormalisedNormal=FaceVector[I].normal().normalise();
        for (int i=0;i<4;i++){
            Results.push_back(Results[i]-NormalisedNormal*DiffFromFace);
        }
        return Results;                
    }
    else{
        vector<Point> OppPoints= AssociatedFurthest(FaceVector);
        vector<float> FD=FurthestDistance(FaceVector,OppPoints);
        vector<Point> Results;
        int I=-1;
        float DistMax=-1000;
        for (int f=0;f<fsize;f++){
            if (FD[f]>DistMax){
                I=f;
                DistMax=FD[f];
                cout<<"DistMax is "<< DistMax<<endl;
            }
        }
        Face ChosenFace=FaceVector[I];
//        Point Opp=OppPoints[I];
        float * BB=GetExtremaPoints( FaceVector);
        float * BBMin=new float[3];
        float * BBMax=new float[3];
        for(int d=0;d<3;d++){
            BBMin[d]=BB[2*d];
            BBMax[d]=BB[2*d+1];
        }
        Point Temp;
        Point ProjectedMin=ProjectedElement(ChosenFace,Temp.transcribe(BBMin));
        Point ProjectedMax=ProjectedElement(ChosenFace,Temp.transcribe(BBMax));
        Point DirDiag=ProjectedMax-ProjectedMin;
        vector< vector<Point> > AllowedRectangles;
        for (int d=0;d<3;d++){
            vector<Point> Rectangle;
            Rectangle.push_back(ProjectedMin);
            Point Dir1=ChosenFace.v[d]-ProjectedMin;
            Point Proj1=ProjectedMin+Dir1*(Dir1.dot(DirDiag)/(Dir1.norm()*DirDiag.norm()));
            Rectangle.push_back(Proj1);
            Point Proj1b=ProjectedMax-Dir1*(Dir1.dot(DirDiag)/(Dir1.norm()*DirDiag.norm()));
            Rectangle.push_back(Proj1b);
            Rectangle.push_back(ProjectedMax);

            bool Contained=1;
            for(int d1=0;d1<3;d1++){
                if (d1!=d){
                    Contained*=IsInRectangle(Rectangle,ChosenFace.v[d1]);
                }
            }
        if (Contained){
            AllowedRectangles.push_back(Rectangle);
        }
    }
        int sizeAllowed=AllowedRectangles.size();
        if (sizeAllowed==1){
            cout <<"Easy only one solution !"<<endl;
            for(int p=0;p<4;p++){
            Results.push_back(AllowedRectangles[0][p]);
            }
            Point Dir=ChosenFace.normal().normalise();
            if (DistMax==0){
                cout <<"Actually all on plane.."<<endl;
                return Results;
            }
            for(int p=0;p<4;p++){
                Results.push_back(Results[p]-Dir*DistMax);
            }
            ReorientBB(Results);
            return Results;
        }
        if(sizeAllowed==0){
            cout<<"There seems to be a problem BB instead"<<endl;
            Results=CreatePointForBB(BB);
            return Results;
        }
        else{
            int S=-1;
            float minArea=1000;
            for(int s=0;s<sizeAllowed;s++){
                Face FaceTest=Face(AllowedRectangles[s]);
                if(FaceTest.area()<minArea){
                    S=s;
                }
            }
            cout <<"Solution chosen is "<<S<<endl;
            for(int p=0;p<4;p++){
            Results.push_back(AllowedRectangles[S][p]);
            }
            Point Dir=ChosenFace.normal().normalise();
            for(int p=0;p<4;p++){
                Results.push_back(Results[p]-Dir*DistMax);
            }
            ReorientBB(Results);
            return Results;
        }

    }
}

vector<Point> CreatePointForBB(float *BB){
    vector<Point>Results;
    Results.push_back(Point(BB[0],BB[2],BB[4]));
    Results.push_back(Point(BB[1],BB[2],BB[4]));
    Results.push_back(Point(BB[0],BB[3],BB[4]));
    Results.push_back(Point(BB[1],BB[3],BB[4]));
    Results.push_back(Point(BB[0],BB[2],BB[5]));
    Results.push_back(Point(BB[1],BB[2],BB[5]));
    Results.push_back(Point(BB[0],BB[3],BB[5]));
    Results.push_back(Point(BB[1],BB[3],BB[5]));
    ReorientBB(Results);
    return Results;
}

void ReorientBB(vector<Point>ToReorient){
    if (ToReorient.size()!=8){
        return;
    }
    else{
        vector<Point> Temp;
        for(int i=0;i<8;i++){
            Temp.push_back(ToReorient[i]);
        }
        Face FaceB=Face(ToReorient[0],ToReorient[1],ToReorient[2]);
        Face FaceF=Face(ToReorient[0],ToReorient[1],ToReorient[4]);
        Face FaceL=Face(ToReorient[0],ToReorient[2],ToReorient[4]);
        float AreaB=FaceB.area();
        float AreaF=FaceF.area();
        float AreaL=FaceL.area();
        if(AreaB>AreaF && AreaB>AreaL){
            return;
        }
        else if(AreaL>AreaF){
            ToReorient[0]=Temp[2];
            ToReorient[1]=Temp[0];
            ToReorient[2]=Temp[6];
            ToReorient[3]=Temp[4];
            ToReorient[4]=Temp[3];
            ToReorient[5]=Temp[1];
            ToReorient[6]=Temp[7];
            ToReorient[7]=Temp[5];
            return;
        }
        else{
            ToReorient[0]=Temp[0];
            ToReorient[1]=Temp[1];
            ToReorient[2]=Temp[4];
            ToReorient[3]=Temp[5];
            ToReorient[4]=Temp[2];
            ToReorient[5]=Temp[3];
            ToReorient[6]=Temp[6];
            ToReorient[7]=Temp[7];
            return;
        }
    }
}



bool IsInRectangle(vector<Point> ListP, Point Element){
    int psize=ListP.size();
    if(psize==2){
        Point Dir=ListP[1]-ListP[0];
        Point DirCheck=Element-ListP[0];
        if(Dir.cross(DirCheck).norm()<0.01){
            return true;
        }
        return false;
    }
    if(psize==4){
        Point Dir1=ListP[1]-ListP[0];
        Point Dir2=ListP[3]-ListP[0];
        float Val1a=ListP[0].dot(Dir1);
        float Val1b=ListP[1].dot(Dir1);
        float Val2a=ListP[0].dot(Dir2);
        float Val2b=ListP[3].dot(Dir2);
        float ValCheck1=Element.dot(Dir1);
        float ValCheck2=Element.dot(Dir2);
        if(ValCheck1>Val1b || ValCheck1<Val1a){
            return false;
        }
        if(ValCheck2>Val2b || ValCheck2<Val2a){
            return false;
        }
        return true;
    }
    return false;
}

vector<float> FurthestDistance(vector<Face> FaceVector, vector<Point> ListP){
    int fsize=FaceVector.size();
    vector<float> Results;
    for(int f=0;f<fsize;f++){
        Results.push_back(DistanceFromFace(FaceVector[f],ListP[f]));
    }
    return Results;
}

float * CreateSegPoints(vector<Point>ListP,int* Dim,int *Shift,float* PixDim){
    int numel=Dim[0]*Dim[1]*Dim[2];
    float *Results=new float[numel];
    for(int i=0;i<numel;i++){
        Results[i]=0;
    }
    int psize=ListP.size();
    for(int p=0;p<psize;p++){
        vector<int> ListI=PossibleIndices(ListP[p],Shift,PixDim);
        vector<float> ListF=PossiblePartial(ListP[p],Shift,PixDim);
        int numbI=ListI.size();
        for(int i=0;i<numbI;i++){
            Results[ListI[i]]+=ListF[i];
        }
    }
    return Results;
}

vector<Point> ListPointsFromFaces(vector<Face> FaceVector){
    vector<Point> ListP;
    int fsize=FaceVector.size();
    for(int f=0;f<fsize;f++){
        for(int p=0;p<3;p++){
            ListP.push_back(FaceVector[f].v[p]);
        }
    }
    return ListP;
}

float * GetExtremaPoints(vector<Face> FaceVector){
    vector<Point> ListP=ListPointsFromFaces(FaceVector);
    float * BB=new float[6];
    for (int d =0;d<3;d++){
        BB[2*d]=1000;
        BB[2*d+1]=-1;
    }
    int psize=ListP.size();
    for(int p=0;p<psize;p++){
        Point ToCheck=ListP[p];
        BB[0]=ToCheck.x<BB[0]?ToCheck.x:BB[0];
        BB[1]=ToCheck.x>BB[1]?ToCheck.x:BB[1];
        BB[2]=ToCheck.y<BB[2]?ToCheck.y:BB[2];
        BB[3]=ToCheck.y>BB[3]?ToCheck.y:BB[3];
        BB[4]=ToCheck.z<BB[4]?ToCheck.z:BB[4];
        BB[5]=ToCheck.z>BB[5]?ToCheck.z:BB[5];
    }
    return BB;
}



vector<Point> AssociatedFurthest(vector<Face> FaceVector){
    Face FaceInit=FaceVector[0];
    vector<Point> Results;
    vector<Point> ListP = ListPointsFromFaces(FaceVector);
    int psize=ListP.size();
    int fsize=FaceVector.size();
    for(int f=0;f<fsize;f++){
        float DistMax=-1000;
        Point ToAssociate;
        for (int p=0;p<psize;p++){
            float DistTemp=DistanceFromFace(FaceVector[0],ListP[p]);
            if (DistTemp>DistMax){
                DistMax=DistTemp;
                ToAssociate=ListP[p];
            }
        }
        Results.push_back(ToAssociate);
    }
    return Results;
}

float * CreateCharMM(bool* BoolSeg,vector<Point> ListBB, int* Dim, int* Shift, float* PixDim){
    int psize=ListBB.size();
    int numel=Dim[0]*Dim[1]*Dim[2];
    float * MMChar=new float[4*numel];
    Point Dir;
    float Area;
    if(psize==2){
        Dir=ListBB[1]-ListBB[0];
        Area=1;
    }
    if(psize==4){
        Dir=ListBB[1]-ListBB[0];
        Point Dir2=ListBB[2]-ListBB[0];
        Area=Dir2.norm();
    }
    if(psize==8){
        Dir=ListBB[1]-ListBB[0];
        Point Dir2=ListBB[2]-ListBB[0];
        Point Dir3=ListBB[4]-ListBB[0];
        Area=Dir2.cross(Dir3).norm();
    }
    for(int i=0;i<numel;i++){
        for(int d=0;d<4;d++){
         MMChar[i+numel*d]=0;
        }
        if (BoolSeg[i]){
            MMChar[i]=Area;
            MMChar[i+numel]=Dir.x;
            MMChar[i+2*numel]=Dir.y;
            MMChar[i+3*numel]=Dir.z;
        }

    }
    return MMChar;
}

float * CreatePVBoxFromBBPoint(vector<Point> ListBB, int* Dim, int* Shift, float* PixDim){
    // First create bounding box axis in voxel space
    int * BB=new int[6];
    for(int d=0;d<3;d++){
        BB[2*d]=1000;
        BB[2*d+1]=-1;
    }
    int psize=ListBB.size();
    for (int p=0;p<psize;p++){
        Point Temp=ListBB[p];
        BB[0]=floor(Temp.x)<BB[0]?floor(Temp.x):BB[0];
        BB[1]=ceil(Temp.x)>BB[1]?ceil(Temp.x):BB[1];
        BB[2]=floor(Temp.y)<BB[2]?floor(Temp.y):BB[2];
        BB[3]=ceil(Temp.y)>BB[3]?ceil(Temp.y):BB[3];
        BB[4]=floor(Temp.z)<BB[4]?floor(Temp.z):BB[4];
        BB[5]=ceil(Temp.z)>BB[5]?ceil(Temp.z):BB[5];
    }
    bool * BBSeg=CreateBoolBoundingBox(BB,Dim);
    // Transfer int to float for the voxels relevant
    vector<Point> ListToCheck=GetListPointsFromBoolSeg(BBSeg,Dim,Shift,PixDim);
    deque<Face> ListFaceBB=CreateListFacesBB(ListBB);
    delete [] BBSeg;
    delete [] BB;
    float * Proba = ProbaInFromFaces(ListFaceBB,ListToCheck,Dim,Shift,PixDim);
    return Proba;
}

Point ProjectedElement(Face ProjectedFace, Point Element){
    float Dist=DistanceFromFace(ProjectedFace,Element);
    Point Normal=ProjectedFace.normal();
    Point NormalisedNormal=Normal.normalise();
    Point ProjectedElement=Element-NormalisedNormal*Dist;
    return ProjectedElement;
}

vector <int> PossibleIndices(Point Element, int* Shift, float * PixDim){
    int xmin=floor(Element.x/PixDim[0]);
    int xmax=ceil(Element.x/PixDim[0]);
    int ymin=floor(Element.y/PixDim[1]);
    int ymax=ceil(Element.y/PixDim[1]);
    int zmin=floor(Element.z/PixDim[2]);
    int zmax=ceil(Element.z/PixDim[2]);
    vector<int> PossibleIndices;
    PossibleIndices.push_back(xmin+ymin*Shift[1]+zmin*Shift[2]);
    PossibleIndices.push_back(xmax+ymin*Shift[1]+zmin*Shift[2]);
    PossibleIndices.push_back(xmin+ymax*Shift[1]+zmin*Shift[2]);
    PossibleIndices.push_back(xmax+ymax*Shift[1]+zmin*Shift[2]);
    PossibleIndices.push_back(xmin+ymin*Shift[1]+zmax*Shift[2]);
    PossibleIndices.push_back(xmin+ymax*Shift[1]+zmax*Shift[2]);
    PossibleIndices.push_back(xmax+ymin*Shift[1]+zmax*Shift[2]);
    PossibleIndices.push_back(xmax+ymax*Shift[1]+zmax*Shift[2]);
    return PossibleIndices;
}

vector <float> PossiblePartial(Point Element, int* Shift, float* PixDim){
    vector<float> PossiblePartial;
    float xmin=1-Element.x/PixDim[0]+floor(Element.x/PixDim[0]);
    float xmax=1-ceil(Element.x/PixDim[0])+Element.x/PixDim[0];
    float ymin=1-Element.y/PixDim[1]+floor(Element.y/PixDim[1]);
    float ymax=1-ceil(Element.y/PixDim[1])+Element.y/PixDim[1];
    float zmin=1-Element.z/PixDim[2]+floor(Element.z/PixDim[2]);
    float zmax=1-ceil(Element.z/PixDim[2])+Element.z/PixDim[2];
    PossiblePartial.push_back(xmin*ymin*zmin);
    PossiblePartial.push_back(xmax*ymin*zmin);
    PossiblePartial.push_back(xmin*ymax*zmin);
    PossiblePartial.push_back(xmax*ymax*zmin);
    PossiblePartial.push_back(xmin*ymin*zmax);
    PossiblePartial.push_back(xmin*ymax*zmax);
    PossiblePartial.push_back(xmax*ymin*zmax);
    PossiblePartial.push_back(xmax*ymax*zmax);
    return PossiblePartial;
}

float * ProbaInFromFaces(deque<Face> FaceList, vector<Point> ListToCheck, int * Dim, int* Shift, float* PixDim){
    int numel = Dim[0]*Dim[1]*Dim[2];
    float * Proba=new float[numel];
    for (int i=0;i<numel;i++){
        Proba[i]=0;
    }
    int psize=ListToCheck.size();
    for(int p=0;p<psize;p++){
        Point ToCheck=ListToCheck[p];
        bool Result=InsidePolyhedron(FaceList, ListToCheck[p]);
        if (!Result){
            Face ClosestFace=FindClosestFace(FaceList,ToCheck);
            Point Project=ProjectedElement(ClosestFace,ToCheck);
            vector<int> PossibleAssociated=PossibleIndices(Project,Shift,PixDim);
            vector<float> PartialAssociated=PossiblePartial(Project,Shift,PixDim);
            int numbI=PossibleAssociated.size();
            for(int i=0;i<numbI;i++){
                Proba[PossibleAssociated[i]]+=PartialAssociated[i];
            }
        }
        else {
             int Index=ToCheck.x/PixDim[0]+ToCheck.y/PixDim[1]*Shift[1]+ToCheck.z/PixDim[2]*Shift[2];
             Proba[Index]=1;
        }
    }
    return Proba;
}

Face FindClosestFace(deque<Face> FaceList,Point Element){
    float DistMin=1000;
    Face ChosenFace;
    int fsize=FaceList.size();
    for(int f=0;f<fsize;f++){
        float Dist=DistanceFromFace(FaceList[f],Element);
        if (Dist>0 && Dist<DistMin){
            DistMin=Dist;
            ChosenFace=FaceList[f];
        }
    }
    return ChosenFace;
}

vector<Point> GetListPointsFromBoolSeg(bool * BBSet, int* Dim, int* Shift, float* PixDim){
    int * ListPoints=ListCoordinatesBoolSeg(BBSet,Dim,Shift);
    int numel=Dim[0]*Dim[1]*Dim[2];
    int size=CountNonZero(BBSet,numel);
    Point Temp;
    vector<Point> ListPointsFinal;
    float * ListPointsFloat=ListCoordinatesTransformed(ListPoints,size,PixDim);
    for(int i=0;i<size;i++){
        ListPointsFinal.push_back(Temp.transcribe(&ListPointsFloat[3*i]));
    }
    delete []ListPoints;
    delete []ListPointsFloat;
    return ListPointsFinal;
}

deque<Face> CreateListFacesBB(vector<Point> ListBB){
    int psize=ListBB.size();
    deque<Face> ListFaceFinal;
    if (psize==2){
        ListFaceFinal.push_back(Face(ListBB[0],ListBB[1],ListBB[1]));
        return ListFaceFinal;
    }
    if(psize==4){
        ListFaceFinal.push_back(Face(ListBB[0],ListBB[1],ListBB[2]));
        return ListFaceFinal;
    }
    if(psize==8){ // We assume the points have been added according to the rectangle rule made before
        // Create bottom Face
        Face FaceB=Face(ListBB[0],ListBB[1],ListBB[2]);
        if (FaceB.normal().dot(FaceB.v[0]-ListBB[4])<0){
            Point Temp=FaceB.v[2];
            FaceB.v[2]=FaceB.v[1];
            FaceB.v[1]=Temp;
        }
        ListFaceFinal.push_back(FaceB);
        // Face Left 0 1 4
        Face FaceF=Face(ListBB[0],ListBB[1],ListBB[4]);
        if (FaceF.normal().dot(FaceF.v[0]-ListBB[2])<0){
            Point Temp=FaceF.v[2];
            FaceF.v[2]=FaceF.v[1];
            FaceF.v[1]=Temp;
        }
        ListFaceFinal.push_back(FaceF);
        // Face Left 0 2 4
        Face FaceL=Face(ListBB[0],ListBB[2],ListBB[4]);
        if (FaceL.normal().dot(FaceL.v[0]-ListBB[3])<0){
            Point Temp=FaceL.v[2];
            FaceL.v[2]=FaceL.v[1];
            FaceL.v[1]=Temp;
        }
        ListFaceFinal.push_back(FaceL);
        // Face Back 2 3 5
        Face FaceBa=Face(ListBB[2],ListBB[3],ListBB[5]);
        if (FaceBa.normal().dot(FaceBa.v[0]-ListBB[0])<0){
            Point Temp=FaceBa.v[2];
            FaceBa.v[2]=FaceBa.v[1];
            FaceBa.v[1]=Temp;
        }
        ListFaceFinal.push_back(FaceBa);
        // Face Right 1 3 5
        Face FaceR=Face(ListBB[1],ListBB[3],ListBB[5]);
        if (FaceR.normal().dot(FaceR.v[0]-ListBB[0])<0){
            Point Temp=FaceR.v[2];
            FaceR.v[2]=FaceR.v[1];
            FaceR.v[1]=Temp;
        }
        ListFaceFinal.push_back(FaceR);
        Face FaceT=Face(ListBB[5],ListBB[6],ListBB[7]);
        if (FaceT.normal().dot(FaceT.v[0]-ListBB[0])<0){
            Point Temp=FaceT.v[2];
            FaceT.v[2]=FaceT.v[1];
            FaceT.v[1]=Temp;
        }
        ListFaceFinal.push_back(FaceT);
        return ListFaceFinal;
    }
    cout << "No line, rectangle or cuboid defined here !!!"<<endl;
    return ListFaceFinal;
}

vector<Point> RectangleFromFace(Face FaceToDraw){
    Point GreatestSide=FaceToDraw.greatestside();
//    float NormGreatestSide=GreatestSide.norm();
    int OppositePoint=FaceToDraw.greatestside_ind();
    vector<Point> Results;
    for(int d=0;d<3;d++){
        if (d!=OppositePoint){
            Results.push_back(FaceToDraw.v[d]);
            Point ToDot=FaceToDraw.v[d]-FaceToDraw.v[OppositePoint];
            Point NewPoint=FaceToDraw.v[OppositePoint]+GreatestSide*(GreatestSide.dot(ToDot)/(GreatestSide.norm()*ToDot.norm()));
            Results.push_back(NewPoint);
        }
    }
    return Results;
}

void ReorientFace(Face FaceToReorient,Point PointRef){
    Point Normal=FaceToReorient.normal();
    Point Diff=FaceToReorient.v[0]-PointRef;
    if(Diff.dot(Normal)<0){
        Point Temp=FaceToReorient.v[1];
        FaceToReorient.v[1]=FaceToReorient.v[2];
        FaceToReorient.v[2]=Temp;
    }
    return;
}

deque <vector<int> > AssociatePointsToFace(deque<Face> FacesInList, vector<int> PointsIndex, vector<float*> CoordinatesPoints){
    int fsize=FacesInList.size();
    deque <vector<int> > Association;
    for(int f=0;f<fsize;f++){
        vector<int> NewTemp;
        Association.push_back(NewTemp);
    }
    int psize=PointsIndex.size();
    for(int p=0;p<psize;p++){
        float DistMin=1000;
        int ChosenFace=-1;
        Point Temp;
        Point Tested=Temp.transcribe(CoordinatesPoints[PointsIndex[p]]);
        for(int f=0;f<fsize;f++){
            float DistTemp=DistanceFromFace(FacesInList[f],Tested);
            if(DistTemp>0){
            if(DistTemp<DistMin){
                ChosenFace=f;
                DistMin=DistTemp;
            }
            }
        }
        if(ChosenFace!=-1){
        Association[ChosenFace].push_back(PointsIndex[p]);
        }
        else{
            cout<<"Pb with this point "<<endl;
        }
    }
    return Association;
}

int DifferentInAdjacent3(Face Face1, Face Face2){
    // Assumes faces to be adjacent...
    for(int ve=0;ve<3;ve++){
        Point Element=Face2.v[ve];
        bool flag_Diff=1;
        for (int v1=0;v1<3;v1++){
            if ((Element-Face1.v[v1]).norm()==0){
                flag_Diff=0;
            }
        }
        if (flag_Diff){
            return ve;
        }
    }
    return -1;
}

bool IsAdjacent(Face Face1, Face Face2){
    int numbVertices=Face1.v.size();
    int numbVertices2=Face2.v.size();
    int commonVertices=0;
    for (int d=0;d<numbVertices;d++){
        Point Element=Face1.v[d];
        for(int d2=0;d2<numbVertices2;d2++){
            Point Diff=Element-Face2.v[d2];
            if (Diff.norm()==0){
                commonVertices++;
            }
        }
    }
    if(commonVertices==2){
        return true;
    }
    return false;
}

float DistanceFromFace(Face FaceDistance, Point Element){
    Point Normal=FaceDistance.normal();
    if (FaceDistance.isDegenerate()){
        Normal=FaceDistance.v[0]-FaceDistance.v[1];
    }

    Point DiffVector = Element - FaceDistance.v[0];
    float Dot = Normal.dot(DiffVector);
    return Dot;
}

void InsidePolyhedronList(deque<Face>Faces,vector<float *> ListBorderFloat,vector<bool> &OnlineBool,int numbBorder, int& numberOut){
    for(int b=0;b<numbBorder;b++){
        if(! OnlineBool[b]){
             Point Temp;
            Point Temp2= Temp.transcribe(ListBorderFloat[b]);
            OnlineBool[b]=InsidePolyhedron(Faces,Temp2);
            if (!OnlineBool[b]){
                numberOut++;
            }
        }
    }
    return;
}

bool InsidePolyhedron(deque<Face> Faces,Point Element ){
    int fsize=Faces.size();
    for(int f=0;f<fsize;f++){
         Point DiffVector=Faces[f].v[0]-Element;
         Point NormalFace = Faces[f].normal();
        float d = DiffVector.dot(NormalFace);
        if(DiffVector.norm()==0){
            return true;
        }
           d /= DiffVector.norm();
        if (d<-0.1){
            float DistTemp=DistanceFromFace(Faces[f],Element);
            if(DistTemp<0.75){
                cout<<"Almost on face approximation"<<endl;
                return true;
            }
            return false;
        }
    }
    return true;
}



float * NormalisedVector(float * Vector){
    float Dot=0;
    float * Normalised=new float[3];
    for(int d=0;d<3;d++){
        Dot+=Vector[d]*Vector[d];
    }
    for(int d=0;d<3;d++){
        Normalised[d]=Vector[d]/sqrt(Dot);
    }
    return Normalised;
}


float * ProjectionToPlane(float *Point1, float* VectNorm, float* Point3){
    // We assume VectNorm to be normalised
    float * ProjectedPoint=new float[3];
    float DotProduct=0;
    for(int d=0;d<3;d++){
        DotProduct+=(Point3[d]-Point1[d])*VectNorm[d];
    }
    for(int d=0;d<3;d++){
        ProjectedPoint[d]=Point3[d]-DotProduct*VectNorm[d];
    }
    return ProjectedPoint;

}

float * ProjectionToLine(float * Point1, float* Point2, float*Point3){
    float DotProductV1=0;
    float DotProductV2=0;
    for (int d=0;d<3;d++){
        DotProductV1+=(Point2[d]-Point1[d])*(Point3[d]-Point1[d]);
        DotProductV2+=(Point2[d]-Point1[d])*(Point2[d]-Point1[d]);
    }
    float * Projection=new float[3];
    for (int d=0;d<3;d++){
        Projection[d]=Point1[d]+DotProductV1/DotProductV2*(Point2[d]-Point1[d]);
    }
    return Projection;
}

float DistanceFromLineFloat(float * Point1, float* Point2, float* Point3){
    float F1[3];
    float F2[3];
    float F3[3];
    float F32[3];
    float F31[3];
    float F21[3];
    for(int d=0;d<3;d++){
        F1[d]=Point1[d];
        F2[d]=Point2[d];
        F3[d]=Point3[d];
        F32[d]=F3[d]-F2[d];
        F31[d]=F3[d]-F1[d];
        F21[d]=F2[d]-F1[d];
    }
    float * CP=CrossProduct(F32,F31);
    float Den=0;
    float CPFin=0;
    for(int d=0;d<3;d++){
        Den+=F21[d]*F21[d];
        CPFin+=CP[d]*CP[d];
    }
    Den=sqrt(Den);
    CPFin=sqrt(CPFin);
    return CPFin/Den;
}

float DistanceFromLine(int * Point1, int* Point2, int* Point3, float* PixDim){
    float F1[3];
    float F2[3];
    float F3[3];
    float F32[3];
    float F31[3];
    float F21[3];
    for(int d=0;d<3;d++){
        F1[d]=Point1[d]*PixDim[d];
        F2[d]=Point2[d]*PixDim[d];
        F3[d]=Point3[d]*PixDim[d];
        F32[d]=F3[d]-F2[d];
        F31[d]=F3[d]-F1[d];
        F21[d]=F2[d]-F1[d];
    }
    float * CP=CrossProduct(F32,F31);
    float Den=0;
    float CPFin=0;
    for(int d=0;d<3;d++){
        Den+=F21[d]*F21[d];
        CPFin+=CP[d]*CP[d];
    }
    Den=sqrt(Den);
    CPFin=sqrt(CPFin);
    return CPFin/Den;
}

float * CrossProduct(float * Vect1, float* Vect2){
    float * CP=new float[3];
    CP[0] = Vect1[1]*Vect2[2] - Vect1[2]*Vect2[1];
    CP[1] = Vect1[2]*Vect2[0] - Vect1[0]*Vect2[2];
    CP[2] = Vect1[0]*Vect2[1] - Vect1[1]*Vect2[0];
    return CP;
}




float * CreateLineFromEigenCoMBB(float * Eigen, int  CoM, int* BB,int* Dim,int* Shift){
    int numel=Dim[0]*Dim[1]*Dim[2];
    float *LineCreated=new float[numel];
    for (int i=0;i<numel;i++){
        LineCreated[i]=0;
    }
    int * CoM_coord=CorrespondingCoordinates(CoM,Dim,Shift);
    float x=(float)CoM_coord[0];
    float y=(float)CoM_coord[1];
    float z=(float)CoM_coord[2];
    LineCreated[CoM]=1;
    // Going first into positive direction of vector
    while( x<=BB[1]+1 && y<=BB[3]+1 && z<=BB[5]+1 && x>=BB[0]-1 && y>=BB[2]-1 && z>=BB[4]-1){
        x+=Eigen[0];
        y+=Eigen[1];
        z+=Eigen[2];
        int ind=(int)(round(x)*Shift[0]+round(y)*Shift[1]+round(z)*Shift[2]);
        LineCreated[ind]++;
    }
     x=(float)CoM_coord[0];
     y=(float)CoM_coord[1];
     z=(float)CoM_coord[2];
    while( x<=BB[1]+1 && y<=BB[3]+1 && z<=BB[5]+1 && x>=BB[0]-1 && y>=BB[2]-1 && z>=BB[4]-1){
        x-=Eigen[0];
        y-=Eigen[1];
        z-=Eigen[2];
        int ind=(int)(round(x)*Shift[0]+round(y)*Shift[1]+round(z)*Shift[2]);
        LineCreated[ind]++;
    }
    return LineCreated;
}

int CountNeighbourBinary(int * Vessel,int index ,int * Dim,int * Shift,int Neigh){
     int ListNeighbours[6];
     int CountBin=0;
     GetListNeighbours_bis(ListNeighbours,index,Dim,Shift,Neigh);
     for(int i=0;i<Neigh;i++){
         if (Vessel[ListNeighbours[i]]){
             CountBin++;
         }
     }
     return CountBin;
}

/********************** NEEDED FOR THE LESION SIMULATOR *******************/
 
nifti_image * RandomGaussianNoiseNii(vector<float> Mean, vector<float> Std, nifti_image * BasicImage, nifti_image * Mask){
    
    if(BasicImage==NULL){
        return NULL;
    }
    int Dimensions=Mean.size();
    if (Mean.size()!=Std.size()) {
        Dimensions=Mean.size()>Std.size()?Std.size():Mean.size();
    }
    if (Dimensions==0) {
        return NULL;
    }
    cout<<"Proper beginning of random noise"<<endl;
    nifti_image * RandomImage=nifti_copy_nim_info(BasicImage);
//    std::default_random_engine generator;
    RandomImage->dim[0]=Dimensions>1?4:3;
    RandomImage->dim[4]=Dimensions;
    nifti_update_dims_from_array(RandomImage);
    RandomImage->data=(void*)calloc(RandomImage->nvox, sizeof(float));
    float * RandomData=static_cast<float*>(RandomImage->data);
    int numel=BasicImage->nx*BasicImage->ny*BasicImage->nz;
    if (Mask!=NULL) {
        bool * MaskData=static_cast<bool *>(Mask->data);
        for (int d=0; d<Dimensions; d++) {
            srand ( time(NULL) );
            cout<<"Beginning random noise for "<<d<<endl;
// Generate the relevant distribution
//            std::normal_distribution<float> distribution(Mean[d],Std[d]);
            for (int i=0; i<numel; i++) {
                if (!MaskData[i]) {
                    RandomData[d*numel+i]=0;
                }
                else{
//                    RandomData[d*numel+i]=distribution(generator);
                    RandomData[d*numel+i]=randn(Mean[d], Std[d]/5);
                }
            }
        
        }
    }
    else{
        for (int d=0; d<Dimensions; d++) {
            srand ( time(NULL) );
            // Generate the relevant distribution
//            std::normal_distribution<float> distribution(Mean[d],Std[d]);
            for (int i=0; i<numel; i++) {
//                    RandomData[d*numel+i]=distribution(generator);
            RandomData[d*numel+i]=randn(Mean[d], Std[d]);
//                
            }
            
        }
    }
    return RandomImage;
}

float
randn (float mu, float sigma)
{
    float U1, U2, W, mult;
    static float X1, X2;
    static int call = 0;
    
    if (call == 1)
    {
        call = !call;
        return (mu + sigma * (float) X2);
    }
    
    do
    {
        U1 = -1 + ((float) rand () / RAND_MAX) * 2;
        U2 = -1 + ((float) rand () / RAND_MAX) * 2;
        W = pow (U1, 2) + pow (U2, 2);
    }
    while (W >= 1 || W == 0);
    
    mult = sqrt ((-2 * log (W)) / W);
    X1 = U1 * mult;
    X2 = U2 * mult;
    
    call = !call;
    
    return (mu + sigma * (float) X1);
}

float randu(float min, float max){
    float x;
    do{

        x=min+((float)rand()/RAND_MAX)*(max-min);
    }
    while (x>max || x<min);
    return x;
}

float * randuSeries(float min, float max, int numb){
        srand ( time(NULL) );
    float * ResultRandom=new float[numb];
    for (int i=0; i<numb; i++) {
        ResultRandom[i]=randu(min, max);
    }
    return ResultRandom;
}

